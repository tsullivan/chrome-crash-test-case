webpackJsonp([1],[
/* 0 */,
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * THESE ARE AUTOMATICALLY INCLUDED IN LODASH
 *
 * use:
 * var _ = require('lodash');
 */

var _ = __webpack_require__(1166).runInContext();
var lodashLangMixin = __webpack_require__(1167).lodashLangMixin;
var lodashObjectMixin = __webpack_require__(1168).lodashObjectMixin;
var lodashCollectionMixin = __webpack_require__(1169).lodashCollectionMixin;
var lodashFunctionMixin = __webpack_require__(1170).lodashFunctionMixin;
var lodashOopMixin = __webpack_require__(1171).lodashOopMixin;

lodashLangMixin(_);
lodashObjectMixin(_);
lodashCollectionMixin(_);
lodashFunctionMixin(_);
lodashOopMixin(_);

module.exports = _;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.uiModules = undefined;
exports.link = link;
exports.get = get;
exports.close = close;

var _angular = __webpack_require__(16);

var _angular2 = _interopRequireDefault(_angular);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This module is used by Kibana to create and reuse angular modules. Angular modules
 * can only be created once and need to have their dependencies at creation. This is
 * hard/impossible to do in require.js since all of the dependencies for a module are
 * loaded before it is.
 *
 * Here is an example:
 *
 * 	In the scenario below, require.js would load directive.js first because it is a
 * 	dependency of app.js. This would cause the call to `angular.module('app')` to
 * 	execute before the module is actually created. This causes angular to throw an
 * 	error. This effect is magnified when app.js links off to many different modules.
 *
 * 	This is normally solved by creating unique modules per file, listed as the 1st
 * 	alternate solution below. Unfortunately this solution would have required that
 * 	we replicate our require statements.
 *
 *  	app.js
 *      ```
 *      angular.module('app', ['ui.bootstrap'])
 *      .controller('AppController', function () { ... });
 *
 *      require('./directive');
 *      ```
 *
 *    directive.js
 *      ```
 *      angular.module('app')
 *      .directive('someDirective', function () { ... });
 *      ```
 *
 * Before taking this approach we saw three possible solutions:
 *   1. replicate our js modules in angular modules/use a different module per file
 *   2. create a single module outside of our js modules and share it
 *   3. use a helper lib to dynamically create modules as needed.
 *
 * We decided to go with #3
 *
 * This ends up working by creating a list of modules that the code base creates by
 * calling `modules.get(name)` with different names, and then before bootstrapping
 * the application kibana uses `modules.link()` to set the dependencies of the "kibana"
 * module to include every defined module. This guarantees that kibana can always find
 * any angular dependecy defined in the kibana code base. This **also** means that
 * Private modules are able to find any dependency, since they are injected using the
 * "kibana" module's injector.
 *
 */
var existingModules = {};
var links = [];

/**
 * Take an angular module and extends the dependencies for that module to include all of the modules
 * created using `ui/modules`
 *
 * @param  {AngularModule} module - the module to extend
 * @return {undefined}
 */
function link(module) {
  // as modules are defined they will be set as requirements for this app
  links.push(module);

  // merge in the existing modules
  module.requires = _lodash2.default.union(module.requires, _lodash2.default.keys(existingModules));
}

/**
 * The primary means of interacting with `ui/modules`. Returns an angular module. If the module already
 * exists the existing version will be returned. `dependencies` are either set as or merged into the
 * modules total dependencies.
 *
 * This is in contrast to the `angular.module(name, [dependencies])` function which will only
 * create a module if the `dependencies` list is passed and get an existing module if no dependencies
 * are passed. This requires knowing the order that your files will load, which we can't guarantee.
 *
 * @param  {string} moduleName - the unique name for this module
 * @param  {array[string]} [requires=[]] - the other modules this module requires
 * @return {AngularModule}
 */
function get(moduleName, requires) {
  var module = existingModules[moduleName];

  if (module === void 0) {
    // create the module
    module = existingModules[moduleName] = _angular2.default.module(moduleName, []);

    module.close = _lodash2.default.partial(close, moduleName);

    // ensure that it is required by linked modules
    _lodash2.default.each(links, function (app) {
      if (!~app.requires.indexOf(moduleName)) app.requires.push(moduleName);
    });
  }

  if (requires) {
    // update requires list with possibly new requirements
    module.requires = _lodash2.default.union(module.requires, requires);
  }

  return module;
}

function close(moduleName) {
  var module = existingModules[moduleName];

  // already closed
  if (!module) return;

  // if the module is currently linked, unlink it
  var i = links.indexOf(module);
  if (i > -1) links.splice(i, 1);

  // remove from linked modules list of required modules
  _lodash2.default.each(links, function (app) {
    _lodash2.default.pull(app.requires, moduleName);
  });

  // remove module from existingModules
  delete existingModules[moduleName];
}

var uiModules = exports.uiModules = { link: link, get: get, close: close };

/***/ }),
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var $ = window.jQuery = window.$ = module.exports = __webpack_require__(1172);
__webpack_require__(1173)($);


/***/ }),
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(1280);


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(7);
__webpack_require__(1175);
module.exports = window.angular;

__webpack_require__(1176);

__webpack_require__(2).get('kibana', ['monospaced.elastic']);


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _chrome = __webpack_require__(1165);

// eslint-disable-next-line @elastic/kibana-custom/no-default-export
exports.default = _chrome.chrome;
module.exports = exports['default'];

/***/ }),
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _routes = __webpack_require__(1340);

// eslint-disable-next-line @elastic/kibana-custom/no-default-export
exports.default = _routes.uiRoutes;
module.exports = exports['default'];

/***/ }),
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NoResults = exports.StackedBarChartConfig = exports.InvalidLogScaleValues = exports.PieContainsAllZeros = exports.InvalidWiggleSelection = exports.ContainerTooSmall = exports.VislibError = exports.PersistedStateError = exports.NoDefaultIndexPattern = exports.NoDefinedIndexPatterns = exports.IndexPatternMissingIndices = exports.SavedObjectNotFound = exports.IndexPatternAlreadyExists = exports.DuplicateField = exports.FieldNotFoundInCache = exports.CacheWriteFailure = exports.RestrictedMapping = exports.MappingConflict = exports.VersionConflict = exports.ShardFailure = exports.FetchFailure = exports.RequestFailure = exports.SearchTimeout = exports.KbnError = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _angular = __webpack_require__(16);

var _angular2 = _interopRequireDefault(_angular);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var canStack = function () {
  var err = new Error();
  return !!err.stack;
}();

// abstract error class

var KbnError = exports.KbnError = function () {
  function KbnError(msg, constructor) {
    _classCallCheck(this, KbnError);

    this.message = msg;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, constructor || KbnError);
    } else if (canStack) {
      this.stack = new Error().stack;
    } else {
      this.stack = '';
    }
  }

  /**
   * If the error permits, propagate the error to be rendered on screen
   */


  _createClass(KbnError, [{
    key: 'displayToScreen',
    value: function displayToScreen() {
      throw this;
    }
  }]);

  return KbnError;
}();
// Note, you can't extend the built in Error class:
// http://stackoverflow.com/questions/33870684/why-doesnt-instanceof-work-on-instances-of-error-subclasses-under-babel-node
// Hence we are inheriting from it this way, instead of using extends Error, and this will then preserve
// instanceof checks.


_lodash2.default.class(KbnError).inherits(Error);

/**
 * SearchTimeout error class
 */

var SearchTimeout = exports.SearchTimeout = function (_KbnError) {
  _inherits(SearchTimeout, _KbnError);

  function SearchTimeout() {
    _classCallCheck(this, SearchTimeout);

    return _possibleConstructorReturn(this, (SearchTimeout.__proto__ || Object.getPrototypeOf(SearchTimeout)).call(this, 'All or part of your request has timed out. The data shown may be incomplete.', SearchTimeout));
  }

  return SearchTimeout;
}(KbnError);

/**
 * Request Failure - When an entire mutli request fails
 * @param {Error} err - the Error that came back
 * @param {Object} resp - optional HTTP response
 */


var RequestFailure = exports.RequestFailure = function (_KbnError2) {
  _inherits(RequestFailure, _KbnError2);

  function RequestFailure(err, resp) {
    _classCallCheck(this, RequestFailure);

    err = err || false;

    var _this2 = _possibleConstructorReturn(this, (RequestFailure.__proto__ || Object.getPrototypeOf(RequestFailure)).call(this, 'Request to Elasticsearch failed: ' + _angular2.default.toJson(resp || err.message), RequestFailure));

    _this2.origError = err;
    _this2.resp = resp;
    return _this2;
  }

  return RequestFailure;
}(KbnError);

/**
 * FetchFailure Error - when there is an error getting a doc or search within
 *  a multi-response response body
 * @param {Object} resp - The response from es.
 */


var FetchFailure = exports.FetchFailure = function (_KbnError3) {
  _inherits(FetchFailure, _KbnError3);

  function FetchFailure(resp) {
    _classCallCheck(this, FetchFailure);

    var _this3 = _possibleConstructorReturn(this, (FetchFailure.__proto__ || Object.getPrototypeOf(FetchFailure)).call(this, 'Failed to get the doc: ' + _angular2.default.toJson(resp), FetchFailure));

    _this3.resp = resp;
    return _this3;
  }

  return FetchFailure;
}(KbnError);

/**
 * ShardFailure Error - when one or more shards fail
 * @param {Object} resp - The response from es.
 */


var ShardFailure = exports.ShardFailure = function (_KbnError4) {
  _inherits(ShardFailure, _KbnError4);

  function ShardFailure(resp) {
    _classCallCheck(this, ShardFailure);

    var _this4 = _possibleConstructorReturn(this, (ShardFailure.__proto__ || Object.getPrototypeOf(ShardFailure)).call(this, resp._shards.failed + ' of ' + resp._shards.total + ' shards failed.', ShardFailure));

    _this4.resp = resp;
    return _this4;
  }

  return ShardFailure;
}(KbnError);

/**
 * A doc was re-indexed but it was out of date.
 * @param {Object} resp - The response from es (one of the multi-response responses).
 */


var VersionConflict = exports.VersionConflict = function (_KbnError5) {
  _inherits(VersionConflict, _KbnError5);

  function VersionConflict(resp) {
    _classCallCheck(this, VersionConflict);

    var _this5 = _possibleConstructorReturn(this, (VersionConflict.__proto__ || Object.getPrototypeOf(VersionConflict)).call(this, 'Failed to store document changes do to a version conflict.', VersionConflict));

    _this5.resp = resp;
    return _this5;
  }

  return VersionConflict;
}(KbnError);

/**
 * there was a conflict storing a doc
 * @param {String} field - the fields which contains the conflict
 */


var MappingConflict = exports.MappingConflict = function (_KbnError6) {
  _inherits(MappingConflict, _KbnError6);

  function MappingConflict(field) {
    _classCallCheck(this, MappingConflict);

    return _possibleConstructorReturn(this, (MappingConflict.__proto__ || Object.getPrototypeOf(MappingConflict)).call(this, 'Field "' + field + '" is defined with at least two different types in indices matching the pattern', MappingConflict));
  }

  return MappingConflict;
}(KbnError);

/**
 * a field mapping was using a restricted fields name
 * @param {String} field - the fields which contains the conflict
 */


var RestrictedMapping = exports.RestrictedMapping = function (_KbnError7) {
  _inherits(RestrictedMapping, _KbnError7);

  function RestrictedMapping(field, index) {
    _classCallCheck(this, RestrictedMapping);

    var msg = '"' + field + '" is a restricted field name';
    if (index) msg += ', found it while attempting to fetch mapping for index pattern: ' + index;

    return _possibleConstructorReturn(this, (RestrictedMapping.__proto__ || Object.getPrototypeOf(RestrictedMapping)).call(this, msg, RestrictedMapping));
  }

  return RestrictedMapping;
}(KbnError);

/**
 * a non-critical cache write to elasticseach failed
 */


var CacheWriteFailure = exports.CacheWriteFailure = function (_KbnError8) {
  _inherits(CacheWriteFailure, _KbnError8);

  function CacheWriteFailure() {
    _classCallCheck(this, CacheWriteFailure);

    return _possibleConstructorReturn(this, (CacheWriteFailure.__proto__ || Object.getPrototypeOf(CacheWriteFailure)).call(this, 'A Elasticsearch cache write has failed.', CacheWriteFailure));
  }

  return CacheWriteFailure;
}(KbnError);

/**
 * when a field mapping is requested for an unknown field
 * @param {String} name - the field name
 */


var FieldNotFoundInCache = exports.FieldNotFoundInCache = function (_KbnError9) {
  _inherits(FieldNotFoundInCache, _KbnError9);

  function FieldNotFoundInCache(name) {
    _classCallCheck(this, FieldNotFoundInCache);

    return _possibleConstructorReturn(this, (FieldNotFoundInCache.__proto__ || Object.getPrototypeOf(FieldNotFoundInCache)).call(this, 'The "' + name + '" field was not found in the cached mappings', FieldNotFoundInCache));
  }

  return FieldNotFoundInCache;
}(KbnError);

/**
 * when a mapping already exists for a field the user is attempting to add
 * @param {String} name - the field name
 */


var DuplicateField = exports.DuplicateField = function (_KbnError10) {
  _inherits(DuplicateField, _KbnError10);

  function DuplicateField(name) {
    _classCallCheck(this, DuplicateField);

    return _possibleConstructorReturn(this, (DuplicateField.__proto__ || Object.getPrototypeOf(DuplicateField)).call(this, 'The field "' + name + '" already exists in this mapping', DuplicateField));
  }

  return DuplicateField;
}(KbnError);

/**
 * when a mapping already exists for a field the user is attempting to add
 * @param {String} name - the field name
 */


var IndexPatternAlreadyExists = exports.IndexPatternAlreadyExists = function (_KbnError11) {
  _inherits(IndexPatternAlreadyExists, _KbnError11);

  function IndexPatternAlreadyExists(name) {
    _classCallCheck(this, IndexPatternAlreadyExists);

    return _possibleConstructorReturn(this, (IndexPatternAlreadyExists.__proto__ || Object.getPrototypeOf(IndexPatternAlreadyExists)).call(this, 'An index pattern of "' + name + '" already exists', IndexPatternAlreadyExists));
  }

  return IndexPatternAlreadyExists;
}(KbnError);

/**
 * A saved object was not found
 */


var SavedObjectNotFound = exports.SavedObjectNotFound = function (_KbnError12) {
  _inherits(SavedObjectNotFound, _KbnError12);

  function SavedObjectNotFound(type, id, link) {
    _classCallCheck(this, SavedObjectNotFound);

    var idMsg = id ? ' (id: ' + id + ')' : '';
    var message = 'Could not locate that ' + type + idMsg;

    if (link) {
      message += ', [click here to re-create it](' + link + ')';
    }

    var _this12 = _possibleConstructorReturn(this, (SavedObjectNotFound.__proto__ || Object.getPrototypeOf(SavedObjectNotFound)).call(this, message, SavedObjectNotFound));

    _this12.savedObjectType = type;
    _this12.savedObjectId = id;
    return _this12;
  }

  return SavedObjectNotFound;
}(KbnError);

/**
 * Tried to call a method that relies on SearchSource having an indexPattern assigned
 */


var IndexPatternMissingIndices = exports.IndexPatternMissingIndices = function (_KbnError13) {
  _inherits(IndexPatternMissingIndices, _KbnError13);

  function IndexPatternMissingIndices(message) {
    _classCallCheck(this, IndexPatternMissingIndices);

    var defaultMessage = 'IndexPattern\'s configured pattern does not match any indices';

    return _possibleConstructorReturn(this, (IndexPatternMissingIndices.__proto__ || Object.getPrototypeOf(IndexPatternMissingIndices)).call(this, message && message.length ? 'No matching indices found: ' + message : defaultMessage, IndexPatternMissingIndices));
  }

  return IndexPatternMissingIndices;
}(KbnError);

/**
 * Tried to call a method that relies on SearchSource having an indexPattern assigned
 */


var NoDefinedIndexPatterns = exports.NoDefinedIndexPatterns = function (_KbnError14) {
  _inherits(NoDefinedIndexPatterns, _KbnError14);

  function NoDefinedIndexPatterns() {
    _classCallCheck(this, NoDefinedIndexPatterns);

    return _possibleConstructorReturn(this, (NoDefinedIndexPatterns.__proto__ || Object.getPrototypeOf(NoDefinedIndexPatterns)).call(this, 'Define at least one index pattern to continue', NoDefinedIndexPatterns));
  }

  return NoDefinedIndexPatterns;
}(KbnError);

/**
 * Tried to load a route besides management/kibana/index but you don't have a default index pattern!
 */


var NoDefaultIndexPattern = exports.NoDefaultIndexPattern = function (_KbnError15) {
  _inherits(NoDefaultIndexPattern, _KbnError15);

  function NoDefaultIndexPattern() {
    _classCallCheck(this, NoDefaultIndexPattern);

    return _possibleConstructorReturn(this, (NoDefaultIndexPattern.__proto__ || Object.getPrototypeOf(NoDefaultIndexPattern)).call(this, 'Please specify a default index pattern', NoDefaultIndexPattern));
  }

  return NoDefaultIndexPattern;
}(KbnError);

var PersistedStateError = exports.PersistedStateError = function (_KbnError16) {
  _inherits(PersistedStateError, _KbnError16);

  function PersistedStateError() {
    _classCallCheck(this, PersistedStateError);

    return _possibleConstructorReturn(this, (PersistedStateError.__proto__ || Object.getPrototypeOf(PersistedStateError)).call(this, 'Error with the persisted state', PersistedStateError));
  }

  return PersistedStateError;
}(KbnError);

/**
 * UI Errors
 */


var VislibError = exports.VislibError = function (_KbnError17) {
  _inherits(VislibError, _KbnError17);

  function VislibError(message) {
    _classCallCheck(this, VislibError);

    return _possibleConstructorReturn(this, (VislibError.__proto__ || Object.getPrototypeOf(VislibError)).call(this, message));
  }

  _createClass(VislibError, [{
    key: 'displayToScreen',
    value: function displayToScreen(handler) {
      handler.error(this.message);
    }
  }]);

  return VislibError;
}(KbnError);

var ContainerTooSmall = exports.ContainerTooSmall = function (_VislibError) {
  _inherits(ContainerTooSmall, _VislibError);

  function ContainerTooSmall() {
    _classCallCheck(this, ContainerTooSmall);

    return _possibleConstructorReturn(this, (ContainerTooSmall.__proto__ || Object.getPrototypeOf(ContainerTooSmall)).call(this, 'This container is too small to render the visualization'));
  }

  return ContainerTooSmall;
}(VislibError);

var InvalidWiggleSelection = exports.InvalidWiggleSelection = function (_VislibError2) {
  _inherits(InvalidWiggleSelection, _VislibError2);

  function InvalidWiggleSelection() {
    _classCallCheck(this, InvalidWiggleSelection);

    return _possibleConstructorReturn(this, (InvalidWiggleSelection.__proto__ || Object.getPrototypeOf(InvalidWiggleSelection)).call(this, 'In wiggle mode the area chart requires ordered values on the x-axis. Try using a Histogram or Date Histogram aggregation.'));
  }

  return InvalidWiggleSelection;
}(VislibError);

var PieContainsAllZeros = exports.PieContainsAllZeros = function (_VislibError3) {
  _inherits(PieContainsAllZeros, _VislibError3);

  function PieContainsAllZeros() {
    _classCallCheck(this, PieContainsAllZeros);

    return _possibleConstructorReturn(this, (PieContainsAllZeros.__proto__ || Object.getPrototypeOf(PieContainsAllZeros)).call(this, 'No results displayed because all values equal 0.'));
  }

  return PieContainsAllZeros;
}(VislibError);

var InvalidLogScaleValues = exports.InvalidLogScaleValues = function (_VislibError4) {
  _inherits(InvalidLogScaleValues, _VislibError4);

  function InvalidLogScaleValues() {
    _classCallCheck(this, InvalidLogScaleValues);

    return _possibleConstructorReturn(this, (InvalidLogScaleValues.__proto__ || Object.getPrototypeOf(InvalidLogScaleValues)).call(this, 'Values less than 1 cannot be displayed on a log scale'));
  }

  return InvalidLogScaleValues;
}(VislibError);

var StackedBarChartConfig = exports.StackedBarChartConfig = function (_VislibError5) {
  _inherits(StackedBarChartConfig, _VislibError5);

  function StackedBarChartConfig(message) {
    _classCallCheck(this, StackedBarChartConfig);

    return _possibleConstructorReturn(this, (StackedBarChartConfig.__proto__ || Object.getPrototypeOf(StackedBarChartConfig)).call(this, message));
  }

  return StackedBarChartConfig;
}(VislibError);

var NoResults = exports.NoResults = function (_VislibError6) {
  _inherits(NoResults, _VislibError6);

  function NoResults() {
    _classCallCheck(this, NoResults);

    return _possibleConstructorReturn(this, (NoResults.__proto__ || Object.getPrototypeOf(NoResults)).call(this, 'No results found'));
  }

  return NoResults;
}(VislibError);

/***/ }),
/* 38 */,
/* 39 */,
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesMetricsMetricAggTypeProvider = AggTypesMetricsMetricAggTypeProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _agg_type = __webpack_require__(527);

var _field_formats = __webpack_require__(64);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function AggTypesMetricsMetricAggTypeProvider(Private) {
  var AggType = Private(_agg_type.AggTypesAggTypeProvider);
  var fieldFormats = Private(_field_formats.RegistryFieldFormatsProvider);

  _lodash2.default.class(MetricAggType).inherits(AggType);
  function MetricAggType(config) {
    MetricAggType.Super.call(this, config);

    // allow overriding any value on the prototype
    _lodash2.default.forOwn(config, function (val, key) {
      if (_lodash2.default.has(MetricAggType.prototype, key)) {
        this[key] = val;
      }
    }, this);
  }

  MetricAggType.prototype.subtype = 'Metric Aggregations';
  /**
   * Read the values for this metric from the
   * @param  {[type]} bucket [description]
   * @return {*}        [description]
   */
  MetricAggType.prototype.getValue = function (agg, bucket) {
    // Metric types where an empty set equals `zero`
    var isSettableToZero = ['cardinality', 'sum'].indexOf(agg.__type.name) !== -1;

    // Return proper values when no buckets are present
    // `Count` handles empty sets properly
    if (!bucket[agg.id] && isSettableToZero) return 0;

    return bucket[agg.id] && bucket[agg.id].value;
  };

  /**
   * Pick a format for the values produced by this agg type,
   * overriden by several metrics that always output a simple
   * number
   *
   * @param  {agg} agg - the agg to pick a format for
   * @return {FieldFromat}
   */
  MetricAggType.prototype.getFormat = function (agg) {
    var field = agg.getField();
    return field ? field.format : fieldFormats.getDefaultInstance('number');
  };

  /**
   * Determines if this metric can be scaled
   */
  MetricAggType.prototype.isScalable = function () {
    return false;
  };

  return MetricAggType;
}

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var CATEGORY = exports.CATEGORY = {
  BASIC: 'basic',
  DATA: 'data',
  MAP: 'map',
  OTHER: 'other',
  TIME: 'time',
  HIDDEN: 'hidden'
};

/***/ }),
/* 42 */,
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Notifier = Notifier;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _angular = __webpack_require__(16);

var _angular2 = _interopRequireDefault(_angular);

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

var _metadata = __webpack_require__(225);

var _format_msg = __webpack_require__(1321);

var _fatal_splash_screen = __webpack_require__(1323);

var _fatal_splash_screen2 = _interopRequireDefault(_fatal_splash_screen);

__webpack_require__(676);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint no-console: 0 */

var notifs = [];
var version = _metadata.metadata.version;
var buildNum = _metadata.metadata.buildNum;
var consoleGroups = 'group' in window.console && 'groupCollapsed' in window.console && 'groupEnd' in window.console;

var log = _lodash2.default.bindKey(console, 'log');

// used to identify the first call to fatal, set to false there
var firstFatal = true;

var fatalToastTemplate = function lazyTemplate(tmpl) {
  var compiled = void 0;
  return function (vars) {
    return (compiled || (compiled = _lodash2.default.template(tmpl)))(vars);
  };
}(__webpack_require__(1327));

function now() {
  if (window.performance && window.performance.now) {
    return window.performance.now();
  }
  return Date.now();
}

function closeNotif(notif) {
  var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _lodash2.default.noop;
  var key = arguments[2];

  return function () {
    // this === notif
    var i = notifs.indexOf(notif);
    if (i !== -1) notifs.splice(i, 1);

    cancelTimer(notif);
    cb(key);
  };
}

function cancelTimer(notif) {
  if (notif.timerId) {
    Notifier.config.clearInterval(notif.timerId);
    notif.timerId = undefined;
  }
}

function timerCanceler(notif) {
  var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _lodash2.default.noop;
  var key = arguments[2];

  return function cancelNotifTimer() {
    cancelTimer(notif);
    cb(key);
  };
}

/**
 * Initiates a timer to update _timeRemaining_ on the notif at second
 * intervals and clears the notif once the notif _lifetime_ has been reached.
 */
function startNotifTimer(notif, cb) {
  var interval = 1000;

  if (notif.lifetime === Infinity || notif.lifetime === 0) {
    return;
  }

  notif.timeRemaining = Math.floor(notif.lifetime / interval);

  notif.timerId = Notifier.config.setInterval(function () {
    notif.timeRemaining -= 1;

    if (notif.timeRemaining <= 0) {
      closeNotif(notif, cb, 'ignore')();
    }
  }, interval, notif.timeRemaining);

  notif.cancelTimer = timerCanceler(notif, cb);
}

function restartNotifTimer(notif, cb) {
  cancelTimer(notif);
  startNotifTimer(notif, cb);
}

var typeToButtonClassMap = {
  danger: 'kuiButton--danger', // NOTE: `error` type is internally named as `danger`
  warning: 'kuiButton--warning',
  info: 'kuiButton--primary',
  banner: 'kuiButton--basic'
};
var buttonHierarchyClass = function buttonHierarchyClass(index) {
  if (index === 0) {
    // first action: primary className
    return 'kuiButton--primary';
  }
  // subsequent actions: secondary/default className
  return 'kuiButton--basic';
};
var typeToAlertClassMap = {
  danger: 'alert-danger',
  warning: 'alert-warning',
  info: 'alert-info',
  banner: 'alert-banner'
};

function add(notif, cb) {
  _lodash2.default.set(notif, 'info.version', version);
  _lodash2.default.set(notif, 'info.buildNum', buildNum);

  notif.clear = closeNotif(notif);

  if (notif.actions) {
    notif.actions.forEach(function (action) {
      notif[action] = closeNotif(notif, cb, action);
    });
  } else if (notif.customActions) {
    // wrap all of the custom functions in a close
    notif.customActions = notif.customActions.map(function (action, index) {
      return {
        key: action.text,
        dataTestSubj: action.dataTestSubj,
        callback: closeNotif(notif, action.callback, action.text),
        getButtonClass: function getButtonClass() {
          var buttonTypeClass = typeToButtonClassMap[notif.type];
          return buttonHierarchyClass(index) + ' ' + buttonTypeClass;
        }
      };
    });
  }

  notif.count = (notif.count || 0) + 1;

  notif.isTimed = function isTimed() {
    return notif.timerId ? true : false;
  };

  // decorate the notification with helper functions for the template
  notif.getButtonClass = function () {
    return typeToButtonClassMap[notif.type];
  };
  notif.getAlertClassStack = function () {
    return 'toast-stack alert ' + typeToAlertClassMap[notif.type];
  };
  notif.getIconClass = function () {
    return notif.type === 'banner' ? '' : 'fa fa-' + notif.icon;
  };
  notif.getToastMessageClass = function () {
    return notif.type === 'banner' ? 'toast-message-banner' : 'toast-message';
  };
  notif.getAlertClass = function () {
    return notif.type === 'banner' ? 'alert ' + typeToAlertClassMap[notif.type] : // not including `.toast` class leaves out the flex properties for banner
    'toast alert ' + typeToAlertClassMap[notif.type];
  };
  notif.getButtonGroupClass = function () {
    return notif.type === 'banner' ? 'toast-controls-banner' : 'toast-controls';
  };

  var dup = null;
  if (notif.content) {
    dup = _lodash2.default.find(notifs, function (item) {
      return item.content === notif.content && item.lifetime === notif.lifetime;
    });
  }

  if (dup) {
    dup.count += 1;
    dup.stacks = _lodash2.default.union(dup.stacks, [notif.stack]);

    restartNotifTimer(dup, cb);

    return dup;
  }

  startNotifTimer(notif, cb);

  notif.stacks = [notif.stack];
  notifs.push(notif);
  return notif;
}

function set(opts, cb) {
  if (!opts.content) {
    return null;
  }

  if (this._sovereignNotif) {
    this._sovereignNotif.clear();
  }

  this._sovereignNotif = add(opts, cb);
  return this._sovereignNotif;
}

Notifier.prototype.add = add;
Notifier.prototype.set = set;

function formatInfo() {
  var info = [];

  if (!_lodash2.default.isUndefined(version)) {
    info.push('Version: ' + version);
  }

  if (!_lodash2.default.isUndefined(buildNum)) {
    info.push('Build: ' + buildNum);
  }

  return info.join('\n');
}

// browsers format Error.stack differently; always include message
function formatStack(err) {
  if (err.stack && !~err.stack.indexOf(err.message)) {
    return 'Error: ' + err.message + '\n' + err.stack;
  }
  return err.stack;
}

/**
 * Functionality to check that
 */
function Notifier(opts) {
  var self = this;
  opts = opts || {};

  // label type thing to say where notifications came from
  self.from = opts.location;

  'event lifecycle timed fatal error warning info banner'.split(' ').forEach(function (m) {
    self[m] = _lodash2.default.bind(self[m], self);
  });
}

Notifier.config = {
  bannerLifetime: 3000000,
  errorLifetime: 300000,
  warningLifetime: 10000,
  infoLifetime: 5000,
  setInterval: window.setInterval,
  clearInterval: window.clearInterval
};

Notifier.applyConfig = function (config) {
  _lodash2.default.merge(Notifier.config, config);
};

// to be notified when the first fatal error occurs, push a function into this array.
Notifier.fatalCallbacks = [];

// "Constants"
Notifier.QS_PARAM_MESSAGE = 'notif_msg';
Notifier.QS_PARAM_LEVEL = 'notif_lvl';
Notifier.QS_PARAM_LOCATION = 'notif_loc';

Notifier.pullMessageFromUrl = function ($location) {
  var queryString = $location.search();
  if (!queryString.notif_msg) {
    return;
  }
  var message = queryString[Notifier.QS_PARAM_MESSAGE];
  var config = queryString[Notifier.QS_PARAM_LOCATION] ? { location: queryString[Notifier.QS_PARAM_LOCATION] } : {};
  var level = queryString[Notifier.QS_PARAM_LEVEL] || 'info';

  $location.search(Notifier.QS_PARAM_MESSAGE, null);
  $location.search(Notifier.QS_PARAM_LOCATION, null);
  $location.search(Notifier.QS_PARAM_LEVEL, null);

  var notifier = new Notifier(config);
  notifier[level](message);
};

// simply a pointer to the global notif list
Notifier.prototype._notifs = notifs;

/**
 * Log a sometimes redundant event
 * @param {string} name - The name of the group
 * @param {boolean} success - Simple flag stating whether the event succeeded
 */
Notifier.prototype.event = createGroupLogger('event', {
  open: true
});

/**
 * Log a major, important, event in the lifecycle of the application
 * @param {string} name - The name of the lifecycle event
 * @param {boolean} success - Simple flag stating whether the lifecycle event succeeded
 */
Notifier.prototype.lifecycle = createGroupLogger('lifecycle', {
  open: true
});

/**
 * Wrap a function so that it's execution time gets logged.
 *
 * @param {function} fn - the function to wrap, it's .name property is
 *                      read so make sure to set it
 * @return {function} - the wrapped function
 */
Notifier.prototype.timed = function (name, fn) {
  var self = this;

  if (typeof name === 'function') {
    fn = name;
    name = fn.name;
  }

  return function WrappedNotifierFunction() {
    var cntx = this;
    var args = arguments;

    return self.event(name, function () {
      return fn.apply(cntx, args);
    });
  };
};

/**
 * Kill the page, display an error, then throw the error.
 * Used as a last-resort error back in many promise chains
 * so it rethrows the error that's displayed on the page.
 *
 * @param  {Error} err - The error that occured
 */
Notifier.prototype.fatal = function (err) {
  this._showFatal(err);
  throw err;
};

/**
 * Display an error that destroys the entire app. Broken out so that
 * global error handlers can display fatal errors without throwing another
 * error like in #fatal()
 *
 * @param  {Error} err - The fatal error that occured
 */
Notifier.prototype._showFatal = function (err) {
  if (firstFatal) {
    _lodash2.default.callEach(Notifier.fatalCallbacks);
    firstFatal = false;
    window.addEventListener('hashchange', function () {
      window.location.reload();
    });
  }

  var html = fatalToastTemplate({
    info: formatInfo(),
    msg: (0, _format_msg.formatMsg)(err, this.from),
    stack: formatStack(err)
  });

  var $container = (0, _jquery2.default)('#fatal-splash-screen');

  if (!$container.length) {
    (0, _jquery2.default)(document.body)
    // in case the app has not completed boot
    .removeAttr('ng-cloak').html(_fatal_splash_screen2.default);

    $container = (0, _jquery2.default)('#fatal-splash-screen');
  }

  $container.append(html);
  console.error(err.stack);
};

var overrideableOptions = ['lifetime', 'icon'];

/**
 * Alert the user of an error that occured
 * @param  {Error|String} err
 * @param  {Function} cb
 */
Notifier.prototype.error = function (err, opts, cb) {
  if (_lodash2.default.isFunction(opts)) {
    cb = opts;
    opts = {};
  }

  var config = _lodash2.default.assign({
    type: 'danger',
    content: (0, _format_msg.formatMsg)(err, this.from),
    icon: 'warning',
    title: 'Error',
    lifetime: Notifier.config.errorLifetime,
    actions: ['report', 'accept'],
    stack: formatStack(err)
  }, _lodash2.default.pick(opts, overrideableOptions));
  return add(config, cb);
};

/**
 * Warn the user abort something
 * @param  {String} msg
 * @param  {Function} cb
 */
Notifier.prototype.warning = function (msg, opts, cb) {
  if (_lodash2.default.isFunction(opts)) {
    cb = opts;
    opts = {};
  }

  var config = _lodash2.default.assign({
    type: 'warning',
    content: (0, _format_msg.formatMsg)(msg, this.from),
    icon: 'warning',
    title: 'Warning',
    lifetime: Notifier.config.warningLifetime,
    actions: ['accept']
  }, _lodash2.default.pick(opts, overrideableOptions));
  return add(config, cb);
};

/**
 * Display a debug message
 * @param  {String} msg
 * @param  {Function} cb
 */
Notifier.prototype.info = function (msg, opts, cb) {
  if (_lodash2.default.isFunction(opts)) {
    cb = opts;
    opts = {};
  }

  var config = _lodash2.default.assign({
    type: 'info',
    content: (0, _format_msg.formatMsg)(msg, this.from),
    icon: 'info-circle',
    title: 'Debug',
    lifetime: _lodash2.default.get(opts, 'lifetime', Notifier.config.infoLifetime),
    actions: ['accept']
  }, _lodash2.default.pick(opts, overrideableOptions));
  return add(config, cb);
};

/**
 * Display a banner message
 * @param  {String} msg
 * @param  {Function} cb
 */
Notifier.prototype.banner = function (msg, cb) {
  return this.set({
    type: 'banner',
    title: 'Attention',
    content: (0, _format_msg.formatMsg)(msg, this.from),
    lifetime: Notifier.config.bannerLifetime,
    actions: ['accept']
  }, cb);
};

/**
 * Helper for common behavior in custom and directive types
 */
function getDecoratedCustomConfig(config) {
  // There is no helper condition that will allow for 2 parameters, as the
  // other methods have. So check that config is an object
  if (!_lodash2.default.isPlainObject(config)) {
    throw new Error('Config param is required, and must be an object');
  }

  // workaround to allow callers to send `config.type` as `error` instead of
  // reveal internal implementation that error notifications use a `danger`
  // style
  if (config.type === 'error') {
    config.type = 'danger';
  }

  var getLifetime = function getLifetime(type) {
    switch (type) {
      case 'banner':
        return Notifier.config.bannerLifetime;
      case 'warning':
        return Notifier.config.warningLifetime;
      case 'danger':
        return Notifier.config.errorLifetime;
      default:
        // info
        return Notifier.config.infoLifetime;
    }
  };

  var customConfig = _lodash2.default.assign({
    type: 'info',
    title: 'Notification',
    lifetime: getLifetime(config.type)
  }, config);

  var hasActions = _lodash2.default.get(customConfig, 'actions.length');
  if (hasActions) {
    customConfig.customActions = customConfig.actions;
    delete customConfig.actions;
  } else {
    customConfig.actions = ['accept'];
  }

  return customConfig;
}

/**
 * Display a custom message
 * @param  {String} msg - required
 * @param  {Object} config - required
 * @param  {Function} cb - optional
 *
 * config = {
 *   title: 'Some Title here',
 *   type: 'info',
 *   actions: [{
 *     text: 'next',
 *     callback: function() { next(); }
 *   }, {
 *     text: 'prev',
 *     callback: function() { prev(); }
 *   }]
 * }
 */
Notifier.prototype.custom = function (msg, config, cb) {
  var customConfig = getDecoratedCustomConfig(config);
  customConfig.content = (0, _format_msg.formatMsg)(msg, this.from);
  return add(customConfig, cb);
};

/**
 * Display a scope-bound directive using template rendering in the message area
 * @param  {Object} directive - required
 * @param  {Object} config - required
 * @param  {Function} cb - optional
 *
 * directive = {
 *  template: `<p>Hello World! <a ng-click="example.clickHandler()">Click me</a>.`,
 *  controllerAs: 'example',
 *  controller() {
 *    this.clickHandler = () {
 *      // do something
 *    };
 *  }
 * }
 *
 * config = {
 *   title: 'Some Title here',
 *   type: 'info',
 *   actions: [{
 *     text: 'next',
 *     callback: function() { next(); }
 *   }, {
 *     text: 'prev',
 *     callback: function() { prev(); }
 *   }]
 * }
 */
Notifier.prototype.directive = function (directive, config, cb) {
  if (!_lodash2.default.isPlainObject(directive)) {
    throw new Error('Directive param is required, and must be an object');
  }
  if (!Notifier.$compile) {
    throw new Error('Unable to use the directive notification until Angular has initialized.');
  }
  if (directive.scope) {
    throw new Error('Directive should not have a scope definition. Notifier has an internal implementation.');
  }
  if (directive.link) {
    throw new Error('Directive should not have a link function. Notifier has an internal link function helper.');
  }

  // make a local copy of the directive param (helps unit tests)
  var localDirective = _lodash2.default.clone(directive, true);

  localDirective.scope = { notif: '=' };
  localDirective.link = function link($scope, $el) {
    var $template = _angular2.default.element($scope.notif.directive.template);
    var postLinkFunction = Notifier.$compile($template);
    $el.html($template);
    postLinkFunction($scope);
  };

  var customConfig = getDecoratedCustomConfig(config);
  customConfig.directive = localDirective;
  return add(customConfig, cb);
};

Notifier.prototype.describeError = _format_msg.formatMsg.describeError;

if (log === _lodash2.default.noop) {
  Notifier.prototype.log = _lodash2.default.noop;
} else {
  Notifier.prototype.log = function () {
    var args = [].slice.apply(arguments);
    if (this.from) args.unshift(this.from + ':');
    log.apply(null, args);
  };
}

// general functionality used by .event() and .lifecycle()
function createGroupLogger(type, opts) {
  // Track the groups managed by this logger
  var groups = window[type + 'Groups'] = {};

  return function logger(name, success) {
    var status = void 0; // status of the timer
    var exec = void 0; // function to execute and wrap
    var ret = void 0; // return value

    var complete = function complete(val) {
      logger(name, true);return val;
    };
    var failure = function failure(err) {
      logger(name, false);throw err;
    };

    if (typeof success === 'function' || success === void 0) {
      // start
      groups[name] = now();
      if (success) {
        // success === the function to time
        exec = success;
      } else {
        // function that can report on the success or failure of an op, and pass their value along
        ret = complete;
        ret.failure = failure;
      }
    } else {
      groups[name] = now() - (groups[name] || 0);
      var time = ' in ' + groups[name].toFixed(2) + 'ms';

      // end
      if (success) {
        status = 'complete' + time;
      } else {
        groups[name] = false;
        status = 'failure' + time;
      }
    }

    if (consoleGroups) {
      if (status) {
        console.log(status);
        console.groupEnd();
      } else {
        if (opts.open) {
          console.group(name);
        } else {
          console.groupCollapsed(name);
        }
      }
    } else {
      log('KBN: ' + name + (status ? ' - ' + status : ''));
    }

    if (exec) {
      try {
        ret = exec();
      } catch (e) {
        return failure(e);
      }

      if (ret && typeof ret.then === 'function') {
        // return a new promise that proxies the value
        // and logs about the promise outcome
        return ret.then(function (val) {
          complete();
          return val;
        }, function (err) {
          failure(err);
          throw err;
        });
      }

      // the function executed fine, and didn't return a promise, move along
      complete();
    }

    return ret;
  };
}

/***/ }),
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VisFactoryProvider = undefined;

var _vis_types = __webpack_require__(525);

var VisFactoryProvider = exports.VisFactoryProvider = function VisFactoryProvider(Private) {
  var VisType = Private(_vis_types.VisTypeProvider);
  var AngularVisType = Private(_vis_types.AngularVisTypeProvider);
  var ReactVisType = Private(_vis_types.ReactVisTypeProvider);
  var VislibVisType = Private(_vis_types.VislibVisTypeProvider);

  return {
    createBaseVisualization: function createBaseVisualization(config) {
      return new VisType(config);
    },
    createAngularVisualization: function createAngularVisualization(config) {
      return new AngularVisType(config);
    },
    createReactVisualization: function createReactVisualization(config) {
      return new ReactVisType(config);
    },
    createVislibVisualization: function createVislibVisualization(config) {
      return new VislibVisType(config);
    }
  };
};

/***/ }),
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(3145);
module.exports = window.consoleAce;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nodeTypes = undefined;

var _function = __webpack_require__(2076);

var functionType = _interopRequireWildcard(_function);

var _literal = __webpack_require__(473);

var literal = _interopRequireWildcard(_literal);

var _named_arg = __webpack_require__(2086);

var namedArg = _interopRequireWildcard(_named_arg);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var nodeTypes = exports.nodeTypes = {
  function: functionType,
  literal: literal,
  namedArg: namedArg
};

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _components = __webpack_require__(101);

Object.keys(_components).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _components[key];
    }
  });
});

/***/ }),
/* 54 */,
/* 55 */,
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VisSchemasProvider = VisSchemasProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _indexed_array = __webpack_require__(99);

var _agg_params = __webpack_require__(528);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function VisSchemasProvider(Private) {
  var AggParams = Private(_agg_params.AggTypesAggParamsProvider);

  function Schemas(schemas) {
    var self = this;

    (0, _lodash2.default)(schemas || []).map(function (schema) {
      if (!schema.name) throw new Error('all schema must have a unique name');

      if (schema.name === 'split') {
        schema.params = [{
          name: 'row',
          default: true
        }];
        schema.editor = __webpack_require__(3090);
      } else if (schema.name === 'radius') {
        schema.editor = __webpack_require__(3091);
      }

      _lodash2.default.defaults(schema, {
        min: 0,
        max: Infinity,
        group: 'buckets',
        title: schema.name,
        aggFilter: '*',
        editor: false,
        params: [],
        deprecate: false
      });

      // convert the params into a params registry
      schema.params = new AggParams(schema.params);

      return schema;
    }).tap(function (schemas) {
      self.all = new _indexed_array.IndexedArray({
        index: ['name'],
        group: ['group'],
        immutable: true,
        initialSet: schemas
      });
    }).groupBy('group').forOwn(function (group, groupName) {
      self[groupName] = new _indexed_array.IndexedArray({
        index: ['name'],
        immutable: true,
        initialSet: group
      });
    }).commit();
  }

  return Schemas;
}

/***/ }),
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _notify = __webpack_require__(1346);

Object.defineProperty(exports, 'notify', {
  enumerable: true,
  get: function get() {
    return _notify.notify;
  }
});

var _notifier = __webpack_require__(43);

Object.defineProperty(exports, 'Notifier', {
  enumerable: true,
  get: function get() {
    return _notifier.Notifier;
  }
});

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.uiRegistry = uiRegistry;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _indexed_array = __webpack_require__(99);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var notPropsOptNames = _indexed_array.IndexedArray.OPT_NAMES.concat('constructor', 'invokeProviders');

/**
 * Create a registry, which is just a Private module provider.
 *
 * The registry allows modifying the values it will provide
 * using the #register method.
 *
 * To access these modules, pass the registry to the Private
 * module loader.
 *
 * # Examples
 *
 * + register a module
 * ```js
 * let registry = require('ui/registry/vis_types');
 * registry.add(function InjectablePrivateModule($http, Promise) {
 *   ...
 * })
 * ```
 *
 * + get all registered modules
 * ```js
 * let visTypes = Private(RegistryVisTypesProvider);
 * ```
 *
 *
 * @param  {object} [spec] - an object describing the properties of
 *                         the registry to create. Any property specified
 *                         that is not listed below will be mixed into the
 *                         final IndexedArray object.
 *
 * # init
 * @param {Function} [spec.constructor] - an injectable function that is called when
 *                                      the registry is first instanciated by the app.
 *
 * # IndexedArray params
 * @param {array[String]} [spec.index] - passed to the IndexedArray constructor
 * @param {array[String]} [spec.group] - passed to the IndexedArray constructor
 * @param {array[String]} [spec.order] - passed to the IndexedArray constructor
 * @param {array[String]} [spec.initialSet] - passed to the IndexedArray constructor
 * @param {array[String]} [spec.immutable] - passed to the IndexedArray constructor
 *
 * @return {[type]}      [description]
 */
function uiRegistry(spec) {
  spec = spec || {};

  var constructor = _lodash2.default.has(spec, 'constructor') && spec.constructor;
  var invokeProviders = _lodash2.default.has(spec, 'invokeProviders') && spec.invokeProviders;
  var iaOpts = _lodash2.default.defaults(_lodash2.default.pick(spec, _indexed_array.IndexedArray.OPT_NAMES), { index: ['name'] });
  var props = _lodash2.default.omit(spec, notPropsOptNames);
  var providers = [];

  /**
   * This is the Private module that will be instantiated by
   *
   * @tag:PrivateModule
   * @return {IndexedArray} - an indexed array containing the values
   *                          that were registered, the registry spec
   *                          defines how things will be indexed.
   */
  var registry = function registry(Private, $injector) {
    // call the registered providers to get their values
    iaOpts.initialSet = invokeProviders ? $injector.invoke(invokeProviders, undefined, { providers: providers }) : providers.map(Private);

    // index all of the modules
    var modules = new _indexed_array.IndexedArray(iaOpts);

    // mixin other props
    _lodash2.default.assign(modules, props);

    // construct
    if (constructor) {
      modules = $injector.invoke(constructor, modules) || modules;
    }

    return modules;
  };

  registry.displayName = '[registry ' + props.name + ']';

  registry.register = function (privateModule) {
    providers.push(privateModule);
    return registry;
  };

  return registry;
}

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RegistryFieldFormatsProvider = undefined;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _registry = __webpack_require__(63);

var _field_format = __webpack_require__(321);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RegistryFieldFormatsProvider = exports.RegistryFieldFormatsProvider = (0, _registry.uiRegistry)({
  name: 'fieldFormats',
  index: ['id'],
  group: ['fieldType'],

  invokeProviders: function invokeProviders(providers) {
    // in order to ensure that FieldFormats can be instantiated on the
    // server and the browser we don't provide them access to the Angular
    // injector, just the FieldFormat class.
    return providers.map(function (createSomeFormat) {
      return createSomeFormat(_field_format.FieldFormat);
    });
  },


  constructor: function constructor(config) {
    var getConfig = function getConfig() {
      return config.get.apply(config, arguments);
    };
    var self = this;
    var defaultMap = void 0;

    function init() {
      config.watch('format:defaultTypeMap', parseDefaultTypeMap);
    }

    /**
     * Get the id of the default type for this field type
     * using the format:defaultTypeMap config map
     *
     * @param  {String} fieldType - the field type
     * @return {String}
     */
    self.getDefaultConfig = function (fieldType) {
      return defaultMap[fieldType] || defaultMap._default_;
    };

    /**
     * Get a FieldFormat type (class) by it's id.
     *
     * @param  {String} formatId - the format id
     * @return {Function}
     */
    self.getType = function (formatId) {
      return self.byId[formatId];
    };

    /**
     * Get the default FieldFormat type (class) for
     * a field type, using the format:defaultTypeMap.
     *
     * @param  {String} fieldType
     * @return {Function}
     */
    self.getDefaultType = function (fieldType) {
      return self.byId[self.getDefaultConfig(fieldType).id];
    };

    /**
     * Get the singleton instance of the FieldFormat type by it's id.
     *
     * @param  {String} formatId
     * @return {FieldFormat}
     */
    self.getInstance = _lodash2.default.memoize(function (formatId) {
      var FieldFormat = self.byId[formatId];
      return new FieldFormat(null, getConfig);
    });

    /**
     * Get the default fieldFormat instance for a field format.
     *
     * @param  {String} fieldType
     * @return {FieldFormat}
     */
    self.getDefaultInstance = _lodash2.default.memoize(function (fieldType) {
      var conf = self.getDefaultConfig(fieldType);
      var FieldFormat = self.byId[conf.id];
      return new FieldFormat(conf.params, getConfig);
    });

    function parseDefaultTypeMap(value) {
      defaultMap = value;
      _lodash2.default.forOwn(self, function (fn) {
        if (_lodash2.default.isFunction(fn) && fn.cache) {
          // clear all memoize caches
          fn.cache = new _lodash2.default.memoize.Cache();
        }
      });
    }

    init();
  }
});

/***/ }),
/* 65 */,
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VisTypesRegistryProvider = undefined;

var _registry = __webpack_require__(63);

var VisTypesRegistryProvider = exports.VisTypesRegistryProvider = (0, _registry.uiRegistry)({
  name: 'visTypes',
  index: ['name'],
  order: ['title']
});

/***/ }),
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _saved_objects_client = __webpack_require__(756);

Object.defineProperty(exports, 'SavedObjectsClient', {
  enumerable: true,
  get: function get() {
    return _saved_objects_client.SavedObjectsClient;
  }
});

var _saved_object_registry = __webpack_require__(134);

Object.defineProperty(exports, 'SavedObjectRegistryProvider', {
  enumerable: true,
  get: function get() {
    return _saved_object_registry.SavedObjectRegistryProvider;
  }
});

var _saved_objects_client_provider = __webpack_require__(2033);

Object.defineProperty(exports, 'SavedObjectsClientProvider', {
  enumerable: true,
  get: function get() {
    return _saved_objects_client_provider.SavedObjectsClientProvider;
  }
});

var _saved_object = __webpack_require__(757);

Object.defineProperty(exports, 'SavedObject', {
  enumerable: true,
  get: function get() {
    return _saved_object.SavedObject;
  }
});

var _find_object_by_title = __webpack_require__(2038);

Object.defineProperty(exports, 'findObjectByTitle', {
  enumerable: true,
  get: function get() {
    return _find_object_by_title.findObjectByTitle;
  }
});

/***/ }),
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _indexed_array = __webpack_require__(1453);

Object.defineProperty(exports, 'IndexedArray', {
  enumerable: true,
  get: function get() {
    return _indexed_array.IndexedArray;
  }
});

/***/ }),
/* 100 */,
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _action_item = __webpack_require__(2243);

Object.defineProperty(exports, 'KuiActionItem', {
  enumerable: true,
  get: function get() {
    return _action_item.KuiActionItem;
  }
});

var _accessibility = __webpack_require__(2248);

Object.defineProperty(exports, 'KuiKeyboardAccessible', {
  enumerable: true,
  get: function get() {
    return _accessibility.KuiKeyboardAccessible;
  }
});
Object.defineProperty(exports, 'KuiScreenReaderOnly', {
  enumerable: true,
  get: function get() {
    return _accessibility.KuiScreenReaderOnly;
  }
});

var _bar = __webpack_require__(2261);

Object.defineProperty(exports, 'KuiBar', {
  enumerable: true,
  get: function get() {
    return _bar.KuiBar;
  }
});
Object.defineProperty(exports, 'KuiBarSection', {
  enumerable: true,
  get: function get() {
    return _bar.KuiBarSection;
  }
});

var _button = __webpack_require__(800);

Object.defineProperty(exports, 'KuiButton', {
  enumerable: true,
  get: function get() {
    return _button.KuiButton;
  }
});
Object.defineProperty(exports, 'KuiButtonGroup', {
  enumerable: true,
  get: function get() {
    return _button.KuiButtonGroup;
  }
});
Object.defineProperty(exports, 'KuiButtonIcon', {
  enumerable: true,
  get: function get() {
    return _button.KuiButtonIcon;
  }
});
Object.defineProperty(exports, 'KuiLinkButton', {
  enumerable: true,
  get: function get() {
    return _button.KuiLinkButton;
  }
});
Object.defineProperty(exports, 'KuiSubmitButton', {
  enumerable: true,
  get: function get() {
    return _button.KuiSubmitButton;
  }
});

var _card = __webpack_require__(2266);

Object.defineProperty(exports, 'KuiCard', {
  enumerable: true,
  get: function get() {
    return _card.KuiCard;
  }
});
Object.defineProperty(exports, 'KuiCardDescriptionText', {
  enumerable: true,
  get: function get() {
    return _card.KuiCardDescriptionText;
  }
});
Object.defineProperty(exports, 'KuiCardDescriptionTitle', {
  enumerable: true,
  get: function get() {
    return _card.KuiCardDescriptionTitle;
  }
});
Object.defineProperty(exports, 'KuiCardDescription', {
  enumerable: true,
  get: function get() {
    return _card.KuiCardDescription;
  }
});
Object.defineProperty(exports, 'KuiCardFooter', {
  enumerable: true,
  get: function get() {
    return _card.KuiCardFooter;
  }
});
Object.defineProperty(exports, 'KuiCardGroup', {
  enumerable: true,
  get: function get() {
    return _card.KuiCardGroup;
  }
});

var _code_editor = __webpack_require__(2273);

Object.defineProperty(exports, 'KuiCodeEditor', {
  enumerable: true,
  get: function get() {
    return _code_editor.KuiCodeEditor;
  }
});

var _color_picker = __webpack_require__(2275);

Object.defineProperty(exports, 'KuiColorPicker', {
  enumerable: true,
  get: function get() {
    return _color_picker.KuiColorPicker;
  }
});

var _collapse_button = __webpack_require__(2526);

Object.defineProperty(exports, 'KuiCollapseButton', {
  enumerable: true,
  get: function get() {
    return _collapse_button.KuiCollapseButton;
  }
});

var _context_menu = __webpack_require__(2528);

Object.defineProperty(exports, 'KuiContextMenu', {
  enumerable: true,
  get: function get() {
    return _context_menu.KuiContextMenu;
  }
});
Object.defineProperty(exports, 'KuiContextMenuPanel', {
  enumerable: true,
  get: function get() {
    return _context_menu.KuiContextMenuPanel;
  }
});
Object.defineProperty(exports, 'KuiContextMenuItem', {
  enumerable: true,
  get: function get() {
    return _context_menu.KuiContextMenuItem;
  }
});

var _empty_table_prompt = __webpack_require__(2530);

Object.defineProperty(exports, 'KuiEmptyTablePrompt', {
  enumerable: true,
  get: function get() {
    return _empty_table_prompt.KuiEmptyTablePrompt;
  }
});
Object.defineProperty(exports, 'KuiEmptyTablePromptMessage', {
  enumerable: true,
  get: function get() {
    return _empty_table_prompt.KuiEmptyTablePromptMessage;
  }
});
Object.defineProperty(exports, 'KuiEmptyTablePromptPanel', {
  enumerable: true,
  get: function get() {
    return _empty_table_prompt.KuiEmptyTablePromptPanel;
  }
});

var _event = __webpack_require__(2534);

Object.defineProperty(exports, 'KuiEvent', {
  enumerable: true,
  get: function get() {
    return _event.KuiEvent;
  }
});
Object.defineProperty(exports, 'KuiEventSymbol', {
  enumerable: true,
  get: function get() {
    return _event.KuiEventSymbol;
  }
});
Object.defineProperty(exports, 'KuiEventBody', {
  enumerable: true,
  get: function get() {
    return _event.KuiEventBody;
  }
});
Object.defineProperty(exports, 'KuiEventBodyMessage', {
  enumerable: true,
  get: function get() {
    return _event.KuiEventBodyMessage;
  }
});
Object.defineProperty(exports, 'KuiEventBodyMetadata', {
  enumerable: true,
  get: function get() {
    return _event.KuiEventBodyMetadata;
  }
});

var _expression = __webpack_require__(2540);

Object.defineProperty(exports, 'KuiExpression', {
  enumerable: true,
  get: function get() {
    return _expression.KuiExpression;
  }
});
Object.defineProperty(exports, 'KuiExpressionButton', {
  enumerable: true,
  get: function get() {
    return _expression.KuiExpressionButton;
  }
});

var _flex = __webpack_require__(2543);

Object.defineProperty(exports, 'KuiFlexGroup', {
  enumerable: true,
  get: function get() {
    return _flex.KuiFlexGroup;
  }
});
Object.defineProperty(exports, 'KuiFlexGrid', {
  enumerable: true,
  get: function get() {
    return _flex.KuiFlexGrid;
  }
});
Object.defineProperty(exports, 'KuiFlexItem', {
  enumerable: true,
  get: function get() {
    return _flex.KuiFlexItem;
  }
});

var _form_layout = __webpack_require__(2547);

Object.defineProperty(exports, 'KuiFieldGroup', {
  enumerable: true,
  get: function get() {
    return _form_layout.KuiFieldGroup;
  }
});
Object.defineProperty(exports, 'KuiFieldGroupSection', {
  enumerable: true,
  get: function get() {
    return _form_layout.KuiFieldGroupSection;
  }
});

var _gallery = __webpack_require__(2550);

Object.defineProperty(exports, 'KuiGallery', {
  enumerable: true,
  get: function get() {
    return _gallery.KuiGallery;
  }
});
Object.defineProperty(exports, 'KuiGalleryItem', {
  enumerable: true,
  get: function get() {
    return _gallery.KuiGalleryItem;
  }
});
Object.defineProperty(exports, 'KuiGalleryItemIcon', {
  enumerable: true,
  get: function get() {
    return _gallery.KuiGalleryItemIcon;
  }
});
Object.defineProperty(exports, 'KuiGalleryItemImage', {
  enumerable: true,
  get: function get() {
    return _gallery.KuiGalleryItemImage;
  }
});
Object.defineProperty(exports, 'KuiGalleryItemLabel', {
  enumerable: true,
  get: function get() {
    return _gallery.KuiGalleryItemLabel;
  }
});

var _header_bar = __webpack_require__(2556);

Object.defineProperty(exports, 'KuiHeaderBar', {
  enumerable: true,
  get: function get() {
    return _header_bar.KuiHeaderBar;
  }
});
Object.defineProperty(exports, 'KuiHeaderBarSection', {
  enumerable: true,
  get: function get() {
    return _header_bar.KuiHeaderBarSection;
  }
});

var _info_button = __webpack_require__(2559);

Object.defineProperty(exports, 'KuiInfoButton', {
  enumerable: true,
  get: function get() {
    return _info_button.KuiInfoButton;
  }
});

var _form = __webpack_require__(2561);

Object.defineProperty(exports, 'KuiLabel', {
  enumerable: true,
  get: function get() {
    return _form.KuiLabel;
  }
});
Object.defineProperty(exports, 'KuiTextInput', {
  enumerable: true,
  get: function get() {
    return _form.KuiTextInput;
  }
});
Object.defineProperty(exports, 'KuiTextArea', {
  enumerable: true,
  get: function get() {
    return _form.KuiTextArea;
  }
});
Object.defineProperty(exports, 'KuiSelect', {
  enumerable: true,
  get: function get() {
    return _form.KuiSelect;
  }
});
Object.defineProperty(exports, 'KuiCheckBox', {
  enumerable: true,
  get: function get() {
    return _form.KuiCheckBox;
  }
});
Object.defineProperty(exports, 'KuiCheckBoxLabel', {
  enumerable: true,
  get: function get() {
    return _form.KuiCheckBoxLabel;
  }
});

var _local_nav = __webpack_require__(2572);

Object.defineProperty(exports, 'KuiLocalNav', {
  enumerable: true,
  get: function get() {
    return _local_nav.KuiLocalNav;
  }
});
Object.defineProperty(exports, 'KuiLocalNavRow', {
  enumerable: true,
  get: function get() {
    return _local_nav.KuiLocalNavRow;
  }
});
Object.defineProperty(exports, 'KuiLocalNavRowSection', {
  enumerable: true,
  get: function get() {
    return _local_nav.KuiLocalNavRowSection;
  }
});
Object.defineProperty(exports, 'KuiLocalTab', {
  enumerable: true,
  get: function get() {
    return _local_nav.KuiLocalTab;
  }
});
Object.defineProperty(exports, 'KuiLocalTabs', {
  enumerable: true,
  get: function get() {
    return _local_nav.KuiLocalTabs;
  }
});
Object.defineProperty(exports, 'KuiLocalTitle', {
  enumerable: true,
  get: function get() {
    return _local_nav.KuiLocalTitle;
  }
});

var _menu = __webpack_require__(2579);

Object.defineProperty(exports, 'KuiMenu', {
  enumerable: true,
  get: function get() {
    return _menu.KuiMenu;
  }
});
Object.defineProperty(exports, 'KuiMenuItem', {
  enumerable: true,
  get: function get() {
    return _menu.KuiMenuItem;
  }
});

var _modal = __webpack_require__(2582);

Object.defineProperty(exports, 'KUI_MODAL_CANCEL_BUTTON', {
  enumerable: true,
  get: function get() {
    return _modal.KUI_MODAL_CANCEL_BUTTON;
  }
});
Object.defineProperty(exports, 'KUI_MODAL_CONFIRM_BUTTON', {
  enumerable: true,
  get: function get() {
    return _modal.KUI_MODAL_CONFIRM_BUTTON;
  }
});
Object.defineProperty(exports, 'KuiConfirmModal', {
  enumerable: true,
  get: function get() {
    return _modal.KuiConfirmModal;
  }
});
Object.defineProperty(exports, 'KuiModal', {
  enumerable: true,
  get: function get() {
    return _modal.KuiModal;
  }
});
Object.defineProperty(exports, 'KuiModalBody', {
  enumerable: true,
  get: function get() {
    return _modal.KuiModalBody;
  }
});
Object.defineProperty(exports, 'KuiModalFooter', {
  enumerable: true,
  get: function get() {
    return _modal.KuiModalFooter;
  }
});
Object.defineProperty(exports, 'KuiModalHeader', {
  enumerable: true,
  get: function get() {
    return _modal.KuiModalHeader;
  }
});
Object.defineProperty(exports, 'KuiModalHeaderTitle', {
  enumerable: true,
  get: function get() {
    return _modal.KuiModalHeaderTitle;
  }
});
Object.defineProperty(exports, 'KuiModalOverlay', {
  enumerable: true,
  get: function get() {
    return _modal.KuiModalOverlay;
  }
});

var _outside_click_detector = __webpack_require__(512);

Object.defineProperty(exports, 'KuiOutsideClickDetector', {
  enumerable: true,
  get: function get() {
    return _outside_click_detector.KuiOutsideClickDetector;
  }
});

var _pager = __webpack_require__(2585);

Object.defineProperty(exports, 'KuiPager', {
  enumerable: true,
  get: function get() {
    return _pager.KuiPager;
  }
});
Object.defineProperty(exports, 'KuiPagerButtonGroup', {
  enumerable: true,
  get: function get() {
    return _pager.KuiPagerButtonGroup;
  }
});

var _panel_simple = __webpack_require__(870);

Object.defineProperty(exports, 'KuiPanelSimple', {
  enumerable: true,
  get: function get() {
    return _panel_simple.KuiPanelSimple;
  }
});

var _popover = __webpack_require__(2588);

Object.defineProperty(exports, 'KuiPopover', {
  enumerable: true,
  get: function get() {
    return _popover.KuiPopover;
  }
});
Object.defineProperty(exports, 'KuiPopoverTitle', {
  enumerable: true,
  get: function get() {
    return _popover.KuiPopoverTitle;
  }
});

var _tabs = __webpack_require__(2591);

Object.defineProperty(exports, 'KuiTabs', {
  enumerable: true,
  get: function get() {
    return _tabs.KuiTabs;
  }
});
Object.defineProperty(exports, 'KuiTab', {
  enumerable: true,
  get: function get() {
    return _tabs.KuiTab;
  }
});

var _table = __webpack_require__(871);

Object.defineProperty(exports, 'KuiTable', {
  enumerable: true,
  get: function get() {
    return _table.KuiTable;
  }
});
Object.defineProperty(exports, 'KuiControlledTable', {
  enumerable: true,
  get: function get() {
    return _table.KuiControlledTable;
  }
});
Object.defineProperty(exports, 'KuiTableHeaderCell', {
  enumerable: true,
  get: function get() {
    return _table.KuiTableHeaderCell;
  }
});
Object.defineProperty(exports, 'KuiTableRow', {
  enumerable: true,
  get: function get() {
    return _table.KuiTableRow;
  }
});
Object.defineProperty(exports, 'KuiTableRowCell', {
  enumerable: true,
  get: function get() {
    return _table.KuiTableRowCell;
  }
});
Object.defineProperty(exports, 'KuiTableInfo', {
  enumerable: true,
  get: function get() {
    return _table.KuiTableInfo;
  }
});
Object.defineProperty(exports, 'KuiTableRowCheckBoxCell', {
  enumerable: true,
  get: function get() {
    return _table.KuiTableRowCheckBoxCell;
  }
});
Object.defineProperty(exports, 'KuiTableHeaderCheckBoxCell', {
  enumerable: true,
  get: function get() {
    return _table.KuiTableHeaderCheckBoxCell;
  }
});
Object.defineProperty(exports, 'KuiTableHeader', {
  enumerable: true,
  get: function get() {
    return _table.KuiTableHeader;
  }
});
Object.defineProperty(exports, 'KuiTableBody', {
  enumerable: true,
  get: function get() {
    return _table.KuiTableBody;
  }
});
Object.defineProperty(exports, 'KuiListingTable', {
  enumerable: true,
  get: function get() {
    return _table.KuiListingTable;
  }
});
Object.defineProperty(exports, 'KuiListingTableCreateButton', {
  enumerable: true,
  get: function get() {
    return _table.KuiListingTableCreateButton;
  }
});
Object.defineProperty(exports, 'KuiListingTableDeleteButton', {
  enumerable: true,
  get: function get() {
    return _table.KuiListingTableDeleteButton;
  }
});
Object.defineProperty(exports, 'KuiListingTableNoMatchesPrompt', {
  enumerable: true,
  get: function get() {
    return _table.KuiListingTableNoMatchesPrompt;
  }
});
Object.defineProperty(exports, 'KuiListingTableLoadingPrompt', {
  enumerable: true,
  get: function get() {
    return _table.KuiListingTableLoadingPrompt;
  }
});

var _tool_bar = __webpack_require__(2611);

Object.defineProperty(exports, 'KuiToolBar', {
  enumerable: true,
  get: function get() {
    return _tool_bar.KuiToolBar;
  }
});
Object.defineProperty(exports, 'KuiToolBarSearchBox', {
  enumerable: true,
  get: function get() {
    return _tool_bar.KuiToolBarSearchBox;
  }
});
Object.defineProperty(exports, 'KuiToolBarFooter', {
  enumerable: true,
  get: function get() {
    return _tool_bar.KuiToolBarFooter;
  }
});
Object.defineProperty(exports, 'KuiToolBarSection', {
  enumerable: true,
  get: function get() {
    return _tool_bar.KuiToolBarSection;
  }
});
Object.defineProperty(exports, 'KuiToolBarFooterSection', {
  enumerable: true,
  get: function get() {
    return _tool_bar.KuiToolBarFooterSection;
  }
});
Object.defineProperty(exports, 'KuiToolBarText', {
  enumerable: true,
  get: function get() {
    return _tool_bar.KuiToolBarText;
  }
});

/***/ }),
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VisAggConfigProvider = VisAggConfigProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _field_formats = __webpack_require__(64);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @name AggConfig
 *
 * @description This class represents an aggregation, which is displayed in the left-hand nav of
 * the Visualize app.
 */

function VisAggConfigProvider(Private, Promise) {
  var fieldFormats = Private(_field_formats.RegistryFieldFormatsProvider);

  function AggConfig(vis, opts) {
    var self = this;

    self.id = String(opts.id || AggConfig.nextId(vis.aggs));
    self.vis = vis;
    self._opts = opts = opts || {};
    self.enabled = typeof opts.enabled === 'boolean' ? opts.enabled : true;

    // start with empty params so that checks in type/schema setters don't freak
    // because self.params is undefined
    self.params = {};

    // setters
    self.type = opts.type;
    self.schema = opts.schema;

    // set the params to the values from opts, or just to the defaults
    self.setParams(opts.params || {});
  }

  /**
   * Ensure that all of the objects in the list have ids, the objects
   * and list are modified by reference.
   *
   * @param  {array[object]} list - a list of objects, objects can be anything really
   * @return {array} - the list that was passed in
   */
  AggConfig.ensureIds = function (list) {
    var have = [];
    var haveNot = [];
    list.forEach(function (obj) {
      (obj.id ? have : haveNot).push(obj);
    });

    var nextId = AggConfig.nextId(have);
    haveNot.forEach(function (obj) {
      obj.id = String(nextId++);
    });

    return list;
  };

  /**
   * Calculate the next id based on the ids in this list
   *
   * @return {array} list - a list of objects with id properties
   */
  AggConfig.nextId = function (list) {
    return 1 + list.reduce(function (max, obj) {
      return Math.max(max, +obj.id || 0);
    }, 0);
  };

  Object.defineProperties(AggConfig.prototype, {
    type: {
      get: function get() {
        return this.__type;
      },
      set: function set(type) {
        if (this.__typeDecorations) {
          _lodash2.default.forOwn(this.__typeDecorations, function (prop, name) {
            delete this[name];
          }, this);
        }

        if (_lodash2.default.isString(type)) {
          type = AggConfig.aggTypes.byName[type];
        }

        if (type && _lodash2.default.isFunction(type.decorateAggConfig)) {
          this.__typeDecorations = type.decorateAggConfig();
          Object.defineProperties(this, this.__typeDecorations);
        }

        this.__type = type;

        // clear out the previous params except for a few special ones
        this.setParams({
          // split row/columns is "outside" of the agg, so don't reset it
          row: this.params.row,

          // almost every agg has fields, so we try to persist that when type changes
          field: _lodash2.default.get(this.getFieldOptions(), ['byName', this.getField()])
        });
      }
    },
    schema: {
      get: function get() {
        return this.__schema;
      },
      set: function set(schema) {
        if (_lodash2.default.isString(schema)) {
          schema = this.vis.type.schemas.all.byName[schema];
        }

        this.__schema = schema;
      }
    }
  });

  /**
   * Write the current values to this.params, filling in the defaults as we go
   *
   * @param  {object} [from] - optional object to read values from,
   *                         used when initializing
   * @return {undefined}
   */
  AggConfig.prototype.setParams = function (from) {
    var self = this;
    from = from || self.params || {};
    var to = self.params = {};

    self.getAggParams().forEach(function (aggParam) {
      var val = from[aggParam.name];

      if (val == null) {
        if (aggParam.default == null) return;

        if (!_lodash2.default.isFunction(aggParam.default)) {
          val = aggParam.default;
        } else {
          val = aggParam.default(self);
          if (val == null) return;
        }
      }

      if (aggParam.deserialize) {
        var isTyped = _lodash2.default.isFunction(aggParam.type);

        var isType = isTyped && val instanceof aggParam.type;
        var isObject = !isTyped && _lodash2.default.isObject(val);
        var isDeserialized = isType || isObject;

        if (!isDeserialized) {
          val = aggParam.deserialize(val, self);
        }

        to[aggParam.name] = val;
        return;
      }

      to[aggParam.name] = _lodash2.default.cloneDeep(val);
    });
  };

  AggConfig.prototype.write = function () {
    return this.type.params.write(this);
  };

  AggConfig.prototype.isFilterable = function () {
    return _lodash2.default.isFunction(this.type.createFilter);
  };

  AggConfig.prototype.createFilter = function (key) {
    if (!this.isFilterable()) {
      throw new TypeError('The "' + this.type.title + '" aggregation does not support filtering.');
    }

    var field = this.getField();
    var label = this.getFieldDisplayName();
    if (field && !field.filterable) {
      var message = 'The "' + label + '" field can not be used for filtering.';
      if (field.scripted) {
        message = 'The "' + label + '" field is scripted and can not be used for filtering.';
      }
      throw new TypeError(message);
    }

    return this.type.createFilter(this, key);
  };

  /**
   *  Hook for pre-flight logic, see AggType#onSearchRequestStart
   *  @param {Courier.SearchSource} searchSource
   *  @param {Courier.SearchRequest} searchRequest
   *  @return {Promise<undefined>}
   */
  AggConfig.prototype.onSearchRequestStart = function (searchSource, searchRequest) {
    var _this = this;

    if (!this.type) {
      return Promise.resolve();
    }

    return Promise.map(this.type.params, function (param) {
      return param.modifyAggConfigOnSearchRequestStart(_this, searchSource, searchRequest);
    });
  };

  /**
   * Convert this aggConfig to its dsl syntax.
   *
   * Adds params and adhoc subaggs to a pojo, then returns it
   *
   * @param  {AggConfig} aggConfig - the config object to convert
   * @return {void|Object} - if the config has a dsl representation, it is
   *                         returned, else undefined is returned
   */
  AggConfig.prototype.toDsl = function () {
    if (this.type.hasNoDsl) return;
    var output = this.write();

    var configDsl = {};
    configDsl[this.type.dslName || this.type.name] = output.params;

    // if the config requires subAggs, write them to the dsl as well
    if (this.subAggs && !output.subAggs) output.subAggs = this.subAggs;
    if (output.subAggs) {
      var subDslLvl = configDsl.aggs || (configDsl.aggs = {});
      output.subAggs.forEach(function nestAdhocSubAggs(subAggConfig) {
        subDslLvl[subAggConfig.id] = subAggConfig.toDsl();
      });
    }

    if (output.parentAggs) {
      var _subDslLvl = configDsl.parentAggs || (configDsl.parentAggs = {});
      output.parentAggs.forEach(function nestAdhocSubAggs(subAggConfig) {
        _subDslLvl[subAggConfig.id] = subAggConfig.toDsl();
      });
    }

    return configDsl;
  };

  AggConfig.prototype.toJSON = function () {
    var self = this;
    var params = self.params;

    var outParams = _lodash2.default.transform(self.getAggParams(), function (out, aggParam) {
      var val = params[aggParam.name];

      // don't serialize undefined/null values
      if (val == null) return;
      if (aggParam.serialize) val = aggParam.serialize(val, self);
      if (val == null) return;

      // to prevent accidental leaking, we will clone all complex values
      out[aggParam.name] = _lodash2.default.cloneDeep(val);
    }, {});

    return {
      id: self.id,
      enabled: self.enabled,
      type: self.type && self.type.name,
      schema: self.schema && self.schema.name,
      params: outParams
    };
  };

  AggConfig.prototype.getAggParams = function () {
    return [].concat(this.type ? this.type.params.raw : [], _lodash2.default.has(this, 'schema.params') ? this.schema.params.raw : []);
  };

  AggConfig.prototype.getRequestAggs = function () {
    if (!this.type) return;
    return this.type.getRequestAggs(this) || [this];
  };

  AggConfig.prototype.getResponseAggs = function () {
    if (!this.type) return;
    return this.type.getResponseAggs(this) || [this];
  };

  AggConfig.prototype.getValue = function (bucket) {
    return this.type.getValue(this, bucket);
  };

  AggConfig.prototype.getKey = function (bucket, key) {
    return this.type.getKey(bucket, key, this);
  };

  AggConfig.prototype.getFieldDisplayName = function () {
    var field = this.getField();
    return field ? field.displayName || this.fieldName() : '';
  };

  AggConfig.prototype.getField = function () {
    return this.params.field;
  };

  AggConfig.prototype.makeLabel = function () {
    if (this.params.customLabel) {
      return this.params.customLabel;
    }

    if (!this.type) return '';
    var pre = _lodash2.default.get(this.vis, 'params.mode') === 'percentage' ? 'Percentage of ' : '';
    return pre += this.type.makeLabel(this);
  };

  AggConfig.prototype.getIndexPattern = function () {
    return this.vis.indexPattern;
  };

  AggConfig.prototype.getFieldOptions = function () {
    var fieldParamType = this.type && this.type.params.byName.field;

    if (!fieldParamType || !fieldParamType.getFieldOptions) {
      return null;
    }

    return fieldParamType.getFieldOptions(this);
  };

  AggConfig.prototype.fieldFormatter = function (contentType, defaultFormat) {
    var format = this.type && this.type.getFormat(this);
    if (format) return format.getConverterFor(contentType);
    return this.fieldOwnFormatter(contentType, defaultFormat);
  };

  AggConfig.prototype.fieldOwnFormatter = function (contentType, defaultFormat) {
    var field = this.getField();
    var format = field && field.format;
    if (!format) format = defaultFormat;
    if (!format) format = fieldFormats.getDefaultInstance('string');
    return format.getConverterFor(contentType);
  };

  AggConfig.prototype.fieldName = function () {
    var field = this.getField();
    return field ? field.name : '';
  };

  AggConfig.prototype.fieldIsTimeField = function () {
    var timeFieldName = this.vis.indexPattern.timeFieldName;
    return timeFieldName && this.fieldName() === timeFieldName;
  };

  return AggConfig;
}

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesBucketsBucketAggTypeProvider = AggTypesBucketsBucketAggTypeProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _agg_type = __webpack_require__(527);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function AggTypesBucketsBucketAggTypeProvider(Private) {
  var AggType = Private(_agg_type.AggTypesAggTypeProvider);

  _lodash2.default.class(BucketAggType).inherits(AggType);
  function BucketAggType(config) {
    BucketAggType.Super.call(this, config);

    if (_lodash2.default.isFunction(config.getKey)) {
      this.getKey = config.getKey;
    }
  }

  BucketAggType.prototype.getKey = function (bucket, key) {
    return key || bucket.key;
  };

  return BucketAggType;
}

/***/ }),
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.buildRangeFilter = buildRangeFilter;
exports.getRangeScript = getRangeScript;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OPERANDS_IN_RANGE = 2;

function buildRangeFilter(field, params, indexPattern, formattedValue) {
  var filter = { meta: { index: indexPattern.id } };
  if (formattedValue) filter.meta.formattedValue = formattedValue;

  params = _lodash2.default.mapValues(params, function (value) {
    return field.type === 'number' ? parseFloat(value) : value;
  });

  if ('gte' in params && 'gt' in params) throw new Error('gte and gt are mutually exclusive');
  if ('lte' in params && 'lt' in params) throw new Error('lte and lt are mutually exclusive');

  var totalInfinite = ['gt', 'lt'].reduce(function (totalInfinite, op) {
    var key = op in params ? op : op + 'e';
    var isInfinite = Math.abs(params[key]) === Infinity;

    if (isInfinite) {
      totalInfinite++;
      delete params[key];
    }

    return totalInfinite;
  }, 0);

  if (totalInfinite === OPERANDS_IN_RANGE) {
    filter.match_all = {};
    filter.meta.field = field.name;
  } else if (field.scripted) {
    filter.script = getRangeScript(field, params);
    filter.meta.field = field.name;
  } else {
    filter.range = {};
    filter.range[field.name] = params;
  }

  return filter;
}

function getRangeScript(field, params) {
  var operators = {
    gt: '>',
    gte: '>=',
    lte: '<=',
    lt: '<'
  };
  var comparators = {
    gt: 'boolean gt(Supplier s, def v) {return s.get() > v}',
    gte: 'boolean gte(Supplier s, def v) {return s.get() >= v}',
    lte: 'boolean lte(Supplier s, def v) {return s.get() <= v}',
    lt: 'boolean lt(Supplier s, def v) {return s.get() < v}'
  };

  var knownParams = _lodash2.default.pick(params, function (val, key) {
    return key in operators;
  });
  var script = _lodash2.default.map(knownParams, function (val, key) {
    return '(' + field.script + ')' + operators[key] + key;
  }).join(' && ');

  // We must wrap painless scripts in a lambda in case they're more than a simple expression
  if (field.lang === 'painless') {
    var currentComparators = _lodash2.default.reduce(knownParams, function (acc, val, key) {
      return acc.concat(comparators[key]);
    }, []).join(' ');

    var comparisons = _lodash2.default.map(knownParams, function (val, key) {
      return key + '(() -> { ' + field.script + ' }, params.' + key + ')';
    }).join(' && ');

    script = '' + currentComparators + comparisons;
  }

  var value = _lodash2.default.map(knownParams, function (val, key) {
    return operators[key] + field.format.convert(val);
  }).join(' ');

  return {
    script: {
      inline: script,
      params: _extends({}, knownParams, {
        value: value
      }),
      lang: field.lang
    }
  };
}

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _documentation_links = __webpack_require__(2113);

var _modules = __webpack_require__(2);

var _module = _modules.uiModules.get('kibana');

_module.directive('documentationHref', function () {
  return {
    restrict: 'A',
    link: function link(scope, element, attributes) {
      element.attr('href', (0, _lodash.get)(_documentation_links.documentationLinks, attributes.documentationHref));
    }
  };
});

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FilterBarQueryFilterProvider = FilterBarQueryFilterProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _only_disabled = __webpack_require__(2154);

var _only_state_changed = __webpack_require__(2155);

var _uniq_filters = __webpack_require__(790);

var _compare_filters = __webpack_require__(328);

var _events = __webpack_require__(133);

var _map_and_flatten_filters = __webpack_require__(327);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function FilterBarQueryFilterProvider(Private, $rootScope, getAppState, globalState, config) {
  var EventEmitter = Private(_events.EventsProvider);
  var mapAndFlattenFilters = Private(_map_and_flatten_filters.FilterBarLibMapAndFlattenFiltersProvider);

  var queryFilter = new EventEmitter();

  queryFilter.getFilters = function () {
    var compareOptions = { disabled: true, negate: true };
    var appFilters = queryFilter.getAppFilters();
    var globalFilters = queryFilter.getGlobalFilters();

    return (0, _uniq_filters.uniqFilters)(globalFilters.concat(appFilters), compareOptions);
  };

  queryFilter.getAppFilters = function () {
    var appState = getAppState();
    if (!appState || !appState.filters) return [];

    // Work around for https://github.com/elastic/kibana/issues/5896
    appState.filters = validateStateFilters(appState);

    return appState.filters ? _lodash2.default.map(appState.filters, appendStoreType('appState')) : [];
  };

  queryFilter.getGlobalFilters = function () {
    if (!globalState.filters) return [];

    // Work around for https://github.com/elastic/kibana/issues/5896
    globalState.filters = validateStateFilters(globalState);

    return _lodash2.default.map(globalState.filters, appendStoreType('globalState'));
  };

  /**
   * Adds new filters to the scope and state
   * @param {object|array} filters Filter(s) to add
   * @param {bool} global Whether the filter should be added to global state
   * @returns {Promise} filter map promise
   */
  queryFilter.addFilters = function (filters, global) {

    if (global === undefined) {
      var configDefault = config.get('filters:pinnedByDefault');

      if (configDefault === false || configDefault === true) {
        global = configDefault;
      }
    }

    // Determine the state for the new filter (whether to pass the filter through other apps or not)
    var appState = getAppState();
    var filterState = global ? globalState : appState;

    if (!Array.isArray(filters)) {
      filters = [filters];
    }

    return mapAndFlattenFilters(filters).then(function (filters) {
      if (!filterState.filters) {
        filterState.filters = [];
      }

      filterState.filters = filterState.filters.concat(filters);
    });
  };

  /**
   * Removes the filter from the proper state
   * @param {object} matchFilter The filter to remove
   */
  queryFilter.removeFilter = function (matchFilter) {
    var appState = getAppState();
    var filter = _lodash2.default.omit(matchFilter, ['$$hashKey']);
    var state = void 0;
    var index = void 0;

    // check for filter in appState
    if (appState) {
      index = _lodash2.default.findIndex(appState.filters, filter);
      if (index !== -1) state = appState;
    }

    // if not found, check for filter in globalState
    if (!state) {
      index = _lodash2.default.findIndex(globalState.filters, filter);
      if (index !== -1) state = globalState;else return; // not found in either state, do nothing
    }

    state.filters.splice(index, 1);
  };

  /**
   * Removes all filters
   */
  queryFilter.removeAll = function () {
    var appState = getAppState();
    appState.filters = [];
    globalState.filters = [];
  };

  /**
   * Toggles the filter between enabled/disabled.
   * @param {object} filter The filter to toggle
   & @param {boolean} force Disabled true/false
   * @returns {object} updated filter
   */
  queryFilter.toggleFilter = function (filter, force) {
    // Toggle the disabled flag
    var disabled = _lodash2.default.isUndefined(force) ? !filter.meta.disabled : !!force;
    filter.meta.disabled = disabled;
    return filter;
  };

  /**
   * Disables all filters
   * @params {boolean} force Disable/enable all filters
   */
  queryFilter.toggleAll = function (force) {
    function doToggle(filter) {
      queryFilter.toggleFilter(filter, force);
    }

    executeOnFilters(doToggle);
  };

  /**
   * Inverts the nagate value on the filter
   * @param {object} filter The filter to toggle
   * @returns {object} updated filter
   */
  queryFilter.invertFilter = function (filter) {
    // Toggle the negate meta state
    filter.meta.negate = !filter.meta.negate;
    return filter;
  };

  /**
   * Inverts all filters
   * @returns {object} Resulting updated filter list
   */
  queryFilter.invertAll = function () {
    executeOnFilters(queryFilter.invertFilter);
  };

  /**
   * Pins the filter to the global state
   * @param {object} filter The filter to pin
   * @param {boolean} force pinned state
   * @returns {object} updated filter
   */
  queryFilter.pinFilter = function (filter, force) {
    var appState = getAppState();
    if (!appState) return filter;

    // ensure that both states have a filters property
    if (!Array.isArray(globalState.filters)) globalState.filters = [];
    if (!Array.isArray(appState.filters)) appState.filters = [];

    var appIndex = _lodash2.default.findIndex(appState.filters, function (appFilter) {
      return _lodash2.default.isEqual(appFilter, filter);
    });

    if (appIndex !== -1 && force !== false) {
      appState.filters.splice(appIndex, 1);
      globalState.filters.push(filter);
    } else {
      var globalIndex = _lodash2.default.findIndex(globalState.filters, function (globalFilter) {
        return _lodash2.default.isEqual(globalFilter, filter);
      });

      if (globalIndex === -1 || force === true) return filter;

      globalState.filters.splice(globalIndex, 1);
      appState.filters.push(filter);
    }

    return filter;
  };

  /**
   * Pins all filters
   * @params {boolean} force Pin/Unpin all filters
   */
  queryFilter.pinAll = function (force) {
    function pin(filter) {
      queryFilter.pinFilter(filter, force);
    }

    executeOnFilters(pin);
  };

  initWatchers();

  return queryFilter;

  /**
   * Rids filter list of null values and replaces state if any nulls are found
   */
  function validateStateFilters(state) {
    var compacted = _lodash2.default.compact(state.filters);
    if (state.filters.length !== compacted.length) {
      state.filters = compacted;
      state.replace();
    }
    return state.filters;
  }

  /**
   * Saves both app and global states, ensuring filters are persisted
   * @returns {object} Resulting filter list, app and global combined
   */
  function saveState() {
    var appState = getAppState();
    if (appState) appState.save();
    globalState.save();
  }

  function appendStoreType(type) {
    return function (filter) {
      filter.$state = {
        store: type
      };
      return filter;
    };
  }

  // helper to run a function on all filters in all states
  function executeOnFilters(fn) {
    var appState = getAppState();
    var globalFilters = [];
    var appFilters = [];

    if (globalState.filters) globalFilters = globalState.filters;
    if (appState && appState.filters) appFilters = appState.filters;

    globalFilters.concat(appFilters).forEach(fn);
  }

  function mergeStateFilters(gFilters, aFilters, compareOptions) {
    // ensure we don't mutate the filters passed in
    var globalFilters = gFilters ? _lodash2.default.cloneDeep(gFilters) : [];
    var appFilters = aFilters ? _lodash2.default.cloneDeep(aFilters) : [];
    compareOptions = _lodash2.default.defaults(compareOptions || {}, { disabled: true });

    // existing globalFilters should be mutated by appFilters
    _lodash2.default.each(appFilters, function (filter, i) {
      var match = _lodash2.default.find(globalFilters, function (globalFilter) {
        return (0, _compare_filters.compareFilters)(globalFilter, filter, compareOptions);
      });

      // no match, do nothing
      if (!match) return;

      // matching filter in globalState, update global and remove from appState
      _lodash2.default.assign(match.meta, filter.meta);
      appFilters.splice(i, 1);
    });

    return [(0, _uniq_filters.uniqFilters)(globalFilters, { disabled: true }), (0, _uniq_filters.uniqFilters)(appFilters, { disabled: true })];
  }

  /**
   * Initializes state watchers that use the event emitter
   * @returns {void}
   */
  function initWatchers() {
    var removeAppStateWatchers = void 0;

    $rootScope.$watch(getAppState, function () {
      removeAppStateWatchers && removeAppStateWatchers();
      removeAppStateWatchers = initAppStateWatchers();
    });

    function initAppStateWatchers() {
      // multi watch on the app and global states
      var stateWatchers = [{
        fn: $rootScope.$watch,
        deep: true,
        get: queryFilter.getGlobalFilters
      }, {
        fn: $rootScope.$watch,
        deep: true,
        get: queryFilter.getAppFilters
      }];

      // when states change, use event emitter to trigger updates and fetches
      return $rootScope.$watchMulti(stateWatchers, function (next, prev) {
        // prevent execution on watcher instantiation
        if (_lodash2.default.isEqual(next, prev)) return;

        var doUpdate = false;
        var doFetch = false;

        // reconcile filter in global and app states
        var filters = mergeStateFilters(next[0], next[1]);
        var globalFilters = filters[0];
        var appFilters = filters[1];
        var appState = getAppState();

        // save the state, as it may have updated
        var globalChanged = !_lodash2.default.isEqual(next[0], globalFilters);
        var appChanged = !_lodash2.default.isEqual(next[1], appFilters);

        // the filters were changed, apply to state (re-triggers this watcher)
        if (globalChanged || appChanged) {
          globalState.filters = globalFilters;
          if (appState) appState.filters = appFilters;
          return;
        }

        // check for actions, bail if we're done
        getActions();
        if (!doUpdate) return;

        // save states and emit the required events
        saveState();
        queryFilter.emit('update').then(function () {
          if (!doFetch) return;
          queryFilter.emit('fetch');
        });

        // iterate over each state type, checking for changes
        function getActions() {
          var newFilters = [];
          var oldFilters = [];

          stateWatchers.forEach(function (watcher, i) {
            var nextVal = next[i];
            var prevVal = prev[i];
            newFilters = newFilters.concat(nextVal);
            oldFilters = oldFilters.concat(prevVal);

            // no update or fetch if there was no change
            if (nextVal === prevVal) return;

            if (nextVal) doUpdate = true;

            // don't trigger fetch when only disabled filters
            if (!(0, _only_disabled.onlyDisabled)(nextVal, prevVal)) doFetch = true;
          });

          // make sure change wasn't only a state move
          // checking length first is an optimization
          if (doFetch && newFilters.length === oldFilters.length) {
            if ((0, _only_state_changed.onlyStateChanged)(newFilters, oldFilters)) doFetch = false;
          }
        }
      });
    }
  }
}

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RIGHT_ALIGNMENT = exports.LEFT_ALIGNMENT = exports.SortableProperties = exports.htmlIdGenerator = exports.comboBoxKeyCodes = exports.cascadingMenuKeyCodes = exports.accessibleClickKeys = exports.keyCodes = undefined;

var _accessibility = __webpack_require__(2250);

Object.defineProperty(exports, 'accessibleClickKeys', {
  enumerable: true,
  get: function get() {
    return _accessibility.accessibleClickKeys;
  }
});
Object.defineProperty(exports, 'cascadingMenuKeyCodes', {
  enumerable: true,
  get: function get() {
    return _accessibility.cascadingMenuKeyCodes;
  }
});
Object.defineProperty(exports, 'comboBoxKeyCodes', {
  enumerable: true,
  get: function get() {
    return _accessibility.comboBoxKeyCodes;
  }
});
Object.defineProperty(exports, 'htmlIdGenerator', {
  enumerable: true,
  get: function get() {
    return _accessibility.htmlIdGenerator;
  }
});

var _sort = __webpack_require__(2257);

Object.defineProperty(exports, 'SortableProperties', {
  enumerable: true,
  get: function get() {
    return _sort.SortableProperties;
  }
});

var _alignment = __webpack_require__(2259);

Object.defineProperty(exports, 'LEFT_ALIGNMENT', {
  enumerable: true,
  get: function get() {
    return _alignment.LEFT_ALIGNMENT;
  }
});
Object.defineProperty(exports, 'RIGHT_ALIGNMENT', {
  enumerable: true,
  get: function get() {
    return _alignment.RIGHT_ALIGNMENT;
  }
});

var _key_codes = __webpack_require__(329);

var keyCodes = _interopRequireWildcard(_key_codes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.keyCodes = keyCodes; // Export all keyCodes under a `keyCodes` named variable

/***/ }),
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EventsProvider = EventsProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _notifier = __webpack_require__(43);

var _simple_emitter = __webpack_require__(437);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function EventsProvider(Private, Promise) {
  var notify = new _notifier.Notifier({ location: 'EventEmitter' });

  _lodash2.default.class(Events).inherits(_simple_emitter.SimpleEmitter);
  function Events() {
    Events.Super.call(this);
    this._listeners = {};
    this._emitChain = Promise.resolve();
  }

  /**
   * Listens for events
   * @param {string} name - The name of the event
   * @param {function} handler - The function to call when the event is triggered
   * @return {Events} - this, for chaining
   */
  Events.prototype.on = function (name, handler) {
    if (!Array.isArray(this._listeners[name])) {
      this._listeners[name] = [];
    }

    var listener = {
      handler: handler
    };
    this._listeners[name].push(listener);

    (function rebuildDefer() {
      listener.defer = Promise.defer();
      listener.resolved = listener.defer.promise.then(function (args) {
        rebuildDefer();

        // we ignore the completion of handlers, just watch for unhandled errors
        Promise.resolve(handler.apply(handler, args)).catch(notify.fatal);
      });
    })();

    return this;
  };

  /**
   * Removes an event listener
   * @param {string} [name] - The name of the event
   * @param {function} [handler] - The handler to remove
   * @return {Events} - this, for chaining
   */
  Events.prototype.off = function (name, handler) {
    if (!name && !handler) {
      return this.removeAllListeners();
    }

    // exit early if there is not an event that matches
    if (!this._listeners[name]) return this;

    // If no hander remove all the events
    if (!handler) {
      delete this._listeners[name];
    } else {
      this._listeners[name] = _lodash2.default.filter(this._listeners[name], function (listener) {
        return handler !== listener.handler;
      });
    }

    return this;
  };

  /**
   * Emits the event to all listeners
   *
   * @param {string} name - The name of the event.
   * @param {any} [value] - The value that will be passed to all event handlers.
   * @returns {Promise}
   */
  Events.prototype.emit = function (name) {
    var self = this;
    var args = _lodash2.default.rest(arguments);

    if (!self._listeners[name]) {
      return self._emitChain;
    }

    return Promise.map(self._listeners[name], function (listener) {
      return self._emitChain = self._emitChain.then(function () {
        // Double check that off wasn't called after an emit, but before this is fired.
        if (!self._listeners[name] || self._listeners[name].indexOf(listener) < 0) return;

        listener.defer.resolve(args);
        return listener.resolved;
      });
    });
  };

  /**
   * Get a list of the handler functions for a specific event
   *
   * @param  {string} name
   * @return {array[function]}
   */
  Events.prototype.listeners = function (name) {
    return _lodash2.default.pluck(this._listeners[name], 'handler');
  };

  return Events;
} /**
   * @name Events
   *
   * @extends SimpleEmitter
   */

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SavedObjectRegistryProvider = undefined;

var _registry = __webpack_require__(63);

var SavedObjectRegistryProvider = exports.SavedObjectRegistryProvider = (0, _registry.uiRegistry)({
  name: 'savedObjects',
  index: ['loaderProperties.name'],
  order: ['loaderProperties.name']
});

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SearchSourceProvider = SearchSourceProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _normalize_sort_request = __webpack_require__(2044);

var _root_search_source = __webpack_require__(763);

var _abstract = __webpack_require__(2045);

var _request = __webpack_require__(766);

var _segmented = __webpack_require__(2095);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /**
                                                                                                                                                                                                     * @name SearchSource
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * @description A promise-based stream of search results that can inherit from other search sources.
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * Because filters/queries in Kibana have different levels of persistence and come from different
                                                                                                                                                                                                     * places, it is important to keep track of where filters come from for when they are saved back to
                                                                                                                                                                                                     * the savedObject store in the Kibana index. To do this, we create trees of searchSource objects
                                                                                                                                                                                                     * that can have associated query parameters (index, query, filter, etc) which can also inherit from
                                                                                                                                                                                                     * other searchSource objects.
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * At query time, all of the searchSource objects that have subscribers are "flattened", at which
                                                                                                                                                                                                     * point the query params from the searchSource are collected while traversing up the inheritance
                                                                                                                                                                                                     * chain. At each link in the chain a decision about how to merge the query params is made until a
                                                                                                                                                                                                     * single set of query parameters is created for each active searchSource (a searchSource with
                                                                                                                                                                                                     * subscribers).
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * That set of query parameters is then sent to elasticsearch. This is how the filter hierarchy
                                                                                                                                                                                                     * works in Kibana.
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * Visualize, starting from a new search:
                                                                                                                                                                                                     *
                                                                                                                                                                                                     *  - the `savedVis.searchSource` is set as the `appSearchSource`.
                                                                                                                                                                                                     *  - The `savedVis.searchSource` would normally inherit from the `appSearchSource`, but now it is
                                                                                                                                                                                                     *    upgraded to inherit from the `rootSearchSource`.
                                                                                                                                                                                                     *  - Any interaction with the visualization will still apply filters to the `appSearchSource`, so
                                                                                                                                                                                                     *    they will be stored directly on the `savedVis.searchSource`.
                                                                                                                                                                                                     *  - Any interaction with the time filter will be written to the `rootSearchSource`, so those
                                                                                                                                                                                                     *    filters will not be saved by the `savedVis`.
                                                                                                                                                                                                     *  - When the `savedVis` is saved to elasticsearch, it takes with it all the filters that are
                                                                                                                                                                                                     *    defined on it directly, but none of the ones that it inherits from other places.
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * Visualize, starting from an existing search:
                                                                                                                                                                                                     *
                                                                                                                                                                                                     *  - The `savedVis` loads the `savedSearch` on which it is built.
                                                                                                                                                                                                     *  - The `savedVis.searchSource` is set to inherit from the `saveSearch.searchSource` and set as
                                                                                                                                                                                                     *    the `appSearchSource`.
                                                                                                                                                                                                     *  - The `savedSearch.searchSource`, is set to inherit from the `rootSearchSource`.
                                                                                                                                                                                                     *  - Then the `savedVis` is written to elasticsearch it will be flattened and only include the
                                                                                                                                                                                                     *    filters created in the visualize application and will reconnect the filters from the
                                                                                                                                                                                                     *    `savedSearch` at runtime to prevent losing the relationship
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * Dashboard search sources:
                                                                                                                                                                                                     *
                                                                                                                                                                                                     *  - Each panel in a dashboard has a search source.
                                                                                                                                                                                                     *  - The `savedDashboard` also has a searchsource, and it is set as the `appSearchSource`.
                                                                                                                                                                                                     *  - Each panel's search source inherits from the `appSearchSource`, meaning that they inherit from
                                                                                                                                                                                                     *    the dashboard search source.
                                                                                                                                                                                                     *  - When a filter is added to the search box, or via a visualization, it is written to the
                                                                                                                                                                                                     *    `appSearchSource`.
                                                                                                                                                                                                     */

function SearchSourceProvider(Promise, Private, config) {
  var SourceAbstract = Private(_abstract.AbstractDataSourceProvider);
  var SearchRequest = Private(_request.SearchRequestProvider);
  var SegmentedRequest = Private(_segmented.SegmentedRequestProvider);
  var normalizeSortRequest = Private(_normalize_sort_request.NormalizeSortRequestProvider);

  var forIp = Symbol('for which index pattern?');

  function isIndexPattern(val) {
    return Boolean(val && typeof val.toIndexList === 'function');
  }

  _lodash2.default.class(SearchSource).inherits(SourceAbstract);
  function SearchSource(initialState) {
    SearchSource.Super.call(this, initialState);
  }

  /*****
   * PUBLIC API
   *****/

  /**
   * List of the editable state properties that turn into a
   * chainable API
   *
   * @type {Array}
   */
  SearchSource.prototype._methods = ['type', 'query', 'filter', 'sort', 'highlight', 'highlightAll', 'aggs', 'from', 'searchAfter', 'size', 'source', 'version', 'fields'];

  SearchSource.prototype.index = function (indexPattern) {
    var state = this._state;

    var hasSource = state.source;
    var sourceCameFromIp = hasSource && state.source.hasOwnProperty(forIp);
    var sourceIsForOurIp = sourceCameFromIp && state.source[forIp] === state.index;
    if (sourceIsForOurIp) {
      delete state.source;
    }

    if (indexPattern === undefined) return state.index;
    if (indexPattern === null) return delete state.index;
    if (!isIndexPattern(indexPattern)) {
      throw new TypeError('expected indexPattern to be an IndexPattern duck.');
    }

    state.index = indexPattern;
    if (!state.source) {
      // imply source filtering based on the index pattern, but allow overriding
      // it by simply setting another value for "source". When index is changed
      state.source = function () {
        return indexPattern.getSourceFiltering();
      };
      state.source[forIp] = indexPattern;
    }

    return this;
  };

  SearchSource.prototype.extend = function () {
    return new SearchSource().inherits(this);
  };

  /**
   * Set a searchSource that this source should inherit from
   * @param  {SearchSource} searchSource - the parent searchSource
   * @return {this} - chainable
   */
  SearchSource.prototype.inherits = function (parent) {
    this._parent = parent;
    return this;
  };

  /**
   * Get the parent of this SearchSource
   * @return {undefined|searchSource}
   */
  SearchSource.prototype.getParent = function (onlyHardLinked) {
    var self = this;
    if (self._parent === false) return;
    if (self._parent) return self._parent;
    return onlyHardLinked || this.skipTimeRangeFilter ? undefined : Private(_root_search_source.RootSearchSourceProvider).get();
  };

  /**
   * Temporarily prevent this Search from being fetched... not a fan but it's easy
   */
  SearchSource.prototype.disable = function () {
    this._fetchDisabled = true;
  };

  /**
   * Reverse of SourceAbstract#disable(), only need to call this if source was previously disabled
   */
  SearchSource.prototype.enable = function () {
    this._fetchDisabled = false;
  };

  SearchSource.prototype.onBeginSegmentedFetch = function (initFunction) {
    var self = this;
    return new Promise(function (resolve, reject) {
      function addRequest() {
        var defer = Promise.defer();
        var req = new SegmentedRequest(self, defer, initFunction);

        req.setErrorHandler(function (request, error) {
          reject(error);
          request.abort();
        });

        // Return promises created by the completion handler so that
        // errors will bubble properly
        return req.getCompletePromise().then(addRequest);
      }
      addRequest();
    });
  };

  /******
   * PRIVATE APIS
   ******/

  /**
   * Gets the type of the DataSource
   * @return {string}
   */
  SearchSource.prototype._getType = function () {
    return 'search';
  };

  /**
   * Create a common search request object, which should
   * be put into the pending request queye, for this search
   * source
   *
   * @param {Deferred} defer - the deferred object that should be resolved
   *                         when the request is complete
   * @return {SearchRequest}
   */
  SearchSource.prototype._createRequest = function (defer) {
    return new SearchRequest(this, defer);
  };

  /**
   * Used to merge properties into the state within ._flatten().
   * The state is passed in and modified by the function
   *
   * @param  {object} state - the current merged state
   * @param  {*} val - the value at `key`
   * @param  {*} key - The key of `val`
   * @return {undefined}
   */
  SearchSource.prototype._mergeProp = function (state, val, key) {
    if (typeof val === 'function') {
      var source = this;
      return Promise.cast(val(this)).then(function (newVal) {
        return source._mergeProp(state, newVal, key);
      });
    }

    if (val == null || !key || !_lodash2.default.isString(key)) return;

    switch (key) {
      case 'filter':
        var verifiedFilters = val;
        if (config.get('courier:ignoreFilterIfFieldNotInIndex')) {
          if (!Array.isArray(val)) val = [val];
          verifiedFilters = val.filter(function (el) {
            if ('meta' in el && 'index' in state) {
              var field = state.index.fields.byName[el.meta.key];
              if (!field) return false;
            }
            return true;
          });
        }
        // user a shallow flatten to detect if val is an array, and pull the values out if it is
        state.filters = (0, _lodash2.default)([state.filters || [], verifiedFilters]).flatten()
        // Yo Dawg! I heard you needed to filter out your filters
        .reject(function (filter) {
          return !filter || _lodash2.default.get(filter, 'meta.disabled');
        }).value();
        return;
      case 'index':
      case 'type':
      case 'id':
      case 'highlightAll':
        if (key && state[key] == null) {
          state[key] = val;
        }
        return;
      case 'searchAfter':
        key = 'search_after';
        addToBody();
        break;
      case 'source':
        key = '_source';
        addToBody();
        break;
      case 'sort':
        val = normalizeSortRequest(val, this.get('index'));
        addToBody();
        break;
      case 'query':
        state.query = (state.query || []).concat(val);
        break;
      case 'fields':
        state[key] = _lodash2.default.uniq([].concat(_toConsumableArray(state[key] || []), _toConsumableArray(val)));
        break;
      default:
        addToBody();
    }

    /**
     * Add the key and val to the body of the request
     */
    function addToBody() {
      state.body = state.body || {};
      // ignore if we already have a value
      if (state.body[key] == null) {
        state.body[key] = val;
      }
    }
  };

  SearchSource.prototype.clone = function () {
    var clone = new SearchSource(this.toString());
    // when serializing the internal state with .toString() we lose the internal classes used in the index
    // pattern, so we have to set it again to workaround this behavior
    clone.set('index', this.get('index'));
    clone.inherits(this.getParent());
    return clone;
  };

  SearchSource.prototype.getSearchRequestBody = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    var searchRequest;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return this._flatten();

          case 2:
            searchRequest = _context.sent;
            return _context.abrupt('return', searchRequest.body);

          case 4:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return SearchSource;
}

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ast = __webpack_require__(2064);

Object.defineProperty(exports, 'fromKueryExpression', {
  enumerable: true,
  get: function get() {
    return _ast.fromKueryExpression;
  }
});
Object.defineProperty(exports, 'fromKqlExpression', {
  enumerable: true,
  get: function get() {
    return _ast.fromKqlExpression;
  }
});
Object.defineProperty(exports, 'toKueryExpression', {
  enumerable: true,
  get: function get() {
    return _ast.toKueryExpression;
  }
});
Object.defineProperty(exports, 'toElasticsearchQuery', {
  enumerable: true,
  get: function get() {
    return _ast.toElasticsearchQuery;
  }
});

/***/ }),
/* 137 */,
/* 138 */,
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeNestedLabel = undefined;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var makeNestedLabel = function makeNestedLabel(aggConfig, label) {
  var uppercaseLabel = _lodash2.default.startCase(label);
  if (aggConfig.params.customMetric) {
    var metricLabel = aggConfig.params.customMetric.makeLabel();
    if (metricLabel.includes(uppercaseLabel + ' of ')) {
      metricLabel = metricLabel.substring((uppercaseLabel + ' of ').length);
      metricLabel = '2. ' + label + ' of ' + metricLabel;
    } else if (metricLabel.includes(label + ' of ')) {
      metricLabel = parseInt(metricLabel.substring(0, 1)) + 1 + metricLabel.substring(1);
    } else {
      metricLabel = uppercaseLabel + ' of ' + metricLabel;
    }
    return metricLabel;
  }
  var metric = aggConfig.vis.aggs.find(function (agg) {
    return agg.id === aggConfig.params.metricAgg;
  });
  if (!metric) return '';
  return uppercaseLabel + ' of ' + metric.makeLabel();
};

exports.makeNestedLabel = makeNestedLabel;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AutocompleteComponent = AutocompleteComponent;
exports.wrapComponentWithDefaults = wrapComponentWithDefaults;
exports.resolvePathToComponents = resolvePathToComponents;
exports.populateContext = populateContext;
var _ = __webpack_require__(1);

function AutocompleteComponent(name) {
  this.name = name;
}

/** called to get the possible suggestions for tokens, when this object is at the end of
 * the resolving chain (and thus can suggest possible continuation paths)
 */
AutocompleteComponent.prototype.getTerms = function () {
  return [];
};

/*
 if the current matcher matches this term, this method should return an object with the following keys
 {
 context_values: {
 values extract from term that should be added to the context
 }
 next: AutocompleteComponent(s) to use next
 priority: optional priority to solve collisions between multiple paths. Min value is used across entire chain
 }
 */
AutocompleteComponent.prototype.match = function () {
  return {
    next: this.next
  };
};

function SharedComponent(name, parent) {
  AutocompleteComponent.call(this, name);
  this._nextDict = {};
  if (parent) {
    parent.addComponent(this);
  }
  // for debugging purposes
  this._parent = parent;
}

SharedComponent.prototype = _.create(AutocompleteComponent.prototype, { 'constructor': SharedComponent });

(function (cls) {
  /* return the first component with a given name */
  cls.getComponent = function (name) {
    return (this._nextDict[name] || [undefined])[0];
  };

  cls.addComponent = function (component) {
    var current = this._nextDict[component.name] || [];
    current.push(component);
    this._nextDict[component.name] = current;
    this.next = [].concat.apply([], _.values(this._nextDict));
  };
})(SharedComponent.prototype);

/** A component that suggests one of the give options, but accepts anything */
function ListComponent(name, list, parent, multi_valued, allow_non_valid_values) {
  SharedComponent.call(this, name, parent);
  this.listGenerator = Array.isArray(list) ? function () {
    return list;
  } : list;
  this.multi_valued = _.isUndefined(multi_valued) ? true : multi_valued;
  this.allow_non_valid_values = _.isUndefined(allow_non_valid_values) ? false : allow_non_valid_values;
}

ListComponent.prototype = _.create(SharedComponent.prototype, { "constructor": ListComponent });

(function (cls) {
  cls.getTerms = function (context, editor) {
    if (!this.multi_valued && context.otherTokenValues) {
      // already have a value -> no suggestions
      return [];
    }
    var already_set = context.otherTokenValues || [];
    if (_.isString(already_set)) {
      already_set = [already_set];
    }
    var ret = _.difference(this.listGenerator(context, editor), already_set);

    if (this.getDefaultTermMeta()) {
      var meta = this.getDefaultTermMeta();
      ret = _.map(ret, function (term) {
        if (_.isString(term)) {
          term = { "name": term };
        }
        return _.defaults(term, { meta: meta });
      });
    }

    return ret;
  };

  cls.validateTokens = function (tokens) {
    if (!this.multi_valued && tokens.length > 1) {
      return false;
    }

    // verify we have all tokens
    var list = this.listGenerator();
    var not_found = _.any(tokens, function (token) {
      return list.indexOf(token) == -1;
    });

    if (not_found) {
      return false;
    }
    return true;
  };

  cls.getContextKey = function () {
    return this.name;
  };

  cls.getDefaultTermMeta = function () {
    return this.name;
  };

  cls.match = function (token, context, editor) {
    if (!Array.isArray(token)) {
      token = [token];
    }
    if (!this.allow_non_valid_values && !this.validateTokens(token, context, editor)) {
      return null;
    }

    var result = Object.getPrototypeOf(cls).match.call(this, token, context, editor);
    result.context_values = result.context_values || {};
    result.context_values[this.getContextKey()] = token;
    return result;
  };
})(ListComponent.prototype);

function SimpleParamComponent(name, parent) {
  SharedComponent.call(this, name, parent);
}

SimpleParamComponent.prototype = _.create(SharedComponent.prototype, { "constructor": SimpleParamComponent });

(function (cls) {
  cls.match = function (token, context, editor) {
    var result = Object.getPrototypeOf(cls).match.call(this, token, context, editor);
    result.context_values = result.context_values || {};
    result.context_values[this.name] = token;
    return result;
  };
})(SimpleParamComponent.prototype);

function ConstantComponent(name, parent, options) {
  SharedComponent.call(this, name, parent);
  if (_.isString(options)) {
    options = [options];
  }
  this.options = options || [name];
}

ConstantComponent.prototype = _.create(SharedComponent.prototype, { "constructor": ConstantComponent });

exports.SharedComponent = SharedComponent;
exports.ListComponent = ListComponent;
exports.SimpleParamComponent = SimpleParamComponent;
exports.ConstantComponent = ConstantComponent;


(function (cls) {
  cls.getTerms = function () {
    return this.options;
  };

  cls.addOption = function (options) {
    if (!Array.isArray(options)) {
      options = [options];
    }

    [].push.apply(this.options, options);
    this.options = _.uniq(this.options);
  };
  cls.match = function (token, context, editor) {
    if (token !== this.name) {
      return null;
    }

    return Object.getPrototypeOf(cls).match.call(this, token, context, editor);
  };
})(ConstantComponent.prototype);

function wrapComponentWithDefaults(component, defaults) {
  function Wrapper() {}

  Wrapper.prototype = {};
  for (var key in component) {
    if (_.isFunction(component[key])) {
      Wrapper.prototype[key] = _.bindKey(component, key);
    }
  }

  Wrapper.prototype.getTerms = function (context, editor) {
    var result = component.getTerms(context, editor);
    if (!result) {
      return result;
    }
    result = _.map(result, function (term) {
      if (!_.isObject(term)) {
        term = { name: term };
      }
      return _.defaults(term, defaults);
    }, this);
    return result;
  };
  return new Wrapper();
}

var tracer = function tracer() {
  if (window.engine_trace) {
    console.log.call(console, arguments);
  }
};

function passThroughContext(context, extensionList) {
  function PTC() {}

  PTC.prototype = context;
  var result = new PTC();
  if (extensionList) {
    extensionList.unshift(result);
    _.assign.apply(_, extensionList);
    extensionList.shift();
  }
  return result;
}

function WalkingState(parent_name, components, contextExtensionList, depth, priority) {
  this.parent_name = parent_name;
  this.components = components;
  this.contextExtensionList = contextExtensionList;
  this.depth = depth || 0;
  this.priority = priority;
}

function walkTokenPath(tokenPath, walkingStates, context, editor) {
  if (!tokenPath || tokenPath.length === 0) {
    return walkingStates;
  }
  var token = tokenPath[0],
      nextWalkingStates = [];

  tracer("starting token evaluation [" + token + "]");

  _.each(walkingStates, function (ws) {
    var contextForState = passThroughContext(context, ws.contextExtensionList);
    _.each(ws.components, function (component) {
      tracer("evaluating [" + token + "] with [" + component.name + "]", component);
      var result = component.match(token, contextForState, editor);
      if (result && !_.isEmpty(result)) {
        tracer("matched [" + token + "] with:", result);
        var next, extensionList;
        if (result.next && !Array.isArray(result.next)) {
          next = [result.next];
        } else {
          next = result.next;
        }
        if (result.context_values) {
          extensionList = [];
          [].push.apply(extensionList, ws.contextExtensionList);
          extensionList.push(result.context_values);
        } else {
          extensionList = ws.contextExtensionList;
        }

        var priority = ws.priority;
        if (_.isNumber(result.priority)) {
          if (_.isNumber(priority)) {
            priority = Math.min(priority, result.priority);
          } else {
            priority = result.priority;
          }
        }

        nextWalkingStates.push(new WalkingState(component.name, next, extensionList, ws.depth + 1, priority));
      }
    });
  });

  if (nextWalkingStates.length == 0) {
    // no where to go, still return context variables returned so far..
    return _.map(walkingStates, function (ws) {
      return new WalkingState(ws.name, [], ws.contextExtensionList);
    });
  }

  return walkTokenPath(tokenPath.slice(1), nextWalkingStates, context, editor);
}

function resolvePathToComponents(tokenPath, context, editor, components) {
  var walkStates = walkTokenPath(tokenPath, [new WalkingState("ROOT", components, [])], context, editor);
  var result = [].concat.apply([], _.pluck(walkStates, 'components'));
  return result;
}

function populateContext(tokenPath, context, editor, includeAutoComplete, components) {

  var walkStates = walkTokenPath(tokenPath, [new WalkingState("ROOT", components, [])], context, editor);
  if (includeAutoComplete) {
    var autoCompleteSet = [];
    _.each(walkStates, function (ws) {
      var contextForState = passThroughContext(context, ws.contextExtensionList);
      _.each(ws.components, function (component) {
        _.each(component.getTerms(contextForState, editor), function (term) {
          if (!_.isObject(term)) {
            term = { name: term };
          }
          autoCompleteSet.push(term);
        });
      });
    });
    autoCompleteSet = _.uniq(autoCompleteSet, false);
    context.autoCompleteSet = autoCompleteSet;
  }

  // apply what values were set so far to context, selecting the deepest on which sets the context
  if (walkStates.length !== 0) {
    var wsToUse;
    walkStates = _.sortBy(walkStates, function (ws) {
      return _.isNumber(ws.priority) ? ws.priority : Number.MAX_VALUE;
    });
    wsToUse = _.find(walkStates, function (ws) {
      return _.isEmpty(ws.components);
    });

    if (!wsToUse && walkStates.length > 1 && !includeAutoComplete) {
      console.info("more then one context active for current path, but autocomplete isn't requested", walkStates);
    }

    if (!wsToUse) {
      wsToUse = walkStates[0];
    }

    _.each(wsToUse.contextExtensionList, function (extension) {
      _.assign(context, extension);
    });
  }
}

/***/ }),
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _url = __webpack_require__(1424);

Object.defineProperty(exports, 'KbnUrlProvider', {
  enumerable: true,
  get: function get() {
    return _url.KbnUrlProvider;
  }
});

var _modify_url = __webpack_require__(1426);

Object.defineProperty(exports, 'modifyUrl', {
  enumerable: true,
  get: function get() {
    return _modify_url.modifyUrl;
  }
});

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _registry = __webpack_require__(63);

exports.default = (0, _registry.uiRegistry)({
  name: 'timelionPanels',
  index: ['name'],
  order: ['name']
});
module.exports = exports['default'];

/***/ }),
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildPhraseFilter = buildPhraseFilter;
exports.getPhraseScript = getPhraseScript;
exports.getConvertedValueForField = getConvertedValueForField;
exports.buildInlineScriptForPhraseFilter = buildInlineScriptForPhraseFilter;
function buildPhraseFilter(field, value, indexPattern) {
  var filter = { meta: { index: indexPattern.id } };
  var convertedValue = getConvertedValueForField(field, value);

  if (field.scripted) {
    filter.script = getPhraseScript(field, value);
    filter.meta.field = field.name;
  } else {
    filter.query = { match: {} };
    filter.query.match[field.name] = {
      query: convertedValue,
      type: 'phrase'
    };
  }
  return filter;
}

function getPhraseScript(field, value) {
  var convertedValue = getConvertedValueForField(field, value);
  var script = buildInlineScriptForPhraseFilter(field);

  return {
    script: {
      inline: script,
      lang: field.lang,
      params: {
        value: convertedValue
      }
    }
  };
}

// See https://github.com/elastic/elasticsearch/issues/20941 and https://github.com/elastic/kibana/issues/8677
// and https://github.com/elastic/elasticsearch/pull/22201
// for the reason behind this change. Aggs now return boolean buckets with a key of 1 or 0.
function getConvertedValueForField(field, value) {
  if (typeof value !== 'boolean' && field.type === 'boolean') {
    if (value !== 1 && value !== 0) {
      throw new Error('Boolean scripted fields must return true or false');
    }
    return value === 1 ? true : false;
  }
  return value;
}

/**
 * Takes a scripted field and returns an inline script appropriate for use in a script query.
 * Handles lucene expression and Painless scripts. Other langs aren't guaranteed to generate valid
 * scripts.
 *
 * @param {object} scriptedField A Field object representing a scripted field
 * @returns {string} The inline script string
 */
function buildInlineScriptForPhraseFilter(scriptedField) {
  // We must wrap painless scripts in a lambda in case they're more than a simple expression
  if (scriptedField.lang === 'painless') {
    return 'boolean compare(Supplier s, def v) {return s.get() == v;}' + ('compare(() -> { ' + scriptedField.script + ' }, params.value);');
  } else {
    return '(' + scriptedField.script + ') == value';
  }
}

/***/ }),
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _binder = __webpack_require__(432);

Object.defineProperty(exports, 'BinderBase', {
  enumerable: true,
  get: function get() {
    return _binder.BinderBase;
  }
});

var _binder_for = __webpack_require__(1282);

Object.defineProperty(exports, 'BinderFor', {
  enumerable: true,
  get: function get() {
    return _binder_for.BinderFor;
  }
});

var _deep_clone_with_buffers = __webpack_require__(1283);

Object.defineProperty(exports, 'deepCloneWithBuffers', {
  enumerable: true,
  get: function get() {
    return _deep_clone_with_buffers.deepCloneWithBuffers;
  }
});

var _from_root = __webpack_require__(1286);

Object.defineProperty(exports, 'fromRoot', {
  enumerable: true,
  get: function get() {
    return _from_root.fromRoot;
  }
});

var _package_json = __webpack_require__(665);

Object.defineProperty(exports, 'pkg', {
  enumerable: true,
  get: function get() {
    return _package_json.pkg;
  }
});

var _unset = __webpack_require__(1287);

Object.defineProperty(exports, 'unset', {
  enumerable: true,
  get: function get() {
    return _unset.unset;
  }
});

var _encode_query_component = __webpack_require__(1295);

Object.defineProperty(exports, 'encodeQueryComponent', {
  enumerable: true,
  get: function get() {
    return _encode_query_component.encodeQueryComponent;
  }
});

var _modify_url = __webpack_require__(668);

Object.defineProperty(exports, 'modifyUrl', {
  enumerable: true,
  get: function get() {
    return _modify_url.modifyUrl;
  }
});

var _get_flattened_object = __webpack_require__(1297);

Object.defineProperty(exports, 'getFlattenedObject', {
  enumerable: true,
  get: function get() {
    return _get_flattened_object.getFlattenedObject;
  }
});

var _kbn_field_types = __webpack_require__(1298);

Object.defineProperty(exports, 'getKbnTypeNames', {
  enumerable: true,
  get: function get() {
    return _kbn_field_types.getKbnTypeNames;
  }
});
Object.defineProperty(exports, 'getKbnFieldType', {
  enumerable: true,
  get: function get() {
    return _kbn_field_types.getKbnFieldType;
  }
});
Object.defineProperty(exports, 'castEsToKbnFieldTypeName', {
  enumerable: true,
  get: function get() {
    return _kbn_field_types.castEsToKbnFieldTypeName;
  }
});

var _streams = __webpack_require__(1299);

Object.defineProperty(exports, 'createConcatStream', {
  enumerable: true,
  get: function get() {
    return _streams.createConcatStream;
  }
});
Object.defineProperty(exports, 'createIntersperseStream', {
  enumerable: true,
  get: function get() {
    return _streams.createIntersperseStream;
  }
});
Object.defineProperty(exports, 'createJsonParseStream', {
  enumerable: true,
  get: function get() {
    return _streams.createJsonParseStream;
  }
});
Object.defineProperty(exports, 'createJsonStringifyStream', {
  enumerable: true,
  get: function get() {
    return _streams.createJsonStringifyStream;
  }
});
Object.defineProperty(exports, 'createListStream', {
  enumerable: true,
  get: function get() {
    return _streams.createListStream;
  }
});
Object.defineProperty(exports, 'createPromiseFromStreams', {
  enumerable: true,
  get: function get() {
    return _streams.createPromiseFromStreams;
  }
});
Object.defineProperty(exports, 'createReduceStream', {
  enumerable: true,
  get: function get() {
    return _streams.createReduceStream;
  }
});
Object.defineProperty(exports, 'createSplitStream', {
  enumerable: true,
  get: function get() {
    return _streams.createSplitStream;
  }
});
Object.defineProperty(exports, 'createMapStream', {
  enumerable: true,
  get: function get() {
    return _streams.createMapStream;
  }
});
Object.defineProperty(exports, 'createReplaceStream', {
  enumerable: true,
  get: function get() {
    return _streams.createReplaceStream;
  }
});

var _strings = __webpack_require__(1317);

Object.defineProperty(exports, 'parseCommaSeparatedList', {
  enumerable: true,
  get: function get() {
    return _strings.parseCommaSeparatedList;
  }
});
Object.defineProperty(exports, 'formatListAsProse', {
  enumerable: true,
  get: function get() {
    return _strings.formatListAsProse;
  }
});

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DocTitleProvider = undefined;

var _doc_title = __webpack_require__(705);

Object.defineProperty(exports, 'DocTitleProvider', {
  enumerable: true,
  get: function get() {
    return _doc_title.DocTitleProvider;
  }
});

__webpack_require__(705);

/***/ }),
/* 201 */,
/* 202 */,
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _init_after_bindings_workaround = __webpack_require__(2111);

Object.defineProperty(exports, 'InitAfterBindingsWorkaround', {
  enumerable: true,
  get: function get() {
    return _init_after_bindings_workaround.InitAfterBindingsWorkaround;
  }
});
Object.defineProperty(exports, 'callAfterBindingsWorkaround', {
  enumerable: true,
  get: function get() {
    return _init_after_bindings_workaround.callAfterBindingsWorkaround;
  }
});

/***/ }),
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */,
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = AggConfigResult;

var _chrome = __webpack_require__(17);

var _chrome2 = _interopRequireDefault(_chrome);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line @elastic/kibana-custom/no-default-export
function AggConfigResult(aggConfig, parent, value, key, filters) {
  this.key = key;
  this.value = value;
  this.aggConfig = aggConfig;
  this.filters = filters;
  this.$parent = parent;

  if (aggConfig.schema.group === 'buckets') {
    this.type = 'bucket';
  } else {
    this.type = 'metric';
  }
}

/**
 * Returns an array of the aggConfigResult and parents up the branch
 * @returns {array} Array of aggConfigResults
 */
AggConfigResult.prototype.getPath = function () {
  return function walk(result, path) {
    path.unshift(result);
    if (result.$parent) return walk(result.$parent, path);
    return path;
  }(this, []);
};

/**
 * Returns an Elasticsearch filter that represents the result.
 * @returns {object} Elasticsearch filter
 */
AggConfigResult.prototype.createFilter = function () {
  return this.filters || this.aggConfig.createFilter(this.key);
};

AggConfigResult.prototype.toString = function (contentType) {
  var parsedUrl = {
    origin: window.location.origin,
    pathname: window.location.pathname,
    basePath: _chrome2.default.getBasePath()
  };
  return this.aggConfig.fieldFormatter(contentType)(this.value, null, null, parsedUrl);
};

AggConfigResult.prototype.valueOf = function () {
  return this.value;
};
module.exports = exports['default'];

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.savedObjectManagementRegistry = undefined;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var registry = [];
var savedObjectManagementRegistry = exports.savedObjectManagementRegistry = {
  register: function register(service) {
    registry.push(service);
  },
  all: function all() {
    return registry;
  },
  get: function get(id) {
    return _lodash2.default.find(registry, { service: id });
  }
};

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseParamTypeProvider = BaseParamTypeProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function BaseParamTypeProvider() {

  function BaseParamType(config) {
    _lodash2.default.assign(this, config);
  }

  /**
   *  A function that will be called before an aggConfig is serialized and sent to ES.
   *  Allows aggConfig to retrieve values needed for serialization by creating a {SearchRequest}
   *  Example usage: an aggregation needs to know the min/max of a field to determine an appropriate interval
   *
   *  @param {AggConfig} aggconfig
   *  @param {Courier.SearchSource} searchSource
   *  @param {Courier.SearchRequest} searchRequest
   *  @returns {Promise<undefined>|undefined}
   */
  // eslint-disable-next-line no-unused-vars
  BaseParamType.prototype.modifyAggConfigOnSearchRequestStart = function (aggconfig, searchSource, searchRequest) {};

  return BaseParamType;
}

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var vislibColorMaps = exports.vislibColorMaps = [];

// Sequential
vislibColorMaps.Blues = [[0.000, [0.969, 0.984, 1.000]], [0.002, [0.969, 0.984, 1.000]], [0.004, [0.966, 0.982, 0.999]], [0.006, [0.966, 0.982, 0.999]], [0.008, [0.962, 0.980, 0.998]], [0.010, [0.962, 0.980, 0.998]], [0.012, [0.959, 0.978, 0.997]], [0.014, [0.959, 0.978, 0.997]], [0.016, [0.956, 0.976, 0.996]], [0.018, [0.956, 0.976, 0.996]], [0.020, [0.953, 0.974, 0.995]], [0.022, [0.953, 0.974, 0.995]], [0.023, [0.950, 0.973, 0.994]], [0.025, [0.950, 0.973, 0.994]], [0.027, [0.947, 0.971, 0.993]], [0.029, [0.947, 0.971, 0.993]], [0.031, [0.944, 0.969, 0.992]], [0.033, [0.944, 0.969, 0.992]], [0.035, [0.941, 0.967, 0.991]], [0.037, [0.941, 0.967, 0.991]], [0.039, [0.938, 0.965, 0.990]], [0.041, [0.938, 0.965, 0.990]], [0.043, [0.935, 0.963, 0.989]], [0.045, [0.935, 0.963, 0.989]], [0.047, [0.932, 0.961, 0.988]], [0.049, [0.932, 0.961, 0.988]], [0.051, [0.929, 0.959, 0.987]], [0.053, [0.929, 0.959, 0.987]], [0.055, [0.926, 0.957, 0.986]], [0.057, [0.926, 0.957, 0.986]], [0.059, [0.922, 0.955, 0.985]], [0.061, [0.922, 0.955, 0.985]], [0.063, [0.919, 0.953, 0.984]], [0.065, [0.919, 0.953, 0.984]], [0.067, [0.916, 0.951, 0.983]], [0.068, [0.916, 0.951, 0.983]], [0.070, [0.913, 0.949, 0.982]], [0.072, [0.913, 0.949, 0.982]], [0.074, [0.910, 0.947, 0.981]], [0.076, [0.910, 0.947, 0.981]], [0.078, [0.907, 0.945, 0.980]], [0.080, [0.907, 0.945, 0.980]], [0.082, [0.904, 0.943, 0.979]], [0.084, [0.904, 0.943, 0.979]], [0.086, [0.901, 0.941, 0.978]], [0.088, [0.901, 0.941, 0.978]], [0.090, [0.898, 0.939, 0.977]], [0.092, [0.898, 0.939, 0.977]], [0.094, [0.895, 0.937, 0.976]], [0.096, [0.895, 0.937, 0.976]], [0.098, [0.892, 0.935, 0.975]], [0.100, [0.892, 0.935, 0.975]], [0.102, [0.889, 0.933, 0.974]], [0.104, [0.889, 0.933, 0.974]], [0.106, [0.886, 0.931, 0.973]], [0.108, [0.886, 0.931, 0.973]], [0.110, [0.883, 0.929, 0.972]], [0.112, [0.883, 0.929, 0.972]], [0.114, [0.879, 0.927, 0.971]], [0.115, [0.879, 0.927, 0.971]], [0.117, [0.876, 0.925, 0.970]], [0.119, [0.876, 0.925, 0.970]], [0.121, [0.873, 0.923, 0.969]], [0.123, [0.873, 0.923, 0.969]], [0.125, [0.870, 0.921, 0.969]], [0.127, [0.870, 0.921, 0.969]], [0.129, [0.867, 0.919, 0.968]], [0.131, [0.867, 0.919, 0.968]], [0.133, [0.864, 0.917, 0.967]], [0.135, [0.864, 0.917, 0.967]], [0.137, [0.861, 0.915, 0.966]], [0.139, [0.861, 0.915, 0.966]], [0.141, [0.858, 0.913, 0.965]], [0.143, [0.858, 0.913, 0.965]], [0.145, [0.855, 0.911, 0.964]], [0.147, [0.855, 0.911, 0.964]], [0.149, [0.853, 0.910, 0.963]], [0.151, [0.853, 0.910, 0.963]], [0.153, [0.850, 0.908, 0.962]], [0.155, [0.850, 0.908, 0.962]], [0.157, [0.847, 0.906, 0.961]], [0.159, [0.847, 0.906, 0.961]], [0.160, [0.844, 0.904, 0.960]], [0.162, [0.844, 0.904, 0.960]], [0.164, [0.841, 0.902, 0.959]], [0.166, [0.841, 0.902, 0.959]], [0.168, [0.838, 0.900, 0.958]], [0.170, [0.838, 0.900, 0.958]], [0.172, [0.835, 0.898, 0.957]], [0.174, [0.835, 0.898, 0.957]], [0.176, [0.832, 0.896, 0.956]], [0.178, [0.832, 0.896, 0.956]], [0.180, [0.829, 0.894, 0.955]], [0.182, [0.829, 0.894, 0.955]], [0.184, [0.826, 0.892, 0.954]], [0.186, [0.826, 0.892, 0.954]], [0.188, [0.823, 0.890, 0.953]], [0.190, [0.823, 0.890, 0.953]], [0.192, [0.820, 0.888, 0.952]], [0.194, [0.820, 0.888, 0.952]], [0.196, [0.817, 0.886, 0.951]], [0.198, [0.817, 0.886, 0.951]], [0.200, [0.814, 0.884, 0.950]], [0.202, [0.814, 0.884, 0.950]], [0.204, [0.811, 0.882, 0.949]], [0.205, [0.811, 0.882, 0.949]], [0.207, [0.808, 0.880, 0.948]], [0.209, [0.808, 0.880, 0.948]], [0.211, [0.805, 0.878, 0.947]], [0.213, [0.805, 0.878, 0.947]], [0.215, [0.802, 0.876, 0.946]], [0.217, [0.802, 0.876, 0.946]], [0.219, [0.799, 0.874, 0.945]], [0.221, [0.799, 0.874, 0.945]], [0.223, [0.796, 0.872, 0.944]], [0.225, [0.796, 0.872, 0.944]], [0.227, [0.793, 0.870, 0.943]], [0.229, [0.793, 0.870, 0.943]], [0.231, [0.790, 0.868, 0.942]], [0.233, [0.790, 0.868, 0.942]], [0.235, [0.788, 0.866, 0.941]], [0.237, [0.788, 0.866, 0.941]], [0.239, [0.785, 0.864, 0.940]], [0.241, [0.785, 0.864, 0.940]], [0.243, [0.782, 0.862, 0.939]], [0.245, [0.782, 0.862, 0.939]], [0.247, [0.779, 0.860, 0.938]], [0.249, [0.779, 0.860, 0.938]], [0.250, [0.775, 0.858, 0.937]], [0.252, [0.775, 0.858, 0.937]], [0.254, [0.770, 0.856, 0.935]], [0.256, [0.770, 0.856, 0.935]], [0.258, [0.765, 0.854, 0.933]], [0.260, [0.765, 0.854, 0.933]], [0.262, [0.760, 0.852, 0.932]], [0.264, [0.760, 0.852, 0.932]], [0.266, [0.756, 0.850, 0.930]], [0.268, [0.756, 0.850, 0.930]], [0.270, [0.751, 0.848, 0.928]], [0.272, [0.751, 0.848, 0.928]], [0.274, [0.746, 0.846, 0.926]], [0.276, [0.746, 0.846, 0.926]], [0.278, [0.741, 0.844, 0.925]], [0.280, [0.741, 0.844, 0.925]], [0.282, [0.736, 0.842, 0.923]], [0.284, [0.736, 0.842, 0.923]], [0.286, [0.731, 0.839, 0.921]], [0.288, [0.731, 0.839, 0.921]], [0.290, [0.726, 0.837, 0.920]], [0.292, [0.726, 0.837, 0.920]], [0.294, [0.721, 0.835, 0.918]], [0.295, [0.721, 0.835, 0.918]], [0.297, [0.716, 0.833, 0.916]], [0.299, [0.716, 0.833, 0.916]], [0.301, [0.711, 0.831, 0.914]], [0.303, [0.711, 0.831, 0.914]], [0.305, [0.706, 0.829, 0.913]], [0.307, [0.706, 0.829, 0.913]], [0.309, [0.701, 0.827, 0.911]], [0.311, [0.701, 0.827, 0.911]], [0.313, [0.697, 0.825, 0.909]], [0.315, [0.697, 0.825, 0.909]], [0.317, [0.692, 0.823, 0.908]], [0.319, [0.692, 0.823, 0.908]], [0.321, [0.687, 0.821, 0.906]], [0.323, [0.687, 0.821, 0.906]], [0.325, [0.682, 0.819, 0.904]], [0.327, [0.682, 0.819, 0.904]], [0.329, [0.677, 0.816, 0.902]], [0.331, [0.677, 0.816, 0.902]], [0.333, [0.672, 0.814, 0.901]], [0.335, [0.672, 0.814, 0.901]], [0.337, [0.667, 0.812, 0.899]], [0.339, [0.667, 0.812, 0.899]], [0.341, [0.662, 0.810, 0.897]], [0.342, [0.662, 0.810, 0.897]], [0.344, [0.657, 0.808, 0.895]], [0.346, [0.657, 0.808, 0.895]], [0.348, [0.652, 0.806, 0.894]], [0.350, [0.652, 0.806, 0.894]], [0.352, [0.647, 0.804, 0.892]], [0.354, [0.647, 0.804, 0.892]], [0.356, [0.642, 0.802, 0.890]], [0.358, [0.642, 0.802, 0.890]], [0.360, [0.637, 0.800, 0.889]], [0.362, [0.637, 0.800, 0.889]], [0.364, [0.633, 0.798, 0.887]], [0.366, [0.633, 0.798, 0.887]], [0.368, [0.628, 0.796, 0.885]], [0.370, [0.628, 0.796, 0.885]], [0.372, [0.623, 0.793, 0.883]], [0.374, [0.623, 0.793, 0.883]], [0.376, [0.617, 0.791, 0.882]], [0.378, [0.617, 0.791, 0.882]], [0.380, [0.611, 0.787, 0.880]], [0.382, [0.611, 0.787, 0.880]], [0.384, [0.605, 0.784, 0.879]], [0.386, [0.605, 0.784, 0.879]], [0.387, [0.598, 0.781, 0.878]], [0.389, [0.598, 0.781, 0.878]], [0.391, [0.592, 0.777, 0.876]], [0.393, [0.592, 0.777, 0.876]], [0.395, [0.586, 0.774, 0.875]], [0.397, [0.586, 0.774, 0.875]], [0.399, [0.580, 0.770, 0.874]], [0.401, [0.580, 0.770, 0.874]], [0.403, [0.573, 0.767, 0.872]], [0.405, [0.573, 0.767, 0.872]], [0.407, [0.567, 0.763, 0.871]], [0.409, [0.567, 0.763, 0.871]], [0.411, [0.561, 0.760, 0.870]], [0.413, [0.561, 0.760, 0.870]], [0.415, [0.555, 0.756, 0.868]], [0.417, [0.555, 0.756, 0.868]], [0.419, [0.548, 0.753, 0.867]], [0.421, [0.548, 0.753, 0.867]], [0.423, [0.542, 0.750, 0.866]], [0.425, [0.542, 0.750, 0.866]], [0.427, [0.536, 0.746, 0.864]], [0.429, [0.536, 0.746, 0.864]], [0.431, [0.529, 0.743, 0.863]], [0.432, [0.529, 0.743, 0.863]], [0.434, [0.523, 0.739, 0.862]], [0.436, [0.523, 0.739, 0.862]], [0.438, [0.517, 0.736, 0.860]], [0.440, [0.517, 0.736, 0.860]], [0.442, [0.511, 0.732, 0.859]], [0.444, [0.511, 0.732, 0.859]], [0.446, [0.504, 0.729, 0.857]], [0.448, [0.504, 0.729, 0.857]], [0.450, [0.498, 0.725, 0.856]], [0.452, [0.498, 0.725, 0.856]], [0.454, [0.492, 0.722, 0.855]], [0.456, [0.492, 0.722, 0.855]], [0.458, [0.485, 0.719, 0.853]], [0.460, [0.485, 0.719, 0.853]], [0.462, [0.479, 0.715, 0.852]], [0.464, [0.479, 0.715, 0.852]], [0.466, [0.473, 0.712, 0.851]], [0.468, [0.473, 0.712, 0.851]], [0.470, [0.467, 0.708, 0.849]], [0.472, [0.467, 0.708, 0.849]], [0.474, [0.460, 0.705, 0.848]], [0.476, [0.460, 0.705, 0.848]], [0.477, [0.454, 0.701, 0.847]], [0.479, [0.454, 0.701, 0.847]], [0.481, [0.448, 0.698, 0.845]], [0.483, [0.448, 0.698, 0.845]], [0.485, [0.442, 0.694, 0.844]], [0.487, [0.442, 0.694, 0.844]], [0.489, [0.435, 0.691, 0.843]], [0.491, [0.435, 0.691, 0.843]], [0.493, [0.429, 0.688, 0.841]], [0.495, [0.429, 0.688, 0.841]], [0.497, [0.423, 0.684, 0.840]], [0.499, [0.423, 0.684, 0.840]], [0.501, [0.417, 0.681, 0.838]], [0.503, [0.417, 0.681, 0.838]], [0.505, [0.412, 0.677, 0.836]], [0.507, [0.412, 0.677, 0.836]], [0.509, [0.407, 0.674, 0.834]], [0.511, [0.407, 0.674, 0.834]], [0.513, [0.402, 0.670, 0.832]], [0.515, [0.402, 0.670, 0.832]], [0.517, [0.397, 0.667, 0.830]], [0.519, [0.397, 0.667, 0.830]], [0.521, [0.392, 0.663, 0.828]], [0.523, [0.392, 0.663, 0.828]], [0.524, [0.387, 0.660, 0.826]], [0.526, [0.387, 0.660, 0.826]], [0.528, [0.382, 0.657, 0.824]], [0.530, [0.382, 0.657, 0.824]], [0.532, [0.377, 0.653, 0.822]], [0.534, [0.377, 0.653, 0.822]], [0.536, [0.372, 0.650, 0.821]], [0.538, [0.372, 0.650, 0.821]], [0.540, [0.367, 0.646, 0.819]], [0.542, [0.367, 0.646, 0.819]], [0.544, [0.362, 0.643, 0.817]], [0.546, [0.362, 0.643, 0.817]], [0.548, [0.357, 0.639, 0.815]], [0.550, [0.357, 0.639, 0.815]], [0.552, [0.352, 0.636, 0.813]], [0.554, [0.352, 0.636, 0.813]], [0.556, [0.346, 0.632, 0.811]], [0.558, [0.346, 0.632, 0.811]], [0.560, [0.341, 0.629, 0.809]], [0.562, [0.341, 0.629, 0.809]], [0.564, [0.336, 0.626, 0.807]], [0.566, [0.336, 0.626, 0.807]], [0.568, [0.331, 0.622, 0.805]], [0.569, [0.331, 0.622, 0.805]], [0.571, [0.326, 0.619, 0.803]], [0.573, [0.326, 0.619, 0.803]], [0.575, [0.321, 0.615, 0.801]], [0.577, [0.321, 0.615, 0.801]], [0.579, [0.316, 0.612, 0.799]], [0.581, [0.316, 0.612, 0.799]], [0.583, [0.311, 0.608, 0.797]], [0.585, [0.311, 0.608, 0.797]], [0.587, [0.306, 0.605, 0.795]], [0.589, [0.306, 0.605, 0.795]], [0.591, [0.301, 0.601, 0.793]], [0.593, [0.301, 0.601, 0.793]], [0.595, [0.296, 0.598, 0.791]], [0.597, [0.296, 0.598, 0.791]], [0.599, [0.291, 0.595, 0.789]], [0.601, [0.291, 0.595, 0.789]], [0.603, [0.286, 0.591, 0.787]], [0.605, [0.286, 0.591, 0.787]], [0.607, [0.281, 0.588, 0.785]], [0.609, [0.281, 0.588, 0.785]], [0.611, [0.276, 0.584, 0.783]], [0.613, [0.276, 0.584, 0.783]], [0.614, [0.271, 0.581, 0.781]], [0.616, [0.271, 0.581, 0.781]], [0.618, [0.266, 0.577, 0.779]], [0.620, [0.266, 0.577, 0.779]], [0.622, [0.261, 0.574, 0.777]], [0.624, [0.261, 0.574, 0.777]], [0.626, [0.256, 0.570, 0.775]], [0.628, [0.256, 0.570, 0.775]], [0.630, [0.252, 0.566, 0.773]], [0.632, [0.252, 0.566, 0.773]], [0.634, [0.248, 0.562, 0.771]], [0.636, [0.248, 0.562, 0.771]], [0.638, [0.244, 0.558, 0.769]], [0.640, [0.244, 0.558, 0.769]], [0.642, [0.240, 0.554, 0.767]], [0.644, [0.240, 0.554, 0.767]], [0.646, [0.236, 0.550, 0.765]], [0.648, [0.236, 0.550, 0.765]], [0.650, [0.232, 0.546, 0.763]], [0.652, [0.232, 0.546, 0.763]], [0.654, [0.228, 0.542, 0.761]], [0.656, [0.228, 0.542, 0.761]], [0.658, [0.224, 0.538, 0.758]], [0.659, [0.224, 0.538, 0.758]], [0.661, [0.220, 0.533, 0.756]], [0.663, [0.220, 0.533, 0.756]], [0.665, [0.216, 0.529, 0.754]], [0.667, [0.216, 0.529, 0.754]], [0.669, [0.212, 0.525, 0.752]], [0.671, [0.212, 0.525, 0.752]], [0.673, [0.208, 0.521, 0.750]], [0.675, [0.208, 0.521, 0.750]], [0.677, [0.204, 0.517, 0.748]], [0.679, [0.204, 0.517, 0.748]], [0.681, [0.199, 0.513, 0.746]], [0.683, [0.199, 0.513, 0.746]], [0.685, [0.195, 0.509, 0.744]], [0.687, [0.195, 0.509, 0.744]], [0.689, [0.191, 0.505, 0.742]], [0.691, [0.191, 0.505, 0.742]], [0.693, [0.187, 0.501, 0.740]], [0.695, [0.187, 0.501, 0.740]], [0.697, [0.183, 0.497, 0.738]], [0.699, [0.183, 0.497, 0.738]], [0.701, [0.179, 0.493, 0.735]], [0.703, [0.179, 0.493, 0.735]], [0.705, [0.175, 0.489, 0.733]], [0.706, [0.175, 0.489, 0.733]], [0.708, [0.171, 0.485, 0.731]], [0.710, [0.171, 0.485, 0.731]], [0.712, [0.167, 0.481, 0.729]], [0.714, [0.167, 0.481, 0.729]], [0.716, [0.163, 0.477, 0.727]], [0.718, [0.163, 0.477, 0.727]], [0.720, [0.159, 0.473, 0.725]], [0.722, [0.159, 0.473, 0.725]], [0.724, [0.155, 0.469, 0.723]], [0.726, [0.155, 0.469, 0.723]], [0.728, [0.151, 0.464, 0.721]], [0.730, [0.151, 0.464, 0.721]], [0.732, [0.147, 0.460, 0.719]], [0.734, [0.147, 0.460, 0.719]], [0.736, [0.143, 0.456, 0.717]], [0.738, [0.143, 0.456, 0.717]], [0.740, [0.139, 0.452, 0.715]], [0.742, [0.139, 0.452, 0.715]], [0.744, [0.134, 0.448, 0.712]], [0.746, [0.134, 0.448, 0.712]], [0.748, [0.130, 0.444, 0.710]], [0.750, [0.130, 0.444, 0.710]], [0.751, [0.127, 0.440, 0.707]], [0.753, [0.127, 0.440, 0.707]], [0.755, [0.124, 0.436, 0.704]], [0.757, [0.124, 0.436, 0.704]], [0.759, [0.121, 0.432, 0.701]], [0.761, [0.121, 0.432, 0.701]], [0.763, [0.118, 0.428, 0.698]], [0.765, [0.118, 0.428, 0.698]], [0.767, [0.115, 0.424, 0.695]], [0.769, [0.115, 0.424, 0.695]], [0.771, [0.112, 0.420, 0.692]], [0.773, [0.112, 0.420, 0.692]], [0.775, [0.109, 0.417, 0.689]], [0.777, [0.109, 0.417, 0.689]], [0.779, [0.106, 0.413, 0.686]], [0.781, [0.106, 0.413, 0.686]], [0.783, [0.102, 0.409, 0.683]], [0.785, [0.102, 0.409, 0.683]], [0.787, [0.099, 0.405, 0.680]], [0.789, [0.099, 0.405, 0.680]], [0.791, [0.096, 0.401, 0.677]], [0.793, [0.096, 0.401, 0.677]], [0.795, [0.093, 0.397, 0.674]], [0.796, [0.093, 0.397, 0.674]], [0.798, [0.090, 0.393, 0.671]], [0.800, [0.090, 0.393, 0.671]], [0.802, [0.087, 0.389, 0.668]], [0.804, [0.087, 0.389, 0.668]], [0.806, [0.084, 0.385, 0.664]], [0.808, [0.084, 0.385, 0.664]], [0.810, [0.081, 0.381, 0.661]], [0.812, [0.081, 0.381, 0.661]], [0.814, [0.078, 0.377, 0.658]], [0.816, [0.078, 0.377, 0.658]], [0.818, [0.075, 0.373, 0.655]], [0.820, [0.075, 0.373, 0.655]], [0.822, [0.072, 0.369, 0.652]], [0.824, [0.072, 0.369, 0.652]], [0.826, [0.069, 0.365, 0.649]], [0.828, [0.069, 0.365, 0.649]], [0.830, [0.066, 0.361, 0.646]], [0.832, [0.066, 0.361, 0.646]], [0.834, [0.063, 0.358, 0.643]], [0.836, [0.063, 0.358, 0.643]], [0.838, [0.059, 0.354, 0.640]], [0.840, [0.059, 0.354, 0.640]], [0.841, [0.056, 0.350, 0.637]], [0.843, [0.056, 0.350, 0.637]], [0.845, [0.053, 0.346, 0.634]], [0.847, [0.053, 0.346, 0.634]], [0.849, [0.050, 0.342, 0.631]], [0.851, [0.050, 0.342, 0.631]], [0.853, [0.047, 0.338, 0.628]], [0.855, [0.047, 0.338, 0.628]], [0.857, [0.044, 0.334, 0.624]], [0.859, [0.044, 0.334, 0.624]], [0.861, [0.041, 0.330, 0.621]], [0.863, [0.041, 0.330, 0.621]], [0.865, [0.038, 0.326, 0.618]], [0.867, [0.038, 0.326, 0.618]], [0.869, [0.035, 0.322, 0.615]], [0.871, [0.035, 0.322, 0.615]], [0.873, [0.032, 0.318, 0.612]], [0.875, [0.032, 0.318, 0.612]], [0.877, [0.031, 0.314, 0.606]], [0.879, [0.031, 0.314, 0.606]], [0.881, [0.031, 0.310, 0.600]], [0.883, [0.031, 0.310, 0.600]], [0.885, [0.031, 0.306, 0.594]], [0.886, [0.031, 0.306, 0.594]], [0.888, [0.031, 0.302, 0.588]], [0.890, [0.031, 0.302, 0.588]], [0.892, [0.031, 0.298, 0.582]], [0.894, [0.031, 0.298, 0.582]], [0.896, [0.031, 0.294, 0.576]], [0.898, [0.031, 0.294, 0.576]], [0.900, [0.031, 0.290, 0.570]], [0.902, [0.031, 0.290, 0.570]], [0.904, [0.031, 0.286, 0.564]], [0.906, [0.031, 0.286, 0.564]], [0.908, [0.031, 0.282, 0.558]], [0.910, [0.031, 0.282, 0.558]], [0.912, [0.031, 0.278, 0.552]], [0.914, [0.031, 0.278, 0.552]], [0.916, [0.031, 0.273, 0.546]], [0.918, [0.031, 0.273, 0.546]], [0.920, [0.031, 0.269, 0.540]], [0.922, [0.031, 0.269, 0.540]], [0.924, [0.031, 0.265, 0.534]], [0.926, [0.031, 0.265, 0.534]], [0.928, [0.031, 0.261, 0.528]], [0.930, [0.031, 0.261, 0.528]], [0.932, [0.031, 0.257, 0.522]], [0.933, [0.031, 0.257, 0.522]], [0.935, [0.031, 0.253, 0.516]], [0.937, [0.031, 0.253, 0.516]], [0.939, [0.031, 0.249, 0.510]], [0.941, [0.031, 0.249, 0.510]], [0.943, [0.031, 0.245, 0.504]], [0.945, [0.031, 0.245, 0.504]], [0.947, [0.031, 0.241, 0.498]], [0.949, [0.031, 0.241, 0.498]], [0.951, [0.031, 0.237, 0.492]], [0.953, [0.031, 0.237, 0.492]], [0.955, [0.031, 0.233, 0.486]], [0.957, [0.031, 0.233, 0.486]], [0.959, [0.031, 0.229, 0.480]], [0.961, [0.031, 0.229, 0.480]], [0.963, [0.031, 0.225, 0.474]], [0.965, [0.031, 0.225, 0.474]], [0.967, [0.031, 0.221, 0.468]], [0.969, [0.031, 0.221, 0.468]], [0.971, [0.031, 0.217, 0.462]], [0.973, [0.031, 0.217, 0.462]], [0.975, [0.031, 0.213, 0.456]], [0.977, [0.031, 0.213, 0.456]], [0.978, [0.031, 0.209, 0.450]], [0.980, [0.031, 0.209, 0.450]], [0.982, [0.031, 0.204, 0.444]], [0.984, [0.031, 0.204, 0.444]], [0.986, [0.031, 0.200, 0.438]], [0.988, [0.031, 0.200, 0.438]], [0.990, [0.031, 0.196, 0.432]], [0.992, [0.031, 0.196, 0.432]], [0.994, [0.031, 0.192, 0.426]], [0.996, [0.031, 0.192, 0.426]], [0.998, [0.031, 0.188, 0.420]], [1.000, [0.031, 0.188, 0.420]]];
vislibColorMaps.Greens = [[0.000, [0.969, 0.988, 0.961]], [0.002, [0.969, 0.988, 0.961]], [0.004, [0.966, 0.987, 0.958]], [0.006, [0.966, 0.987, 0.958]], [0.008, [0.964, 0.987, 0.956]], [0.010, [0.964, 0.987, 0.956]], [0.012, [0.962, 0.986, 0.953]], [0.014, [0.962, 0.986, 0.953]], [0.016, [0.960, 0.985, 0.950]], [0.018, [0.960, 0.985, 0.950]], [0.020, [0.958, 0.984, 0.948]], [0.022, [0.958, 0.984, 0.948]], [0.023, [0.955, 0.983, 0.945]], [0.025, [0.955, 0.983, 0.945]], [0.027, [0.953, 0.982, 0.943]], [0.029, [0.953, 0.982, 0.943]], [0.031, [0.951, 0.981, 0.940]], [0.033, [0.951, 0.981, 0.940]], [0.035, [0.949, 0.980, 0.938]], [0.037, [0.949, 0.980, 0.938]], [0.039, [0.946, 0.980, 0.935]], [0.041, [0.946, 0.980, 0.935]], [0.043, [0.944, 0.979, 0.932]], [0.045, [0.944, 0.979, 0.932]], [0.047, [0.942, 0.978, 0.930]], [0.049, [0.942, 0.978, 0.930]], [0.051, [0.940, 0.977, 0.927]], [0.053, [0.940, 0.977, 0.927]], [0.055, [0.938, 0.976, 0.925]], [0.057, [0.938, 0.976, 0.925]], [0.059, [0.935, 0.975, 0.922]], [0.061, [0.935, 0.975, 0.922]], [0.063, [0.933, 0.974, 0.919]], [0.065, [0.933, 0.974, 0.919]], [0.067, [0.931, 0.974, 0.917]], [0.068, [0.931, 0.974, 0.917]], [0.070, [0.929, 0.973, 0.914]], [0.072, [0.929, 0.973, 0.914]], [0.074, [0.927, 0.972, 0.912]], [0.076, [0.927, 0.972, 0.912]], [0.078, [0.924, 0.971, 0.909]], [0.080, [0.924, 0.971, 0.909]], [0.082, [0.922, 0.970, 0.907]], [0.084, [0.922, 0.970, 0.907]], [0.086, [0.920, 0.969, 0.904]], [0.088, [0.920, 0.969, 0.904]], [0.090, [0.918, 0.968, 0.901]], [0.092, [0.918, 0.968, 0.901]], [0.094, [0.915, 0.968, 0.899]], [0.096, [0.915, 0.968, 0.899]], [0.098, [0.913, 0.967, 0.896]], [0.100, [0.913, 0.967, 0.896]], [0.102, [0.911, 0.966, 0.894]], [0.104, [0.911, 0.966, 0.894]], [0.106, [0.909, 0.965, 0.891]], [0.108, [0.909, 0.965, 0.891]], [0.110, [0.907, 0.964, 0.888]], [0.112, [0.907, 0.964, 0.888]], [0.114, [0.904, 0.963, 0.886]], [0.115, [0.904, 0.963, 0.886]], [0.117, [0.902, 0.962, 0.883]], [0.119, [0.902, 0.962, 0.883]], [0.121, [0.900, 0.962, 0.881]], [0.123, [0.900, 0.962, 0.881]], [0.125, [0.898, 0.961, 0.878]], [0.127, [0.898, 0.961, 0.878]], [0.129, [0.894, 0.959, 0.874]], [0.131, [0.894, 0.959, 0.874]], [0.133, [0.890, 0.958, 0.870]], [0.135, [0.890, 0.958, 0.870]], [0.137, [0.887, 0.956, 0.866]], [0.139, [0.887, 0.956, 0.866]], [0.141, [0.883, 0.955, 0.862]], [0.143, [0.883, 0.955, 0.862]], [0.145, [0.879, 0.953, 0.858]], [0.147, [0.879, 0.953, 0.858]], [0.149, [0.875, 0.952, 0.854]], [0.151, [0.875, 0.952, 0.854]], [0.153, [0.872, 0.950, 0.850]], [0.155, [0.872, 0.950, 0.850]], [0.157, [0.868, 0.949, 0.846]], [0.159, [0.868, 0.949, 0.846]], [0.160, [0.864, 0.947, 0.843]], [0.162, [0.864, 0.947, 0.843]], [0.164, [0.861, 0.946, 0.839]], [0.166, [0.861, 0.946, 0.839]], [0.168, [0.857, 0.944, 0.835]], [0.170, [0.857, 0.944, 0.835]], [0.172, [0.853, 0.943, 0.831]], [0.174, [0.853, 0.943, 0.831]], [0.176, [0.850, 0.941, 0.827]], [0.178, [0.850, 0.941, 0.827]], [0.180, [0.846, 0.940, 0.823]], [0.182, [0.846, 0.940, 0.823]], [0.184, [0.842, 0.938, 0.819]], [0.186, [0.842, 0.938, 0.819]], [0.188, [0.839, 0.937, 0.815]], [0.190, [0.839, 0.937, 0.815]], [0.192, [0.835, 0.936, 0.811]], [0.194, [0.835, 0.936, 0.811]], [0.196, [0.831, 0.934, 0.807]], [0.198, [0.831, 0.934, 0.807]], [0.200, [0.827, 0.933, 0.803]], [0.202, [0.827, 0.933, 0.803]], [0.204, [0.824, 0.931, 0.799]], [0.205, [0.824, 0.931, 0.799]], [0.207, [0.820, 0.930, 0.795]], [0.209, [0.820, 0.930, 0.795]], [0.211, [0.816, 0.928, 0.791]], [0.213, [0.816, 0.928, 0.791]], [0.215, [0.813, 0.927, 0.787]], [0.217, [0.813, 0.927, 0.787]], [0.219, [0.809, 0.925, 0.783]], [0.221, [0.809, 0.925, 0.783]], [0.223, [0.805, 0.924, 0.780]], [0.225, [0.805, 0.924, 0.780]], [0.227, [0.802, 0.922, 0.776]], [0.229, [0.802, 0.922, 0.776]], [0.231, [0.798, 0.921, 0.772]], [0.233, [0.798, 0.921, 0.772]], [0.235, [0.794, 0.919, 0.768]], [0.237, [0.794, 0.919, 0.768]], [0.239, [0.791, 0.918, 0.764]], [0.241, [0.791, 0.918, 0.764]], [0.243, [0.787, 0.916, 0.760]], [0.245, [0.787, 0.916, 0.760]], [0.247, [0.783, 0.915, 0.756]], [0.249, [0.783, 0.915, 0.756]], [0.250, [0.779, 0.913, 0.752]], [0.252, [0.779, 0.913, 0.752]], [0.254, [0.775, 0.911, 0.747]], [0.256, [0.775, 0.911, 0.747]], [0.258, [0.770, 0.909, 0.743]], [0.260, [0.770, 0.909, 0.743]], [0.262, [0.765, 0.907, 0.738]], [0.264, [0.765, 0.907, 0.738]], [0.266, [0.761, 0.905, 0.734]], [0.268, [0.761, 0.905, 0.734]], [0.270, [0.756, 0.903, 0.729]], [0.272, [0.756, 0.903, 0.729]], [0.274, [0.751, 0.901, 0.724]], [0.276, [0.751, 0.901, 0.724]], [0.278, [0.746, 0.899, 0.720]], [0.280, [0.746, 0.899, 0.720]], [0.282, [0.742, 0.897, 0.715]], [0.284, [0.742, 0.897, 0.715]], [0.286, [0.737, 0.896, 0.711]], [0.288, [0.737, 0.896, 0.711]], [0.290, [0.732, 0.894, 0.706]], [0.292, [0.732, 0.894, 0.706]], [0.294, [0.728, 0.892, 0.702]], [0.295, [0.728, 0.892, 0.702]], [0.297, [0.723, 0.890, 0.697]], [0.299, [0.723, 0.890, 0.697]], [0.301, [0.718, 0.888, 0.693]], [0.303, [0.718, 0.888, 0.693]], [0.305, [0.714, 0.886, 0.688]], [0.307, [0.714, 0.886, 0.688]], [0.309, [0.709, 0.884, 0.684]], [0.311, [0.709, 0.884, 0.684]], [0.313, [0.704, 0.882, 0.679]], [0.315, [0.704, 0.882, 0.679]], [0.317, [0.700, 0.880, 0.674]], [0.319, [0.700, 0.880, 0.674]], [0.321, [0.695, 0.878, 0.670]], [0.323, [0.695, 0.878, 0.670]], [0.325, [0.690, 0.876, 0.665]], [0.327, [0.690, 0.876, 0.665]], [0.329, [0.686, 0.874, 0.661]], [0.331, [0.686, 0.874, 0.661]], [0.333, [0.681, 0.872, 0.656]], [0.335, [0.681, 0.872, 0.656]], [0.337, [0.676, 0.870, 0.652]], [0.339, [0.676, 0.870, 0.652]], [0.341, [0.672, 0.868, 0.647]], [0.342, [0.672, 0.868, 0.647]], [0.344, [0.667, 0.866, 0.643]], [0.346, [0.667, 0.866, 0.643]], [0.348, [0.662, 0.864, 0.638]], [0.350, [0.662, 0.864, 0.638]], [0.352, [0.658, 0.862, 0.633]], [0.354, [0.658, 0.862, 0.633]], [0.356, [0.653, 0.860, 0.629]], [0.358, [0.653, 0.860, 0.629]], [0.360, [0.648, 0.858, 0.624]], [0.362, [0.648, 0.858, 0.624]], [0.364, [0.644, 0.856, 0.620]], [0.366, [0.644, 0.856, 0.620]], [0.368, [0.639, 0.854, 0.615]], [0.370, [0.639, 0.854, 0.615]], [0.372, [0.634, 0.852, 0.611]], [0.374, [0.634, 0.852, 0.611]], [0.376, [0.629, 0.850, 0.606]], [0.378, [0.629, 0.850, 0.606]], [0.380, [0.624, 0.847, 0.602]], [0.382, [0.624, 0.847, 0.602]], [0.384, [0.618, 0.845, 0.597]], [0.386, [0.618, 0.845, 0.597]], [0.387, [0.613, 0.842, 0.592]], [0.389, [0.613, 0.842, 0.592]], [0.391, [0.607, 0.840, 0.588]], [0.393, [0.607, 0.840, 0.588]], [0.395, [0.602, 0.837, 0.583]], [0.397, [0.602, 0.837, 0.583]], [0.399, [0.596, 0.835, 0.579]], [0.401, [0.596, 0.835, 0.579]], [0.403, [0.591, 0.832, 0.574]], [0.405, [0.591, 0.832, 0.574]], [0.407, [0.585, 0.829, 0.570]], [0.409, [0.585, 0.829, 0.570]], [0.411, [0.579, 0.827, 0.565]], [0.413, [0.579, 0.827, 0.565]], [0.415, [0.574, 0.824, 0.561]], [0.417, [0.574, 0.824, 0.561]], [0.419, [0.568, 0.822, 0.556]], [0.421, [0.568, 0.822, 0.556]], [0.423, [0.563, 0.819, 0.552]], [0.425, [0.563, 0.819, 0.552]], [0.427, [0.557, 0.816, 0.547]], [0.429, [0.557, 0.816, 0.547]], [0.431, [0.552, 0.814, 0.542]], [0.432, [0.552, 0.814, 0.542]], [0.434, [0.546, 0.811, 0.538]], [0.436, [0.546, 0.811, 0.538]], [0.438, [0.541, 0.809, 0.533]], [0.440, [0.541, 0.809, 0.533]], [0.442, [0.535, 0.806, 0.529]], [0.444, [0.535, 0.806, 0.529]], [0.446, [0.530, 0.804, 0.524]], [0.448, [0.530, 0.804, 0.524]], [0.450, [0.524, 0.801, 0.520]], [0.452, [0.524, 0.801, 0.520]], [0.454, [0.519, 0.798, 0.515]], [0.456, [0.519, 0.798, 0.515]], [0.458, [0.513, 0.796, 0.511]], [0.460, [0.513, 0.796, 0.511]], [0.462, [0.507, 0.793, 0.506]], [0.464, [0.507, 0.793, 0.506]], [0.466, [0.502, 0.791, 0.501]], [0.468, [0.502, 0.791, 0.501]], [0.470, [0.496, 0.788, 0.497]], [0.472, [0.496, 0.788, 0.497]], [0.474, [0.491, 0.785, 0.492]], [0.476, [0.491, 0.785, 0.492]], [0.477, [0.485, 0.783, 0.488]], [0.479, [0.485, 0.783, 0.488]], [0.481, [0.480, 0.780, 0.483]], [0.483, [0.480, 0.780, 0.483]], [0.485, [0.474, 0.778, 0.479]], [0.487, [0.474, 0.778, 0.479]], [0.489, [0.469, 0.775, 0.474]], [0.491, [0.469, 0.775, 0.474]], [0.493, [0.463, 0.773, 0.470]], [0.495, [0.463, 0.773, 0.470]], [0.497, [0.458, 0.770, 0.465]], [0.499, [0.458, 0.770, 0.465]], [0.501, [0.452, 0.767, 0.461]], [0.503, [0.452, 0.767, 0.461]], [0.505, [0.445, 0.764, 0.458]], [0.507, [0.445, 0.764, 0.458]], [0.509, [0.439, 0.761, 0.455]], [0.511, [0.439, 0.761, 0.455]], [0.513, [0.433, 0.758, 0.452]], [0.515, [0.433, 0.758, 0.452]], [0.517, [0.427, 0.755, 0.449]], [0.519, [0.427, 0.755, 0.449]], [0.521, [0.420, 0.752, 0.446]], [0.523, [0.420, 0.752, 0.446]], [0.524, [0.414, 0.749, 0.443]], [0.526, [0.414, 0.749, 0.443]], [0.528, [0.408, 0.746, 0.440]], [0.530, [0.408, 0.746, 0.440]], [0.532, [0.402, 0.742, 0.437]], [0.534, [0.402, 0.742, 0.437]], [0.536, [0.395, 0.739, 0.434]], [0.538, [0.395, 0.739, 0.434]], [0.540, [0.389, 0.736, 0.430]], [0.542, [0.389, 0.736, 0.430]], [0.544, [0.383, 0.733, 0.427]], [0.546, [0.383, 0.733, 0.427]], [0.548, [0.376, 0.730, 0.424]], [0.550, [0.376, 0.730, 0.424]], [0.552, [0.370, 0.727, 0.421]], [0.554, [0.370, 0.727, 0.421]], [0.556, [0.364, 0.724, 0.418]], [0.558, [0.364, 0.724, 0.418]], [0.560, [0.358, 0.721, 0.415]], [0.562, [0.358, 0.721, 0.415]], [0.564, [0.351, 0.718, 0.412]], [0.566, [0.351, 0.718, 0.412]], [0.568, [0.345, 0.715, 0.409]], [0.569, [0.345, 0.715, 0.409]], [0.571, [0.339, 0.712, 0.406]], [0.573, [0.339, 0.712, 0.406]], [0.575, [0.333, 0.709, 0.403]], [0.577, [0.333, 0.709, 0.403]], [0.579, [0.326, 0.706, 0.400]], [0.581, [0.326, 0.706, 0.400]], [0.583, [0.320, 0.702, 0.397]], [0.585, [0.320, 0.702, 0.397]], [0.587, [0.314, 0.699, 0.394]], [0.589, [0.314, 0.699, 0.394]], [0.591, [0.307, 0.696, 0.390]], [0.593, [0.307, 0.696, 0.390]], [0.595, [0.301, 0.693, 0.387]], [0.597, [0.301, 0.693, 0.387]], [0.599, [0.295, 0.690, 0.384]], [0.601, [0.295, 0.690, 0.384]], [0.603, [0.289, 0.687, 0.381]], [0.605, [0.289, 0.687, 0.381]], [0.607, [0.282, 0.684, 0.378]], [0.609, [0.282, 0.684, 0.378]], [0.611, [0.276, 0.681, 0.375]], [0.613, [0.276, 0.681, 0.375]], [0.614, [0.270, 0.678, 0.372]], [0.616, [0.270, 0.678, 0.372]], [0.618, [0.264, 0.675, 0.369]], [0.620, [0.264, 0.675, 0.369]], [0.622, [0.257, 0.672, 0.366]], [0.624, [0.257, 0.672, 0.366]], [0.626, [0.253, 0.668, 0.363]], [0.628, [0.253, 0.668, 0.363]], [0.630, [0.249, 0.664, 0.360]], [0.632, [0.249, 0.664, 0.360]], [0.634, [0.245, 0.660, 0.357]], [0.636, [0.245, 0.660, 0.357]], [0.638, [0.242, 0.656, 0.354]], [0.640, [0.242, 0.656, 0.354]], [0.642, [0.238, 0.652, 0.351]], [0.644, [0.238, 0.652, 0.351]], [0.646, [0.234, 0.648, 0.348]], [0.648, [0.234, 0.648, 0.348]], [0.650, [0.230, 0.645, 0.345]], [0.652, [0.230, 0.645, 0.345]], [0.654, [0.227, 0.641, 0.342]], [0.656, [0.227, 0.641, 0.342]], [0.658, [0.223, 0.637, 0.339]], [0.659, [0.223, 0.637, 0.339]], [0.661, [0.219, 0.633, 0.336]], [0.663, [0.219, 0.633, 0.336]], [0.665, [0.216, 0.629, 0.333]], [0.667, [0.216, 0.629, 0.333]], [0.669, [0.212, 0.625, 0.330]], [0.671, [0.212, 0.625, 0.330]], [0.673, [0.208, 0.621, 0.327]], [0.675, [0.208, 0.621, 0.327]], [0.677, [0.205, 0.617, 0.324]], [0.679, [0.205, 0.617, 0.324]], [0.681, [0.201, 0.613, 0.322]], [0.683, [0.201, 0.613, 0.322]], [0.685, [0.197, 0.609, 0.319]], [0.687, [0.197, 0.609, 0.319]], [0.689, [0.194, 0.605, 0.316]], [0.691, [0.194, 0.605, 0.316]], [0.693, [0.190, 0.601, 0.313]], [0.695, [0.190, 0.601, 0.313]], [0.697, [0.186, 0.597, 0.310]], [0.699, [0.186, 0.597, 0.310]], [0.701, [0.182, 0.593, 0.307]], [0.703, [0.182, 0.593, 0.307]], [0.705, [0.179, 0.589, 0.304]], [0.706, [0.179, 0.589, 0.304]], [0.708, [0.175, 0.585, 0.301]], [0.710, [0.175, 0.585, 0.301]], [0.712, [0.171, 0.582, 0.298]], [0.714, [0.171, 0.582, 0.298]], [0.716, [0.168, 0.578, 0.295]], [0.718, [0.168, 0.578, 0.295]], [0.720, [0.164, 0.574, 0.292]], [0.722, [0.164, 0.574, 0.292]], [0.724, [0.160, 0.570, 0.289]], [0.726, [0.160, 0.570, 0.289]], [0.728, [0.157, 0.566, 0.286]], [0.730, [0.157, 0.566, 0.286]], [0.732, [0.153, 0.562, 0.283]], [0.734, [0.153, 0.562, 0.283]], [0.736, [0.149, 0.558, 0.280]], [0.738, [0.149, 0.558, 0.280]], [0.740, [0.146, 0.554, 0.277]], [0.742, [0.146, 0.554, 0.277]], [0.744, [0.142, 0.550, 0.274]], [0.746, [0.142, 0.550, 0.274]], [0.748, [0.138, 0.546, 0.271]], [0.750, [0.138, 0.546, 0.271]], [0.751, [0.134, 0.542, 0.268]], [0.753, [0.134, 0.542, 0.268]], [0.755, [0.130, 0.539, 0.265]], [0.757, [0.130, 0.539, 0.265]], [0.759, [0.125, 0.535, 0.262]], [0.761, [0.125, 0.535, 0.262]], [0.763, [0.121, 0.531, 0.259]], [0.765, [0.121, 0.531, 0.259]], [0.767, [0.117, 0.528, 0.256]], [0.769, [0.117, 0.528, 0.256]], [0.771, [0.112, 0.524, 0.253]], [0.773, [0.112, 0.524, 0.253]], [0.775, [0.108, 0.520, 0.250]], [0.777, [0.108, 0.520, 0.250]], [0.779, [0.104, 0.516, 0.247]], [0.781, [0.104, 0.516, 0.247]], [0.783, [0.100, 0.513, 0.244]], [0.785, [0.100, 0.513, 0.244]], [0.787, [0.095, 0.509, 0.241]], [0.789, [0.095, 0.509, 0.241]], [0.791, [0.091, 0.505, 0.238]], [0.793, [0.091, 0.505, 0.238]], [0.795, [0.087, 0.502, 0.234]], [0.796, [0.087, 0.502, 0.234]], [0.798, [0.082, 0.498, 0.231]], [0.800, [0.082, 0.498, 0.231]], [0.802, [0.078, 0.494, 0.228]], [0.804, [0.078, 0.494, 0.228]], [0.806, [0.074, 0.491, 0.225]], [0.808, [0.074, 0.491, 0.225]], [0.810, [0.069, 0.487, 0.222]], [0.812, [0.069, 0.487, 0.222]], [0.814, [0.065, 0.483, 0.219]], [0.816, [0.065, 0.483, 0.219]], [0.818, [0.061, 0.480, 0.216]], [0.820, [0.061, 0.480, 0.216]], [0.822, [0.057, 0.476, 0.213]], [0.824, [0.057, 0.476, 0.213]], [0.826, [0.052, 0.472, 0.210]], [0.828, [0.052, 0.472, 0.210]], [0.830, [0.048, 0.469, 0.207]], [0.832, [0.048, 0.469, 0.207]], [0.834, [0.044, 0.465, 0.204]], [0.836, [0.044, 0.465, 0.204]], [0.838, [0.039, 0.461, 0.201]], [0.840, [0.039, 0.461, 0.201]], [0.841, [0.035, 0.457, 0.198]], [0.843, [0.035, 0.457, 0.198]], [0.845, [0.031, 0.454, 0.194]], [0.847, [0.031, 0.454, 0.194]], [0.849, [0.026, 0.450, 0.191]], [0.851, [0.026, 0.450, 0.191]], [0.853, [0.022, 0.446, 0.188]], [0.855, [0.022, 0.446, 0.188]], [0.857, [0.018, 0.443, 0.185]], [0.859, [0.018, 0.443, 0.185]], [0.861, [0.013, 0.439, 0.182]], [0.863, [0.013, 0.439, 0.182]], [0.865, [0.009, 0.435, 0.179]], [0.867, [0.009, 0.435, 0.179]], [0.869, [0.005, 0.432, 0.176]], [0.871, [0.005, 0.432, 0.176]], [0.873, [0.001, 0.428, 0.173]], [0.875, [0.001, 0.428, 0.173]], [0.877, [0.000, 0.423, 0.171]], [0.879, [0.000, 0.423, 0.171]], [0.881, [0.000, 0.418, 0.169]], [0.883, [0.000, 0.418, 0.169]], [0.885, [0.000, 0.413, 0.167]], [0.886, [0.000, 0.413, 0.167]], [0.888, [0.000, 0.408, 0.164]], [0.890, [0.000, 0.408, 0.164]], [0.892, [0.000, 0.403, 0.162]], [0.894, [0.000, 0.403, 0.162]], [0.896, [0.000, 0.398, 0.160]], [0.898, [0.000, 0.398, 0.160]], [0.900, [0.000, 0.393, 0.158]], [0.902, [0.000, 0.393, 0.158]], [0.904, [0.000, 0.388, 0.156]], [0.906, [0.000, 0.388, 0.156]], [0.908, [0.000, 0.383, 0.154]], [0.910, [0.000, 0.383, 0.154]], [0.912, [0.000, 0.378, 0.152]], [0.914, [0.000, 0.378, 0.152]], [0.916, [0.000, 0.373, 0.150]], [0.918, [0.000, 0.373, 0.150]], [0.920, [0.000, 0.368, 0.148]], [0.922, [0.000, 0.368, 0.148]], [0.924, [0.000, 0.363, 0.146]], [0.926, [0.000, 0.363, 0.146]], [0.928, [0.000, 0.357, 0.144]], [0.930, [0.000, 0.357, 0.144]], [0.932, [0.000, 0.352, 0.141]], [0.933, [0.000, 0.352, 0.141]], [0.935, [0.000, 0.347, 0.139]], [0.937, [0.000, 0.347, 0.139]], [0.939, [0.000, 0.342, 0.137]], [0.941, [0.000, 0.342, 0.137]], [0.943, [0.000, 0.337, 0.135]], [0.945, [0.000, 0.337, 0.135]], [0.947, [0.000, 0.332, 0.133]], [0.949, [0.000, 0.332, 0.133]], [0.951, [0.000, 0.327, 0.131]], [0.953, [0.000, 0.327, 0.131]], [0.955, [0.000, 0.322, 0.129]], [0.957, [0.000, 0.322, 0.129]], [0.959, [0.000, 0.317, 0.127]], [0.961, [0.000, 0.317, 0.127]], [0.963, [0.000, 0.312, 0.125]], [0.965, [0.000, 0.312, 0.125]], [0.967, [0.000, 0.307, 0.123]], [0.969, [0.000, 0.307, 0.123]], [0.971, [0.000, 0.302, 0.121]], [0.973, [0.000, 0.302, 0.121]], [0.975, [0.000, 0.297, 0.118]], [0.977, [0.000, 0.297, 0.118]], [0.978, [0.000, 0.292, 0.116]], [0.980, [0.000, 0.292, 0.116]], [0.982, [0.000, 0.287, 0.114]], [0.984, [0.000, 0.287, 0.114]], [0.986, [0.000, 0.282, 0.112]], [0.988, [0.000, 0.282, 0.112]], [0.990, [0.000, 0.277, 0.110]], [0.992, [0.000, 0.277, 0.110]], [0.994, [0.000, 0.272, 0.108]], [0.996, [0.000, 0.272, 0.108]], [0.998, [0.000, 0.267, 0.106]], [1.000, [0.000, 0.267, 0.106]]];
vislibColorMaps.Greys = [[0.000, [1.000, 1.000, 1.000]], [0.002, [1.000, 1.000, 1.000]], [0.004, [0.998, 0.998, 0.998]], [0.006, [0.998, 0.998, 0.998]], [0.008, [0.996, 0.996, 0.996]], [0.010, [0.996, 0.996, 0.996]], [0.012, [0.994, 0.994, 0.994]], [0.014, [0.994, 0.994, 0.994]], [0.016, [0.993, 0.993, 0.993]], [0.018, [0.993, 0.993, 0.993]], [0.020, [0.991, 0.991, 0.991]], [0.022, [0.991, 0.991, 0.991]], [0.023, [0.989, 0.989, 0.989]], [0.025, [0.989, 0.989, 0.989]], [0.027, [0.987, 0.987, 0.987]], [0.029, [0.987, 0.987, 0.987]], [0.031, [0.985, 0.985, 0.985]], [0.033, [0.985, 0.985, 0.985]], [0.035, [0.983, 0.983, 0.983]], [0.037, [0.983, 0.983, 0.983]], [0.039, [0.982, 0.982, 0.982]], [0.041, [0.982, 0.982, 0.982]], [0.043, [0.980, 0.980, 0.980]], [0.045, [0.980, 0.980, 0.980]], [0.047, [0.978, 0.978, 0.978]], [0.049, [0.978, 0.978, 0.978]], [0.051, [0.976, 0.976, 0.976]], [0.053, [0.976, 0.976, 0.976]], [0.055, [0.974, 0.974, 0.974]], [0.057, [0.974, 0.974, 0.974]], [0.059, [0.972, 0.972, 0.972]], [0.061, [0.972, 0.972, 0.972]], [0.063, [0.970, 0.970, 0.970]], [0.065, [0.970, 0.970, 0.970]], [0.067, [0.969, 0.969, 0.969]], [0.068, [0.969, 0.969, 0.969]], [0.070, [0.967, 0.967, 0.967]], [0.072, [0.967, 0.967, 0.967]], [0.074, [0.965, 0.965, 0.965]], [0.076, [0.965, 0.965, 0.965]], [0.078, [0.963, 0.963, 0.963]], [0.080, [0.963, 0.963, 0.963]], [0.082, [0.961, 0.961, 0.961]], [0.084, [0.961, 0.961, 0.961]], [0.086, [0.959, 0.959, 0.959]], [0.088, [0.959, 0.959, 0.959]], [0.090, [0.958, 0.958, 0.958]], [0.092, [0.958, 0.958, 0.958]], [0.094, [0.956, 0.956, 0.956]], [0.096, [0.956, 0.956, 0.956]], [0.098, [0.954, 0.954, 0.954]], [0.100, [0.954, 0.954, 0.954]], [0.102, [0.952, 0.952, 0.952]], [0.104, [0.952, 0.952, 0.952]], [0.106, [0.950, 0.950, 0.950]], [0.108, [0.950, 0.950, 0.950]], [0.110, [0.948, 0.948, 0.948]], [0.112, [0.948, 0.948, 0.948]], [0.114, [0.946, 0.946, 0.946]], [0.115, [0.946, 0.946, 0.946]], [0.117, [0.945, 0.945, 0.945]], [0.119, [0.945, 0.945, 0.945]], [0.121, [0.943, 0.943, 0.943]], [0.123, [0.943, 0.943, 0.943]], [0.125, [0.941, 0.941, 0.941]], [0.127, [0.941, 0.941, 0.941]], [0.129, [0.938, 0.938, 0.938]], [0.131, [0.938, 0.938, 0.938]], [0.133, [0.935, 0.935, 0.935]], [0.135, [0.935, 0.935, 0.935]], [0.137, [0.932, 0.932, 0.932]], [0.139, [0.932, 0.932, 0.932]], [0.141, [0.930, 0.930, 0.930]], [0.143, [0.930, 0.930, 0.930]], [0.145, [0.927, 0.927, 0.927]], [0.147, [0.927, 0.927, 0.927]], [0.149, [0.924, 0.924, 0.924]], [0.151, [0.924, 0.924, 0.924]], [0.153, [0.921, 0.921, 0.921]], [0.155, [0.921, 0.921, 0.921]], [0.157, [0.918, 0.918, 0.918]], [0.159, [0.918, 0.918, 0.918]], [0.160, [0.915, 0.915, 0.915]], [0.162, [0.915, 0.915, 0.915]], [0.164, [0.913, 0.913, 0.913]], [0.166, [0.913, 0.913, 0.913]], [0.168, [0.910, 0.910, 0.910]], [0.170, [0.910, 0.910, 0.910]], [0.172, [0.907, 0.907, 0.907]], [0.174, [0.907, 0.907, 0.907]], [0.176, [0.904, 0.904, 0.904]], [0.178, [0.904, 0.904, 0.904]], [0.180, [0.901, 0.901, 0.901]], [0.182, [0.901, 0.901, 0.901]], [0.184, [0.898, 0.898, 0.898]], [0.186, [0.898, 0.898, 0.898]], [0.188, [0.896, 0.896, 0.896]], [0.190, [0.896, 0.896, 0.896]], [0.192, [0.893, 0.893, 0.893]], [0.194, [0.893, 0.893, 0.893]], [0.196, [0.890, 0.890, 0.890]], [0.198, [0.890, 0.890, 0.890]], [0.200, [0.887, 0.887, 0.887]], [0.202, [0.887, 0.887, 0.887]], [0.204, [0.884, 0.884, 0.884]], [0.205, [0.884, 0.884, 0.884]], [0.207, [0.881, 0.881, 0.881]], [0.209, [0.881, 0.881, 0.881]], [0.211, [0.879, 0.879, 0.879]], [0.213, [0.879, 0.879, 0.879]], [0.215, [0.876, 0.876, 0.876]], [0.217, [0.876, 0.876, 0.876]], [0.219, [0.873, 0.873, 0.873]], [0.221, [0.873, 0.873, 0.873]], [0.223, [0.870, 0.870, 0.870]], [0.225, [0.870, 0.870, 0.870]], [0.227, [0.867, 0.867, 0.867]], [0.229, [0.867, 0.867, 0.867]], [0.231, [0.864, 0.864, 0.864]], [0.233, [0.864, 0.864, 0.864]], [0.235, [0.862, 0.862, 0.862]], [0.237, [0.862, 0.862, 0.862]], [0.239, [0.859, 0.859, 0.859]], [0.241, [0.859, 0.859, 0.859]], [0.243, [0.856, 0.856, 0.856]], [0.245, [0.856, 0.856, 0.856]], [0.247, [0.853, 0.853, 0.853]], [0.249, [0.853, 0.853, 0.853]], [0.250, [0.850, 0.850, 0.850]], [0.252, [0.850, 0.850, 0.850]], [0.254, [0.847, 0.847, 0.847]], [0.256, [0.847, 0.847, 0.847]], [0.258, [0.843, 0.843, 0.843]], [0.260, [0.843, 0.843, 0.843]], [0.262, [0.840, 0.840, 0.840]], [0.264, [0.840, 0.840, 0.840]], [0.266, [0.836, 0.836, 0.836]], [0.268, [0.836, 0.836, 0.836]], [0.270, [0.833, 0.833, 0.833]], [0.272, [0.833, 0.833, 0.833]], [0.274, [0.829, 0.829, 0.829]], [0.276, [0.829, 0.829, 0.829]], [0.278, [0.826, 0.826, 0.826]], [0.280, [0.826, 0.826, 0.826]], [0.282, [0.823, 0.823, 0.823]], [0.284, [0.823, 0.823, 0.823]], [0.286, [0.819, 0.819, 0.819]], [0.288, [0.819, 0.819, 0.819]], [0.290, [0.816, 0.816, 0.816]], [0.292, [0.816, 0.816, 0.816]], [0.294, [0.812, 0.812, 0.812]], [0.295, [0.812, 0.812, 0.812]], [0.297, [0.809, 0.809, 0.809]], [0.299, [0.809, 0.809, 0.809]], [0.301, [0.805, 0.805, 0.805]], [0.303, [0.805, 0.805, 0.805]], [0.305, [0.802, 0.802, 0.802]], [0.307, [0.802, 0.802, 0.802]], [0.309, [0.798, 0.798, 0.798]], [0.311, [0.798, 0.798, 0.798]], [0.313, [0.795, 0.795, 0.795]], [0.315, [0.795, 0.795, 0.795]], [0.317, [0.792, 0.792, 0.792]], [0.319, [0.792, 0.792, 0.792]], [0.321, [0.788, 0.788, 0.788]], [0.323, [0.788, 0.788, 0.788]], [0.325, [0.785, 0.785, 0.785]], [0.327, [0.785, 0.785, 0.785]], [0.329, [0.781, 0.781, 0.781]], [0.331, [0.781, 0.781, 0.781]], [0.333, [0.778, 0.778, 0.778]], [0.335, [0.778, 0.778, 0.778]], [0.337, [0.774, 0.774, 0.774]], [0.339, [0.774, 0.774, 0.774]], [0.341, [0.771, 0.771, 0.771]], [0.342, [0.771, 0.771, 0.771]], [0.344, [0.767, 0.767, 0.767]], [0.346, [0.767, 0.767, 0.767]], [0.348, [0.764, 0.764, 0.764]], [0.350, [0.764, 0.764, 0.764]], [0.352, [0.761, 0.761, 0.761]], [0.354, [0.761, 0.761, 0.761]], [0.356, [0.757, 0.757, 0.757]], [0.358, [0.757, 0.757, 0.757]], [0.360, [0.754, 0.754, 0.754]], [0.362, [0.754, 0.754, 0.754]], [0.364, [0.750, 0.750, 0.750]], [0.366, [0.750, 0.750, 0.750]], [0.368, [0.747, 0.747, 0.747]], [0.370, [0.747, 0.747, 0.747]], [0.372, [0.743, 0.743, 0.743]], [0.374, [0.743, 0.743, 0.743]], [0.376, [0.739, 0.739, 0.739]], [0.378, [0.739, 0.739, 0.739]], [0.380, [0.735, 0.735, 0.735]], [0.382, [0.735, 0.735, 0.735]], [0.384, [0.730, 0.730, 0.730]], [0.386, [0.730, 0.730, 0.730]], [0.387, [0.725, 0.725, 0.725]], [0.389, [0.725, 0.725, 0.725]], [0.391, [0.720, 0.720, 0.720]], [0.393, [0.720, 0.720, 0.720]], [0.395, [0.715, 0.715, 0.715]], [0.397, [0.715, 0.715, 0.715]], [0.399, [0.711, 0.711, 0.711]], [0.401, [0.711, 0.711, 0.711]], [0.403, [0.706, 0.706, 0.706]], [0.405, [0.706, 0.706, 0.706]], [0.407, [0.701, 0.701, 0.701]], [0.409, [0.701, 0.701, 0.701]], [0.411, [0.696, 0.696, 0.696]], [0.413, [0.696, 0.696, 0.696]], [0.415, [0.691, 0.691, 0.691]], [0.417, [0.691, 0.691, 0.691]], [0.419, [0.687, 0.687, 0.687]], [0.421, [0.687, 0.687, 0.687]], [0.423, [0.682, 0.682, 0.682]], [0.425, [0.682, 0.682, 0.682]], [0.427, [0.677, 0.677, 0.677]], [0.429, [0.677, 0.677, 0.677]], [0.431, [0.672, 0.672, 0.672]], [0.432, [0.672, 0.672, 0.672]], [0.434, [0.667, 0.667, 0.667]], [0.436, [0.667, 0.667, 0.667]], [0.438, [0.663, 0.663, 0.663]], [0.440, [0.663, 0.663, 0.663]], [0.442, [0.658, 0.658, 0.658]], [0.444, [0.658, 0.658, 0.658]], [0.446, [0.653, 0.653, 0.653]], [0.448, [0.653, 0.653, 0.653]], [0.450, [0.648, 0.648, 0.648]], [0.452, [0.648, 0.648, 0.648]], [0.454, [0.643, 0.643, 0.643]], [0.456, [0.643, 0.643, 0.643]], [0.458, [0.639, 0.639, 0.639]], [0.460, [0.639, 0.639, 0.639]], [0.462, [0.634, 0.634, 0.634]], [0.464, [0.634, 0.634, 0.634]], [0.466, [0.629, 0.629, 0.629]], [0.468, [0.629, 0.629, 0.629]], [0.470, [0.624, 0.624, 0.624]], [0.472, [0.624, 0.624, 0.624]], [0.474, [0.619, 0.619, 0.619]], [0.476, [0.619, 0.619, 0.619]], [0.477, [0.615, 0.615, 0.615]], [0.479, [0.615, 0.615, 0.615]], [0.481, [0.610, 0.610, 0.610]], [0.483, [0.610, 0.610, 0.610]], [0.485, [0.605, 0.605, 0.605]], [0.487, [0.605, 0.605, 0.605]], [0.489, [0.600, 0.600, 0.600]], [0.491, [0.600, 0.600, 0.600]], [0.493, [0.595, 0.595, 0.595]], [0.495, [0.595, 0.595, 0.595]], [0.497, [0.591, 0.591, 0.591]], [0.499, [0.591, 0.591, 0.591]], [0.501, [0.586, 0.586, 0.586]], [0.503, [0.586, 0.586, 0.586]], [0.505, [0.582, 0.582, 0.582]], [0.507, [0.582, 0.582, 0.582]], [0.509, [0.577, 0.577, 0.577]], [0.511, [0.577, 0.577, 0.577]], [0.513, [0.573, 0.573, 0.573]], [0.515, [0.573, 0.573, 0.573]], [0.517, [0.569, 0.569, 0.569]], [0.519, [0.569, 0.569, 0.569]], [0.521, [0.565, 0.565, 0.565]], [0.523, [0.565, 0.565, 0.565]], [0.524, [0.560, 0.560, 0.560]], [0.526, [0.560, 0.560, 0.560]], [0.528, [0.556, 0.556, 0.556]], [0.530, [0.556, 0.556, 0.556]], [0.532, [0.552, 0.552, 0.552]], [0.534, [0.552, 0.552, 0.552]], [0.536, [0.547, 0.547, 0.547]], [0.538, [0.547, 0.547, 0.547]], [0.540, [0.543, 0.543, 0.543]], [0.542, [0.543, 0.543, 0.543]], [0.544, [0.539, 0.539, 0.539]], [0.546, [0.539, 0.539, 0.539]], [0.548, [0.534, 0.534, 0.534]], [0.550, [0.534, 0.534, 0.534]], [0.552, [0.530, 0.530, 0.530]], [0.554, [0.530, 0.530, 0.530]], [0.556, [0.526, 0.526, 0.526]], [0.558, [0.526, 0.526, 0.526]], [0.560, [0.521, 0.521, 0.521]], [0.562, [0.521, 0.521, 0.521]], [0.564, [0.517, 0.517, 0.517]], [0.566, [0.517, 0.517, 0.517]], [0.568, [0.513, 0.513, 0.513]], [0.569, [0.513, 0.513, 0.513]], [0.571, [0.509, 0.509, 0.509]], [0.573, [0.509, 0.509, 0.509]], [0.575, [0.504, 0.504, 0.504]], [0.577, [0.504, 0.504, 0.504]], [0.579, [0.500, 0.500, 0.500]], [0.581, [0.500, 0.500, 0.500]], [0.583, [0.496, 0.496, 0.496]], [0.585, [0.496, 0.496, 0.496]], [0.587, [0.491, 0.491, 0.491]], [0.589, [0.491, 0.491, 0.491]], [0.591, [0.487, 0.487, 0.487]], [0.593, [0.487, 0.487, 0.487]], [0.595, [0.483, 0.483, 0.483]], [0.597, [0.483, 0.483, 0.483]], [0.599, [0.478, 0.478, 0.478]], [0.601, [0.478, 0.478, 0.478]], [0.603, [0.474, 0.474, 0.474]], [0.605, [0.474, 0.474, 0.474]], [0.607, [0.470, 0.470, 0.470]], [0.609, [0.470, 0.470, 0.470]], [0.611, [0.466, 0.466, 0.466]], [0.613, [0.466, 0.466, 0.466]], [0.614, [0.461, 0.461, 0.461]], [0.616, [0.461, 0.461, 0.461]], [0.618, [0.457, 0.457, 0.457]], [0.620, [0.457, 0.457, 0.457]], [0.622, [0.453, 0.453, 0.453]], [0.624, [0.453, 0.453, 0.453]], [0.626, [0.448, 0.448, 0.448]], [0.628, [0.448, 0.448, 0.448]], [0.630, [0.444, 0.444, 0.444]], [0.632, [0.444, 0.444, 0.444]], [0.634, [0.440, 0.440, 0.440]], [0.636, [0.440, 0.440, 0.440]], [0.638, [0.436, 0.436, 0.436]], [0.640, [0.436, 0.436, 0.436]], [0.642, [0.432, 0.432, 0.432]], [0.644, [0.432, 0.432, 0.432]], [0.646, [0.428, 0.428, 0.428]], [0.648, [0.428, 0.428, 0.428]], [0.650, [0.424, 0.424, 0.424]], [0.652, [0.424, 0.424, 0.424]], [0.654, [0.420, 0.420, 0.420]], [0.656, [0.420, 0.420, 0.420]], [0.658, [0.416, 0.416, 0.416]], [0.659, [0.416, 0.416, 0.416]], [0.661, [0.412, 0.412, 0.412]], [0.663, [0.412, 0.412, 0.412]], [0.665, [0.408, 0.408, 0.408]], [0.667, [0.408, 0.408, 0.408]], [0.669, [0.404, 0.404, 0.404]], [0.671, [0.404, 0.404, 0.404]], [0.673, [0.400, 0.400, 0.400]], [0.675, [0.400, 0.400, 0.400]], [0.677, [0.396, 0.396, 0.396]], [0.679, [0.396, 0.396, 0.396]], [0.681, [0.392, 0.392, 0.392]], [0.683, [0.392, 0.392, 0.392]], [0.685, [0.388, 0.388, 0.388]], [0.687, [0.388, 0.388, 0.388]], [0.689, [0.383, 0.383, 0.383]], [0.691, [0.383, 0.383, 0.383]], [0.693, [0.379, 0.379, 0.379]], [0.695, [0.379, 0.379, 0.379]], [0.697, [0.375, 0.375, 0.375]], [0.699, [0.375, 0.375, 0.375]], [0.701, [0.371, 0.371, 0.371]], [0.703, [0.371, 0.371, 0.371]], [0.705, [0.367, 0.367, 0.367]], [0.706, [0.367, 0.367, 0.367]], [0.708, [0.363, 0.363, 0.363]], [0.710, [0.363, 0.363, 0.363]], [0.712, [0.359, 0.359, 0.359]], [0.714, [0.359, 0.359, 0.359]], [0.716, [0.355, 0.355, 0.355]], [0.718, [0.355, 0.355, 0.355]], [0.720, [0.351, 0.351, 0.351]], [0.722, [0.351, 0.351, 0.351]], [0.724, [0.347, 0.347, 0.347]], [0.726, [0.347, 0.347, 0.347]], [0.728, [0.343, 0.343, 0.343]], [0.730, [0.343, 0.343, 0.343]], [0.732, [0.339, 0.339, 0.339]], [0.734, [0.339, 0.339, 0.339]], [0.736, [0.335, 0.335, 0.335]], [0.738, [0.335, 0.335, 0.335]], [0.740, [0.331, 0.331, 0.331]], [0.742, [0.331, 0.331, 0.331]], [0.744, [0.327, 0.327, 0.327]], [0.746, [0.327, 0.327, 0.327]], [0.748, [0.323, 0.323, 0.323]], [0.750, [0.323, 0.323, 0.323]], [0.751, [0.317, 0.317, 0.317]], [0.753, [0.317, 0.317, 0.317]], [0.755, [0.312, 0.312, 0.312]], [0.757, [0.312, 0.312, 0.312]], [0.759, [0.306, 0.306, 0.306]], [0.761, [0.306, 0.306, 0.306]], [0.763, [0.301, 0.301, 0.301]], [0.765, [0.301, 0.301, 0.301]], [0.767, [0.295, 0.295, 0.295]], [0.769, [0.295, 0.295, 0.295]], [0.771, [0.290, 0.290, 0.290]], [0.773, [0.290, 0.290, 0.290]], [0.775, [0.284, 0.284, 0.284]], [0.777, [0.284, 0.284, 0.284]], [0.779, [0.279, 0.279, 0.279]], [0.781, [0.279, 0.279, 0.279]], [0.783, [0.273, 0.273, 0.273]], [0.785, [0.273, 0.273, 0.273]], [0.787, [0.268, 0.268, 0.268]], [0.789, [0.268, 0.268, 0.268]], [0.791, [0.262, 0.262, 0.262]], [0.793, [0.262, 0.262, 0.262]], [0.795, [0.257, 0.257, 0.257]], [0.796, [0.257, 0.257, 0.257]], [0.798, [0.251, 0.251, 0.251]], [0.800, [0.251, 0.251, 0.251]], [0.802, [0.245, 0.245, 0.245]], [0.804, [0.245, 0.245, 0.245]], [0.806, [0.240, 0.240, 0.240]], [0.808, [0.240, 0.240, 0.240]], [0.810, [0.234, 0.234, 0.234]], [0.812, [0.234, 0.234, 0.234]], [0.814, [0.229, 0.229, 0.229]], [0.816, [0.229, 0.229, 0.229]], [0.818, [0.223, 0.223, 0.223]], [0.820, [0.223, 0.223, 0.223]], [0.822, [0.218, 0.218, 0.218]], [0.824, [0.218, 0.218, 0.218]], [0.826, [0.212, 0.212, 0.212]], [0.828, [0.212, 0.212, 0.212]], [0.830, [0.207, 0.207, 0.207]], [0.832, [0.207, 0.207, 0.207]], [0.834, [0.201, 0.201, 0.201]], [0.836, [0.201, 0.201, 0.201]], [0.838, [0.196, 0.196, 0.196]], [0.840, [0.196, 0.196, 0.196]], [0.841, [0.190, 0.190, 0.190]], [0.843, [0.190, 0.190, 0.190]], [0.845, [0.185, 0.185, 0.185]], [0.847, [0.185, 0.185, 0.185]], [0.849, [0.179, 0.179, 0.179]], [0.851, [0.179, 0.179, 0.179]], [0.853, [0.173, 0.173, 0.173]], [0.855, [0.173, 0.173, 0.173]], [0.857, [0.168, 0.168, 0.168]], [0.859, [0.168, 0.168, 0.168]], [0.861, [0.162, 0.162, 0.162]], [0.863, [0.162, 0.162, 0.162]], [0.865, [0.157, 0.157, 0.157]], [0.867, [0.157, 0.157, 0.157]], [0.869, [0.151, 0.151, 0.151]], [0.871, [0.151, 0.151, 0.151]], [0.873, [0.146, 0.146, 0.146]], [0.875, [0.146, 0.146, 0.146]], [0.877, [0.141, 0.141, 0.141]], [0.879, [0.141, 0.141, 0.141]], [0.881, [0.137, 0.137, 0.137]], [0.883, [0.137, 0.137, 0.137]], [0.885, [0.132, 0.132, 0.132]], [0.886, [0.132, 0.132, 0.132]], [0.888, [0.127, 0.127, 0.127]], [0.890, [0.127, 0.127, 0.127]], [0.892, [0.123, 0.123, 0.123]], [0.894, [0.123, 0.123, 0.123]], [0.896, [0.118, 0.118, 0.118]], [0.898, [0.118, 0.118, 0.118]], [0.900, [0.114, 0.114, 0.114]], [0.902, [0.114, 0.114, 0.114]], [0.904, [0.109, 0.109, 0.109]], [0.906, [0.109, 0.109, 0.109]], [0.908, [0.105, 0.105, 0.105]], [0.910, [0.105, 0.105, 0.105]], [0.912, [0.100, 0.100, 0.100]], [0.914, [0.100, 0.100, 0.100]], [0.916, [0.096, 0.096, 0.096]], [0.918, [0.096, 0.096, 0.096]], [0.920, [0.091, 0.091, 0.091]], [0.922, [0.091, 0.091, 0.091]], [0.924, [0.086, 0.086, 0.086]], [0.926, [0.086, 0.086, 0.086]], [0.928, [0.082, 0.082, 0.082]], [0.930, [0.082, 0.082, 0.082]], [0.932, [0.077, 0.077, 0.077]], [0.933, [0.077, 0.077, 0.077]], [0.935, [0.073, 0.073, 0.073]], [0.937, [0.073, 0.073, 0.073]], [0.939, [0.068, 0.068, 0.068]], [0.941, [0.068, 0.068, 0.068]], [0.943, [0.064, 0.064, 0.064]], [0.945, [0.064, 0.064, 0.064]], [0.947, [0.059, 0.059, 0.059]], [0.949, [0.059, 0.059, 0.059]], [0.951, [0.055, 0.055, 0.055]], [0.953, [0.055, 0.055, 0.055]], [0.955, [0.050, 0.050, 0.050]], [0.957, [0.050, 0.050, 0.050]], [0.959, [0.046, 0.046, 0.046]], [0.961, [0.046, 0.046, 0.046]], [0.963, [0.041, 0.041, 0.041]], [0.965, [0.041, 0.041, 0.041]], [0.967, [0.036, 0.036, 0.036]], [0.969, [0.036, 0.036, 0.036]], [0.971, [0.032, 0.032, 0.032]], [0.973, [0.032, 0.032, 0.032]], [0.975, [0.027, 0.027, 0.027]], [0.977, [0.027, 0.027, 0.027]], [0.978, [0.023, 0.023, 0.023]], [0.980, [0.023, 0.023, 0.023]], [0.982, [0.018, 0.018, 0.018]], [0.984, [0.018, 0.018, 0.018]], [0.986, [0.014, 0.014, 0.014]], [0.988, [0.014, 0.014, 0.014]], [0.990, [0.009, 0.009, 0.009]], [0.992, [0.009, 0.009, 0.009]], [0.994, [0.005, 0.005, 0.005]], [0.996, [0.005, 0.005, 0.005]], [0.998, [0.000, 0.000, 0.000]], [1.000, [0.000, 0.000, 0.000]]];
vislibColorMaps.Reds = [[0.000, [1.000, 0.961, 0.941]], [0.002, [1.000, 0.961, 0.941]], [0.004, [1.000, 0.958, 0.937]], [0.006, [1.000, 0.958, 0.937]], [0.008, [1.000, 0.956, 0.934]], [0.010, [1.000, 0.956, 0.934]], [0.012, [1.000, 0.953, 0.930]], [0.014, [1.000, 0.953, 0.930]], [0.016, [1.000, 0.950, 0.926]], [0.018, [1.000, 0.950, 0.926]], [0.020, [0.999, 0.948, 0.923]], [0.022, [0.999, 0.948, 0.923]], [0.023, [0.999, 0.945, 0.919]], [0.025, [0.999, 0.945, 0.919]], [0.027, [0.999, 0.943, 0.915]], [0.029, [0.999, 0.943, 0.915]], [0.031, [0.999, 0.940, 0.912]], [0.033, [0.999, 0.940, 0.912]], [0.035, [0.999, 0.938, 0.908]], [0.037, [0.999, 0.938, 0.908]], [0.039, [0.999, 0.935, 0.904]], [0.041, [0.999, 0.935, 0.904]], [0.043, [0.999, 0.932, 0.901]], [0.045, [0.999, 0.932, 0.901]], [0.047, [0.999, 0.930, 0.897]], [0.049, [0.999, 0.930, 0.897]], [0.051, [0.998, 0.927, 0.893]], [0.053, [0.998, 0.927, 0.893]], [0.055, [0.998, 0.925, 0.890]], [0.057, [0.998, 0.925, 0.890]], [0.059, [0.998, 0.922, 0.886]], [0.061, [0.998, 0.922, 0.886]], [0.063, [0.998, 0.919, 0.882]], [0.065, [0.998, 0.919, 0.882]], [0.067, [0.998, 0.917, 0.878]], [0.068, [0.998, 0.917, 0.878]], [0.070, [0.998, 0.914, 0.875]], [0.072, [0.998, 0.914, 0.875]], [0.074, [0.998, 0.912, 0.871]], [0.076, [0.998, 0.912, 0.871]], [0.078, [0.998, 0.909, 0.867]], [0.080, [0.998, 0.909, 0.867]], [0.082, [0.997, 0.907, 0.864]], [0.084, [0.997, 0.907, 0.864]], [0.086, [0.997, 0.904, 0.860]], [0.088, [0.997, 0.904, 0.860]], [0.090, [0.997, 0.901, 0.856]], [0.092, [0.997, 0.901, 0.856]], [0.094, [0.997, 0.899, 0.853]], [0.096, [0.997, 0.899, 0.853]], [0.098, [0.997, 0.896, 0.849]], [0.100, [0.997, 0.896, 0.849]], [0.102, [0.997, 0.894, 0.845]], [0.104, [0.997, 0.894, 0.845]], [0.106, [0.997, 0.891, 0.842]], [0.108, [0.997, 0.891, 0.842]], [0.110, [0.997, 0.888, 0.838]], [0.112, [0.997, 0.888, 0.838]], [0.114, [0.996, 0.886, 0.834]], [0.115, [0.996, 0.886, 0.834]], [0.117, [0.996, 0.883, 0.830]], [0.119, [0.996, 0.883, 0.830]], [0.121, [0.996, 0.881, 0.827]], [0.123, [0.996, 0.881, 0.827]], [0.125, [0.996, 0.878, 0.823]], [0.127, [0.996, 0.878, 0.823]], [0.129, [0.996, 0.873, 0.817]], [0.131, [0.996, 0.873, 0.817]], [0.133, [0.996, 0.869, 0.811]], [0.135, [0.996, 0.869, 0.811]], [0.137, [0.995, 0.864, 0.805]], [0.139, [0.995, 0.864, 0.805]], [0.141, [0.995, 0.860, 0.799]], [0.143, [0.995, 0.860, 0.799]], [0.145, [0.995, 0.855, 0.793]], [0.147, [0.995, 0.855, 0.793]], [0.149, [0.995, 0.851, 0.787]], [0.151, [0.995, 0.851, 0.787]], [0.153, [0.994, 0.846, 0.781]], [0.155, [0.994, 0.846, 0.781]], [0.157, [0.994, 0.841, 0.775]], [0.159, [0.994, 0.841, 0.775]], [0.160, [0.994, 0.837, 0.769]], [0.162, [0.994, 0.837, 0.769]], [0.164, [0.994, 0.832, 0.762]], [0.166, [0.994, 0.832, 0.762]], [0.168, [0.993, 0.828, 0.756]], [0.170, [0.993, 0.828, 0.756]], [0.172, [0.993, 0.823, 0.750]], [0.174, [0.993, 0.823, 0.750]], [0.176, [0.993, 0.819, 0.744]], [0.178, [0.993, 0.819, 0.744]], [0.180, [0.993, 0.814, 0.738]], [0.182, [0.993, 0.814, 0.738]], [0.184, [0.992, 0.810, 0.732]], [0.186, [0.992, 0.810, 0.732]], [0.188, [0.992, 0.805, 0.726]], [0.190, [0.992, 0.805, 0.726]], [0.192, [0.992, 0.800, 0.720]], [0.194, [0.992, 0.800, 0.720]], [0.196, [0.992, 0.796, 0.714]], [0.198, [0.992, 0.796, 0.714]], [0.200, [0.991, 0.791, 0.708]], [0.202, [0.991, 0.791, 0.708]], [0.204, [0.991, 0.787, 0.702]], [0.205, [0.991, 0.787, 0.702]], [0.207, [0.991, 0.782, 0.696]], [0.209, [0.991, 0.782, 0.696]], [0.211, [0.991, 0.778, 0.690]], [0.213, [0.991, 0.778, 0.690]], [0.215, [0.990, 0.773, 0.684]], [0.217, [0.990, 0.773, 0.684]], [0.219, [0.990, 0.769, 0.678]], [0.221, [0.990, 0.769, 0.678]], [0.223, [0.990, 0.764, 0.672]], [0.225, [0.990, 0.764, 0.672]], [0.227, [0.990, 0.760, 0.666]], [0.229, [0.990, 0.760, 0.666]], [0.231, [0.989, 0.755, 0.660]], [0.233, [0.989, 0.755, 0.660]], [0.235, [0.989, 0.750, 0.654]], [0.237, [0.989, 0.750, 0.654]], [0.239, [0.989, 0.746, 0.648]], [0.241, [0.989, 0.746, 0.648]], [0.243, [0.989, 0.741, 0.642]], [0.245, [0.989, 0.741, 0.642]], [0.247, [0.988, 0.737, 0.636]], [0.249, [0.988, 0.737, 0.636]], [0.250, [0.988, 0.732, 0.630]], [0.252, [0.988, 0.732, 0.630]], [0.254, [0.988, 0.727, 0.624]], [0.256, [0.988, 0.727, 0.624]], [0.258, [0.988, 0.722, 0.618]], [0.260, [0.988, 0.722, 0.618]], [0.262, [0.988, 0.717, 0.613]], [0.264, [0.988, 0.717, 0.613]], [0.266, [0.988, 0.712, 0.607]], [0.268, [0.988, 0.712, 0.607]], [0.270, [0.988, 0.707, 0.601]], [0.272, [0.988, 0.707, 0.601]], [0.274, [0.988, 0.702, 0.595]], [0.276, [0.988, 0.702, 0.595]], [0.278, [0.988, 0.697, 0.589]], [0.280, [0.988, 0.697, 0.589]], [0.282, [0.988, 0.692, 0.584]], [0.284, [0.988, 0.692, 0.584]], [0.286, [0.988, 0.687, 0.578]], [0.288, [0.988, 0.687, 0.578]], [0.290, [0.988, 0.682, 0.572]], [0.292, [0.988, 0.682, 0.572]], [0.294, [0.988, 0.677, 0.566]], [0.295, [0.988, 0.677, 0.566]], [0.297, [0.988, 0.672, 0.561]], [0.299, [0.988, 0.672, 0.561]], [0.301, [0.988, 0.666, 0.555]], [0.303, [0.988, 0.666, 0.555]], [0.305, [0.988, 0.661, 0.549]], [0.307, [0.988, 0.661, 0.549]], [0.309, [0.988, 0.656, 0.543]], [0.311, [0.988, 0.656, 0.543]], [0.313, [0.988, 0.651, 0.537]], [0.315, [0.988, 0.651, 0.537]], [0.317, [0.988, 0.646, 0.532]], [0.319, [0.988, 0.646, 0.532]], [0.321, [0.988, 0.641, 0.526]], [0.323, [0.988, 0.641, 0.526]], [0.325, [0.988, 0.636, 0.520]], [0.327, [0.988, 0.636, 0.520]], [0.329, [0.988, 0.631, 0.514]], [0.331, [0.988, 0.631, 0.514]], [0.333, [0.988, 0.626, 0.508]], [0.335, [0.988, 0.626, 0.508]], [0.337, [0.988, 0.621, 0.503]], [0.339, [0.988, 0.621, 0.503]], [0.341, [0.988, 0.616, 0.497]], [0.342, [0.988, 0.616, 0.497]], [0.344, [0.988, 0.611, 0.491]], [0.346, [0.988, 0.611, 0.491]], [0.348, [0.988, 0.606, 0.485]], [0.350, [0.988, 0.606, 0.485]], [0.352, [0.988, 0.601, 0.480]], [0.354, [0.988, 0.601, 0.480]], [0.356, [0.988, 0.596, 0.474]], [0.358, [0.988, 0.596, 0.474]], [0.360, [0.988, 0.591, 0.468]], [0.362, [0.988, 0.591, 0.468]], [0.364, [0.988, 0.586, 0.462]], [0.366, [0.988, 0.586, 0.462]], [0.368, [0.988, 0.581, 0.456]], [0.370, [0.988, 0.581, 0.456]], [0.372, [0.988, 0.576, 0.451]], [0.374, [0.988, 0.576, 0.451]], [0.376, [0.988, 0.571, 0.445]], [0.378, [0.988, 0.571, 0.445]], [0.380, [0.988, 0.566, 0.440]], [0.382, [0.988, 0.566, 0.440]], [0.384, [0.988, 0.561, 0.435]], [0.386, [0.988, 0.561, 0.435]], [0.387, [0.988, 0.556, 0.430]], [0.389, [0.988, 0.556, 0.430]], [0.391, [0.988, 0.551, 0.426]], [0.393, [0.988, 0.551, 0.426]], [0.395, [0.988, 0.546, 0.421]], [0.397, [0.988, 0.546, 0.421]], [0.399, [0.987, 0.541, 0.416]], [0.401, [0.987, 0.541, 0.416]], [0.403, [0.987, 0.536, 0.411]], [0.405, [0.987, 0.536, 0.411]], [0.407, [0.987, 0.531, 0.406]], [0.409, [0.987, 0.531, 0.406]], [0.411, [0.987, 0.526, 0.401]], [0.413, [0.987, 0.526, 0.401]], [0.415, [0.987, 0.521, 0.396]], [0.417, [0.987, 0.521, 0.396]], [0.419, [0.987, 0.517, 0.391]], [0.421, [0.987, 0.517, 0.391]], [0.423, [0.987, 0.512, 0.386]], [0.425, [0.987, 0.512, 0.386]], [0.427, [0.987, 0.507, 0.381]], [0.429, [0.987, 0.507, 0.381]], [0.431, [0.986, 0.502, 0.376]], [0.432, [0.986, 0.502, 0.376]], [0.434, [0.986, 0.497, 0.371]], [0.436, [0.986, 0.497, 0.371]], [0.438, [0.986, 0.492, 0.366]], [0.440, [0.986, 0.492, 0.366]], [0.442, [0.986, 0.487, 0.362]], [0.444, [0.986, 0.487, 0.362]], [0.446, [0.986, 0.482, 0.357]], [0.448, [0.986, 0.482, 0.357]], [0.450, [0.986, 0.477, 0.352]], [0.452, [0.986, 0.477, 0.352]], [0.454, [0.986, 0.472, 0.347]], [0.456, [0.986, 0.472, 0.347]], [0.458, [0.986, 0.467, 0.342]], [0.460, [0.986, 0.467, 0.342]], [0.462, [0.985, 0.462, 0.337]], [0.464, [0.985, 0.462, 0.337]], [0.466, [0.985, 0.458, 0.332]], [0.468, [0.985, 0.458, 0.332]], [0.470, [0.985, 0.453, 0.327]], [0.472, [0.985, 0.453, 0.327]], [0.474, [0.985, 0.448, 0.322]], [0.476, [0.985, 0.448, 0.322]], [0.477, [0.985, 0.443, 0.317]], [0.479, [0.985, 0.443, 0.317]], [0.481, [0.985, 0.438, 0.312]], [0.483, [0.985, 0.438, 0.312]], [0.485, [0.985, 0.433, 0.307]], [0.487, [0.985, 0.433, 0.307]], [0.489, [0.985, 0.428, 0.302]], [0.491, [0.985, 0.428, 0.302]], [0.493, [0.984, 0.423, 0.298]], [0.495, [0.984, 0.423, 0.298]], [0.497, [0.984, 0.418, 0.293]], [0.499, [0.984, 0.418, 0.293]], [0.501, [0.984, 0.413, 0.288]], [0.503, [0.984, 0.413, 0.288]], [0.505, [0.982, 0.407, 0.285]], [0.507, [0.982, 0.407, 0.285]], [0.509, [0.981, 0.401, 0.281]], [0.511, [0.981, 0.401, 0.281]], [0.513, [0.979, 0.395, 0.277]], [0.515, [0.979, 0.395, 0.277]], [0.517, [0.978, 0.390, 0.274]], [0.519, [0.978, 0.390, 0.274]], [0.521, [0.976, 0.384, 0.270]], [0.523, [0.976, 0.384, 0.270]], [0.524, [0.975, 0.378, 0.266]], [0.526, [0.975, 0.378, 0.266]], [0.528, [0.973, 0.372, 0.263]], [0.530, [0.973, 0.372, 0.263]], [0.532, [0.972, 0.367, 0.259]], [0.534, [0.972, 0.367, 0.259]], [0.536, [0.970, 0.361, 0.255]], [0.538, [0.970, 0.361, 0.255]], [0.540, [0.969, 0.355, 0.251]], [0.542, [0.969, 0.355, 0.251]], [0.544, [0.967, 0.349, 0.248]], [0.546, [0.967, 0.349, 0.248]], [0.548, [0.966, 0.343, 0.244]], [0.550, [0.966, 0.343, 0.244]], [0.552, [0.964, 0.338, 0.240]], [0.554, [0.964, 0.338, 0.240]], [0.556, [0.963, 0.332, 0.237]], [0.558, [0.963, 0.332, 0.237]], [0.560, [0.961, 0.326, 0.233]], [0.562, [0.961, 0.326, 0.233]], [0.564, [0.960, 0.320, 0.229]], [0.566, [0.960, 0.320, 0.229]], [0.568, [0.958, 0.314, 0.226]], [0.569, [0.958, 0.314, 0.226]], [0.571, [0.957, 0.309, 0.222]], [0.573, [0.957, 0.309, 0.222]], [0.575, [0.956, 0.303, 0.218]], [0.577, [0.956, 0.303, 0.218]], [0.579, [0.954, 0.297, 0.215]], [0.581, [0.954, 0.297, 0.215]], [0.583, [0.953, 0.291, 0.211]], [0.585, [0.953, 0.291, 0.211]], [0.587, [0.951, 0.286, 0.207]], [0.589, [0.951, 0.286, 0.207]], [0.591, [0.950, 0.280, 0.203]], [0.593, [0.950, 0.280, 0.203]], [0.595, [0.948, 0.274, 0.200]], [0.597, [0.948, 0.274, 0.200]], [0.599, [0.947, 0.268, 0.196]], [0.601, [0.947, 0.268, 0.196]], [0.603, [0.945, 0.262, 0.192]], [0.605, [0.945, 0.262, 0.192]], [0.607, [0.944, 0.257, 0.189]], [0.609, [0.944, 0.257, 0.189]], [0.611, [0.942, 0.251, 0.185]], [0.613, [0.942, 0.251, 0.185]], [0.614, [0.941, 0.245, 0.181]], [0.616, [0.941, 0.245, 0.181]], [0.618, [0.939, 0.239, 0.178]], [0.620, [0.939, 0.239, 0.178]], [0.622, [0.938, 0.234, 0.174]], [0.624, [0.938, 0.234, 0.174]], [0.626, [0.934, 0.229, 0.171]], [0.628, [0.934, 0.229, 0.171]], [0.630, [0.930, 0.224, 0.170]], [0.632, [0.930, 0.224, 0.170]], [0.634, [0.926, 0.220, 0.168]], [0.636, [0.926, 0.220, 0.168]], [0.638, [0.921, 0.216, 0.166]], [0.640, [0.921, 0.216, 0.166]], [0.642, [0.917, 0.211, 0.164]], [0.644, [0.917, 0.211, 0.164]], [0.646, [0.912, 0.207, 0.162]], [0.648, [0.912, 0.207, 0.162]], [0.650, [0.908, 0.203, 0.160]], [0.652, [0.908, 0.203, 0.160]], [0.654, [0.903, 0.199, 0.158]], [0.656, [0.903, 0.199, 0.158]], [0.658, [0.899, 0.194, 0.157]], [0.659, [0.899, 0.194, 0.157]], [0.661, [0.895, 0.190, 0.155]], [0.663, [0.895, 0.190, 0.155]], [0.665, [0.890, 0.186, 0.153]], [0.667, [0.890, 0.186, 0.153]], [0.669, [0.886, 0.181, 0.151]], [0.671, [0.886, 0.181, 0.151]], [0.673, [0.881, 0.177, 0.149]], [0.675, [0.881, 0.177, 0.149]], [0.677, [0.877, 0.173, 0.147]], [0.679, [0.877, 0.173, 0.147]], [0.681, [0.872, 0.168, 0.146]], [0.683, [0.872, 0.168, 0.146]], [0.685, [0.868, 0.164, 0.144]], [0.687, [0.868, 0.164, 0.144]], [0.689, [0.864, 0.160, 0.142]], [0.691, [0.864, 0.160, 0.142]], [0.693, [0.859, 0.155, 0.140]], [0.695, [0.859, 0.155, 0.140]], [0.697, [0.855, 0.151, 0.138]], [0.699, [0.855, 0.151, 0.138]], [0.701, [0.850, 0.147, 0.136]], [0.703, [0.850, 0.147, 0.136]], [0.705, [0.846, 0.143, 0.134]], [0.706, [0.846, 0.143, 0.134]], [0.708, [0.841, 0.138, 0.133]], [0.710, [0.841, 0.138, 0.133]], [0.712, [0.837, 0.134, 0.131]], [0.714, [0.837, 0.134, 0.131]], [0.716, [0.833, 0.130, 0.129]], [0.718, [0.833, 0.130, 0.129]], [0.720, [0.828, 0.125, 0.127]], [0.722, [0.828, 0.125, 0.127]], [0.724, [0.824, 0.121, 0.125]], [0.726, [0.824, 0.121, 0.125]], [0.728, [0.819, 0.117, 0.123]], [0.730, [0.819, 0.117, 0.123]], [0.732, [0.815, 0.112, 0.122]], [0.734, [0.815, 0.112, 0.122]], [0.736, [0.810, 0.108, 0.120]], [0.738, [0.810, 0.108, 0.120]], [0.740, [0.806, 0.104, 0.118]], [0.742, [0.806, 0.104, 0.118]], [0.744, [0.802, 0.100, 0.116]], [0.746, [0.802, 0.100, 0.116]], [0.748, [0.797, 0.095, 0.114]], [0.750, [0.797, 0.095, 0.114]], [0.751, [0.793, 0.093, 0.113]], [0.753, [0.793, 0.093, 0.113]], [0.755, [0.788, 0.092, 0.112]], [0.757, [0.788, 0.092, 0.112]], [0.759, [0.783, 0.091, 0.111]], [0.761, [0.783, 0.091, 0.111]], [0.763, [0.779, 0.090, 0.110]], [0.765, [0.779, 0.090, 0.110]], [0.767, [0.774, 0.089, 0.109]], [0.769, [0.774, 0.089, 0.109]], [0.771, [0.769, 0.088, 0.108]], [0.773, [0.769, 0.088, 0.108]], [0.775, [0.765, 0.087, 0.107]], [0.777, [0.765, 0.087, 0.107]], [0.779, [0.760, 0.086, 0.106]], [0.781, [0.760, 0.086, 0.106]], [0.783, [0.755, 0.084, 0.105]], [0.785, [0.755, 0.084, 0.105]], [0.787, [0.750, 0.083, 0.104]], [0.789, [0.750, 0.083, 0.104]], [0.791, [0.746, 0.082, 0.103]], [0.793, [0.746, 0.082, 0.103]], [0.795, [0.741, 0.081, 0.102]], [0.796, [0.741, 0.081, 0.102]], [0.798, [0.736, 0.080, 0.101]], [0.800, [0.736, 0.080, 0.101]], [0.802, [0.732, 0.079, 0.100]], [0.804, [0.732, 0.079, 0.100]], [0.806, [0.727, 0.078, 0.099]], [0.808, [0.727, 0.078, 0.099]], [0.810, [0.722, 0.077, 0.098]], [0.812, [0.722, 0.077, 0.098]], [0.814, [0.718, 0.076, 0.097]], [0.816, [0.718, 0.076, 0.097]], [0.818, [0.713, 0.074, 0.096]], [0.820, [0.713, 0.074, 0.096]], [0.822, [0.708, 0.073, 0.095]], [0.824, [0.708, 0.073, 0.095]], [0.826, [0.704, 0.072, 0.094]], [0.828, [0.704, 0.072, 0.094]], [0.830, [0.699, 0.071, 0.093]], [0.832, [0.699, 0.071, 0.093]], [0.834, [0.694, 0.070, 0.092]], [0.836, [0.694, 0.070, 0.092]], [0.838, [0.690, 0.069, 0.091]], [0.840, [0.690, 0.069, 0.091]], [0.841, [0.685, 0.068, 0.090]], [0.843, [0.685, 0.068, 0.090]], [0.845, [0.680, 0.067, 0.089]], [0.847, [0.680, 0.067, 0.089]], [0.849, [0.676, 0.066, 0.088]], [0.851, [0.676, 0.066, 0.088]], [0.853, [0.671, 0.064, 0.087]], [0.855, [0.671, 0.064, 0.087]], [0.857, [0.666, 0.063, 0.086]], [0.859, [0.666, 0.063, 0.086]], [0.861, [0.662, 0.062, 0.085]], [0.863, [0.662, 0.062, 0.085]], [0.865, [0.657, 0.061, 0.084]], [0.867, [0.657, 0.061, 0.084]], [0.869, [0.652, 0.060, 0.083]], [0.871, [0.652, 0.060, 0.083]], [0.873, [0.648, 0.059, 0.082]], [0.875, [0.648, 0.059, 0.082]], [0.877, [0.640, 0.057, 0.081]], [0.879, [0.640, 0.057, 0.081]], [0.881, [0.633, 0.055, 0.081]], [0.883, [0.633, 0.055, 0.081]], [0.885, [0.625, 0.054, 0.080]], [0.886, [0.625, 0.054, 0.080]], [0.888, [0.618, 0.052, 0.079]], [0.890, [0.618, 0.052, 0.079]], [0.892, [0.610, 0.050, 0.078]], [0.894, [0.610, 0.050, 0.078]], [0.896, [0.602, 0.048, 0.077]], [0.898, [0.602, 0.048, 0.077]], [0.900, [0.595, 0.046, 0.076]], [0.902, [0.595, 0.046, 0.076]], [0.904, [0.587, 0.044, 0.075]], [0.906, [0.587, 0.044, 0.075]], [0.908, [0.579, 0.042, 0.074]], [0.910, [0.579, 0.042, 0.074]], [0.912, [0.572, 0.041, 0.073]], [0.914, [0.572, 0.041, 0.073]], [0.916, [0.564, 0.039, 0.072]], [0.918, [0.564, 0.039, 0.072]], [0.920, [0.556, 0.037, 0.071]], [0.922, [0.556, 0.037, 0.071]], [0.924, [0.549, 0.035, 0.070]], [0.926, [0.549, 0.035, 0.070]], [0.928, [0.541, 0.033, 0.069]], [0.930, [0.541, 0.033, 0.069]], [0.932, [0.534, 0.031, 0.068]], [0.933, [0.534, 0.031, 0.068]], [0.935, [0.526, 0.030, 0.067]], [0.937, [0.526, 0.030, 0.067]], [0.939, [0.518, 0.028, 0.066]], [0.941, [0.518, 0.028, 0.066]], [0.943, [0.511, 0.026, 0.065]], [0.945, [0.511, 0.026, 0.065]], [0.947, [0.503, 0.024, 0.064]], [0.949, [0.503, 0.024, 0.064]], [0.951, [0.495, 0.022, 0.063]], [0.953, [0.495, 0.022, 0.063]], [0.955, [0.488, 0.020, 0.062]], [0.957, [0.488, 0.020, 0.062]], [0.959, [0.480, 0.018, 0.061]], [0.961, [0.480, 0.018, 0.061]], [0.963, [0.473, 0.017, 0.060]], [0.965, [0.473, 0.017, 0.060]], [0.967, [0.465, 0.015, 0.059]], [0.969, [0.465, 0.015, 0.059]], [0.971, [0.457, 0.013, 0.058]], [0.973, [0.457, 0.013, 0.058]], [0.975, [0.450, 0.011, 0.057]], [0.977, [0.450, 0.011, 0.057]], [0.978, [0.442, 0.009, 0.056]], [0.980, [0.442, 0.009, 0.056]], [0.982, [0.434, 0.007, 0.055]], [0.984, [0.434, 0.007, 0.055]], [0.986, [0.427, 0.006, 0.054]], [0.988, [0.427, 0.006, 0.054]], [0.990, [0.419, 0.004, 0.053]], [0.992, [0.419, 0.004, 0.053]], [0.994, [0.412, 0.002, 0.052]], [0.996, [0.412, 0.002, 0.052]], [0.998, [0.404, 0.000, 0.051]], [1.000, [0.404, 0.000, 0.051]]];
vislibColorMaps['Yellow to Red'] = [[0.000, [1.000, 1.000, 0.800]], [0.002, [1.000, 1.000, 0.800]], [0.004, [1.000, 0.998, 0.795]], [0.006, [1.000, 0.998, 0.795]], [0.008, [1.000, 0.996, 0.789]], [0.010, [1.000, 0.996, 0.789]], [0.012, [1.000, 0.993, 0.784]], [0.014, [1.000, 0.993, 0.784]], [0.016, [1.000, 0.991, 0.778]], [0.018, [1.000, 0.991, 0.778]], [0.020, [1.000, 0.989, 0.773]], [0.022, [1.000, 0.989, 0.773]], [0.023, [1.000, 0.987, 0.768]], [0.025, [1.000, 0.987, 0.768]], [0.027, [1.000, 0.984, 0.762]], [0.029, [1.000, 0.984, 0.762]], [0.031, [1.000, 0.982, 0.757]], [0.033, [1.000, 0.982, 0.757]], [0.035, [1.000, 0.980, 0.751]], [0.037, [1.000, 0.980, 0.751]], [0.039, [1.000, 0.978, 0.746]], [0.041, [1.000, 0.978, 0.746]], [0.043, [1.000, 0.976, 0.740]], [0.045, [1.000, 0.976, 0.740]], [0.047, [1.000, 0.973, 0.735]], [0.049, [1.000, 0.973, 0.735]], [0.051, [1.000, 0.971, 0.730]], [0.053, [1.000, 0.971, 0.730]], [0.055, [1.000, 0.969, 0.724]], [0.057, [1.000, 0.969, 0.724]], [0.059, [1.000, 0.967, 0.719]], [0.061, [1.000, 0.967, 0.719]], [0.063, [1.000, 0.965, 0.713]], [0.065, [1.000, 0.965, 0.713]], [0.067, [1.000, 0.962, 0.708]], [0.068, [1.000, 0.962, 0.708]], [0.070, [1.000, 0.960, 0.703]], [0.072, [1.000, 0.960, 0.703]], [0.074, [1.000, 0.958, 0.697]], [0.076, [1.000, 0.958, 0.697]], [0.078, [1.000, 0.956, 0.692]], [0.080, [1.000, 0.956, 0.692]], [0.082, [1.000, 0.953, 0.686]], [0.084, [1.000, 0.953, 0.686]], [0.086, [1.000, 0.951, 0.681]], [0.088, [1.000, 0.951, 0.681]], [0.090, [1.000, 0.949, 0.675]], [0.092, [1.000, 0.949, 0.675]], [0.094, [1.000, 0.947, 0.670]], [0.096, [1.000, 0.947, 0.670]], [0.098, [1.000, 0.945, 0.665]], [0.100, [1.000, 0.945, 0.665]], [0.102, [1.000, 0.942, 0.659]], [0.104, [1.000, 0.942, 0.659]], [0.106, [1.000, 0.940, 0.654]], [0.108, [1.000, 0.940, 0.654]], [0.110, [1.000, 0.938, 0.648]], [0.112, [1.000, 0.938, 0.648]], [0.114, [1.000, 0.936, 0.643]], [0.115, [1.000, 0.936, 0.643]], [0.117, [1.000, 0.934, 0.638]], [0.119, [1.000, 0.934, 0.638]], [0.121, [1.000, 0.931, 0.632]], [0.123, [1.000, 0.931, 0.632]], [0.125, [1.000, 0.929, 0.627]], [0.127, [1.000, 0.929, 0.627]], [0.129, [1.000, 0.927, 0.622]], [0.131, [1.000, 0.927, 0.622]], [0.133, [1.000, 0.924, 0.616]], [0.135, [1.000, 0.924, 0.616]], [0.137, [1.000, 0.922, 0.611]], [0.139, [1.000, 0.922, 0.611]], [0.141, [0.999, 0.919, 0.606]], [0.143, [0.999, 0.919, 0.606]], [0.145, [0.999, 0.917, 0.601]], [0.147, [0.999, 0.917, 0.601]], [0.149, [0.999, 0.914, 0.596]], [0.151, [0.999, 0.914, 0.596]], [0.153, [0.999, 0.912, 0.591]], [0.155, [0.999, 0.912, 0.591]], [0.157, [0.999, 0.909, 0.585]], [0.159, [0.999, 0.909, 0.585]], [0.160, [0.999, 0.907, 0.580]], [0.162, [0.999, 0.907, 0.580]], [0.164, [0.999, 0.904, 0.575]], [0.166, [0.999, 0.904, 0.575]], [0.168, [0.999, 0.902, 0.570]], [0.170, [0.999, 0.902, 0.570]], [0.172, [0.999, 0.900, 0.565]], [0.174, [0.999, 0.900, 0.565]], [0.176, [0.998, 0.897, 0.560]], [0.178, [0.998, 0.897, 0.560]], [0.180, [0.998, 0.895, 0.554]], [0.182, [0.998, 0.895, 0.554]], [0.184, [0.998, 0.892, 0.549]], [0.186, [0.998, 0.892, 0.549]], [0.188, [0.998, 0.890, 0.544]], [0.190, [0.998, 0.890, 0.544]], [0.192, [0.998, 0.887, 0.539]], [0.194, [0.998, 0.887, 0.539]], [0.196, [0.998, 0.885, 0.534]], [0.198, [0.998, 0.885, 0.534]], [0.200, [0.998, 0.882, 0.529]], [0.202, [0.998, 0.882, 0.529]], [0.204, [0.998, 0.880, 0.523]], [0.205, [0.998, 0.880, 0.523]], [0.207, [0.997, 0.877, 0.518]], [0.209, [0.997, 0.877, 0.518]], [0.211, [0.997, 0.875, 0.513]], [0.213, [0.997, 0.875, 0.513]], [0.215, [0.997, 0.873, 0.508]], [0.217, [0.997, 0.873, 0.508]], [0.219, [0.997, 0.870, 0.503]], [0.221, [0.997, 0.870, 0.503]], [0.223, [0.997, 0.868, 0.498]], [0.225, [0.997, 0.868, 0.498]], [0.227, [0.997, 0.865, 0.492]], [0.229, [0.997, 0.865, 0.492]], [0.231, [0.997, 0.863, 0.487]], [0.233, [0.997, 0.863, 0.487]], [0.235, [0.997, 0.860, 0.482]], [0.237, [0.997, 0.860, 0.482]], [0.239, [0.996, 0.858, 0.477]], [0.241, [0.996, 0.858, 0.477]], [0.243, [0.996, 0.855, 0.472]], [0.245, [0.996, 0.855, 0.472]], [0.247, [0.996, 0.853, 0.467]], [0.249, [0.996, 0.853, 0.467]], [0.250, [0.996, 0.850, 0.461]], [0.252, [0.996, 0.850, 0.461]], [0.254, [0.996, 0.845, 0.456]], [0.256, [0.996, 0.845, 0.456]], [0.258, [0.996, 0.840, 0.451]], [0.260, [0.996, 0.840, 0.451]], [0.262, [0.996, 0.835, 0.446]], [0.264, [0.996, 0.835, 0.446]], [0.266, [0.996, 0.831, 0.441]], [0.268, [0.996, 0.831, 0.441]], [0.270, [0.996, 0.826, 0.436]], [0.272, [0.996, 0.826, 0.436]], [0.274, [0.996, 0.821, 0.430]], [0.276, [0.996, 0.821, 0.430]], [0.278, [0.996, 0.816, 0.425]], [0.280, [0.996, 0.816, 0.425]], [0.282, [0.996, 0.811, 0.420]], [0.284, [0.996, 0.811, 0.420]], [0.286, [0.996, 0.807, 0.415]], [0.288, [0.996, 0.807, 0.415]], [0.290, [0.996, 0.802, 0.410]], [0.292, [0.996, 0.802, 0.410]], [0.294, [0.996, 0.797, 0.405]], [0.295, [0.996, 0.797, 0.405]], [0.297, [0.996, 0.792, 0.399]], [0.299, [0.996, 0.792, 0.399]], [0.301, [0.996, 0.787, 0.394]], [0.303, [0.996, 0.787, 0.394]], [0.305, [0.996, 0.783, 0.389]], [0.307, [0.996, 0.783, 0.389]], [0.309, [0.996, 0.778, 0.384]], [0.311, [0.996, 0.778, 0.384]], [0.313, [0.996, 0.773, 0.379]], [0.315, [0.996, 0.773, 0.379]], [0.317, [0.996, 0.768, 0.374]], [0.319, [0.996, 0.768, 0.374]], [0.321, [0.996, 0.763, 0.368]], [0.323, [0.996, 0.763, 0.368]], [0.325, [0.996, 0.759, 0.363]], [0.327, [0.996, 0.759, 0.363]], [0.329, [0.996, 0.754, 0.358]], [0.331, [0.996, 0.754, 0.358]], [0.333, [0.996, 0.749, 0.353]], [0.335, [0.996, 0.749, 0.353]], [0.337, [0.996, 0.744, 0.348]], [0.339, [0.996, 0.744, 0.348]], [0.341, [0.996, 0.739, 0.343]], [0.342, [0.996, 0.739, 0.343]], [0.344, [0.996, 0.735, 0.337]], [0.346, [0.996, 0.735, 0.337]], [0.348, [0.996, 0.730, 0.332]], [0.350, [0.996, 0.730, 0.332]], [0.352, [0.996, 0.725, 0.327]], [0.354, [0.996, 0.725, 0.327]], [0.356, [0.996, 0.720, 0.322]], [0.358, [0.996, 0.720, 0.322]], [0.360, [0.996, 0.715, 0.317]], [0.362, [0.996, 0.715, 0.317]], [0.364, [0.996, 0.711, 0.312]], [0.366, [0.996, 0.711, 0.312]], [0.368, [0.996, 0.706, 0.306]], [0.370, [0.996, 0.706, 0.306]], [0.372, [0.996, 0.701, 0.301]], [0.374, [0.996, 0.701, 0.301]], [0.376, [0.996, 0.696, 0.297]], [0.378, [0.996, 0.696, 0.297]], [0.380, [0.996, 0.692, 0.295]], [0.382, [0.996, 0.692, 0.295]], [0.384, [0.996, 0.687, 0.293]], [0.386, [0.996, 0.687, 0.293]], [0.387, [0.996, 0.683, 0.291]], [0.389, [0.996, 0.683, 0.291]], [0.391, [0.996, 0.678, 0.289]], [0.393, [0.996, 0.678, 0.289]], [0.395, [0.995, 0.674, 0.287]], [0.397, [0.995, 0.674, 0.287]], [0.399, [0.995, 0.669, 0.285]], [0.401, [0.995, 0.669, 0.285]], [0.403, [0.995, 0.664, 0.284]], [0.405, [0.995, 0.664, 0.284]], [0.407, [0.995, 0.660, 0.282]], [0.409, [0.995, 0.660, 0.282]], [0.411, [0.995, 0.655, 0.280]], [0.413, [0.995, 0.655, 0.280]], [0.415, [0.995, 0.651, 0.278]], [0.417, [0.995, 0.651, 0.278]], [0.419, [0.995, 0.646, 0.276]], [0.421, [0.995, 0.646, 0.276]], [0.423, [0.995, 0.642, 0.274]], [0.425, [0.995, 0.642, 0.274]], [0.427, [0.994, 0.637, 0.272]], [0.429, [0.994, 0.637, 0.272]], [0.431, [0.994, 0.633, 0.270]], [0.432, [0.994, 0.633, 0.270]], [0.434, [0.994, 0.628, 0.268]], [0.436, [0.994, 0.628, 0.268]], [0.438, [0.994, 0.623, 0.266]], [0.440, [0.994, 0.623, 0.266]], [0.442, [0.994, 0.619, 0.264]], [0.444, [0.994, 0.619, 0.264]], [0.446, [0.994, 0.614, 0.262]], [0.448, [0.994, 0.614, 0.262]], [0.450, [0.994, 0.610, 0.260]], [0.452, [0.994, 0.610, 0.260]], [0.454, [0.994, 0.605, 0.258]], [0.456, [0.994, 0.605, 0.258]], [0.458, [0.993, 0.601, 0.256]], [0.460, [0.993, 0.601, 0.256]], [0.462, [0.993, 0.596, 0.254]], [0.464, [0.993, 0.596, 0.254]], [0.466, [0.993, 0.592, 0.252]], [0.468, [0.993, 0.592, 0.252]], [0.470, [0.993, 0.587, 0.250]], [0.472, [0.993, 0.587, 0.250]], [0.474, [0.993, 0.583, 0.248]], [0.476, [0.993, 0.583, 0.248]], [0.477, [0.993, 0.578, 0.246]], [0.479, [0.993, 0.578, 0.246]], [0.481, [0.993, 0.573, 0.244]], [0.483, [0.993, 0.573, 0.244]], [0.485, [0.993, 0.569, 0.242]], [0.487, [0.993, 0.569, 0.242]], [0.489, [0.992, 0.564, 0.240]], [0.491, [0.992, 0.564, 0.240]], [0.493, [0.992, 0.560, 0.238]], [0.495, [0.992, 0.560, 0.238]], [0.497, [0.992, 0.555, 0.236]], [0.499, [0.992, 0.555, 0.236]], [0.501, [0.992, 0.549, 0.234]], [0.503, [0.992, 0.549, 0.234]], [0.505, [0.992, 0.541, 0.232]], [0.507, [0.992, 0.541, 0.232]], [0.509, [0.992, 0.534, 0.230]], [0.511, [0.992, 0.534, 0.230]], [0.513, [0.992, 0.526, 0.228]], [0.515, [0.992, 0.526, 0.228]], [0.517, [0.992, 0.518, 0.225]], [0.519, [0.992, 0.518, 0.225]], [0.521, [0.991, 0.510, 0.223]], [0.523, [0.991, 0.510, 0.223]], [0.524, [0.991, 0.503, 0.221]], [0.526, [0.991, 0.503, 0.221]], [0.528, [0.991, 0.495, 0.219]], [0.530, [0.991, 0.495, 0.219]], [0.532, [0.991, 0.487, 0.216]], [0.534, [0.991, 0.487, 0.216]], [0.536, [0.991, 0.479, 0.214]], [0.538, [0.991, 0.479, 0.214]], [0.540, [0.991, 0.472, 0.212]], [0.542, [0.991, 0.472, 0.212]], [0.544, [0.991, 0.464, 0.210]], [0.546, [0.991, 0.464, 0.210]], [0.548, [0.991, 0.456, 0.208]], [0.550, [0.991, 0.456, 0.208]], [0.552, [0.990, 0.448, 0.205]], [0.554, [0.990, 0.448, 0.205]], [0.556, [0.990, 0.441, 0.203]], [0.558, [0.990, 0.441, 0.203]], [0.560, [0.990, 0.433, 0.201]], [0.562, [0.990, 0.433, 0.201]], [0.564, [0.990, 0.425, 0.199]], [0.566, [0.990, 0.425, 0.199]], [0.568, [0.990, 0.417, 0.197]], [0.569, [0.990, 0.417, 0.197]], [0.571, [0.990, 0.410, 0.194]], [0.573, [0.990, 0.410, 0.194]], [0.575, [0.990, 0.402, 0.192]], [0.577, [0.990, 0.402, 0.192]], [0.579, [0.990, 0.394, 0.190]], [0.581, [0.990, 0.394, 0.190]], [0.583, [0.990, 0.386, 0.188]], [0.585, [0.990, 0.386, 0.188]], [0.587, [0.989, 0.379, 0.185]], [0.589, [0.989, 0.379, 0.185]], [0.591, [0.989, 0.371, 0.183]], [0.593, [0.989, 0.371, 0.183]], [0.595, [0.989, 0.363, 0.181]], [0.597, [0.989, 0.363, 0.181]], [0.599, [0.989, 0.355, 0.179]], [0.601, [0.989, 0.355, 0.179]], [0.603, [0.989, 0.348, 0.177]], [0.605, [0.989, 0.348, 0.177]], [0.607, [0.989, 0.340, 0.174]], [0.609, [0.989, 0.340, 0.174]], [0.611, [0.989, 0.332, 0.172]], [0.613, [0.989, 0.332, 0.172]], [0.614, [0.989, 0.324, 0.170]], [0.616, [0.989, 0.324, 0.170]], [0.618, [0.988, 0.317, 0.168]], [0.620, [0.988, 0.317, 0.168]], [0.622, [0.988, 0.309, 0.166]], [0.624, [0.988, 0.309, 0.166]], [0.626, [0.986, 0.302, 0.164]], [0.628, [0.986, 0.302, 0.164]], [0.630, [0.983, 0.295, 0.162]], [0.632, [0.983, 0.295, 0.162]], [0.634, [0.980, 0.289, 0.160]], [0.636, [0.980, 0.289, 0.160]], [0.638, [0.977, 0.283, 0.158]], [0.640, [0.977, 0.283, 0.158]], [0.642, [0.974, 0.276, 0.157]], [0.644, [0.974, 0.276, 0.157]], [0.646, [0.971, 0.270, 0.155]], [0.648, [0.971, 0.270, 0.155]], [0.650, [0.968, 0.263, 0.153]], [0.652, [0.968, 0.263, 0.153]], [0.654, [0.965, 0.257, 0.152]], [0.656, [0.965, 0.257, 0.152]], [0.658, [0.962, 0.251, 0.150]], [0.659, [0.962, 0.251, 0.150]], [0.661, [0.959, 0.244, 0.148]], [0.663, [0.959, 0.244, 0.148]], [0.665, [0.956, 0.238, 0.146]], [0.667, [0.956, 0.238, 0.146]], [0.669, [0.952, 0.232, 0.145]], [0.671, [0.952, 0.232, 0.145]], [0.673, [0.949, 0.225, 0.143]], [0.675, [0.949, 0.225, 0.143]], [0.677, [0.946, 0.219, 0.141]], [0.679, [0.946, 0.219, 0.141]], [0.681, [0.943, 0.212, 0.140]], [0.683, [0.943, 0.212, 0.140]], [0.685, [0.940, 0.206, 0.138]], [0.687, [0.940, 0.206, 0.138]], [0.689, [0.937, 0.200, 0.136]], [0.691, [0.937, 0.200, 0.136]], [0.693, [0.934, 0.193, 0.134]], [0.695, [0.934, 0.193, 0.134]], [0.697, [0.931, 0.187, 0.133]], [0.699, [0.931, 0.187, 0.133]], [0.701, [0.928, 0.180, 0.131]], [0.703, [0.928, 0.180, 0.131]], [0.705, [0.925, 0.174, 0.129]], [0.706, [0.925, 0.174, 0.129]], [0.708, [0.922, 0.168, 0.127]], [0.710, [0.922, 0.168, 0.127]], [0.712, [0.919, 0.161, 0.126]], [0.714, [0.919, 0.161, 0.126]], [0.716, [0.916, 0.155, 0.124]], [0.718, [0.916, 0.155, 0.124]], [0.720, [0.912, 0.148, 0.122]], [0.722, [0.912, 0.148, 0.122]], [0.724, [0.909, 0.142, 0.121]], [0.726, [0.909, 0.142, 0.121]], [0.728, [0.906, 0.136, 0.119]], [0.730, [0.906, 0.136, 0.119]], [0.732, [0.903, 0.129, 0.117]], [0.734, [0.903, 0.129, 0.117]], [0.736, [0.900, 0.123, 0.115]], [0.738, [0.900, 0.123, 0.115]], [0.740, [0.897, 0.116, 0.114]], [0.742, [0.897, 0.116, 0.114]], [0.744, [0.894, 0.110, 0.112]], [0.746, [0.894, 0.110, 0.112]], [0.748, [0.891, 0.104, 0.110]], [0.750, [0.891, 0.104, 0.110]], [0.751, [0.887, 0.100, 0.111]], [0.753, [0.887, 0.100, 0.111]], [0.755, [0.882, 0.096, 0.112]], [0.757, [0.882, 0.096, 0.112]], [0.759, [0.877, 0.093, 0.113]], [0.761, [0.877, 0.093, 0.113]], [0.763, [0.873, 0.090, 0.114]], [0.765, [0.873, 0.090, 0.114]], [0.767, [0.868, 0.087, 0.116]], [0.769, [0.868, 0.087, 0.116]], [0.771, [0.863, 0.084, 0.117]], [0.773, [0.863, 0.084, 0.117]], [0.775, [0.859, 0.080, 0.118]], [0.777, [0.859, 0.080, 0.118]], [0.779, [0.854, 0.077, 0.119]], [0.781, [0.854, 0.077, 0.119]], [0.783, [0.849, 0.074, 0.121]], [0.785, [0.849, 0.074, 0.121]], [0.787, [0.845, 0.071, 0.122]], [0.789, [0.845, 0.071, 0.122]], [0.791, [0.840, 0.068, 0.123]], [0.793, [0.840, 0.068, 0.123]], [0.795, [0.835, 0.064, 0.124]], [0.796, [0.835, 0.064, 0.124]], [0.798, [0.831, 0.061, 0.125]], [0.800, [0.831, 0.061, 0.125]], [0.802, [0.826, 0.058, 0.127]], [0.804, [0.826, 0.058, 0.127]], [0.806, [0.821, 0.055, 0.128]], [0.808, [0.821, 0.055, 0.128]], [0.810, [0.817, 0.052, 0.129]], [0.812, [0.817, 0.052, 0.129]], [0.814, [0.812, 0.048, 0.130]], [0.816, [0.812, 0.048, 0.130]], [0.818, [0.807, 0.045, 0.132]], [0.820, [0.807, 0.045, 0.132]], [0.822, [0.803, 0.042, 0.133]], [0.824, [0.803, 0.042, 0.133]], [0.826, [0.798, 0.039, 0.134]], [0.828, [0.798, 0.039, 0.134]], [0.830, [0.793, 0.036, 0.135]], [0.832, [0.793, 0.036, 0.135]], [0.834, [0.789, 0.032, 0.137]], [0.836, [0.789, 0.032, 0.137]], [0.838, [0.784, 0.029, 0.138]], [0.840, [0.784, 0.029, 0.138]], [0.841, [0.779, 0.026, 0.139]], [0.843, [0.779, 0.026, 0.139]], [0.845, [0.774, 0.023, 0.140]], [0.847, [0.774, 0.023, 0.140]], [0.849, [0.770, 0.020, 0.141]], [0.851, [0.770, 0.020, 0.141]], [0.853, [0.765, 0.016, 0.143]], [0.855, [0.765, 0.016, 0.143]], [0.857, [0.760, 0.013, 0.144]], [0.859, [0.760, 0.013, 0.144]], [0.861, [0.756, 0.010, 0.145]], [0.863, [0.756, 0.010, 0.145]], [0.865, [0.751, 0.007, 0.146]], [0.867, [0.751, 0.007, 0.146]], [0.869, [0.746, 0.004, 0.148]], [0.871, [0.746, 0.004, 0.148]], [0.873, [0.742, 0.000, 0.149]], [0.875, [0.742, 0.000, 0.149]], [0.877, [0.735, 0.000, 0.149]], [0.879, [0.735, 0.000, 0.149]], [0.881, [0.727, 0.000, 0.149]], [0.883, [0.727, 0.000, 0.149]], [0.885, [0.720, 0.000, 0.149]], [0.886, [0.720, 0.000, 0.149]], [0.888, [0.712, 0.000, 0.149]], [0.890, [0.712, 0.000, 0.149]], [0.892, [0.705, 0.000, 0.149]], [0.894, [0.705, 0.000, 0.149]], [0.896, [0.697, 0.000, 0.149]], [0.898, [0.697, 0.000, 0.149]], [0.900, [0.690, 0.000, 0.149]], [0.902, [0.690, 0.000, 0.149]], [0.904, [0.682, 0.000, 0.149]], [0.906, [0.682, 0.000, 0.149]], [0.908, [0.675, 0.000, 0.149]], [0.910, [0.675, 0.000, 0.149]], [0.912, [0.667, 0.000, 0.149]], [0.914, [0.667, 0.000, 0.149]], [0.916, [0.660, 0.000, 0.149]], [0.918, [0.660, 0.000, 0.149]], [0.920, [0.652, 0.000, 0.149]], [0.922, [0.652, 0.000, 0.149]], [0.924, [0.645, 0.000, 0.149]], [0.926, [0.645, 0.000, 0.149]], [0.928, [0.637, 0.000, 0.149]], [0.930, [0.637, 0.000, 0.149]], [0.932, [0.630, 0.000, 0.149]], [0.933, [0.630, 0.000, 0.149]], [0.935, [0.622, 0.000, 0.149]], [0.937, [0.622, 0.000, 0.149]], [0.939, [0.615, 0.000, 0.149]], [0.941, [0.615, 0.000, 0.149]], [0.943, [0.607, 0.000, 0.149]], [0.945, [0.607, 0.000, 0.149]], [0.947, [0.600, 0.000, 0.149]], [0.949, [0.600, 0.000, 0.149]], [0.951, [0.592, 0.000, 0.149]], [0.953, [0.592, 0.000, 0.149]], [0.955, [0.585, 0.000, 0.149]], [0.957, [0.585, 0.000, 0.149]], [0.959, [0.577, 0.000, 0.149]], [0.961, [0.577, 0.000, 0.149]], [0.963, [0.570, 0.000, 0.149]], [0.965, [0.570, 0.000, 0.149]], [0.967, [0.562, 0.000, 0.149]], [0.969, [0.562, 0.000, 0.149]], [0.971, [0.554, 0.000, 0.149]], [0.973, [0.554, 0.000, 0.149]], [0.975, [0.547, 0.000, 0.149]], [0.977, [0.547, 0.000, 0.149]], [0.978, [0.539, 0.000, 0.149]], [0.980, [0.539, 0.000, 0.149]], [0.982, [0.532, 0.000, 0.149]], [0.984, [0.532, 0.000, 0.149]], [0.986, [0.524, 0.000, 0.149]], [0.988, [0.524, 0.000, 0.149]], [0.990, [0.517, 0.000, 0.149]], [0.992, [0.517, 0.000, 0.149]], [0.994, [0.509, 0.000, 0.149]], [0.996, [0.509, 0.000, 0.149]], [0.998, [0.502, 0.000, 0.149]], [1.000, [0.502, 0.000, 0.149]]];

vislibColorMaps['Green to Red'] = [[0, [0, 0.408, 0.216]], [0.002, [0, 0.408, 0.216]], [0.004, [0.004, 0.415, 0.22]], [0.006, [0.004, 0.415, 0.22]], [0.008, [0.008, 0.423, 0.223]], [0.01, [0.008, 0.423, 0.223]], [0.012, [0.012, 0.43, 0.227]], [0.014, [0.012, 0.43, 0.227]], [0.016, [0.016, 0.437, 0.231]], [0.018, [0.016, 0.437, 0.231]], [0.02, [0.02, 0.445, 0.235]], [0.022, [0.02, 0.445, 0.235]], [0.023, [0.024, 0.452, 0.239]], [0.025, [0.024, 0.452, 0.239]], [0.027, [0.028, 0.46, 0.243]], [0.029, [0.028, 0.46, 0.243]], [0.031, [0.032, 0.467, 0.246]], [0.033, [0.032, 0.467, 0.246]], [0.035, [0.036, 0.474, 0.25]], [0.037, [0.036, 0.474, 0.25]], [0.039, [0.04, 0.482, 0.254]], [0.041, [0.04, 0.482, 0.254]], [0.043, [0.044, 0.489, 0.258]], [0.045, [0.044, 0.489, 0.258]], [0.047, [0.048, 0.496, 0.262]], [0.049, [0.048, 0.496, 0.262]], [0.051, [0.052, 0.504, 0.266]], [0.053, [0.052, 0.504, 0.266]], [0.055, [0.056, 0.511, 0.27]], [0.057, [0.056, 0.511, 0.27]], [0.059, [0.06, 0.519, 0.273]], [0.061, [0.06, 0.519, 0.273]], [0.063, [0.064, 0.526, 0.277]], [0.065, [0.064, 0.526, 0.277]], [0.067, [0.068, 0.533, 0.281]], [0.068, [0.068, 0.533, 0.281]], [0.07, [0.072, 0.541, 0.285]], [0.072, [0.072, 0.541, 0.285]], [0.074, [0.076, 0.548, 0.289]], [0.076, [0.076, 0.548, 0.289]], [0.078, [0.08, 0.555, 0.293]], [0.08, [0.08, 0.555, 0.293]], [0.082, [0.084, 0.563, 0.296]], [0.084, [0.084, 0.563, 0.296]], [0.086, [0.088, 0.57, 0.3]], [0.088, [0.088, 0.57, 0.3]], [0.09, [0.092, 0.578, 0.304]], [0.092, [0.092, 0.578, 0.304]], [0.094, [0.096, 0.585, 0.308]], [0.096, [0.096, 0.585, 0.308]], [0.098, [0.1, 0.592, 0.312]], [0.1, [0.1, 0.592, 0.312]], [0.102, [0.108, 0.599, 0.315]], [0.104, [0.108, 0.599, 0.315]], [0.106, [0.119, 0.605, 0.318]], [0.108, [0.119, 0.605, 0.318]], [0.11, [0.131, 0.61, 0.321]], [0.112, [0.131, 0.61, 0.321]], [0.114, [0.143, 0.616, 0.324]], [0.115, [0.143, 0.616, 0.324]], [0.117, [0.155, 0.622, 0.327]], [0.119, [0.155, 0.622, 0.327]], [0.121, [0.166, 0.627, 0.33]], [0.123, [0.166, 0.627, 0.33]], [0.125, [0.178, 0.633, 0.333]], [0.127, [0.178, 0.633, 0.333]], [0.129, [0.19, 0.639, 0.336]], [0.131, [0.19, 0.639, 0.336]], [0.133, [0.201, 0.644, 0.339]], [0.135, [0.201, 0.644, 0.339]], [0.137, [0.213, 0.65, 0.341]], [0.139, [0.213, 0.65, 0.341]], [0.141, [0.225, 0.656, 0.344]], [0.143, [0.225, 0.656, 0.344]], [0.145, [0.236, 0.662, 0.347]], [0.147, [0.236, 0.662, 0.347]], [0.149, [0.248, 0.667, 0.35]], [0.151, [0.248, 0.667, 0.35]], [0.153, [0.26, 0.673, 0.353]], [0.155, [0.26, 0.673, 0.353]], [0.157, [0.271, 0.679, 0.356]], [0.159, [0.271, 0.679, 0.356]], [0.16, [0.283, 0.684, 0.359]], [0.162, [0.283, 0.684, 0.359]], [0.164, [0.295, 0.69, 0.362]], [0.166, [0.295, 0.69, 0.362]], [0.168, [0.306, 0.696, 0.365]], [0.17, [0.306, 0.696, 0.365]], [0.172, [0.318, 0.701, 0.368]], [0.174, [0.318, 0.701, 0.368]], [0.176, [0.33, 0.707, 0.371]], [0.178, [0.33, 0.707, 0.371]], [0.18, [0.342, 0.713, 0.374]], [0.182, [0.342, 0.713, 0.374]], [0.184, [0.353, 0.718, 0.377]], [0.186, [0.353, 0.718, 0.377]], [0.188, [0.365, 0.724, 0.379]], [0.19, [0.365, 0.724, 0.379]], [0.192, [0.377, 0.73, 0.382]], [0.194, [0.377, 0.73, 0.382]], [0.196, [0.388, 0.735, 0.385]], [0.198, [0.388, 0.735, 0.385]], [0.2, [0.4, 0.741, 0.388]], [0.202, [0.4, 0.741, 0.388]], [0.204, [0.41, 0.745, 0.389]], [0.205, [0.41, 0.745, 0.389]], [0.207, [0.42, 0.75, 0.39]], [0.209, [0.42, 0.75, 0.39]], [0.211, [0.43, 0.754, 0.391]], [0.213, [0.43, 0.754, 0.391]], [0.215, [0.439, 0.758, 0.393]], [0.217, [0.439, 0.758, 0.393]], [0.219, [0.449, 0.763, 0.394]], [0.221, [0.449, 0.763, 0.394]], [0.223, [0.459, 0.767, 0.395]], [0.225, [0.459, 0.767, 0.395]], [0.227, [0.469, 0.771, 0.396]], [0.229, [0.469, 0.771, 0.396]], [0.231, [0.479, 0.776, 0.397]], [0.233, [0.479, 0.776, 0.397]], [0.235, [0.489, 0.78, 0.398]], [0.237, [0.489, 0.78, 0.398]], [0.239, [0.498, 0.784, 0.399]], [0.241, [0.498, 0.784, 0.399]], [0.243, [0.508, 0.789, 0.4]], [0.245, [0.508, 0.789, 0.4]], [0.247, [0.518, 0.793, 0.401]], [0.249, [0.518, 0.793, 0.401]], [0.25, [0.528, 0.797, 0.402]], [0.252, [0.528, 0.797, 0.402]], [0.254, [0.538, 0.801, 0.403]], [0.256, [0.538, 0.801, 0.403]], [0.258, [0.548, 0.806, 0.404]], [0.26, [0.548, 0.806, 0.404]], [0.262, [0.557, 0.81, 0.405]], [0.264, [0.557, 0.81, 0.405]], [0.266, [0.567, 0.814, 0.407]], [0.268, [0.567, 0.814, 0.407]], [0.27, [0.577, 0.819, 0.408]], [0.272, [0.577, 0.819, 0.408]], [0.274, [0.587, 0.823, 0.409]], [0.276, [0.587, 0.823, 0.409]], [0.278, [0.597, 0.827, 0.41]], [0.28, [0.597, 0.827, 0.41]], [0.282, [0.607, 0.832, 0.411]], [0.284, [0.607, 0.832, 0.411]], [0.286, [0.617, 0.836, 0.412]], [0.288, [0.617, 0.836, 0.412]], [0.29, [0.626, 0.84, 0.413]], [0.292, [0.626, 0.84, 0.413]], [0.294, [0.636, 0.845, 0.414]], [0.295, [0.636, 0.845, 0.414]], [0.297, [0.646, 0.849, 0.415]], [0.299, [0.646, 0.849, 0.415]], [0.301, [0.655, 0.853, 0.418]], [0.303, [0.655, 0.853, 0.418]], [0.305, [0.663, 0.856, 0.423]], [0.307, [0.663, 0.856, 0.423]], [0.309, [0.671, 0.859, 0.428]], [0.311, [0.671, 0.859, 0.428]], [0.313, [0.678, 0.863, 0.433]], [0.315, [0.678, 0.863, 0.433]], [0.317, [0.686, 0.866, 0.439]], [0.319, [0.686, 0.866, 0.439]], [0.321, [0.694, 0.87, 0.444]], [0.323, [0.694, 0.87, 0.444]], [0.325, [0.702, 0.873, 0.449]], [0.327, [0.702, 0.873, 0.449]], [0.329, [0.71, 0.876, 0.454]], [0.331, [0.71, 0.876, 0.454]], [0.333, [0.718, 0.88, 0.459]], [0.335, [0.718, 0.88, 0.459]], [0.337, [0.725, 0.883, 0.464]], [0.339, [0.725, 0.883, 0.464]], [0.341, [0.733, 0.887, 0.469]], [0.342, [0.733, 0.887, 0.469]], [0.344, [0.741, 0.89, 0.474]], [0.346, [0.741, 0.89, 0.474]], [0.348, [0.749, 0.893, 0.479]], [0.35, [0.749, 0.893, 0.479]], [0.352, [0.757, 0.897, 0.484]], [0.354, [0.757, 0.897, 0.484]], [0.356, [0.765, 0.9, 0.489]], [0.358, [0.765, 0.9, 0.489]], [0.36, [0.773, 0.903, 0.494]], [0.362, [0.773, 0.903, 0.494]], [0.364, [0.78, 0.907, 0.499]], [0.366, [0.78, 0.907, 0.499]], [0.368, [0.788, 0.91, 0.504]], [0.37, [0.788, 0.91, 0.504]], [0.372, [0.796, 0.914, 0.51]], [0.374, [0.796, 0.914, 0.51]], [0.376, [0.804, 0.917, 0.515]], [0.378, [0.804, 0.917, 0.515]], [0.38, [0.812, 0.92, 0.52]], [0.382, [0.812, 0.92, 0.52]], [0.384, [0.82, 0.924, 0.525]], [0.386, [0.82, 0.924, 0.525]], [0.387, [0.827, 0.927, 0.53]], [0.389, [0.827, 0.927, 0.53]], [0.391, [0.835, 0.93, 0.535]], [0.393, [0.835, 0.93, 0.535]], [0.395, [0.843, 0.934, 0.54]], [0.397, [0.843, 0.934, 0.54]], [0.399, [0.851, 0.937, 0.545]], [0.401, [0.851, 0.937, 0.545]], [0.403, [0.857, 0.94, 0.553]], [0.405, [0.857, 0.94, 0.553]], [0.407, [0.863, 0.942, 0.561]], [0.409, [0.863, 0.942, 0.561]], [0.411, [0.869, 0.945, 0.569]], [0.413, [0.869, 0.945, 0.569]], [0.415, [0.874, 0.947, 0.577]], [0.417, [0.874, 0.947, 0.577]], [0.419, [0.88, 0.95, 0.585]], [0.421, [0.88, 0.95, 0.585]], [0.423, [0.886, 0.952, 0.593]], [0.425, [0.886, 0.952, 0.593]], [0.427, [0.892, 0.954, 0.601]], [0.429, [0.892, 0.954, 0.601]], [0.431, [0.898, 0.957, 0.609]], [0.432, [0.898, 0.957, 0.609]], [0.434, [0.904, 0.959, 0.617]], [0.436, [0.904, 0.959, 0.617]], [0.438, [0.909, 0.962, 0.625]], [0.44, [0.909, 0.962, 0.625]], [0.442, [0.915, 0.964, 0.633]], [0.444, [0.915, 0.964, 0.633]], [0.446, [0.921, 0.967, 0.641]], [0.448, [0.921, 0.967, 0.641]], [0.45, [0.927, 0.969, 0.649]], [0.452, [0.927, 0.969, 0.649]], [0.454, [0.933, 0.972, 0.657]], [0.456, [0.933, 0.972, 0.657]], [0.458, [0.939, 0.974, 0.665]], [0.46, [0.939, 0.974, 0.665]], [0.462, [0.944, 0.977, 0.673]], [0.464, [0.944, 0.977, 0.673]], [0.466, [0.95, 0.979, 0.681]], [0.468, [0.95, 0.979, 0.681]], [0.47, [0.956, 0.982, 0.689]], [0.472, [0.956, 0.982, 0.689]], [0.474, [0.962, 0.984, 0.697]], [0.476, [0.962, 0.984, 0.697]], [0.477, [0.968, 0.986, 0.705]], [0.479, [0.968, 0.986, 0.705]], [0.481, [0.974, 0.989, 0.713]], [0.483, [0.974, 0.989, 0.713]], [0.485, [0.98, 0.991, 0.721]], [0.487, [0.98, 0.991, 0.721]], [0.489, [0.985, 0.994, 0.729]], [0.491, [0.985, 0.994, 0.729]], [0.493, [0.991, 0.996, 0.737]], [0.495, [0.991, 0.996, 0.737]], [0.497, [0.997, 0.999, 0.745]], [0.499, [0.997, 0.999, 0.745]], [0.501, [1, 0.998, 0.745]], [0.503, [1, 0.998, 0.745]], [0.505, [1, 0.993, 0.737]], [0.507, [1, 0.993, 0.737]], [0.509, [1, 0.988, 0.729]], [0.511, [1, 0.988, 0.729]], [0.513, [0.999, 0.983, 0.721]], [0.515, [0.999, 0.983, 0.721]], [0.517, [0.999, 0.979, 0.713]], [0.519, [0.999, 0.979, 0.713]], [0.521, [0.999, 0.974, 0.705]], [0.523, [0.999, 0.974, 0.705]], [0.524, [0.999, 0.969, 0.697]], [0.526, [0.999, 0.969, 0.697]], [0.528, [0.999, 0.964, 0.689]], [0.53, [0.999, 0.964, 0.689]], [0.532, [0.999, 0.959, 0.681]], [0.534, [0.999, 0.959, 0.681]], [0.536, [0.999, 0.955, 0.673]], [0.538, [0.999, 0.955, 0.673]], [0.54, [0.998, 0.95, 0.665]], [0.542, [0.998, 0.95, 0.665]], [0.544, [0.998, 0.945, 0.657]], [0.546, [0.998, 0.945, 0.657]], [0.548, [0.998, 0.94, 0.649]], [0.55, [0.998, 0.94, 0.649]], [0.552, [0.998, 0.936, 0.641]], [0.554, [0.998, 0.936, 0.641]], [0.556, [0.998, 0.931, 0.633]], [0.558, [0.998, 0.931, 0.633]], [0.56, [0.998, 0.926, 0.625]], [0.562, [0.998, 0.926, 0.625]], [0.564, [0.997, 0.921, 0.617]], [0.566, [0.997, 0.921, 0.617]], [0.568, [0.997, 0.917, 0.609]], [0.569, [0.997, 0.917, 0.609]], [0.571, [0.997, 0.912, 0.601]], [0.573, [0.997, 0.912, 0.601]], [0.575, [0.997, 0.907, 0.593]], [0.577, [0.997, 0.907, 0.593]], [0.579, [0.997, 0.902, 0.585]], [0.581, [0.997, 0.902, 0.585]], [0.583, [0.997, 0.898, 0.577]], [0.585, [0.997, 0.898, 0.577]], [0.587, [0.997, 0.893, 0.569]], [0.589, [0.997, 0.893, 0.569]], [0.591, [0.996, 0.888, 0.561]], [0.593, [0.996, 0.888, 0.561]], [0.595, [0.996, 0.883, 0.553]], [0.597, [0.996, 0.883, 0.553]], [0.599, [0.996, 0.878, 0.545]], [0.601, [0.996, 0.878, 0.545]], [0.603, [0.996, 0.871, 0.539]], [0.605, [0.996, 0.871, 0.539]], [0.607, [0.996, 0.863, 0.532]], [0.609, [0.996, 0.863, 0.532]], [0.611, [0.996, 0.855, 0.526]], [0.613, [0.996, 0.855, 0.526]], [0.614, [0.995, 0.848, 0.519]], [0.616, [0.995, 0.848, 0.519]], [0.618, [0.995, 0.84, 0.513]], [0.62, [0.995, 0.84, 0.513]], [0.622, [0.995, 0.832, 0.506]], [0.624, [0.995, 0.832, 0.506]], [0.626, [0.995, 0.825, 0.5]], [0.628, [0.995, 0.825, 0.5]], [0.63, [0.995, 0.817, 0.493]], [0.632, [0.995, 0.817, 0.493]], [0.634, [0.995, 0.809, 0.487]], [0.636, [0.995, 0.809, 0.487]], [0.638, [0.995, 0.802, 0.481]], [0.64, [0.995, 0.802, 0.481]], [0.642, [0.994, 0.794, 0.474]], [0.644, [0.994, 0.794, 0.474]], [0.646, [0.994, 0.786, 0.468]], [0.648, [0.994, 0.786, 0.468]], [0.65, [0.994, 0.778, 0.461]], [0.652, [0.994, 0.778, 0.461]], [0.654, [0.994, 0.771, 0.455]], [0.656, [0.994, 0.771, 0.455]], [0.658, [0.994, 0.763, 0.448]], [0.659, [0.994, 0.763, 0.448]], [0.661, [0.994, 0.755, 0.442]], [0.663, [0.994, 0.755, 0.442]], [0.665, [0.993, 0.748, 0.435]], [0.667, [0.993, 0.748, 0.435]], [0.669, [0.993, 0.74, 0.429]], [0.671, [0.993, 0.74, 0.429]], [0.673, [0.993, 0.732, 0.422]], [0.675, [0.993, 0.732, 0.422]], [0.677, [0.993, 0.725, 0.416]], [0.679, [0.993, 0.725, 0.416]], [0.681, [0.993, 0.717, 0.409]], [0.683, [0.993, 0.717, 0.409]], [0.685, [0.993, 0.709, 0.403]], [0.687, [0.993, 0.709, 0.403]], [0.689, [0.993, 0.702, 0.397]], [0.691, [0.993, 0.702, 0.397]], [0.693, [0.992, 0.694, 0.39]], [0.695, [0.992, 0.694, 0.39]], [0.697, [0.992, 0.686, 0.384]], [0.699, [0.992, 0.686, 0.384]], [0.701, [0.991, 0.677, 0.378]], [0.703, [0.991, 0.677, 0.378]], [0.705, [0.99, 0.667, 0.373]], [0.706, [0.99, 0.667, 0.373]], [0.708, [0.989, 0.657, 0.369]], [0.71, [0.989, 0.657, 0.369]], [0.712, [0.987, 0.647, 0.364]], [0.714, [0.987, 0.647, 0.364]], [0.716, [0.986, 0.637, 0.36]], [0.718, [0.986, 0.637, 0.36]], [0.72, [0.985, 0.627, 0.355]], [0.722, [0.985, 0.627, 0.355]], [0.724, [0.983, 0.617, 0.35]], [0.726, [0.983, 0.617, 0.35]], [0.728, [0.982, 0.607, 0.346]], [0.73, [0.982, 0.607, 0.346]], [0.732, [0.98, 0.597, 0.341]], [0.734, [0.98, 0.597, 0.341]], [0.736, [0.979, 0.587, 0.337]], [0.738, [0.979, 0.587, 0.337]], [0.74, [0.978, 0.577, 0.332]], [0.742, [0.978, 0.577, 0.332]], [0.744, [0.976, 0.567, 0.327]], [0.746, [0.976, 0.567, 0.327]], [0.748, [0.975, 0.557, 0.323]], [0.75, [0.975, 0.557, 0.323]], [0.751, [0.973, 0.547, 0.318]], [0.753, [0.973, 0.547, 0.318]], [0.755, [0.972, 0.537, 0.313]], [0.757, [0.972, 0.537, 0.313]], [0.759, [0.971, 0.527, 0.309]], [0.761, [0.971, 0.527, 0.309]], [0.763, [0.969, 0.517, 0.304]], [0.765, [0.969, 0.517, 0.304]], [0.767, [0.968, 0.507, 0.3]], [0.769, [0.968, 0.507, 0.3]], [0.771, [0.967, 0.497, 0.295]], [0.773, [0.967, 0.497, 0.295]], [0.775, [0.965, 0.487, 0.29]], [0.777, [0.965, 0.487, 0.29]], [0.779, [0.964, 0.477, 0.286]], [0.781, [0.964, 0.477, 0.286]], [0.783, [0.962, 0.467, 0.281]], [0.785, [0.962, 0.467, 0.281]], [0.787, [0.961, 0.457, 0.277]], [0.789, [0.961, 0.457, 0.277]], [0.791, [0.96, 0.447, 0.272]], [0.793, [0.96, 0.447, 0.272]], [0.795, [0.958, 0.437, 0.267]], [0.796, [0.958, 0.437, 0.267]], [0.798, [0.957, 0.427, 0.263]], [0.8, [0.957, 0.427, 0.263]], [0.802, [0.952, 0.418, 0.258]], [0.804, [0.952, 0.418, 0.258]], [0.806, [0.948, 0.409, 0.254]], [0.808, [0.948, 0.409, 0.254]], [0.81, [0.943, 0.399, 0.25]], [0.812, [0.943, 0.399, 0.25]], [0.814, [0.939, 0.39, 0.246]], [0.816, [0.939, 0.39, 0.246]], [0.818, [0.935, 0.381, 0.241]], [0.82, [0.935, 0.381, 0.241]], [0.822, [0.93, 0.371, 0.237]], [0.824, [0.93, 0.371, 0.237]], [0.826, [0.926, 0.362, 0.233]], [0.828, [0.926, 0.362, 0.233]], [0.83, [0.921, 0.352, 0.228]], [0.832, [0.921, 0.352, 0.228]], [0.834, [0.917, 0.343, 0.224]], [0.836, [0.917, 0.343, 0.224]], [0.838, [0.912, 0.334, 0.22]], [0.84, [0.912, 0.334, 0.22]], [0.841, [0.908, 0.324, 0.215]], [0.843, [0.908, 0.324, 0.215]], [0.845, [0.903, 0.315, 0.211]], [0.847, [0.903, 0.315, 0.211]], [0.849, [0.899, 0.305, 0.207]], [0.851, [0.899, 0.305, 0.207]], [0.853, [0.894, 0.296, 0.202]], [0.855, [0.894, 0.296, 0.202]], [0.857, [0.89, 0.287, 0.198]], [0.859, [0.89, 0.287, 0.198]], [0.861, [0.886, 0.277, 0.194]], [0.863, [0.886, 0.277, 0.194]], [0.865, [0.881, 0.268, 0.19]], [0.867, [0.881, 0.268, 0.19]], [0.869, [0.877, 0.259, 0.185]], [0.871, [0.877, 0.259, 0.185]], [0.873, [0.872, 0.249, 0.181]], [0.875, [0.872, 0.249, 0.181]], [0.877, [0.868, 0.24, 0.177]], [0.879, [0.868, 0.24, 0.177]], [0.881, [0.863, 0.23, 0.172]], [0.883, [0.863, 0.23, 0.172]], [0.885, [0.859, 0.221, 0.168]], [0.886, [0.859, 0.221, 0.168]], [0.888, [0.854, 0.212, 0.164]], [0.89, [0.854, 0.212, 0.164]], [0.892, [0.85, 0.202, 0.159]], [0.894, [0.85, 0.202, 0.159]], [0.896, [0.845, 0.193, 0.155]], [0.898, [0.845, 0.193, 0.155]], [0.9, [0.839, 0.185, 0.153]], [0.902, [0.839, 0.185, 0.153]], [0.904, [0.832, 0.177, 0.153]], [0.906, [0.832, 0.177, 0.153]], [0.908, [0.824, 0.17, 0.153]], [0.91, [0.824, 0.17, 0.153]], [0.912, [0.816, 0.162, 0.152]], [0.914, [0.816, 0.162, 0.152]], [0.916, [0.809, 0.155, 0.152]], [0.918, [0.809, 0.155, 0.152]], [0.92, [0.801, 0.148, 0.152]], [0.922, [0.801, 0.148, 0.152]], [0.924, [0.793, 0.14, 0.152]], [0.926, [0.793, 0.14, 0.152]], [0.928, [0.785, 0.133, 0.152]], [0.93, [0.785, 0.133, 0.152]], [0.932, [0.778, 0.125, 0.152]], [0.933, [0.778, 0.125, 0.152]], [0.935, [0.77, 0.118, 0.151]], [0.937, [0.77, 0.118, 0.151]], [0.939, [0.762, 0.111, 0.151]], [0.941, [0.762, 0.111, 0.151]], [0.943, [0.755, 0.103, 0.151]], [0.945, [0.755, 0.103, 0.151]], [0.947, [0.747, 0.096, 0.151]], [0.949, [0.747, 0.096, 0.151]], [0.951, [0.739, 0.089, 0.151]], [0.953, [0.739, 0.089, 0.151]], [0.955, [0.732, 0.081, 0.151]], [0.957, [0.732, 0.081, 0.151]], [0.959, [0.724, 0.074, 0.151]], [0.961, [0.724, 0.074, 0.151]], [0.963, [0.716, 0.066, 0.15]], [0.965, [0.716, 0.066, 0.15]], [0.967, [0.709, 0.059, 0.15]], [0.969, [0.709, 0.059, 0.15]], [0.971, [0.701, 0.052, 0.15]], [0.973, [0.701, 0.052, 0.15]], [0.975, [0.693, 0.044, 0.15]], [0.977, [0.693, 0.044, 0.15]], [0.978, [0.686, 0.037, 0.15]], [0.98, [0.686, 0.037, 0.15]], [0.982, [0.678, 0.03, 0.15]], [0.984, [0.678, 0.03, 0.15]], [0.986, [0.67, 0.022, 0.149]], [0.988, [0.67, 0.022, 0.149]], [0.99, [0.662, 0.015, 0.149]], [0.992, [0.662, 0.015, 0.149]], [0.994, [0.655, 0.007, 0.149]], [0.996, [0.655, 0.007, 0.149]], [0.998, [0.647, 0, 0.149]], [1, [0.647, 0, 0.149]]];

/***/ }),
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.metadata = undefined;

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var metadata = exports.metadata = deepFreeze(getState());

function deepFreeze(object) {
  // for any properties that reference an object, makes sure that object is
  // recursively frozen as well
  Object.keys(object).forEach(function (key) {
    var value = object[key];
    if (_lodash2.default.isObject(value)) {
      deepFreeze(value);
    }
  });

  return Object.freeze(object);
}

function getState() {
  var stateKey = '__KBN__';
  if (!(stateKey in window)) {
    var state = (0, _jquery2.default)('kbn-initial-state').attr('data');
    window[stateKey] = JSON.parse(state);
  }
  return window[stateKey];
}

/***/ }),
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */,
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1416);

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AppStateProvider = AppStateProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _modules = __webpack_require__(2);

var _state = __webpack_require__(436);

__webpack_require__(238);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @name AppState
 *
 * @extends State
 *
 * @description Inherits State, which inherits Events. This class seems to be
 * concerned with mapping "props" to PersistedState instances, and surfacing the
 * ability to destroy those mappings.
 */

var urlParam = '_a';

function AppStateProvider(Private, $rootScope, $location, $injector) {
  var State = Private(_state.StateProvider);
  var PersistedState = $injector.get('PersistedState');
  var persistedStates = void 0;
  var eventUnsubscribers = void 0;

  _lodash2.default.class(AppState).inherits(State);
  function AppState(defaults) {
    // Initialize persistedStates. This object maps "prop" names to
    // PersistedState instances. These are used to make properties "stateful".
    persistedStates = {};

    // Initialize eventUnsubscribers. These will be called in `destroy`, to
    // remove handlers for the 'change' and 'fetch_with_changes' events which
    // are dispatched via the rootScope.
    eventUnsubscribers = [];

    AppState.Super.call(this, urlParam, defaults);
    AppState.getAppState._set(this);
  }

  // if the url param is missing, write it back
  AppState.prototype._persistAcrossApps = false;

  AppState.prototype.destroy = function () {
    AppState.Super.prototype.destroy.call(this);
    AppState.getAppState._set(null);
    _lodash2.default.callEach(eventUnsubscribers);
  };

  /**
   * @returns PersistedState instance.
   */
  AppState.prototype.makeStateful = function (prop) {
    var _this = this;

    if (persistedStates[prop]) return persistedStates[prop];
    var self = this;

    // set up the ui state
    persistedStates[prop] = new PersistedState();

    // update the app state when the stateful instance changes
    var updateOnChange = function updateOnChange() {
      var replaceState = false; // TODO: debouncing logic
      self[prop] = persistedStates[prop].getChanges();
      // Save state to the URL.
      self.save(replaceState);
    };
    var handlerOnChange = function handlerOnChange(method) {
      return persistedStates[prop][method]('change', updateOnChange);
    };
    handlerOnChange('on');
    eventUnsubscribers.push(function () {
      return handlerOnChange('off');
    });

    // update the stateful object when the app state changes
    var persistOnChange = function persistOnChange(changes) {
      if (!changes) return;

      if (changes.indexOf(prop) !== -1) {
        persistedStates[prop].set(self[prop]);
      }
    };
    var handlePersist = function handlePersist(method) {
      return _this[method]('fetch_with_changes', persistOnChange);
    };
    handlePersist('on');
    eventUnsubscribers.push(function () {
      return handlePersist('off');
    });

    // if the thing we're making stateful has an appState value, write to persisted state
    if (self[prop]) persistedStates[prop].setSilent(self[prop]);

    return persistedStates[prop];
  };

  AppState.getAppState = function () {
    var currentAppState = void 0;

    function get() {
      return currentAppState;
    }

    // Checks to see if the appState might already exist, even if it hasn't been newed up
    get.previouslyStored = function () {
      var search = $location.search();
      return search[urlParam] ? true : false;
    };

    get._set = function (current) {
      currentAppState = current;
    };

    return get;
  }();

  return AppState;
}

_modules.uiModules.get('kibana/global_state').factory('AppState', function (Private) {
  return Private(AppStateProvider);
}).service('getAppState', function (Private) {
  return Private(AppStateProvider).getAppState;
});

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PersistedState = undefined;

var _persisted_state = __webpack_require__(698);

Object.defineProperty(exports, 'PersistedState', {
  enumerable: true,
  get: function get() {
    return _persisted_state.PersistedState;
  }
});

__webpack_require__(1425);

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _dev_tools = __webpack_require__(303);

_dev_tools.DevToolsRegistryProvider.register(function () {
  return {
    order: 1,
    name: 'console',
    display: 'Console',
    url: '#/dev_tools/console'
  };
});

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hideEmptyDevTools = hideEmptyDevTools;

var _modules = __webpack_require__(2);

var _chrome = __webpack_require__(17);

var _chrome2 = _interopRequireDefault(_chrome);

var _dev_tools = __webpack_require__(303);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function hideEmptyDevTools(Private) {
  var hasTools = !!Private(_dev_tools.DevToolsRegistryProvider).length;
  if (!hasTools) {
    var navLink = _chrome2.default.getNavLinkById('kibana:dev_tools');
    navLink.hidden = true;
  }
}

_modules.uiModules.get('kibana').run(hideEmptyDevTools);

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1494);

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _panel = __webpack_require__(1497);

var _panel2 = _interopRequireDefault(_panel);

var _panel_registry = __webpack_require__(171);

var _panel_registry2 = _interopRequireDefault(_panel_registry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_panel_registry2.default.register(function timeChartProvider(Private) {
  // Schema is broken out so that it may be extended for use in other plugins
  // Its also easier to test.
  return new _panel2.default('timechart', Private(__webpack_require__(1498))());
});

/***/ }),
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _shorten_dotted_string = __webpack_require__(467);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Shorts dot notated strings
// eg: foo.bar.baz becomes f.b.baz
// 'foo.bar.baz'.replace(/(.+?\.)/g,function(v) {return v[0]+'.';});

_modules.uiModules.get('kibana').filter('shortDots', function (Private) {
  return Private(shortDotsFilterProvider);
});

function shortDotsFilterProvider(config) {
  var filter = void 0;

  config.watch('shortDots:enable', updateFilter);

  return wrapper;

  function updateFilter(enabled) {
    filter = enabled ? _shorten_dotted_string.shortenDottedString : _lodash2.default.identity;
  }
  function wrapper(str) {
    return filter(str);
  }
}

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Queue of pending requests, requests are removed as
 * they are processed by fetch.[sourceType]().
 * @type {Array}
 */
var requestQueue = exports.requestQueue = [];

requestQueue.clear = function () {
  requestQueue.splice(0, requestQueue.length);
};

requestQueue.getInactive = function () {
  return requestQueue.filter(function (req) {
    return !req.started;
  });
};

requestQueue.getStartable = function () {
  return requestQueue.filter(function (req) {
    return req.canStart();
  });
};

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var RequestStatus = exports.RequestStatus = {
  ABORTED: 'aborted',
  DUPLICATE: 'duplicate',
  INCOMPLETE: 'incomplete'
};

/***/ }),
/* 252 */,
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(7);
__webpack_require__(16);
__webpack_require__(169);
__webpack_require__(2121);
__webpack_require__(2122);

__webpack_require__(2).get('kibana', ['ui.select', 'ngSanitize']);


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _module = _modules.uiModules.get('kibana');

_module.directive('uiSelectFocusOn', function ($timeout) {
  return {
    restrict: 'A',
    require: 'uiSelect',
    link: function link(scope, elem, attrs, uiSelect) {
      scope.$on(attrs.uiSelectFocusOn, function () {
        $timeout(function () {
          return uiSelect.activate();
        });
      });
    }
  };
});

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _sort_prefix_first = __webpack_require__(2124);

_modules.uiModules.get('kibana').filter('sortPrefixFirst', function () {
  return _sort_prefix_first.sortPrefixFirst;
});

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _filter_manager = __webpack_require__(2156);

Object.defineProperty(exports, 'FilterManagerProvider', {
  enumerable: true,
  get: function get() {
    return _filter_manager.FilterManagerProvider;
  }
});

/***/ }),
/* 257 */,
/* 258 */,
/* 259 */,
/* 260 */,
/* 261 */,
/* 262 */,
/* 263 */,
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dispatchRenderComplete = dispatchRenderComplete;
exports.dispatchRenderStart = dispatchRenderStart;

__webpack_require__(3037);

var dispatchCustomEvent = function dispatchCustomEvent(el, eventName) {
  // we're using the native events so that we aren't tied to the jQuery custom events,
  // otherwise we have to use jQuery(element).on(...) because jQuery's events sit on top
  // of the native events per https://github.com/jquery/jquery/issues/2476
  el.dispatchEvent(new CustomEvent(eventName, { bubbles: true }));
};

function dispatchRenderComplete(el) {
  dispatchCustomEvent(el, 'renderComplete');
}

function dispatchRenderStart(el) {
  dispatchCustomEvent(el, 'renderStart');
}

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var utils = {};

utils.textFromRequest = function (request) {
  var data = request.data;
  if (typeof data != "string") {
    data = data.join("\n");
  }
  return request.method + " " + request.url + "\n" + data;
};

utils.jsonToString = function (data, indent) {
  return JSON.stringify(data, null, indent ? 2 : 0);
};

utils.reformatData = function (data, indent) {
  var changed = false;
  var formatted_data = [];
  for (var i = 0; i < data.length; i++) {
    var cur_doc = data[i];
    try {
      var new_doc = utils.jsonToString(JSON.parse(utils.collapseLiteralStrings(cur_doc)), indent ? 2 : 0);
      if (indent) {
        new_doc = utils.expandLiteralStrings(new_doc);
      }
      changed = changed || new_doc != cur_doc;
      formatted_data.push(new_doc);
    } catch (e) {
      console.log(e);
      formatted_data.push(cur_doc);
    }
  }

  return {
    changed: changed,
    data: formatted_data
  };
};

utils.collapseLiteralStrings = function (data) {
  return data.replace(/"""(?:\s*\r?\n)?((?:.|\r?\n)*?)(?:\r?\n\s*)?"""/g, function (match, literal) {
    return JSON.stringify(literal);
  });
};

utils.expandLiteralStrings = function (data) {
  return data.replace(/("(?:\\"|[^"])*?")/g, function (match, string) {
    // expand things with two slashes or more
    if (string.split(/\\./).length > 2) {
      string = JSON.parse(string).replace("^\s*\n", "").replace("\n\s*^", "");
      var append = string.includes("\n") ? "\n" : ""; // only go multi line if the string has multiline
      return '"""' + append + string + append + '"""';
    } else {
      return string;
    }
  });
};

utils.extractDeprecationMessages = function (warnings) {
  // pattern for valid warning header
  var re = /\d{3} [0-9a-zA-Z!#$%&'*+-.^_`|~]+ \"((?:\t| |!|[\x23-\x5b]|[\x5d-\x7e]|[\x80-\xff]|\\\\|\\")*)\"(?: \"[^"]*\")/;
  // split on any comma that is followed by an even number of quotes
  return _lodash2.default.map(utils.splitOnUnquotedCommaSpace(warnings), function (warning) {
    var match = re.exec(warning);
    // extract the actual warning if there was a match
    return "#! Deprecation: " + (match !== null ? utils.unescape(match[1]) : warning);
  });
};

utils.unescape = function (s) {
  return s.replace(/\\\\/g, "\\").replace(/\\"/g, "\"");
};

utils.splitOnUnquotedCommaSpace = function (s) {
  var quoted = false;
  var arr = [];
  var buffer = '';
  var i = 0;
  while (i < s.length) {
    var token = s.charAt(i++);
    if (token == '\\' && i < s.length) {
      token += s.charAt(i++);
    } else if (token == ',' && i < s.length && s.charAt(i) == ' ') {
      token += s.charAt(i++);
    }
    if (token == '"') {
      quoted = !quoted;
    } else if (!quoted && token == ', ') {
      arr.push(buffer);
      buffer = '';
      continue;
    }
    buffer += token;
  }
  arr.push(buffer);
  return arr;
};

exports.default = utils;
module.exports = exports["default"];

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var $ = __webpack_require__(7);
var _ = __webpack_require__(1);
var es = __webpack_require__(361);
var settings = __webpack_require__(267);

var per_index_types = {};
var per_alias_indexes = [];

var mappingObj = {};

function expandAliases(indicesOrAliases) {
  // takes a list of indices or aliases or a string which may be either and returns a list of indices
  // returns a list for multiple values or a string for a single.

  if (!indicesOrAliases) {
    return indicesOrAliases;
  }

  if (typeof indicesOrAliases === "string") {
    indicesOrAliases = [indicesOrAliases];
  }
  indicesOrAliases = $.map(indicesOrAliases, function (iOrA) {
    if (per_alias_indexes[iOrA]) {
      return per_alias_indexes[iOrA];
    }
    return [iOrA];
  });
  var ret = [].concat.apply([], indicesOrAliases);
  ret.sort();
  var last;
  ret = $.map(ret, function (v) {
    var r = last == v ? null : v;
    last = v;
    return r;
  });
  return ret.length > 1 ? ret : ret[0];
}

function getFields(indices, types) {
  // get fields for indices and types. Both can be a list, a string or null (meaning all).
  var ret = [];
  indices = expandAliases(indices);
  if (typeof indices == "string") {

    var type_dict = per_index_types[indices];
    if (!type_dict) {
      return [];
    }

    if (typeof types == "string") {
      var f = type_dict[types];
      ret = f ? f : [];
    } else {
      // filter what we need
      $.each(type_dict, function (type, fields) {
        if (!types || types.length == 0 || $.inArray(type, types) != -1) {
          ret.push(fields);
        }
      });

      ret = [].concat.apply([], ret);
    }
  } else {
    // multi index mode.
    $.each(per_index_types, function (index) {
      if (!indices || indices.length == 0 || $.inArray(index, indices) != -1) {
        ret.push(getFields(index, types));
      }
    });
    ret = [].concat.apply([], ret);
  }

  return _.uniq(ret, function (f) {
    return f.name + ":" + f.type;
  });
}

function getTypes(indices) {
  var ret = [];
  indices = expandAliases(indices);
  if (typeof indices == "string") {
    var type_dict = per_index_types[indices];
    if (!type_dict) {
      return [];
    }

    // filter what we need
    $.each(type_dict, function (type) {
      ret.push(type);
    });
  } else {
    // multi index mode.
    $.each(per_index_types, function (index) {
      if (!indices || $.inArray(index, indices) != -1) {
        ret.push(getTypes(index));
      }
    });
    ret = [].concat.apply([], ret);
  }

  return _.uniq(ret);
}

function getIndices(include_aliases) {
  var ret = [];
  $.each(per_index_types, function (index) {
    ret.push(index);
  });
  if (typeof include_aliases === "undefined" ? true : include_aliases) {
    $.each(per_alias_indexes, function (alias) {
      ret.push(alias);
    });
  }
  return ret;
}

function getFieldNamesFromFieldMapping(field_name, field_mapping) {
  if (field_mapping['enabled'] == false) {
    return [];
  }
  var nested_fields;

  function applyPathSettings(nested_field_names) {
    var path_type = field_mapping['path'] || "full";
    if (path_type == "full") {
      return $.map(nested_field_names, function (f) {
        f.name = field_name + "." + f.name;
        return f;
      });
    }
    return nested_field_names;
  }

  if (field_mapping["properties"]) {
    // derived object type
    nested_fields = getFieldNamesFromTypeMapping(field_mapping);
    return applyPathSettings(nested_fields);
  }

  var field_type = field_mapping['type'];

  if (field_type === 'multi_field') {
    nested_fields = $.map(field_mapping['fields'], function (field_mapping, field_name) {
      return getFieldNamesFromFieldMapping(field_name, field_mapping);
    });

    return applyPathSettings(nested_fields);
  }

  var ret = { name: field_name, type: field_type };

  if (field_mapping["index_name"]) {
    ret.name = field_mapping["index_name"];
  }

  if (field_mapping["fields"]) {
    nested_fields = $.map(field_mapping['fields'], function (field_mapping, field_name) {
      return getFieldNamesFromFieldMapping(field_name, field_mapping);
    });
    nested_fields = applyPathSettings(nested_fields);
    nested_fields.unshift(ret);
    return nested_fields;
  }

  return [ret];
}

function getFieldNamesFromTypeMapping(type_mapping) {
  var field_list = $.map(type_mapping['properties'] || {}, function (field_mapping, field_name) {
    return getFieldNamesFromFieldMapping(field_name, field_mapping);
  });

  // deduping
  return _.uniq(field_list, function (f) {
    return f.name + ":" + f.type;
  });
}

function loadMappings(mappings) {
  per_index_types = {};
  $.each(mappings, function (index, index_mapping) {
    var normalized_index_mappings = {};
    // 1.0.0 mapping format has changed, extract underlying mapping
    if (index_mapping.mappings && _.keys(index_mapping).length === 1) {
      index_mapping = index_mapping.mappings;
    }
    $.each(index_mapping, function (type_name, type_mapping) {
      var field_list = getFieldNamesFromTypeMapping(type_mapping);
      normalized_index_mappings[type_name] = field_list;
    });
    per_index_types[index] = normalized_index_mappings;
  });
}

function loadAliases(aliases) {
  per_alias_indexes = {};
  $.each(aliases || {}, function (index, index_aliases) {
    // verify we have an index defined. usefull when mapping loading is disabled
    per_index_types[index] = per_index_types[index] || {};

    $.each(index_aliases.aliases || {}, function (alias) {
      if (alias === index) {
        return;
      } // alias which is identical to index means no index.
      var cur_aliases = per_alias_indexes[alias];
      if (!cur_aliases) {
        cur_aliases = [];
        per_alias_indexes[alias] = cur_aliases;
      }
      cur_aliases.push(index);
    });
  });

  per_alias_indexes['_all'] = getIndices(false);
}

function clear() {
  per_index_types = {};
  per_alias_indexes = {};
}

function retrieveAutocompleteInfoFromServer() {
  var autocompleteSettings = settings.getAutocomplete(),
      mappingPromise,
      aliasesPromise;
  if (autocompleteSettings.fields) {
    mappingPromise = es.send("GET", "_mapping", null, null, true);
  } else {
    mappingPromise = new $.Deferred();
    mappingPromise.resolve();
  }
  if (autocompleteSettings.indices) {
    aliasesPromise = es.send("GET", "_aliases", null, null, true);
  } else {
    aliasesPromise = new $.Deferred();
    aliasesPromise.resolve();
  }

  $.when(mappingPromise, aliasesPromise).done(function (mappings, aliases) {
    if (!mappings) {
      mappings = {};
    } else if (mappings[0].length < 10 * 1024 * 1024) {
      mappings = JSON.parse(mappings[0]);
    } else {
      console.warn("mapping size is larger than 10MB (" + mappings[0].length / 1024 / 1024 + " MB). ignoring..");
      mappings = {};
    }
    loadMappings(mappings);
    if (aliases) {
      loadAliases(JSON.parse(aliases[0]));
    } else {
      aliases = [{}];
      loadAliases({});
    }
    // Trigger an update event with the mappings and aliases
    $(mappingObj).trigger('update', [mappings[0], aliases[0]]);
  });
}

function autocomplete_retriever() {
  retrieveAutocompleteInfoFromServer();
  setTimeout(function () {
    autocomplete_retriever();
  }, 60000);
}

exports.default = _.assign(mappingObj, {
  getFields: getFields,
  getIndices: getIndices,
  getTypes: getTypes,
  loadMappings: loadMappings,
  loadAliases: loadAliases,
  expandAliases: expandAliases,
  clear: clear,
  startRetrievingAutoCompleteInfo: autocomplete_retriever
});
module.exports = exports['default'];

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAutocomplete = getAutocomplete;
exports.applyCurrentSettings = applyCurrentSettings;
exports.getCurrentSettings = getCurrentSettings;
exports.updateSettings = updateSettings;

var _input = __webpack_require__(268);

var _input2 = _interopRequireDefault(_input);

var _output = __webpack_require__(544);

var _output2 = _interopRequireDefault(_output);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var storage = __webpack_require__(269);

function getFontSize() {
  return storage.get('font_size', 14);
}

function setFontSize(size) {
  storage.set('font_size', size);
  applyCurrentSettings();
  return true;
}

function getWrapMode() {
  return storage.get('wrap_mode', true);
}

function setWrapMode(mode) {
  storage.set('wrap_mode', mode);
  applyCurrentSettings();
  return true;
}

function getAutocomplete() {
  return storage.get('autocomplete_settings', { fields: true, indices: true });
}

function setAutocomplete(settings) {
  storage.set('autocomplete_settings', settings);
  return true;
}

function applyCurrentSettings(editor) {
  if (typeof editor === 'undefined') {
    applyCurrentSettings((0, _input2.default)());
    applyCurrentSettings((0, _output2.default)());
  }
  if (editor) {
    editor.getSession().setUseWrapMode(getWrapMode());
    editor.$el.css('font-size', getFontSize() + 'px');
  }
}

function getCurrentSettings() {
  return {
    autocomplete: getAutocomplete(),
    wrapMode: getWrapMode(),
    fontSize: parseFloat(getFontSize())
  };
}

function updateSettings(_ref) {
  var fontSize = _ref.fontSize,
      wrapMode = _ref.wrapMode,
      autocomplete = _ref.autocomplete;

  setFontSize(fontSize);
  setWrapMode(wrapMode);
  setAutocomplete(autocomplete);
  (0, _input2.default)().focus();
  return getCurrentSettings();
}

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initializeInput = initializeInput;
exports.default = getInput;

var _modules = __webpack_require__(2);

var $ = __webpack_require__(7);
__webpack_require__(51);
__webpack_require__(3158);
var Autocomplete = __webpack_require__(3159);
var SenseEditor = __webpack_require__(542);
var settings = __webpack_require__(267);
var utils = __webpack_require__(265);
var es = __webpack_require__(361);
var history = __webpack_require__(543);


var input = void 0;
function initializeInput($el, $actionsEl, $copyAsCurlEl, output) {
  input = new SenseEditor($el);

  // this may not exist if running from tests
  var appSense = _modules.uiModules.get('app/sense');
  appSense.setupResizeCheckerForRootEditors($el, input, output);

  input.autocomplete = new Autocomplete(input);

  input.$actions = $actionsEl;

  input.commands.addCommand({
    name: 'auto indent request',
    bindKey: { win: 'Ctrl-I', mac: 'Command-I' },
    exec: function exec() {
      input.autoIndent();
    }
  });
  input.commands.addCommand({
    name: 'move to previous request start or end',
    bindKey: { win: 'Ctrl-Up', mac: 'Command-Up' },
    exec: function exec() {
      input.moveToPreviousRequestEdge();
    }
  });
  input.commands.addCommand({
    name: 'move to next request start or end',
    bindKey: { win: 'Ctrl-Down', mac: 'Command-Down' },
    exec: function exec() {
      input.moveToNextRequestEdge();
    }
  });

  /**
   * COPY AS CURL
   */
  (function setupClipboard() {
    function copyText(text) {
      var node = $('<textarea style="height:1px"></textarea').val(text).appendTo(document.body).select();
      document.execCommand('copy');
      node.remove();
    }

    if (!document.queryCommandSupported('copy')) {
      $copyAsCurlEl.hide();
      return;
    }

    $copyAsCurlEl.click(function () {
      copyText($copyAsCurlEl.attr('data-clipboard-text'));
    });

    input.$actions.on('mouseenter', function () {
      if ($(this).hasClass('open')) return;
      input.getRequestsAsCURL(function (text) {
        $copyAsCurlEl.attr('data-clipboard-text', text);
      });
    });
  })();

  /**
   * Setup the "send" shortcut
   */

  var CURRENT_REQ_ID = 0;

  function sendCurrentRequestToES() {

    var req_id = ++CURRENT_REQ_ID;

    input.getRequestsInRange(function (requests) {
      if (req_id != CURRENT_REQ_ID) {
        return;
      }
      output.update('');

      if (requests.length == 0) {
        return;
      }

      var isMultiRequest = requests.length > 1;
      var finishChain = function finishChain() {/* noop */};

      var isFirstRequest = true;

      var sendNextRequest = function sendNextRequest() {
        if (req_id != CURRENT_REQ_ID) {
          return;
        }
        if (requests.length == 0) {
          finishChain();
          return;
        }
        var req = requests.shift();
        var es_path = req.url;
        var es_method = req.method;
        var es_data = utils.collapseLiteralStrings(req.data.join("\n"));
        if (es_data) {
          es_data += "\n";
        } //append a new line for bulk requests.

        es.send(es_method, es_path, es_data).always(function (dataOrjqXHR, textStatus, jqXhrORerrorThrown) {
          if (req_id != CURRENT_REQ_ID) {
            return;
          }
          var xhr;
          if (dataOrjqXHR.promise) {
            xhr = dataOrjqXHR;
          } else {
            xhr = jqXhrORerrorThrown;
          }
          function modeForContentType(contentType) {
            if (contentType.indexOf("text/plain") >= 0) {
              return "ace/mode/text";
            } else if (contentType.indexOf("application/yaml") >= 0) {
              return "ace/mode/yaml";
            }
            return null;
          }

          if (typeof xhr.status == "number" && (
          // things like DELETE index where the index is not there are OK.
          xhr.status >= 200 && xhr.status < 300 || xhr.status == 404)) {
            // we have someone on the other side. Add to history
            history.addToHistory(es_path, es_method, es_data);

            var value = xhr.responseText;
            var mode = modeForContentType(xhr.getAllResponseHeaders("Content-Type") || "");

            if (mode === null || mode === "application/json") {
              // assume json - auto pretty
              try {
                value = utils.expandLiteralStrings(JSON.stringify(JSON.parse(value), null, 2));
              } catch (e) {}
            }

            var warnings = xhr.getResponseHeader("warning");
            if (warnings) {
              var deprecationMessages = utils.extractDeprecationMessages(warnings);
              value = deprecationMessages.join("\n") + "\n" + value;
            }

            if (isMultiRequest) {
              value = "# " + req.method + " " + req.url + "\n" + value;
            }
            if (isFirstRequest) {
              output.update(value, mode);
            } else {
              output.append("\n" + value);
            }
            isFirstRequest = false;
            // single request terminate via sendNextRequest as well
            sendNextRequest();
          } else {
            var _value = void 0,
                _mode = void 0;
            if (xhr.responseText) {
              _value = xhr.responseText; // ES error should be shown
              _mode = modeForContentType(xhr.getAllResponseHeaders("Content-Type") || "");
              if (_value[0] == "{") {
                try {
                  _value = JSON.stringify(JSON.parse(_value), null, 2);
                } catch (e) {}
              }
            } else {
              _value = "Request failed to get to the server (status code: " + xhr.status + ")";
              _mode = 'ace/mode/text';
            }
            if (isMultiRequest) {
              _value = "# " + req.method + " " + req.url + "\n" + _value;
            }
            if (isFirstRequest) {
              output.update(_value, _mode);
            } else {
              output.append("\n" + _value);
            }
            finishChain();
          }
        });
      };

      sendNextRequest();
    });
  }

  input.commands.addCommand({
    name: 'send to elasticsearch',
    bindKey: { win: 'Ctrl-Enter', mac: 'Command-Enter' },
    exec: sendCurrentRequestToES
  });

  /**
   * Init the editor
   */
  if (settings) {
    settings.applyCurrentSettings(input);
  }
  input.focus();
  input.highlightCurrentRequestsAndUpdateActionBar();

  input.sendCurrentRequestToES = sendCurrentRequestToES;
  __webpack_require__(3165)(input, output);

  return input;
}

function getInput() {
  return input;
}

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = __webpack_require__(1),
    transform = _require.transform,
    _keys = _require.keys,
    startsWith = _require.startsWith;

var Storage = function () {
  function Storage(engine, prefix) {
    _classCallCheck(this, Storage);

    this.engine = engine;
    this.prefix = prefix;
  }

  _createClass(Storage, [{
    key: 'encode',
    value: function encode(val) {
      return JSON.stringify(val);
    }
  }, {
    key: 'decode',
    value: function decode(val) {
      if (typeof val === 'string') {
        return JSON.parse(val);
      }
    }
  }, {
    key: 'encodeKey',
    value: function encodeKey(key) {
      return '' + this.prefix + key;
    }
  }, {
    key: 'decodeKey',
    value: function decodeKey(key) {
      if (startsWith(key, this.prefix)) {
        return '' + key.slice(this.prefix.length);
      }
    }
  }, {
    key: 'set',
    value: function set(key, val) {
      this.engine.setItem(this.encodeKey(key), this.encode(val));
      return val;
    }
  }, {
    key: 'has',
    value: function has(key) {
      return this.engine.getItem(this.encodeKey(key)) != null;
    }
  }, {
    key: 'get',
    value: function get(key, _default) {
      if (this.has(key)) {
        return this.decode(this.engine.getItem(this.encodeKey(key)));
      } else {
        return _default;
      }
    }
  }, {
    key: 'delete',
    value: function _delete(key) {
      return this.engine.removeItem(this.encodeKey(key));
    }
  }, {
    key: 'keys',
    value: function keys() {
      var _this = this;

      return transform(_keys(this.engine), function (ours, key) {
        var ourKey = _this.decodeKey(key);
        if (ourKey != null) ours.push(ourKey);
      });
    }
  }]);

  return Storage;
}();

var instance = new Storage(localStorage, 'sense:');

exports.default = instance;
module.exports = exports['default'];

/***/ }),
/* 270 */,
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */,
/* 276 */,
/* 277 */,
/* 278 */,
/* 279 */,
/* 280 */,
/* 281 */,
/* 282 */,
/* 283 */,
/* 284 */,
/* 285 */,
/* 286 */,
/* 287 */,
/* 288 */,
/* 289 */,
/* 290 */,
/* 291 */,
/* 292 */,
/* 293 */,
/* 294 */,
/* 295 */,
/* 296 */,
/* 297 */,
/* 298 */,
/* 299 */,
/* 300 */,
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1336);

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var theme = __webpack_require__(704);

// Kibana UI Framework
__webpack_require__(1469);

// Elastic UI Framework, light theme
var euiThemeLight = __webpack_require__(1470);
theme.registerTheme('light', euiThemeLight);

// Elastic UI Framework, dark theme
var euiThemeDark = __webpack_require__(1471);
theme.registerTheme('dark', euiThemeDark);

// Set default theme.
theme.applyTheme('light');

// All Kibana styles inside of the /styles dir
var context = __webpack_require__(1472);
context.keys().forEach(function (key) {
  return context(key);
});

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DevToolsRegistryProvider = undefined;

var _registry = __webpack_require__(63);

var DevToolsRegistryProvider = exports.DevToolsRegistryProvider = (0, _registry.uiRegistry)({
  name: 'devTools',
  index: ['name'],
  order: ['order']
});

/***/ }),
/* 304 */,
/* 305 */,
/* 306 */,
/* 307 */,
/* 308 */,
/* 309 */,
/* 310 */,
/* 311 */,
/* 312 */,
/* 313 */,
/* 314 */,
/* 315 */,
/* 316 */,
/* 317 */,
/* 318 */,
/* 319 */,
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index_patterns = __webpack_require__(2026);

Object.defineProperty(exports, 'IndexPatternsProvider', {
  enumerable: true,
  get: function get() {
    return _index_patterns.IndexPatternsProvider;
  }
});

var _index_patterns_api_client_provider = __webpack_require__(762);

Object.defineProperty(exports, 'IndexPatternsApiClientProvider', {
  enumerable: true,
  get: function get() {
    return _index_patterns_api_client_provider.IndexPatternsApiClientProvider;
  }
});

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FieldFormat = FieldFormat;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _content_types = __webpack_require__(2028);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function FieldFormat(params) {
  // give the constructor a more appropriate name
  this.type = this.constructor;

  // keep the params and defaults seperate
  this._params = params || {};

  // one content type, so assume text
  if (_lodash2.default.isFunction(this._convert)) {
    this._convert = { text: this._convert };
  }

  (0, _content_types.contentTypesSetup)(this);
}

FieldFormat.from = function (converter) {
  _lodash2.default.class(FieldFormatFromConverter).inherits(FieldFormat);
  function FieldFormatFromConverter(params) {
    FieldFormatFromConverter.Super.call(this, params);
  }
  FieldFormatFromConverter.prototype._convert = converter;
  return FieldFormatFromConverter;
};

/**
 * Convert a raw value to a formated string
 * @param  {any} value
 * @param  {string} [contentType=text] - optional content type, the only two contentTypes
 *                                currently supported are "html" and "text", which helps
 *                                formatters adjust to different contexts
 * @return {string} - the formatted string, which is assumed to be html, safe for
 *                    injecting into the DOM or a DOM attribute
 */
FieldFormat.prototype.convert = function (value, contentType) {
  return this.getConverterFor(contentType)(value);
};

/**
 * Get a convert function that is bound to a specific contentType
 * @param  {string} [contentType=text]
 * @return {function} - a bound converter function
 */
FieldFormat.prototype.getConverterFor = function (contentType) {
  return this._convert[contentType || 'text'];
};

/**
 * Get parameter defaults
 * @return {object} - parameter defaults
 */
FieldFormat.prototype.getParamDefaults = function () {
  return {};
};

/**
 * Get the value of a param. This value may be a default value.
 *
 * @param  {string} name - the param name to fetch
 * @return {any}
 */
FieldFormat.prototype.param = function (name) {
  var val = this._params[name];
  if (val || val === false || val === 0) {
    // truthy, false, or 0 are fine
    // '', NaN, null, undefined, etc are not
    return val;
  }

  return this.getParamDefaults()[name];
};

/**
 * Get all of the params in a single object
 * @return {object}
 */
FieldFormat.prototype.params = function () {
  return _lodash2.default.cloneDeep(_lodash2.default.defaults({}, this._params, this.getParamDefaults()));
};

/**
 * serialize this format to a simple POJO, with only the params
 * that are not default
 *
 * @return {object}
 */
FieldFormat.prototype.toJSON = function () {
  var type = this.type;
  var defaults = this.getParamDefaults();

  var params = _lodash2.default.transform(this._params, function (uniqParams, val, param) {
    if (val !== defaults[param]) {
      uniqParams[param] = val;
    }
  }, {});

  if (!_lodash2.default.size(params)) {
    params = undefined;
  }

  return {
    id: type.id,
    params: params
  };
};

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.asPrettyString = asPrettyString;
/**
 * Convert a value to a presentable string
 * @param  {any} val - the value to transform
 * @return {string}
 */
function asPrettyString(val) {
  if (val === null || val === undefined) return ' - ';
  switch (typeof val === 'undefined' ? 'undefined' : _typeof(val)) {
    case 'string':
      return val;
    case 'object':
      return JSON.stringify(val, null, '  ');
    default:
      return '' + val;
  }
}

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ast = __webpack_require__(136);

Object.keys(_ast).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _ast[key];
    }
  });
});

var _filter_migration = __webpack_require__(2087);

Object.keys(_filter_migration).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _filter_migration[key];
    }
  });
});

var _node_types = __webpack_require__(52);

Object.keys(_node_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _node_types[key];
    }
  });
});

/***/ }),
/* 324 */,
/* 325 */,
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrateLegacyQuery = migrateLegacyQuery;

var _lodash = __webpack_require__(1);

/**
 * Creates a standardized query object from old queries that were either strings or pure ES query DSL
 *
 * @param query - a legacy query, what used to be stored in SearchSource's query property
 * @return Object
 */
function migrateLegacyQuery(query) {

  // Lucene was the only option before, so language-less queries are all lucene
  if (!(0, _lodash.has)(query, 'language')) {
    return { query: query, language: 'lucene' };
  }

  return query;
}

/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FilterBarLibMapAndFlattenFiltersProvider = FilterBarLibMapAndFlattenFiltersProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _map_filter = __webpack_require__(2141);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function FilterBarLibMapAndFlattenFiltersProvider(Private, Promise) {
  var mapFilter = Private(_map_filter.FilterBarLibMapFilterProvider);
  return function (filters) {
    return (0, _lodash2.default)(filters).flatten().compact().map(mapFilter).thru(Promise.all).value();
  };
}

/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compareFilters = compareFilters;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var excludedAttributes = void 0;
var comparators = void 0;

/**
 * Compare two filters to see if they match
 * @param {object} first The first filter to compare
 * @param {object} second The second filter to compare
 * @param {object} comparatorOptions Parameters to use for comparison
 * @returns {bool} Filters are the same
 */
function compareFilters(first, second, comparatorOptions) {
  excludedAttributes = ['$$hashKey', 'meta'];
  comparators = _lodash2.default.defaults(comparatorOptions || {}, {
    state: false,
    negate: false,
    disabled: false
  });

  if (!comparators.state) excludedAttributes.push('$state');

  return _lodash2.default.isEqual(mapFilter(first), mapFilter(second));
}

function mapFilter(filter) {
  var cleaned = _lodash2.default.omit(filter, excludedAttributes);
  if (comparators.negate) cleaned.negate = filter.meta && !!filter.meta.negate;
  if (comparators.disabled) cleaned.disabled = filter.meta && !!filter.meta.disabled;
  return cleaned;
}

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var ENTER = exports.ENTER = 13;
var SPACE = exports.SPACE = 32;
var ESCAPE = exports.ESCAPE = 27;
var TAB = exports.TAB = 9;

// Arrow keys
var DOWN = exports.DOWN = 40;
var UP = exports.UP = 38;
var LEFT = exports.LEFT = 37;
var RIGHT = exports.RIGHT = 39;

/***/ }),
/* 330 */,
/* 331 */,
/* 332 */,
/* 333 */,
/* 334 */,
/* 335 */,
/* 336 */,
/* 337 */,
/* 338 */,
/* 339 */,
/* 340 */,
/* 341 */,
/* 342 */,
/* 343 */,
/* 344 */,
/* 345 */,
/* 346 */,
/* 347 */,
/* 348 */,
/* 349 */,
/* 350 */,
/* 351 */,
/* 352 */,
/* 353 */,
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FilterBarClickHandlerProvider = FilterBarClickHandlerProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _dedup_filters = __webpack_require__(791);

var _uniq_filters = __webpack_require__(790);

var _find_by_param = __webpack_require__(2920);

var _add_filters_to_kuery = __webpack_require__(2921);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function FilterBarClickHandlerProvider(Notifier, Private) {
  var addFiltersToKuery = Private(_add_filters_to_kuery.AddFiltersToKueryProvider);

  return function ($state) {
    return function (event, simulate) {
      if (!$state) return;

      var notify = new Notifier({
        location: 'Filter bar'
      });
      var aggConfigResult = void 0;

      // Hierarchical and tabular data set their aggConfigResult parameter
      // differently because of how the point is rewritten between the two. So
      // we need to check if the point.orig is set, if not use try the point.aggConfigResult
      if (event.point.orig) {
        aggConfigResult = event.point.orig.aggConfigResult;
      } else if (event.point.values) {
        aggConfigResult = (0, _find_by_param.findByParam)(event.point.values, 'aggConfigResult');
      } else {
        aggConfigResult = event.point.aggConfigResult;
      }

      if (aggConfigResult) {
        var isLegendLabel = !!event.point.values;
        var aggBuckets = _lodash2.default.filter(aggConfigResult.getPath(), { type: 'bucket' });

        // For legend clicks, use the last bucket in the path
        if (isLegendLabel) {
          // series data has multiple values, use aggConfig on the first
          // hierarchical data values is an object with the addConfig
          var aggConfig = (0, _find_by_param.findByParam)(event.point.values, 'aggConfig');
          aggBuckets = aggBuckets.filter(function (result) {
            return result.aggConfig && result.aggConfig === aggConfig;
          });
        }

        var filters = (0, _lodash2.default)(aggBuckets).map(function (result) {
          try {
            return result.createFilter();
          } catch (e) {
            if (!simulate) {
              notify.warning(e.message);
            }
          }
        }).flatten().filter(Boolean).value();

        if (!filters.length) return;

        if (event.negate) {
          _lodash2.default.each(filters, function (filter) {
            filter.meta = filter.meta || {};
            filter.meta.negate = true;
          });
        }

        filters = (0, _dedup_filters.dedupFilters)($state.filters, (0, _uniq_filters.uniqFilters)(filters), { negate: true });

        if (!simulate) {
          if (['lucene', 'kql'].includes($state.query.language)) {
            $state.$newFilters = filters;
          } else if ($state.query.language === 'kuery') {
            addFiltersToKuery($state, filters).then(function () {
              if (_lodash2.default.isFunction($state.save)) {
                $state.save();
              }
            });
          }
        }
        return filters;
      }
    };
  };
}

/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SavedObjectLoader = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _scanner = __webpack_require__(2944);

var _string_utils = __webpack_require__(2945);

var _saved_objects = __webpack_require__(76);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SavedObjectLoader = exports.SavedObjectLoader = function () {
  function SavedObjectLoader(SavedObjectClass, kbnIndex, kbnUrl, $http, chrome) {
    _classCallCheck(this, SavedObjectLoader);

    this.type = SavedObjectClass.type;
    this.Class = SavedObjectClass;
    this.lowercaseType = this.type.toLowerCase();
    this.kbnIndex = kbnIndex;
    this.kbnUrl = kbnUrl;
    this.chrome = chrome;

    this.scanner = new _scanner.Scanner($http, {
      index: kbnIndex,
      type: this.lowercaseType
    });

    this.loaderProperties = {
      name: this.lowercaseType + 's',
      noun: _string_utils.StringUtils.upperFirst(this.type),
      nouns: this.lowercaseType + 's'
    };

    this.savedObjectsClient = new _saved_objects.SavedObjectsClient({
      $http: $http
    });
  }

  /**
   * Retrieve a saved object by id. Returns a promise that completes when the object finishes
   * initializing.
   * @param id
   * @returns {Promise<SavedObject>}
   */


  _createClass(SavedObjectLoader, [{
    key: 'get',
    value: function get(id) {
      return new this.Class(id).init();
    }
  }, {
    key: 'urlFor',
    value: function urlFor(id) {
      return this.kbnUrl.eval('#/' + this.lowercaseType + '/{{id}}', { id: id });
    }
  }, {
    key: 'delete',
    value: function _delete(ids) {
      var _this = this;

      ids = !Array.isArray(ids) ? [ids] : ids;

      var deletions = ids.map(function (id) {
        var savedObject = new _this.Class(id);
        return savedObject.delete();
      });

      return Promise.all(deletions).then(function () {
        if (_this.chrome) {
          _this.chrome.untrackNavLinksForDeletedSavedObjects(ids);
        }
      });
    }

    /**
     * Updates source to contain an id and url field, and returns the updated
     * source object.
     * @param source
     * @param id
     * @returns {source} The modified source object, with an id and url field.
     */

  }, {
    key: 'mapHitSource',
    value: function mapHitSource(source, id) {
      source.id = id;
      source.url = this.urlFor(id);
      return source;
    }
  }, {
    key: 'scanAll',
    value: function scanAll(queryString) {
      var pageSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;

      return this.scanner.scanAndMap(queryString, {
        pageSize: pageSize,
        docCount: Infinity
      });
    }

    /**
     * Updates hit.attributes to contain an id and url field, and returns the updated
     * attributes object.
     * @param hit
     * @returns {hit.attributes} The modified hit.attributes object, with an id and url field.
     */

  }, {
    key: 'mapSavedObjectApiHits',
    value: function mapSavedObjectApiHits(hit) {
      return this.mapHitSource(hit.attributes, hit.id);
    }

    /**
     * TODO: Rather than use a hardcoded limit, implement pagination. See
     * https://github.com/elastic/kibana/issues/8044 for reference.
     *
     * @param searchString
     * @param size
     * @returns {Promise}
     */

  }, {
    key: 'findAll',
    value: function findAll() {
      var _this2 = this;

      var search = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;

      return this.savedObjectsClient.find({
        type: this.lowercaseType,
        search: search ? search + '*' : undefined,
        perPage: size,
        page: 1,
        searchFields: ['title^3', 'description']
      }).then(function (resp) {
        return {
          total: resp.total,
          hits: resp.savedObjects.map(function (savedObject) {
            return _this2.mapSavedObjectApiHits(savedObject);
          })
        };
      });
    }
  }, {
    key: 'find',
    value: function find() {
      var search = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;

      return this.findAll(search, size).then(function (resp) {
        return {
          total: resp.total,
          hits: resp.hits.filter(function (savedObject) {
            return !savedObject.error;
          })
        };
      });
    }
  }]);

  return SavedObjectLoader;
}();

/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.VislibVisualizationsPointSeriesProvider = VislibVisualizationsPointSeriesProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function VislibVisualizationsPointSeriesProvider() {
  var PointSeries = function () {
    function PointSeries(handler, seriesEl, seriesData, seriesConfig) {
      _classCallCheck(this, PointSeries);

      this.handler = handler;
      this.baseChart = handler.pointSeries;
      this.chartEl = seriesEl;
      this.chartData = seriesData;
      this.seriesConfig = seriesConfig;
    }

    _createClass(PointSeries, [{
      key: 'getGroupedCount',
      value: function getGroupedCount() {
        var _this = this;

        var stacks = [];
        return this.baseChart.chartConfig.series.reduce(function (sum, series) {
          var valueAxis = series.valueAxis || _this.baseChart.handler.valueAxes[0].id;
          var isStacked = series.mode === 'stacked';
          var isHistogram = series.type === 'histogram';
          if (!isHistogram) return sum;
          if (isStacked && stacks.includes(valueAxis)) return sum;
          if (isStacked) stacks.push(valueAxis);
          return sum + 1;
        }, 0);
      }
    }, {
      key: 'getGroupedNum',
      value: function getGroupedNum(data) {
        var i = 0;
        var stacks = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.baseChart.chartConfig.series[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var seri = _step.value;

            var valueAxis = seri.valueAxis || this.baseChart.handler.valueAxes[0].id;
            var isStacked = seri.mode === 'stacked';
            if (!isStacked) {
              if (seri.data === data) return i;
              i++;
            } else {
              if (!(valueAxis in stacks)) stacks[valueAxis] = i++;
              if (seri.data === data) return stacks[valueAxis];
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return 0;
      }
    }, {
      key: 'getValueAxis',
      value: function getValueAxis() {
        var _this2 = this;

        return _lodash2.default.find(this.handler.valueAxes, function (axis) {
          return axis.axisConfig.get('id') === _this2.seriesConfig.valueAxis;
        }) || this.handler.valueAxes[0];
      }
    }, {
      key: 'getCategoryAxis',
      value: function getCategoryAxis() {
        var _this3 = this;

        return _lodash2.default.find(this.handler.categoryAxes, function (axis) {
          return axis.axisConfig.get('id') === _this3.seriesConfig.categoryAxis;
        }) || this.handler.categoryAxes[0];
      }
    }, {
      key: 'addCircleEvents',
      value: function addCircleEvents(element) {
        var events = this.events;
        if (this.handler.visConfig.get('enableHover')) {
          var hover = events.addHoverEvent();
          var mouseout = events.addMouseoutEvent();
          element.call(hover).call(mouseout);
        }
        var click = events.addClickEvent();
        return element.call(click);
      }
    }]);

    return PointSeries;
  }();

  return PointSeries;
}

/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var DefaultEditorSize = exports.DefaultEditorSize = {
  SMALL: 'small',
  MEDIUM: 'medium',
  LARGE: 'large'
};

/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(954);

var _vis_types = __webpack_require__(66);

var _modules = __webpack_require__(2);

var _saved_object_loader = __webpack_require__(355);

var _saved_object_registry = __webpack_require__(210);

var app = _modules.uiModules.get('app/visualize');

// Register this service with the saved object registry so it can be
// edited by the object editor.
_saved_object_registry.savedObjectManagementRegistry.register({
  service: 'savedVisualizations',
  title: 'visualizations'
});

app.service('savedVisualizations', function (Promise, kbnIndex, SavedVis, Private, kbnUrl, $http, chrome) {
  var visTypes = Private(_vis_types.VisTypesRegistryProvider);

  var saveVisualizationLoader = new _saved_object_loader.SavedObjectLoader(SavedVis, kbnIndex, kbnUrl, $http, chrome);

  saveVisualizationLoader.mapHitSource = function (source, id) {
    source.id = id;
    source.url = this.urlFor(id);

    var typeName = source.typeName;
    if (source.visState) {
      try {
        typeName = JSON.parse(source.visState).type;
      } catch (e) {} /* missing typename handled below */ // eslint-disable-line no-empty
    }

    if (!typeName || !visTypes.byName[typeName]) {
      source.error = 'Unknown visualization type';
      return source;
    }

    source.type = visTypes.byName[typeName];
    source.icon = source.type.icon;
    return source;
  };

  saveVisualizationLoader.urlFor = function (id) {
    return kbnUrl.eval('#/visualize/edit/{{id}}', { id: id });
  };
  return saveVisualizationLoader;
});

/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ParentPipelineAggHelperProvider = undefined;

var _sub_agg = __webpack_require__(3089);

var _sub_agg2 = _interopRequireDefault(_sub_agg);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _agg_config = __webpack_require__(105);

var _schemas = __webpack_require__(56);

var _parent_pipeline_agg_controller = __webpack_require__(3092);

var _parent_pipeline_agg_writter = __webpack_require__(3093);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ParentPipelineAggHelperProvider = exports.ParentPipelineAggHelperProvider = function ParentPipelineAggHelperProvider(Private) {

  var AggConfig = Private(_agg_config.VisAggConfigProvider);
  var Schemas = Private(_schemas.VisSchemasProvider);

  var metricAggFilter = ['!top_hits', '!percentiles', '!percentile_ranks', '!median', '!std_dev'];
  var metricAggSchema = new Schemas([{
    group: 'none',
    name: 'metricAgg',
    title: 'Metric Agg',
    hideCustomLabel: true,
    aggFilter: metricAggFilter
  }]).all[0];

  return {
    subtype: 'Parent Pipeline Aggregations',
    params: function params() {
      return [{
        name: 'customMetric',
        type: AggConfig,
        default: null,
        serialize: function serialize(customMetric) {
          return customMetric.toJSON();
        },
        deserialize: function deserialize(state, agg) {
          return this.makeAgg(agg, state);
        },
        makeAgg: function makeAgg(termsAgg, state) {
          state = state || { type: 'count' };
          state.schema = metricAggSchema;
          var metricAgg = new AggConfig(termsAgg.vis, state);
          metricAgg.id = termsAgg.id + '-metric';
          return metricAgg;
        },
        write: _lodash2.default.noop
      }, {
        name: 'buckets_path',
        write: _lodash2.default.noop
      }, {
        name: 'metricAgg',
        editor: _sub_agg2.default,
        default: 'custom',
        controller: _parent_pipeline_agg_controller.parentPipelineAggController,
        write: _parent_pipeline_agg_writter.parentPipelineAggWritter
      }];
    },
    getFormat: function getFormat(agg) {
      var subAgg = void 0;
      if (agg.params.customMetric) {
        subAgg = agg.params.customMetric;
      } else {
        subAgg = agg.vis.getAggConfig().byId[agg.params.metricAgg];
      }
      return subAgg.type.getFormat(subAgg);
    }
  };
};

/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SiblingPipelineAggHelperProvider = undefined;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _agg_config = __webpack_require__(105);

var _schemas = __webpack_require__(56);

var _sibling_pipeline_agg_controller = __webpack_require__(3132);

var _sibling_pipeline_agg_writter = __webpack_require__(3133);

var _sub_metric = __webpack_require__(3134);

var _sub_metric2 = _interopRequireDefault(_sub_metric);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SiblingPipelineAggHelperProvider = exports.SiblingPipelineAggHelperProvider = function SiblingPipelineAggHelperProvider(Private) {

  var AggConfig = Private(_agg_config.VisAggConfigProvider);
  var Schemas = Private(_schemas.VisSchemasProvider);

  var metricAggFilter = ['!top_hits', '!percentiles', '!percentile_ranks', '!median', '!std_dev', '!sum_bucket', '!avg_bucket', '!min_bucket', '!max_bucket', '!derivative', '!moving_avg', '!serial_diff', '!cumulative_sum'];

  var metricAggSchema = new Schemas([{
    group: 'none',
    name: 'metricAgg',
    title: 'Metric Agg',
    aggFilter: metricAggFilter
  }]).all[0];

  var bucketAggFilter = [];
  var bucketAggSchema = new Schemas([{
    group: 'none',
    title: 'Bucket Agg',
    name: 'bucketAgg',
    aggFilter: bucketAggFilter
  }]).all[0];

  return {
    subtype: 'Sibling Pipeline Aggregations',
    params: function params() {
      return [{
        name: 'customBucket',
        type: AggConfig,
        default: null,
        serialize: function serialize(customMetric) {
          return customMetric.toJSON();
        },
        deserialize: function deserialize(state, agg) {
          return this.makeAgg(agg, state);
        },
        makeAgg: function makeAgg(agg, state) {
          state = state || { type: 'date_histogram' };
          state.schema = bucketAggSchema;
          var orderAgg = new AggConfig(agg.vis, state);
          orderAgg.id = agg.id + '-bucket';
          return orderAgg;
        },
        editor: _sub_metric2.default,
        controller: (0, _sibling_pipeline_agg_controller.siblingPipelineAggController)('customBucket'),
        write: _lodash2.default.noop
      }, {
        name: 'customMetric',
        type: AggConfig,
        default: null,
        serialize: function serialize(customMetric) {
          return customMetric.toJSON();
        },
        deserialize: function deserialize(state, agg) {
          return this.makeAgg(agg, state);
        },
        makeAgg: function makeAgg(agg, state) {
          state = state || { type: 'count' };
          state.schema = metricAggSchema;
          var orderAgg = new AggConfig(agg.vis, state);
          orderAgg.id = agg.id + '-metric';
          return orderAgg;
        },
        editor: _sub_metric2.default,
        controller: (0, _sibling_pipeline_agg_controller.siblingPipelineAggController)('customMetric'),
        write: _sibling_pipeline_agg_writter.siblingPipelineAggWritter
      }];
    },
    getFormat: function getFormat(agg) {
      return agg.params.customMetric.type.getFormat(agg.params.customMetric);
    }
  };
};

/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getVersion = getVersion;
exports.getContentType = getContentType;
exports.send = send;
exports.constructESUrl = constructESUrl;

var _querystring = __webpack_require__(297);

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var esVersion = [];

function getVersion() {
  return esVersion;
}

function getContentType(body) {
  if (!body) return;
  return 'application/json';
}

function send(method, path, data) {
  var wrappedDfd = _jquery2.default.Deferred();

  var isGetRequest = /^get$/i.test(method);
  if (data && isGetRequest) {
    method = "POST";
  }

  var options = {
    url: '../api/console/proxy?' + (0, _querystring.stringify)({ path: path, method: method }),
    data: data,
    contentType: getContentType(data),
    cache: false,
    crossDomain: true,
    type: 'POST',
    dataType: 'text' // disable automatic guessing
  };

  _jquery2.default.ajax(options).then(function (data, textStatus, jqXHR) {
    wrappedDfd.resolveWith(this, [data, textStatus, jqXHR]);
  }, function (jqXHR, textStatus, errorThrown) {
    if (jqXHR.status == 0) {
      jqXHR.responseText = "\n\nFailed to connect to Console's backend.\nPlease check the Kibana server is up and running";
    }
    wrappedDfd.rejectWith(this, [jqXHR, textStatus, errorThrown]);
  });
  return wrappedDfd;
}

function constructESUrl(baseUri, path) {
  baseUri = baseUri.replace(/\/+$/, '');
  path = path.replace(/^\/+/, '');
  return baseUri + '/' + path;
}

/***/ }),
/* 362 */
/***/ (function(module, exports) {

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

consoleAce.define('ace/mode/json', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/mode/text', 'ace/tokenizer', 'ace/mode/json_highlight_rules', 'ace/mode/matching_brace_outdent', 'ace/mode/behaviour/cstyle', 'ace/mode/folding/cstyle', 'ace/worker/worker_client'], function(require, exports, module) {


var oop = require("../lib/oop");
var TextMode = require("./text").Mode;
var Tokenizer = require("../tokenizer").Tokenizer;
var HighlightRules = require("./json_highlight_rules").JsonHighlightRules;
var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
var CStyleFoldMode = require("./folding/cstyle").FoldMode;
var WorkerClient = require("../worker/worker_client").WorkerClient;

var Mode = function() {
    this.HighlightRules = HighlightRules;
    this.$outdent = new MatchingBraceOutdent();
    this.$behaviour = new CstyleBehaviour();
    this.foldingRules = new CStyleFoldMode();
};
oop.inherits(Mode, TextMode);

(function() {

    this.getNextLineIndent = function(state, line, tab) {
        var indent = this.$getIndent(line);

        if (state == "start") {
            var match = line.match(/^.*[\{\(\[]\s*$/);
            if (match) {
                indent += tab;
            }
        }

        return indent;
    };

    this.checkOutdent = function(state, line, input) {
        return this.$outdent.checkOutdent(line, input);
    };

    this.autoOutdent = function(state, doc, row) {
        this.$outdent.autoOutdent(doc, row);
    };

    this.createWorker = function(session) {
        var worker = new WorkerClient(["ace"], "ace/mode/json_worker", "JsonWorker");
        worker.attachToDocument(session.getDocument());

        worker.on("error", function(e) {
            session.setAnnotations([e.data]);
        });

        worker.on("ok", function() {
            session.clearAnnotations();
        });

        return worker;
    };


    this.$id = "ace/mode/json";
}).call(Mode.prototype);

exports.Mode = Mode;
});

consoleAce.define('ace/mode/json_highlight_rules', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/mode/text_highlight_rules'], function(require, exports, module) {


var oop = require("../lib/oop");
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

var JsonHighlightRules = function() {
    this.$rules = {
        "start" : [
            {
                token : "variable", // single line
                regex : '["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]\\s*(?=:)'
            }, {
                token : "string", // single line
                regex : '"',
                next  : "string"
            }, {
                token : "constant.numeric", // hex
                regex : "0[xX][0-9a-fA-F]+\\b"
            }, {
                token : "constant.numeric", // float
                regex : "[+-]?\\d+(?:(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)?\\b"
            }, {
                token : "constant.language.boolean",
                regex : "(?:true|false)\\b"
            }, {
                token : "invalid.illegal", // single quoted strings are not allowed
                regex : "['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']"
            }, {
                token : "invalid.illegal", // comments are not allowed
                regex : "\\/\\/.*$"
            }, {
                token : "paren.lparen",
                regex : "[[({]"
            }, {
                token : "paren.rparen",
                regex : "[\\])}]"
            }, {
                token : "text",
                regex : "\\s+"
            }
        ],
        "string" : [
            {
                token : "constant.language.escape",
                regex : /\\(?:x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|["\\\/bfnrt])/
            }, {
                token : "string",
                regex : '[^"\\\\]+'
            }, {
                token : "string",
                regex : '"',
                next  : "start"
            }, {
                token : "string",
                regex : "",
                next  : "start"
            }
        ]
    };
    
};

oop.inherits(JsonHighlightRules, TextHighlightRules);

exports.JsonHighlightRules = JsonHighlightRules;
});

consoleAce.define('ace/mode/matching_brace_outdent', ['require', 'exports', 'module' , 'ace/range'], function(require, exports, module) {


var Range = require("../range").Range;

var MatchingBraceOutdent = function() {};

(function() {

    this.checkOutdent = function(line, input) {
        if (! /^\s+$/.test(line))
            return false;

        return /^\s*\}/.test(input);
    };

    this.autoOutdent = function(doc, row) {
        var line = doc.getLine(row);
        var match = line.match(/^(\s*\})/);

        if (!match) return 0;

        var column = match[1].length;
        var openBracePos = doc.findMatchingBracket({row: row, column: column});

        if (!openBracePos || openBracePos.row == row) return 0;

        var indent = this.$getIndent(doc.getLine(openBracePos.row));
        doc.replace(new Range(row, 0, row, column-1), indent);
    };

    this.$getIndent = function(line) {
        return line.match(/^\s*/)[0];
    };

}).call(MatchingBraceOutdent.prototype);

exports.MatchingBraceOutdent = MatchingBraceOutdent;
});

consoleAce.define('ace/mode/behaviour/cstyle', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/mode/behaviour', 'ace/token_iterator', 'ace/lib/lang'], function(require, exports, module) {


var oop = require("../../lib/oop");
var Behaviour = require("../behaviour").Behaviour;
var TokenIterator = require("../../token_iterator").TokenIterator;
var lang = require("../../lib/lang");

var SAFE_INSERT_IN_TOKENS =
    ["text", "paren.rparen", "punctuation.operator"];
var SAFE_INSERT_BEFORE_TOKENS =
    ["text", "paren.rparen", "punctuation.operator", "comment"];


var autoInsertedBrackets = 0;
var autoInsertedRow = -1;
var autoInsertedLineEnd = "";
var maybeInsertedBrackets = 0;
var maybeInsertedRow = -1;
var maybeInsertedLineStart = "";
var maybeInsertedLineEnd = "";

var CstyleBehaviour = function () {
    
    CstyleBehaviour.isSaneInsertion = function(editor, session) {
        var cursor = editor.getCursorPosition();
        var iterator = new TokenIterator(session, cursor.row, cursor.column);
        if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
            var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
            if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
                return false;
        }
        iterator.stepForward();
        return iterator.getCurrentTokenRow() !== cursor.row ||
            this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
    };
    
    CstyleBehaviour.$matchTokenType = function(token, types) {
        return types.indexOf(token.type || token) > -1;
    };
    
    CstyleBehaviour.recordAutoInsert = function(editor, session, bracket) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (!this.isAutoInsertedClosing(cursor, line, autoInsertedLineEnd[0]))
            autoInsertedBrackets = 0;
        autoInsertedRow = cursor.row;
        autoInsertedLineEnd = bracket + line.substr(cursor.column);
        autoInsertedBrackets++;
    };
    
    CstyleBehaviour.recordMaybeInsert = function(editor, session, bracket) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (!this.isMaybeInsertedClosing(cursor, line))
            maybeInsertedBrackets = 0;
        maybeInsertedRow = cursor.row;
        maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
        maybeInsertedLineEnd = line.substr(cursor.column);
        maybeInsertedBrackets++;
    };
    
    CstyleBehaviour.isAutoInsertedClosing = function(cursor, line, bracket) {
        return autoInsertedBrackets > 0 &&
            cursor.row === autoInsertedRow &&
            bracket === autoInsertedLineEnd[0] &&
            line.substr(cursor.column) === autoInsertedLineEnd;
    };
    
    CstyleBehaviour.isMaybeInsertedClosing = function(cursor, line) {
        return maybeInsertedBrackets > 0 &&
            cursor.row === maybeInsertedRow &&
            line.substr(cursor.column) === maybeInsertedLineEnd &&
            line.substr(0, cursor.column) == maybeInsertedLineStart;
    };
    
    CstyleBehaviour.popAutoInsertedClosing = function() {
        autoInsertedLineEnd = autoInsertedLineEnd.substr(1);
        autoInsertedBrackets--;
    };
    
    CstyleBehaviour.clearMaybeInsertedClosing = function() {
        maybeInsertedBrackets = 0;
        maybeInsertedRow = -1;
    };

    this.add("braces", "insertion", function (state, action, editor, session, text) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (text == '{') {
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
                return {
                    text: '{' + selected + '}',
                    selection: false
                };
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode) {
                    CstyleBehaviour.recordAutoInsert(editor, session, "}");
                    return {
                        text: '{}',
                        selection: [1, 1]
                    };
                } else {
                    CstyleBehaviour.recordMaybeInsert(editor, session, "{");
                    return {
                        text: '{',
                        selection: [1, 1]
                    };
                }
            }
        } else if (text == '}') {
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == '}') {
                var matching = session.$findOpeningBracket('}', {column: cursor.column + 1, row: cursor.row});
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        } else if (text == "\n" || text == "\r\n") {
            var closing = "";
            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
                closing = lang.stringRepeat("}", maybeInsertedBrackets);
                CstyleBehaviour.clearMaybeInsertedClosing();
            }
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === '}') {
                var openBracePos = session.findMatchingBracket({row: cursor.row, column: cursor.column+1}, '}');
                if (!openBracePos)
                     return null;
                var next_indent = this.$getIndent(session.getLine(openBracePos.row));
            } else if (closing) {
                var next_indent = this.$getIndent(line);
            } else {
                return;
            }
            var indent = next_indent + session.getTabString();

            return {
                text: '\n' + indent + '\n' + next_indent + closing,
                selection: [1, indent.length, 1, indent.length]
            };
        } else {
            CstyleBehaviour.clearMaybeInsertedClosing();
        }
    });

    this.add("braces", "deletion", function (state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '{') {
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.end.column, range.end.column + 1);
            if (rightChar == '}') {
                range.end.column++;
                return range;
            } else {
                maybeInsertedBrackets--;
            }
        }
    });

    this.add("parens", "insertion", function (state, action, editor, session, text) {
        if (text == '(') {
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                return {
                    text: '(' + selected + ')',
                    selection: false
                };
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                CstyleBehaviour.recordAutoInsert(editor, session, ")");
                return {
                    text: '()',
                    selection: [1, 1]
                };
            }
        } else if (text == ')') {
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ')') {
                var matching = session.$findOpeningBracket(')', {column: cursor.column + 1, row: cursor.row});
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        }
    });

    this.add("parens", "deletion", function (state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '(') {
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == ')') {
                range.end.column++;
                return range;
            }
        }
    });

    this.add("brackets", "insertion", function (state, action, editor, session, text) {
        if (text == '[') {
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                return {
                    text: '[' + selected + ']',
                    selection: false
                };
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                CstyleBehaviour.recordAutoInsert(editor, session, "]");
                return {
                    text: '[]',
                    selection: [1, 1]
                };
            }
        } else if (text == ']') {
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ']') {
                var matching = session.$findOpeningBracket(']', {column: cursor.column + 1, row: cursor.row});
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        }
    });

    this.add("brackets", "deletion", function (state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '[') {
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == ']') {
                range.end.column++;
                return range;
            }
        }
    });

    this.add("string_dquotes", "insertion", function (state, action, editor, session, text) {
        if (text == '"' || text == "'") {
            var quote = text;
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && selected !== "'" && selected != '"' && editor.getWrapBehavioursEnabled()) {
                return {
                    text: quote + selected + quote,
                    selection: false
                };
            } else {
                var cursor = editor.getCursorPosition();
                var line = session.doc.getLine(cursor.row);
                var leftChar = line.substring(cursor.column-1, cursor.column);
                if (leftChar == '\\') {
                    return null;
                }
                var tokens = session.getTokens(selection.start.row);
                var col = 0, token;
                var quotepos = -1; // Track whether we're inside an open quote.

                for (var x = 0; x < tokens.length; x++) {
                    token = tokens[x];
                    if (token.type == "string") {
                      quotepos = -1;
                    } else if (quotepos < 0) {
                      quotepos = token.value.indexOf(quote);
                    }
                    if ((token.value.length + col) > selection.start.column) {
                        break;
                    }
                    col += tokens[x].value.length;
                }
                if (!token || (quotepos < 0 && token.type !== "comment" && (token.type !== "string" || ((selection.start.column !== token.value.length+col-1) && token.value.lastIndexOf(quote) === token.value.length-1)))) {
                    if (!CstyleBehaviour.isSaneInsertion(editor, session))
                        return;
                    return {
                        text: quote + quote,
                        selection: [1,1]
                    };
                } else if (token && token.type === "string") {
                    var rightChar = line.substring(cursor.column, cursor.column + 1);
                    if (rightChar == quote) {
                        return {
                            text: '',
                            selection: [1, 1]
                        };
                    }
                }
            }
        }
    });

    this.add("string_dquotes", "deletion", function (state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == selected) {
                range.end.column++;
                return range;
            }
        }
    });

};

oop.inherits(CstyleBehaviour, Behaviour);

exports.CstyleBehaviour = CstyleBehaviour;
});

consoleAce.define('ace/mode/folding/cstyle', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/range', 'ace/mode/folding/fold_mode'], function(require, exports, module) {


var oop = require("../../lib/oop");
var Range = require("../../range").Range;
var BaseFoldMode = require("./fold_mode").FoldMode;

var FoldMode = exports.FoldMode = function(commentRegex) {
    if (commentRegex) {
        this.foldingStartMarker = new RegExp(
            this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start)
        );
        this.foldingStopMarker = new RegExp(
            this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end)
        );
    }
};
oop.inherits(FoldMode, BaseFoldMode);

(function() {

    this.foldingStartMarker = /(\{|\[)[^\}\]]*$|^\s*(\/\*)/;
    this.foldingStopMarker = /^[^\[\{]*(\}|\])|^[\s\*]*(\*\/)/;

    this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
        var line = session.getLine(row);
        var match = line.match(this.foldingStartMarker);
        if (match) {
            var i = match.index;

            if (match[1])
                return this.openingBracketBlock(session, match[1], row, i);
                
            var range = session.getCommentFoldRange(row, i + match[0].length, 1);
            
            if (range && !range.isMultiLine()) {
                if (forceMultiline) {
                    range = this.getSectionRange(session, row);
                } else if (foldStyle != "all")
                    range = null;
            }
            
            return range;
        }

        if (foldStyle === "markbegin")
            return;

        var match = line.match(this.foldingStopMarker);
        if (match) {
            var i = match.index + match[0].length;

            if (match[1])
                return this.closingBracketBlock(session, match[1], row, i);

            return session.getCommentFoldRange(row, i, -1);
        }
    };
    
    this.getSectionRange = function(session, row) {
        var line = session.getLine(row);
        var startIndent = line.search(/\S/);
        var startRow = row;
        var startColumn = line.length;
        row = row + 1;
        var endRow = row;
        var maxRow = session.getLength();
        while (++row < maxRow) {
            line = session.getLine(row);
            var indent = line.search(/\S/);
            if (indent === -1)
                continue;
            if  (startIndent > indent)
                break;
            var subRange = this.getFoldWidgetRange(session, "all", row);
            
            if (subRange) {
                if (subRange.start.row <= startRow) {
                    break;
                } else if (subRange.isMultiLine()) {
                    row = subRange.end.row;
                } else if (startIndent == indent) {
                    break;
                }
            }
            endRow = row;
        }
        
        return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
    };

}).call(FoldMode.prototype);

});


/***/ }),
/* 363 */,
/* 364 */,
/* 365 */,
/* 366 */,
/* 367 */,
/* 368 */,
/* 369 */,
/* 370 */,
/* 371 */,
/* 372 */,
/* 373 */,
/* 374 */,
/* 375 */,
/* 376 */,
/* 377 */,
/* 378 */,
/* 379 */,
/* 380 */,
/* 381 */,
/* 382 */,
/* 383 */,
/* 384 */,
/* 385 */,
/* 386 */,
/* 387 */,
/* 388 */,
/* 389 */,
/* 390 */,
/* 391 */,
/* 392 */,
/* 393 */,
/* 394 */,
/* 395 */,
/* 396 */,
/* 397 */,
/* 398 */,
/* 399 */,
/* 400 */,
/* 401 */,
/* 402 */,
/* 403 */,
/* 404 */,
/* 405 */,
/* 406 */,
/* 407 */,
/* 408 */,
/* 409 */,
/* 410 */,
/* 411 */,
/* 412 */,
/* 413 */,
/* 414 */,
/* 415 */,
/* 416 */,
/* 417 */,
/* 418 */,
/* 419 */,
/* 420 */,
/* 421 */,
/* 422 */,
/* 423 */,
/* 424 */,
/* 425 */,
/* 426 */,
/* 427 */,
/* 428 */,
/* 429 */,
/* 430 */,
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1279);

/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BinderBase = exports.BinderBase = function () {
  function BinderBase() {
    _classCallCheck(this, BinderBase);

    this.disposal = [];
  }

  _createClass(BinderBase, [{
    key: "on",
    value: function on(emitter) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var on = emitter.on || emitter.addListener;
      var off = emitter.off || emitter.removeListener;

      on.apply(emitter, args);
      this.disposal.push(function () {
        return off.apply(emitter, args);
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var destroyers = this.disposal;
      this.disposal = [];
      destroyers.forEach(function (fn) {
        return fn();
      });
    }
  }]);

  return BinderBase;
}();

/***/ }),
/* 433 */
/***/ (function(module, exports) {

module.exports = {"name":"kibana","description":"Kibana is an open source (Apache Licensed), browser based analytics and search dashboard for Elasticsearch. Kibana is a snap to setup and start using. Kibana strives to be easy to get started with, while also being flexible and powerful, just like Elasticsearch.","keywords":["kibana","elasticsearch","logstash","analytics","visualizations","dashboards","dashboarding"],"private":false,"version":"7.0.0-alpha1","branch":"master","build":{"number":8467,"sha":"6cb7fec4e154faa0a4a3fee4b33dfef91b9870d9"},"homepage":"https://www.elastic.co/products/kibana","bugs":{"url":"http://github.com/elastic/kibana/issues"},"license":"Apache-2.0","author":"Rashid Khan <rashid.khan@elastic.co>","contributors":["Chris Cowan <chris.cowan@elastic.co>","Court Ewing <court@elastic.co>","Jim Unger <jim.unger@elastic.co>","Joe Fleming <joe.fleming@elastic.co>","Jon Budzenski <jonathan.budzenski@elastic.co>","Juan Thomassie <juan.thomassie@elastic.co>","Khalah Jones-Golden <khalah.jones@elastic.co>","Lee Drengenberg <lee.drengenberg@elastic.co>","Lukas Olson <lukas.olson@elastic.co>","Matt Bargar <matt.bargar@elastic.co>","Nicols Bevacqua <nico@elastic.co>","Shelby Sturgis <shelby@elastic.co>","Spencer Alger <spencer.alger@elastic.co>","Tim Sullivan <tim@elastic.co>","Yuri Astrakhan <yuri@elastic.co>"],"scripts":{"test":"grunt test","test:dev":"grunt test:dev","test:quick":"grunt test:quick","test:browser":"grunt test:browser","test:ui":"grunt test:ui","test:ui:server":"grunt test:ui:server","test:ui:runner":"echo 'use `node scripts/functional_test_runner`' && false","test:server":"grunt test:server","test:coverage":"grunt test:coverage","test:visualRegression":"grunt test:visualRegression:buildGallery","checkLicenses":"grunt licenses","build":"grunt build","release":"grunt release","start":"node scripts/kibana --dev","debug":"node --nolazy --inspect --debug-brk scripts/kibana --dev","precommit":"node scripts/precommit_hook","karma":"karma start","elasticsearch":"grunt esvm:dev:keepalive","lint":"echo 'use `node scripts/eslint`' && false","lintroller":"echo 'use `node scripts/eslint --fix`' && false","makelogs":"echo 'use `node scripts/makelogs`' && false","mocha":"echo 'use `node scripts/mocha`' && false","sterilize":"grunt sterilize","uiFramework:start":"grunt uiFramework:start","uiFramework:build":"grunt uiFramework:build","uiFramework:createComponent":"yo ./ui_framework/generator-kui/app/component.js","uiFramework:documentComponent":"yo ./ui_framework/generator-kui/app/documentation.js"},"repository":{"type":"git","url":"https://github.com/elastic/kibana.git"},"dependencies":{"@elastic/datemath":"2.3.0","@elastic/eui":"0.0.11","@elastic/filesaver":"1.1.2","@elastic/numeral":"2.3.1","@elastic/test-subj-selector":"0.2.1","@elastic/ui-ace":"0.2.3","JSONStream":"1.1.1","accept-language-parser":"1.2.0","angular":"1.6.5","angular-aria":"1.6.6","angular-bootstrap-colorpicker":"3.0.19","angular-elastic":"2.5.0","angular-route":"1.4.7","angular-sanitize":"1.5.7","angular-sortable-view":"0.0.15","autoprefixer":"6.5.4","babel-core":"6.21.0","babel-jest":"^22.0.6","babel-loader":"7.1.2","babel-plugin-add-module-exports":"0.2.1","babel-plugin-transform-async-generator-functions":"6.24.1","babel-plugin-transform-class-properties":"6.24.1","babel-plugin-transform-define":"1.3.0","babel-plugin-transform-object-rest-spread":"6.26.0","babel-polyfill":"6.20.0","babel-preset-env":"1.4.0","babel-preset-react":"6.22.0","babel-register":"6.18.0","bluebird":"2.9.34","body-parser":"1.12.0","boom":"5.2.0","brace":"0.10.0","bunyan":"1.7.1","cache-loader":"1.0.3","chalk":"2.3.0","check-hash":"1.0.1","color":"1.0.3","commander":"2.8.1","compare-versions":"3.1.0","css-loader":"0.28.7","d3":"3.5.6","d3-cloud":"1.2.1","dragula":"3.7.0","elasticsearch":"13.0.1","elasticsearch-browser":"13.0.1","encode-uri-query":"1.0.0","even-better":"7.0.2","expiry-js":"0.1.7","exports-loader":"0.6.4","expose-loader":"0.7.3","extract-text-webpack-plugin":"3.0.1","file-loader":"1.1.4","focus-trap-react":"3.0.5","font-awesome":"4.4.0","glob":"5.0.13","glob-all":"3.0.1","good-squeeze":"2.1.0","h2o2":"5.1.1","handlebars":"4.0.5","hapi":"14.2.0","hjson":"3.1.0","http-proxy-agent":"1.0.0","imports-loader":"0.7.1","inert":"4.0.2","jade":"1.11.0","jade-loader":"0.8.0","joi":"10.4.1","jquery":"3.2.1","js-yaml":"3.4.1","json-stringify-pretty-compact":"1.0.4","json-stringify-safe":"5.0.1","jstimezonedetect":"1.0.5","leaflet":"1.0.3","leaflet-draw":"0.4.10","leaflet-responsive-popup":"0.2.0","leaflet.heat":"0.2.0","less":"2.7.1","less-loader":"4.0.5","lodash":"3.10.1","lru-cache":"4.1.1","markdown-it":"8.3.2","minimatch":"2.0.10","mkdirp":"0.5.1","moment":"2.13.0","moment-timezone":"0.5.4","mustache":"2.3.0","ngreact":"0.5.1","no-ui-slider":"1.2.0","node-fetch":"1.3.2","pegjs":"0.9.0","pivotal-ui":"11.0.0","postcss-loader":"2.0.6","prop-types":"15.5.8","proxy-from-env":"1.0.0","querystring-browser":"1.0.4","raw-loader":"0.5.1","react":"16.0.0","react-ace":"5.5.0","react-anything-sortable":"1.7.3","react-color":"2.11.7","react-dom":"16.0.0","react-grid-layout":"0.16.0","react-input-autosize":"1.1.0","react-input-range":"1.2.1","react-markdown":"3.1.0","react-redux":"5.0.5","react-router":"3.2.0","react-router-dom":"4.2.2","react-router-redux":"4.0.4","react-select":"1.0.0-rc.5","react-sizeme":"2.3.4","react-sortable":"1.1.0","react-test-renderer":"16.0.0","react-toggle":"4.0.2","reactcss":"1.2.3","redux":"3.7.2","redux-actions":"2.2.1","redux-thunk":"2.2.0","regression":"2.0.0","request":"2.61.0","resize-observer-polyfill":"1.2.1","rimraf":"2.4.3","rison-node":"1.0.0","rxjs":"5.4.3","script-loader":"0.7.2","semver":"5.1.0","style-loader":"0.19.0","tabbable":"1.1.0","tar":"2.2.0","tinygradient":"0.3.0","trunc-html":"1.0.2","trunc-text":"1.0.2","uglifyjs-webpack-plugin":"0.4.6","ui-select":"0.19.6","url-loader":"0.5.9","uuid":"3.0.1","validate-npm-package-name":"2.2.2","vega":"3.0.8","vega-lite":"2.0.4","vega-schema-url-parser":"1.0.0","vision":"4.1.0","webpack":"3.6.0","webpack-merge":"4.1.0","whatwg-fetch":"^2.0.3","wreck":"12.4.0","yauzl":"2.7.0"},"devDependencies":{"@elastic/eslint-config-kibana":"0.15.0","@elastic/eslint-import-resolver-kibana":"1.0.0","@elastic/eslint-plugin-kibana-custom":"1.1.0","angular-mocks":"1.4.7","babel-eslint":"8.1.2","backport":"2.2.0","chai":"3.5.0","chance":"1.0.6","cheerio":"0.22.0","chokidar":"1.6.0","chromedriver":"2.34.0","classnames":"2.2.5","enzyme":"3.2.0","enzyme-adapter-react-16":"1.1.0","enzyme-to-json":"3.1.4","eslint":"4.14.0","eslint-plugin-babel":"4.1.2","eslint-plugin-import":"2.8.0","eslint-plugin-jest":"^21.6.2","eslint-plugin-mocha":"4.11.0","eslint-plugin-prefer-object-spread":"1.2.1","eslint-plugin-react":"7.5.1","event-stream":"3.3.2","expect.js":"0.3.1","faker":"1.1.0","getopts":"2.0.0","grunt":"1.0.1","grunt-aws-s3":"0.14.5","grunt-babel":"6.0.0","grunt-cli":"0.1.13","grunt-contrib-clean":"1.0.0","grunt-contrib-copy":"0.8.1","grunt-esvm":"3.2.12","grunt-karma":"2.0.0","grunt-run":"0.7.0","grunt-simple-mocha":"0.4.0","gulp-sourcemaps":"1.7.3","highlight.js":"9.0.0","history":"2.1.1","html":"1.0.0","html-loader":"0.5.1","husky":"0.8.1","image-diff":"1.6.0","istanbul-instrumenter-loader":"3.0.0","jest":"^22.0.6","jest-cli":"^22.0.6","jimp":"0.2.28","jsdom":"9.9.1","karma":"1.7.0","karma-chrome-launcher":"2.1.1","karma-coverage":"1.1.1","karma-firefox-launcher":"1.0.1","karma-ie-launcher":"1.0.0","karma-junit-reporter":"1.2.0","karma-mocha":"1.3.0","karma-safari-launcher":"1.0.0","keymirror":"0.1.1","leadfoot":"1.7.1","license-checker":"5.1.2","load-grunt-config":"0.19.2","makelogs":"4.0.2","marked-text-renderer":"0.1.0","mocha":"3.3.0","mock-fs":"4.2.0","murmurhash3js":"3.0.1","ncp":"2.0.0","nock":"8.0.0","node-sass":"4.5.3","pixelmatch":"4.0.2","proxyquire":"1.7.10","sass-loader":"6.0.6","simple-git":"1.37.0","sinon":"1.17.2","source-map":"0.5.6","source-map-support":"0.2.10","strip-ansi":"^3.0.1","supertest":"3.0.0","supertest-as-promised":"2.0.2","tree-kill":"1.1.0","webpack-dev-server":"2.9.1","xml2js":"0.4.19","xmlbuilder":"9.0.4","yeoman-generator":"1.1.1","yo":"2.0.0"},"resolutions":{"angular":"1.6.5","moment":"2.13.0","react":"16.0.0"},"engines":{"node":"6.12.2","yarn":"^1.3.2"}}

/***/ }),
/* 434 */,
/* 435 */,
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StateProvider = StateProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _angular = __webpack_require__(16);

var _angular2 = _interopRequireDefault(_angular);

var _risonNode = __webpack_require__(132);

var _risonNode2 = _interopRequireDefault(_risonNode);

var _diff_object = __webpack_require__(1320);

var _events = __webpack_require__(133);

var _notifier = __webpack_require__(43);

__webpack_require__(1329);

var _state_storage = __webpack_require__(1330);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @name State
 *
 * @extends Events
 *
 * @description Persists generic "state" to and reads it from the URL.
 */

function StateProvider(Private, $rootScope, $location, stateManagementConfig, config, kbnUrl) {
  var Events = Private(_events.EventsProvider);

  _lodash2.default.class(State).inherits(Events);
  function State(urlParam, defaults) {
    var _this = this;

    var hashedItemStore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _state_storage.HashedItemStoreSingleton;
    var notifier = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _notifier.Notifier();

    State.Super.call(this);

    this.setDefaults(defaults);
    this._urlParam = urlParam || '_s';
    this._notifier = notifier;
    this._hashedItemStore = hashedItemStore;

    // When the URL updates we need to fetch the values from the URL
    this._cleanUpListeners = _lodash2.default.partial(_lodash2.default.callEach, [
    // partial route update, no app reload
    $rootScope.$on('$routeUpdate', function () {
      _this.fetch();
    }),

    // beginning of full route update, new app will be initialized before
    // $routeChangeSuccess or $routeChangeError
    $rootScope.$on('$routeChangeStart', function () {
      if (!_this._persistAcrossApps) {
        _this.destroy();
      }
    }), $rootScope.$on('$routeChangeSuccess', function () {
      if (_this._persistAcrossApps) {
        _this.fetch();
      }
    })]);

    // Initialize the State with fetch
    this.fetch();
  }

  State.prototype._readFromURL = function () {
    var search = $location.search();
    var urlVal = search[this._urlParam];

    if (!urlVal) {
      return null;
    }

    if ((0, _state_storage.isStateHash)(urlVal)) {
      return this._parseStateHash(urlVal);
    }

    var risonEncoded = void 0;
    var unableToParse = void 0;
    try {
      risonEncoded = _risonNode2.default.decode(urlVal);
    } catch (e) {
      unableToParse = true;
    }

    if (unableToParse) {
      this._notifier.error('Unable to parse URL');
      search[this._urlParam] = this.toQueryParam(this._defaults);
      $location.search(search).replace();
    }

    if (!risonEncoded) {
      return null;
    }

    if (this.isHashingEnabled()) {
      // RISON can find its way into the URL any number of ways, including the navbar links or
      // shared urls with the entire state embedded. These values need to be translated into
      // hashes and replaced in the browser history when state-hashing is enabled
      search[this._urlParam] = this.toQueryParam(risonEncoded);
      $location.search(search).replace();
    }

    return risonEncoded;
  };

  /**
   * Fetches the state from the url
   * @returns {void}
   */
  State.prototype.fetch = function () {
    if (!stateManagementConfig.enabled) {
      return;
    }

    var stash = this._readFromURL();

    // nothing to read from the url? save if ordered to persist
    if (stash === null) {
      if (this._persistAcrossApps) {
        return this.save();
      } else {
        stash = {};
      }
    }

    _lodash2.default.defaults(stash, this._defaults);
    // apply diff to state from stash, will change state in place via side effect
    var diffResults = (0, _diff_object.applyDiff)(this, stash);

    if (diffResults.keys.length) {
      this.emit('fetch_with_changes', diffResults.keys);
    }
  };

  /**
   * Saves the state to the url
   * @returns {void}
   */
  State.prototype.save = function (replace) {
    if (!stateManagementConfig.enabled) {
      return;
    }

    var stash = this._readFromURL();
    var state = this.toObject();
    replace = replace || false;

    if (!stash) {
      replace = true;
      stash = {};
    }

    // apply diff to state from stash, will change state in place via side effect
    var diffResults = (0, _diff_object.applyDiff)(stash, _lodash2.default.defaults({}, state, this._defaults));

    if (diffResults.keys.length) {
      this.emit('save_with_changes', diffResults.keys);
    }

    // persist the state in the URL
    var search = $location.search();
    search[this._urlParam] = this.toQueryParam(state);
    if (replace) {
      $location.search(search).replace();
    } else {
      $location.search(search);
    }
  };

  /**
   * Calls save with a forced replace
   * @returns {void}
   */
  State.prototype.replace = function () {
    if (!stateManagementConfig.enabled) {
      return;
    }

    this.save(true);
  };

  /**
   * Resets the state to the defaults
   *
   * @returns {void}
   */
  State.prototype.reset = function () {
    if (!stateManagementConfig.enabled) {
      return;
    }

    kbnUrl.removeParam(this.getQueryParamName());
    // apply diff to attributes from defaults, this is side effecting so
    // it will change the state in place.
    var diffResults = (0, _diff_object.applyDiff)(this, this._defaults);
    if (diffResults.keys.length) {
      this.emit('reset_with_changes', diffResults.keys);
    }
    this.save();
  };

  /**
   * Cleans up the state object
   * @returns {void}
   */
  State.prototype.destroy = function () {
    this.off(); // removes all listeners
    this._cleanUpListeners(); // Removes the $routeUpdate listener
  };

  State.prototype.setDefaults = function (defaults) {
    this._defaults = defaults || {};
  };

  /**
   *  Parse the state hash to it's unserialized value. Hashes are restored
   *  to their pre-hashed state.
   *
   *  @param  {string} stateHash - state hash value from the query string.
   *  @return {any} - the stored value, or null if hash does not resolve.
   */
  State.prototype._parseStateHash = function (stateHash) {
    var json = this._hashedItemStore.getItem(stateHash);
    if (json === null) {
      this._notifier.error('Unable to completely restore the URL, be sure to use the share functionality.');
    }

    return JSON.parse(json);
  };

  /**
   *  Lookup the value for a hash and return it's value in rison format or just
   *  return passed argument if it's not recognized as state hash.
   *
   *  @param  {string} stateHashOrRison - either state hash value or rison string.
   *  @return {string} rison
   */
  State.prototype.translateHashToRison = function (stateHashOrRison) {
    if ((0, _state_storage.isStateHash)(stateHashOrRison)) {
      return _risonNode2.default.encode(this._parseStateHash(stateHashOrRison));
    }

    return stateHashOrRison;
  };

  State.prototype.isHashingEnabled = function () {
    return !!config.get('state:storeInSessionStorage');
  };

  /**
   *  Produce the hash version of the state in it's current position
   *
   *  @return {string}
   */
  State.prototype.toQueryParam = function () {
    var _this2 = this;

    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toObject();

    if (!this.isHashingEnabled()) {
      return _risonNode2.default.encode(state);
    }

    // We need to strip out Angular-specific properties.
    var json = _angular2.default.toJson(state);
    var hash = (0, _state_storage.createStateHash)(json, function (hash) {
      return _this2._hashedItemStore.getItem(hash);
    });
    var isItemSet = this._hashedItemStore.setItem(hash, json);

    if (isItemSet) {
      return hash;
    }

    // If we ran out of space trying to persist the state, notify the user.
    this._notifier.fatal(new Error('Kibana is unable to store history items in your session ' + 'because it is full and there don\'t seem to be items any items safe ' + 'to delete.\n' + '\n' + 'This can usually be fixed by moving to a fresh tab, but could ' + 'be caused by a larger issue. If you are seeing this message regularly, ' + 'please file an issue at https://github.com/elastic/kibana/issues.'));
  };

  /**
   *  Get the query string parameter name where this state writes and reads
   *  @return {string}
   */
  State.prototype.getQueryParamName = function () {
    return this._urlParam;
  };

  return State;
}

/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SimpleEmitter = SimpleEmitter;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _base_object = __webpack_require__(1328);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Simple event emitter class used in the vislib. Calls
 * handlers synchronously and implements a chainable api
 *
 * @class
 */
_lodash2.default.class(SimpleEmitter).inherits(_base_object.BaseObject);
function SimpleEmitter() {
  this._listeners = {};
}

/**
 * Add an event handler
 *
 * @param  {string} name
 * @param  {function} handler
 * @return {SimpleEmitter} - this, for chaining
 */
SimpleEmitter.prototype.on = function (name, handler) {
  var handlers = this._listeners[name];
  if (!handlers) handlers = this._listeners[name] = [];

  handlers.push(handler);

  return this;
};

/**
 * Remove an event handler
 *
 * @param  {string} name
 * @param  {function} [handler] - optional handler to remove, if no handler is
 *                              passed then all are removed
 * @return {SimpleEmitter} - this, for chaining
 */
SimpleEmitter.prototype.off = function (name, handler) {
  if (!this._listeners[name]) {
    return this;
  }

  // remove a specific handler
  if (handler) _lodash2.default.pull(this._listeners[name], handler);
  // or remove all listeners
  else this._listeners[name] = null;

  return this;
};

/**
 * Remove all event listeners bound to this emitter.
 *
 * @return {SimpleEmitter} - this, for chaining
 */
SimpleEmitter.prototype.removeAllListeners = function () {
  this._listeners = {};
  return this;
};

/**
 * Emit an event and all arguments to all listeners for an event name
 *
 * @param  {string} name
 * @param  {*} [arg...] - any number of arguments that will be applied to each handler
 * @return {SimpleEmitter} - this, for chaining
 */
SimpleEmitter.prototype.emit = _lodash2.default.restParam(function (name, args) {
  if (!this._listeners[name]) return this;
  var listeners = this.listeners(name);
  var i = -1;

  while (++i < listeners.length) {
    listeners[i].apply(this, args);
  }

  return this;
});

/**
 * Get a list of the event names that currently have listeners
 *
 * @return {array[string]}
 */
SimpleEmitter.prototype.activeEvents = function () {
  return _lodash2.default.reduce(this._listeners, function (active, listeners, name) {
    return active.concat(_lodash2.default.size(listeners) ? name : []);
  }, []);
};

/**
 * Get a list of the handler functions for a specific event
 *
 * @param  {string} name
 * @return {array[function]}
 */
SimpleEmitter.prototype.listeners = function (name) {
  return this._listeners[name] ? this._listeners[name].slice(0) : [];
};

/**
 * Get the count of handlers for a specific event
 *
 * @param  {string} [name] - optional event name to filter by
 * @return {number}
 */
SimpleEmitter.prototype.listenerCount = function (name) {
  if (name) {
    return _lodash2.default.size(this._listeners[name]);
  }

  return _lodash2.default.reduce(this._listeners, function (count, handlers) {
    return count + _lodash2.default.size(handlers);
  }, 0);
};

/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _toaster = __webpack_require__(1347);

var _toaster2 = _interopRequireDefault(_toaster);

__webpack_require__(1348);

__webpack_require__(439);

__webpack_require__(443);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var notify = _modules.uiModules.get('kibana/notify');

notify.directive('kbnNotifications', function () {
  return {
    restrict: 'E',
    scope: {
      list: '=list'
    },
    replace: true,
    template: _toaster2.default
  };
});

/***/ }),
/* 439 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _markdownIt = __webpack_require__(235);

var _markdownIt2 = _interopRequireDefault(_markdownIt);

var _modules = __webpack_require__(2);

__webpack_require__(169);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var markdownIt = new _markdownIt2.default({
  html: false,
  linkify: true
});

_modules.uiModules.get('kibana', ['ngSanitize']).filter('markdown', function ($sanitize) {
  return function (md) {
    return md ? $sanitize(markdownIt.render(md)) : '';
  };
});

/***/ }),
/* 440 */,
/* 441 */,
/* 442 */,
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _truncText = __webpack_require__(1404);

var _truncText2 = _interopRequireDefault(_truncText);

var _truncHtml = __webpack_require__(1405);

var _truncHtml2 = _interopRequireDefault(_truncHtml);

var _modules = __webpack_require__(2);

var _truncated = __webpack_require__(1414);

var _truncated2 = _interopRequireDefault(_truncated);

__webpack_require__(169);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana', ['ngSanitize']);

_module.directive('kbnTruncated', function () {
  return {
    restrict: 'E',
    scope: {
      source: '@',
      length: '@',
      isHtml: '@'
    },
    template: _truncated2.default,
    link: function link($scope) {
      var source = $scope.source;
      var max = $scope.length;
      var truncated = $scope.isHtml ? (0, _truncHtml2.default)(source, max).html : (0, _truncText2.default)(source, max);

      $scope.content = truncated;

      if (source === truncated) {
        return;
      }
      $scope.truncated = true;
      $scope.expanded = false;
      $scope.action = 'more';
      $scope.toggle = function () {
        $scope.expanded = !$scope.expanded;
        $scope.content = $scope.expanded ? source : truncated;
        $scope.action = $scope.expanded ? 'less' : 'more';
      };
    }
  };
});

/***/ }),
/* 444 */,
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1418);

/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get_unhashable_states_provider = __webpack_require__(1446);

Object.defineProperty(exports, 'getUnhashableStatesProvider', {
  enumerable: true,
  get: function get() {
    return _get_unhashable_states_provider.getUnhashableStatesProvider;
  }
});

var _hash_url = __webpack_require__(1447);

Object.defineProperty(exports, 'hashUrl', {
  enumerable: true,
  get: function get() {
    return _hash_url.hashUrl;
  }
});

var _unhash_query_string = __webpack_require__(700);

Object.defineProperty(exports, 'unhashQueryString', {
  enumerable: true,
  get: function get() {
    return _unhash_query_string.unhashQueryString;
  }
});

var _unhash_url = __webpack_require__(1448);

Object.defineProperty(exports, 'unhashUrl', {
  enumerable: true,
  get: function get() {
    return _unhash_url.unhashUrl;
  }
});

/***/ }),
/* 447 */
/***/ (function(module, exports, __webpack_require__) {

var moment = module.exports = __webpack_require__(1499);
moment.tz.load(__webpack_require__(1500));


/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(449);


/***/ }),
/* 449 */,
/* 450 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.timezoneProvider = timezoneProvider;

var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var tzDetect = __webpack_require__(706).jstz;
function timezoneProvider(config) {
  return function () {

    if (config.isDefault('dateFormat:tz')) {
      var detectedTimezone = tzDetect.determine().name();
      if (detectedTimezone) return detectedTimezone;else return (0, _moment2.default)().format('Z');
    } else {
      return config.get('dateFormat:tz', 'Browser');
    }
  };
}

/***/ }),
/* 451 */,
/* 452 */,
/* 453 */,
/* 454 */,
/* 455 */,
/* 456 */,
/* 457 */,
/* 458 */,
/* 459 */,
/* 460 */,
/* 461 */,
/* 462 */,
/* 463 */,
/* 464 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(2016);

/***/ }),
/* 465 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _module = _modules.uiModules.get('kibana');

_module.directive('inputFocus', function ($parse, $timeout) {
  return {
    restrict: 'A',
    link: function link($scope, $elem, attrs) {
      var isDisabled = attrs.disableInputFocus && $parse(attrs.disableInputFocus)($scope);
      if (!isDisabled) {
        $timeout(function () {
          $elem.focus();
          if (attrs.inputFocus === 'select') $elem.select();
        });
      }
    }
  };
});

/***/ }),
/* 466 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(2023);

/***/ }),
/* 467 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shortenDottedString = shortenDottedString;
var DOT_PREFIX_RE = /(.).+?\./g;

/**
 * Convert a dot.notated.string into a short
 * version (d.n.string)
 *
 * @param {string} str - the long string to convert
 * @return {string}
 */
function shortenDottedString(input) {
  return typeof input !== 'string' ? input : input.replace(DOT_PREFIX_RE, '$1.');
}

/***/ }),
/* 468 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.getHighlightHtml = getHighlightHtml;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _highlight_tags = __webpack_require__(754);

var _html_tags = __webpack_require__(2029);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getHighlightHtml(fieldValue, highlights) {
  var highlightHtml = (typeof fieldValue === 'undefined' ? 'undefined' : _typeof(fieldValue)) === 'object' ? JSON.stringify(fieldValue) : fieldValue;

  _lodash2.default.each(highlights, function (highlight) {
    var escapedHighlight = _lodash2.default.escape(highlight);

    // Strip out the highlight tags to compare against the field text
    var untaggedHighlight = escapedHighlight.split(_highlight_tags.highlightTags.pre).join('').split(_highlight_tags.highlightTags.post).join('');

    // Replace all highlight tags with proper html tags
    var taggedHighlight = escapedHighlight.split(_highlight_tags.highlightTags.pre).join(_html_tags.htmlTags.pre).split(_highlight_tags.highlightTags.post).join(_html_tags.htmlTags.post);

    // Replace all instances of the untagged string with the properly tagged string
    highlightHtml = highlightHtml.split(untaggedHighlight).join(taggedHighlight);
  });

  return highlightHtml;
}

/***/ }),
/* 469 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IndexPatternsGetProvider = IndexPatternsGetProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _saved_objects = __webpack_require__(76);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function IndexPatternsGetProvider(Private) {
  var savedObjectsClient = Private(_saved_objects.SavedObjectsClientProvider);

  // many places may require the id list, so we will cache it separately
  // didn't incorporate with the indexPattern cache to prevent id collisions.
  var cachedIdPromise = void 0;

  var get = function get(field) {
    if (field === 'id' && cachedIdPromise) {
      // return a clone of the cached response
      return cachedIdPromise.then(function (cachedResp) {
        return _lodash2.default.clone(cachedResp);
      });
    }

    var promise = savedObjectsClient.find({
      type: 'index-pattern',
      fields: [],
      perPage: 10000
    }).then(function (resp) {
      return resp.savedObjects.map(function (obj) {
        return _lodash2.default.get(obj, field);
      });
    });

    if (field === 'id') {
      cachedIdPromise = promise;
    }

    // ensure that the response stays pristine by cloning it here too
    return promise.then(function (resp) {
      return _lodash2.default.clone(resp);
    });
  };

  return function (field) {
    var getter = get.bind(get, field);
    if (field === 'id') {
      getter.clearCache = function () {
        cachedIdPromise = null;
      };
    }
    return getter;
  };
}

/***/ }),
/* 470 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IndexPatternsFieldProvider = IndexPatternsFieldProvider;

var _obj_define = __webpack_require__(2039);

var _field_format = __webpack_require__(321);

var _field_formats = __webpack_require__(64);

var _utils = __webpack_require__(199);

function IndexPatternsFieldProvider(Private, shortDotsFilter, $rootScope, Notifier) {
  var notify = new Notifier({ location: 'IndexPattern Field' });
  var fieldFormats = Private(_field_formats.RegistryFieldFormatsProvider);

  function Field(indexPattern, spec) {
    // unwrap old instances of Field
    if (spec instanceof Field) spec = spec.$$spec;

    // constuct this object using ObjDefine class, which
    // extends the Field.prototype but gets it's properties
    // defined using the logic below
    var obj = new _obj_define.ObjDefine(spec, Field.prototype);

    if (spec.name === '_source') {
      spec.type = '_source';
    }

    // find the type for this field, fallback to unknown type
    var type = (0, _utils.getKbnFieldType)(spec.type);
    if (spec.type && !type) {
      notify.error('Unknown field type "' + spec.type + '"' + ' for field "' + spec.name + '"' + ' in indexPattern "' + indexPattern.title + '"');
    }

    if (!type) type = (0, _utils.getKbnFieldType)('unknown');

    var format = spec.format;
    if (!format || !(format instanceof _field_format.FieldFormat)) {
      format = indexPattern.fieldFormatMap[spec.name] || fieldFormats.getDefaultInstance(spec.type);
    }

    var indexed = !!spec.indexed;
    var scripted = !!spec.scripted;
    var searchable = !!spec.searchable || scripted;
    var aggregatable = !!spec.aggregatable || scripted;
    var readFromDocValues = !!spec.readFromDocValues && !scripted;
    var sortable = spec.name === '_score' || (indexed || aggregatable) && type.sortable;
    var filterable = spec.name === '_id' || scripted || (indexed || searchable) && type.filterable;
    var visualizable = aggregatable;

    obj.fact('name');
    obj.fact('type');
    obj.writ('count', spec.count || 0);

    // scripted objs
    obj.fact('scripted', scripted);
    obj.writ('script', scripted ? spec.script : null);
    obj.writ('lang', scripted ? spec.lang || 'painless' : null);

    // stats
    obj.fact('searchable', searchable);
    obj.fact('aggregatable', aggregatable);
    obj.fact('readFromDocValues', readFromDocValues);

    // usage flags, read-only and won't be saved
    obj.comp('format', format);
    obj.comp('sortable', sortable);
    obj.comp('filterable', filterable);
    obj.comp('visualizable', visualizable);

    // computed values
    obj.comp('indexPattern', indexPattern);
    obj.comp('displayName', shortDotsFilter(spec.name));
    obj.comp('$$spec', spec);

    // conflict info
    obj.writ('conflictDescriptions');

    return obj.create();
  }

  Object.defineProperties(Field.prototype, {
    indexed: {
      get: function get() {
        throw new Error('field.indexed has been removed, see https://github.com/elastic/kibana/pull/11969');
      }
    },
    analyzed: {
      get: function get() {
        throw new Error('field.analyzed has been removed, see https://github.com/elastic/kibana/pull/11969');
      }
    },
    doc_values: {
      get: function get() {
        throw new Error('field.doc_values has been removed, see https://github.com/elastic/kibana/pull/11969');
      }
    }
  });

  Field.prototype.routes = {
    edit: '/management/kibana/indices/{{indexPattern.id}}/field/{{name}}'
  };

  return Field;
}

/***/ }),
/* 471 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _fetch_soon = __webpack_require__(2046);

Object.defineProperty(exports, 'FetchSoonProvider', {
  enumerable: true,
  get: function get() {
    return _fetch_soon.FetchSoonProvider;
  }
});

/***/ }),
/* 472 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _field_wildcard = __webpack_require__(2058);

Object.defineProperty(exports, 'FieldWildcardProvider', {
  enumerable: true,
  get: function get() {
    return _field_wildcard.FieldWildcardProvider;
  }
});

/***/ }),
/* 473 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildNode = buildNode;
exports.toElasticsearchQuery = toElasticsearchQuery;
exports.toKueryExpression = toKueryExpression;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function buildNode(value) {
  return {
    type: 'literal',
    value: value
  };
}

function toElasticsearchQuery(node) {
  return node.value;
}

function toKueryExpression(node) {
  if (_lodash2.default.isString(node.value)) {
    var escapedValue = node.value.replace(/"/g, '\\"');
    return '"' + escapedValue + '"';
  }

  return node.value;
}

/***/ }),
/* 474 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.luceneStringToDsl = luceneStringToDsl;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function luceneStringToDsl(query) {
  if (!_lodash2.default.isString(query)) {
    return query;
  }

  if (query.trim() === '') {
    return { match_all: {} };
  }

  return { query_string: { query: query } };
}

/***/ }),
/* 475 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.documentationLinks = exports.ELASTIC_WEBSITE_URL = exports.DOC_LINK_VERSION = undefined;

var _metadata = __webpack_require__(225);

var DOC_LINK_VERSION = exports.DOC_LINK_VERSION = _metadata.metadata.branch;
var ELASTIC_WEBSITE_URL = exports.ELASTIC_WEBSITE_URL = 'https://www.elastic.co/';

var documentationLinks = exports.documentationLinks = {
  filebeat: {
    base: ELASTIC_WEBSITE_URL + 'guide/en/beats/filebeat/' + DOC_LINK_VERSION,
    installation: ELASTIC_WEBSITE_URL + 'guide/en/beats/filebeat/' + DOC_LINK_VERSION + '/filebeat-installation.html',
    configuration: ELASTIC_WEBSITE_URL + 'guide/en/beats/filebeat/' + DOC_LINK_VERSION + '/filebeat-configuration.html',
    elasticsearchOutput: ELASTIC_WEBSITE_URL + 'guide/en/beats/filebeat/' + DOC_LINK_VERSION + '/elasticsearch-output.html',
    elasticsearchOutputAnchorParameters: ELASTIC_WEBSITE_URL + 'guide/en/beats/filebeat/' + DOC_LINK_VERSION + '/elasticsearch-output.html#_parameters',
    startup: ELASTIC_WEBSITE_URL + 'guide/en/beats/filebeat/' + DOC_LINK_VERSION + '/filebeat-starting.html',
    exportedFields: ELASTIC_WEBSITE_URL + 'guide/en/beats/filebeat/' + DOC_LINK_VERSION + '/exported-fields.html'
  },
  metricbeat: {
    base: ELASTIC_WEBSITE_URL + 'guide/en/beats/metricbeat/' + DOC_LINK_VERSION
  },
  logstash: {
    base: ELASTIC_WEBSITE_URL + 'guide/en/logstash/' + DOC_LINK_VERSION
  },
  scriptedFields: {
    scriptFields: ELASTIC_WEBSITE_URL + 'guide/en/elasticsearch/reference/' + DOC_LINK_VERSION + '/search-request-script-fields.html',
    scriptAggs: ELASTIC_WEBSITE_URL + 'guide/en/elasticsearch/reference/' + DOC_LINK_VERSION + '/search-aggregations.html#_values_source',
    painless: ELASTIC_WEBSITE_URL + 'guide/en/elasticsearch/reference/' + DOC_LINK_VERSION + '/modules-scripting-painless.html',
    painlessApi: ELASTIC_WEBSITE_URL + 'guide/en/elasticsearch/reference/' + DOC_LINK_VERSION + '/modules-scripting-painless.html#painless-api',
    painlessSyntax: ELASTIC_WEBSITE_URL + 'guide/en/elasticsearch/reference/' + DOC_LINK_VERSION + '/modules-scripting-painless-syntax.html',
    luceneExpressions: ELASTIC_WEBSITE_URL + 'guide/en/elasticsearch/reference/' + DOC_LINK_VERSION + '/modules-scripting-expression.html'
  },
  indexPatterns: {
    loadingData: ELASTIC_WEBSITE_URL + 'guide/en/kibana/' + DOC_LINK_VERSION + '/tutorial-load-dataset.html',
    introduction: ELASTIC_WEBSITE_URL + 'guide/en/kibana/' + DOC_LINK_VERSION + '/index-patterns.html'
  },
  query: {
    luceneQuerySyntax: ELASTIC_WEBSITE_URL + 'guide/en/elasticsearch/reference/' + DOC_LINK_VERSION + '/query-dsl-query-string-query.html#query-string-syntax',
    queryDsl: ELASTIC_WEBSITE_URL + 'guide/en/elasticsearch/reference/' + DOC_LINK_VERSION + '/query-dsl.html',
    kueryQuerySyntax: ELASTIC_WEBSITE_URL + 'guide/en/kibana/' + DOC_LINK_VERSION + '/kuery-query.html'
  },
  date: {
    dateMath: ELASTIC_WEBSITE_URL + 'guide/en/elasticsearch/reference/' + DOC_LINK_VERSION + '/common-options.html#date-math'
  }
};

/***/ }),
/* 476 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(460);
__webpack_require__(2115);
__webpack_require__(2117);

__webpack_require__(2).get('kibana', ['ui.ace']);

module.exports = window.ace;


/***/ }),
/* 477 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _angular = __webpack_require__(16);

var _angular2 = _interopRequireDefault(_angular);

var _modules = __webpack_require__(2);

__webpack_require__(2119);

var _eui = __webpack_require__(11);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The `kbn-ui-ace-keyboard-mode` directive should be used on any element, that
 * `ui-ace` is used on. It will prevent the keyboard trap, that ui-ace usually
 * has, i.e. tabbing into the box won't give you any possibilities to leave
 * it via keyboard again, since tab inside the textbox works like a tab character.
 *
 * This directive won't change anything, if the user uses the mouse. But if she
 * tabs to the ace editor, an overlay will be shown, that you have to press Enter
 * to enter editing mode, and that it can be left by pressing Escape again.
 *
 * That way the ui-ace editor won't trap keyboard focus, and won't cause that
 * accessibility issue anymore.
 */

var aceKeyboardModeId = 0;

_modules.uiModules.get('kibana').factory('kbnUiAceKeyboardModeService', function () {
  return {
    initialize: function initialize(scope, element) {
      var uniqueId = 'uiAceKeyboardHint-' + scope.$id + '-' + aceKeyboardModeId++;

      var hint = _angular2.default.element('<div\n        class="uiAceKeyboardHint"\n        id="' + uniqueId + '"\n        tabindex="0"\n        role="application"\n      >\n        <p class="kuiText kuiVerticalRhythmSmall">\n          Press Enter to start editing.\n        </p>\n        <p class="kuiText kuiVerticalRhythmSmall">\n          When you&rsquo;re done, press Escape to stop editing.\n        </p>\n      </div>\n    ');

      var uiAceTextbox = element.find('textarea');

      function startEditing() {
        // We are not using ng-class in the element, so that we won't need to $compile it
        hint.addClass('uiAceKeyboardHint-isInactive');
        uiAceTextbox.focus();
      }

      function enableOverlay() {
        hint.removeClass('uiAceKeyboardHint-isInactive');
      }

      hint.keydown(function (ev) {
        if (ev.keyCode === _eui.keyCodes.ENTER) {
          ev.preventDefault();
          startEditing();
        }
      });

      uiAceTextbox.blur(function () {
        enableOverlay();
      });

      uiAceTextbox.keydown(function (ev) {
        if (ev.keyCode === _eui.keyCodes.ESCAPE) {
          ev.preventDefault();
          ev.stopPropagation();
          enableOverlay();
          hint.focus();
        }
      });

      hint.click(startEditing);
      // Prevent tabbing into the ACE textarea, we now handle all focusing for it
      uiAceTextbox.attr('tabindex', '-1');
      element.prepend(hint);
    }
  };
}).directive('kbnUiAceKeyboardMode', function (kbnUiAceKeyboardModeService) {
  return {
    restrict: 'A',
    link: function link(scope, element) {
      kbnUiAceKeyboardModeService.initialize(scope, element);
    }
  };
});

/***/ }),
/* 478 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getQueryDslFromFilter = getQueryDslFromFilter;
exports.getFieldFromFilter = getFieldFromFilter;
exports.getOperatorFromFilter = getOperatorFromFilter;
exports.getParamsFromFilter = getParamsFromFilter;
exports.getFieldOptions = getFieldOptions;
exports.getOperatorOptions = getOperatorOptions;
exports.isFilterValid = isFilterValid;
exports.buildFilter = buildFilter;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _filter_operators = __webpack_require__(780);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function getQueryDslFromFilter(filter) {
  return (0, _lodash2.default)(filter).omit(['meta', '$state']).cloneDeep();
}

function getFieldFromFilter(filter, indexPatterns) {
  var _filter$meta = filter.meta,
      index = _filter$meta.index,
      key = _filter$meta.key;

  return indexPatterns.get(index).then(function (indexPattern) {
    return indexPattern.id && indexPattern.fields.byName[key];
  });
}

function getOperatorFromFilter(filter) {
  var _filter$meta2 = filter.meta,
      type = _filter$meta2.type,
      negate = _filter$meta2.negate;

  return _filter_operators.FILTER_OPERATORS.find(function (operator) {
    return operator.type === type && operator.negate === negate;
  });
}

function getParamsFromFilter(filter) {
  var _filter$meta3 = filter.meta,
      type = _filter$meta3.type,
      key = _filter$meta3.key;

  var params = void 0;
  if (type === 'phrase') {
    params = filter.query ? filter.query.match[key].query : filter.script.script.params.value;
  } else if (type === 'phrases') {
    params = filter.meta.params;
  } else if (type === 'range') {
    var range = filter.range ? filter.range[key] : filter.script.script.params;
    var from = _lodash2.default.has(range, 'gte') ? range.gte : range.gt;
    var to = _lodash2.default.has(range, 'lte') ? range.lte : range.lt;
    params = { from: from, to: to };
  }
  return _defineProperty({}, type, params);
}

function getFieldOptions(indexPatterns) {
  return (indexPatterns || []).reduce(function (fields, indexPattern) {
    var filterableFields = indexPattern.fields.filter(function (field) {
      return field.filterable;
    });
    return [].concat(_toConsumableArray(fields), _toConsumableArray(filterableFields));
  }, []);
}

function getOperatorOptions(field) {
  var type = _lodash2.default.get(field, 'type');
  return _filter_operators.FILTER_OPERATORS.filter(function (operator) {
    return !operator.fieldTypes || operator.fieldTypes.includes(type);
  });
}

function isFilterValid(_ref2) {
  var field = _ref2.field,
      operator = _ref2.operator,
      params = _ref2.params;

  if (!field || !operator) {
    return false;
  } else if (operator.type === 'phrase') {
    return _lodash2.default.has(params, 'phrase') && params.phrase !== '';
  } else if (operator.type === 'phrases') {
    return _lodash2.default.has(params, 'phrases') && params.phrases.length > 0;
  } else if (operator.type === 'range') {
    var hasFrom = _lodash2.default.has(params, ['range', 'from']) && params.range.from !== '';
    var hasTo = _lodash2.default.has(params, ['range', 'to']) && params.range.to !== '';
    return hasFrom || hasTo;
  }
  return true;
}

function buildFilter(_ref3) {
  var indexPattern = _ref3.indexPattern,
      field = _ref3.field,
      operator = _ref3.operator,
      params = _ref3.params,
      filterBuilder = _ref3.filterBuilder;

  var filter = void 0;
  if (operator.type === 'phrase') {
    filter = filterBuilder.buildPhraseFilter(field, params.phrase, indexPattern);
  } else if (operator.type === 'phrases') {
    filter = filterBuilder.buildPhrasesFilter(field, params.phrases, indexPattern);
  } else if (operator.type === 'range') {
    filter = filterBuilder.buildRangeFilter(field, { gte: params.range.from, lt: params.range.to }, indexPattern);
  } else if (operator.type === 'exists') {
    filter = filterBuilder.buildExistsFilter(field, indexPattern);
  }
  filter.meta.negate = operator.negate;
  return filter;
}

/***/ }),
/* 479 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _datemath = __webpack_require__(90);

var _datemath2 = _interopRequireDefault(_datemath);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_modules.uiModules.get('kibana').directive('validateDateMath', function () {
  return {
    restrict: 'A',
    require: 'ngModel',
    scope: {
      'ngModel': '='
    },
    link: function link($scope, elem, attr, ngModel) {
      ngModel.$parsers.unshift(validateDateMath);
      ngModel.$formatters.unshift(validateDateMath);

      function validateDateMath(input) {
        if (input == null || input === '') {
          ngModel.$setValidity('validDateMath', true);
          return null;
        }

        var moment = _datemath2.default.parse(input);
        ngModel.$setValidity('validDateMath', moment != null && moment.isValid());
        return input;
      }
    }
  };
});

/***/ }),
/* 480 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _ipv4_address = __webpack_require__(783);

var _ipv4_address2 = _interopRequireDefault(_ipv4_address);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_modules.uiModules.get('kibana').directive('validateIp', function () {
  return {
    restrict: 'A',
    require: 'ngModel',
    scope: {
      'ngModel': '='
    },
    link: function link($scope, elem, attr, ngModel) {
      function validateIp(ipAddress) {
        if (ipAddress == null || ipAddress === '') {
          ngModel.$setValidity('ipInput', true);
          return null;
        }

        try {
          ipAddress = new _ipv4_address2.default(ipAddress);
          ngModel.$setValidity('ipInput', true);
          return ipAddress.toString();
        } catch (e) {
          ngModel.$setValidity('ipInput', false);
        }
      }

      // From User
      ngModel.$parsers.unshift(validateIp);

      // To user
      ngModel.$formatters.unshift(validateIp);
    }
  };
});

/***/ }),
/* 481 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _module = _modules.uiModules.get('kibana');

_module.directive('focusOn', function ($timeout) {
  return {
    restrict: 'A',
    link: function link(scope, elem, attrs) {
      scope.$on(attrs.focusOn, function () {
        $timeout(function () {
          return elem.find('input,select').addBack('input,select').focus();
        });
      });
    }
  };
});

/***/ }),
/* 482 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildPhrasesFilter = buildPhrasesFilter;

var _phrase = __webpack_require__(175);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function buildPhrasesFilter(field, params, indexPattern) {
  var index = indexPattern.id;
  var type = 'phrases';
  var key = field.name;
  var value = params.map(function (value) {
    return field.format.convert(value);
  }).join(', ');

  var filter = {
    meta: { index: index, type: type, key: key, value: value, params: params }
  };

  var should = void 0;
  if (field.scripted) {
    should = params.map(function (value) {
      return {
        script: (0, _phrase.getPhraseScript)(field, value)
      };
    });
  } else {
    should = params.map(function (value) {
      return {
        match_phrase: _defineProperty({}, field.name, value)
      };
    });
  }

  filter.query = {
    bool: {
      should: should,
      minimum_should_match: 1
    }
  };

  return filter;
}

/***/ }),
/* 483 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var keyMap = exports.keyMap = {
  8: 'backspace',
  9: 'tab',
  13: 'enter',
  16: 'shift',
  17: 'ctrl',
  18: 'alt',
  19: 'pause',
  20: 'capsLock',
  27: 'escape',
  32: 'space',
  33: 'pageUp',
  34: 'pageDown',
  35: 'end',
  36: 'home',
  37: 'left',
  38: 'up',
  39: 'right',
  40: 'down',
  45: 'insert',
  46: 'delete',
  48: '0',
  49: '1',
  50: '2',
  51: '3',
  52: '4',
  53: '5',
  54: '6',
  55: '7',
  56: '8',
  57: '9',
  65: 'a',
  66: 'b',
  67: 'c',
  68: 'd',
  69: 'e',
  70: 'f',
  71: 'g',
  72: 'h',
  73: 'i',
  74: 'j',
  75: 'k',
  76: 'l',
  77: 'm',
  78: 'n',
  79: 'o',
  80: 'p',
  81: 'q',
  82: 'r',
  83: 's',
  84: 't',
  85: 'u',
  86: 'v',
  87: 'w',
  88: 'x',
  89: 'y',
  90: 'z',
  91: 'leftWindowKey',
  92: 'rightWindowKey',
  93: 'selectKey',
  96: '0',
  97: '1',
  98: '2',
  99: '3',
  100: '4',
  101: '5',
  102: '6',
  103: '7',
  104: '8',
  105: '9',
  106: 'multiply',
  107: 'add',
  109: 'subtract',
  110: 'period',
  111: 'divide',
  112: 'f1',
  113: 'f2',
  114: 'f3',
  115: 'f4',
  116: 'f5',
  117: 'f6',
  118: 'f7',
  119: 'f8',
  120: 'f9',
  121: 'f10',
  122: 'f11',
  123: 'f12',
  144: 'numLock',
  145: 'scrollLock',
  186: 'semiColon',
  187: 'equalSign',
  188: 'comma',
  189: 'dash',
  190: 'period',
  191: 'forwardSlash',
  192: 'graveAccent',
  219: 'openBracket',
  220: 'backSlash',
  221: 'closeBraket',
  222: 'singleQuote',
  224: 'meta'
};

/***/ }),
/* 484 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ModalOverlay = exports.ConfirmationButtonTypes = undefined;

var _confirm_modal = __webpack_require__(485);

Object.defineProperty(exports, 'ConfirmationButtonTypes', {
  enumerable: true,
  get: function get() {
    return _confirm_modal.ConfirmationButtonTypes;
  }
});

var _modal_overlay = __webpack_require__(792);

Object.defineProperty(exports, 'ModalOverlay', {
  enumerable: true,
  get: function get() {
    return _modal_overlay.ModalOverlay;
  }
});

__webpack_require__(485);

__webpack_require__(2167);

/***/ }),
/* 485 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConfirmationButtonTypes = undefined;

var _angular = __webpack_require__(16);

var _angular2 = _interopRequireDefault(_angular);

var _lodash = __webpack_require__(1);

var _modules = __webpack_require__(2);

var _confirm_modal = __webpack_require__(2165);

var _confirm_modal2 = _interopRequireDefault(_confirm_modal);

var _modal_overlay = __webpack_require__(792);

var _eui = __webpack_require__(11);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');

var ConfirmationButtonTypes = exports.ConfirmationButtonTypes = {
  CONFIRM: _eui.EUI_MODAL_CONFIRM_BUTTON,
  CANCEL: _eui.EUI_MODAL_CANCEL_BUTTON
};

/**
 * @typedef {Object} ConfirmModalOptions
 * @property {String} confirmButtonText
 * @property {String=} cancelButtonText
 * @property {function} onConfirm
 * @property {function=} onCancel
 * @property {String=} title - If given, shows a title on the confirm modal.
 */

_module.factory('confirmModal', function ($rootScope, $compile) {
  var modalPopover = void 0;
  var confirmQueue = [];

  /**
   * @param {String} message - the message to show in the body of the confirmation dialog.
   * @param {ConfirmModalOptions} - Options to further customize the dialog.
   */
  return function confirmModal(message, customOptions) {
    var defaultOptions = {
      onCancel: _lodash.noop,
      cancelButtonText: 'Cancel',
      defaultFocusedButton: ConfirmationButtonTypes.CONFIRM
    };

    if (!customOptions.confirmButtonText || !customOptions.onConfirm) {
      throw new Error('Please specify confirmation button text and onConfirm action');
    }

    var options = Object.assign(defaultOptions, customOptions);

    // Special handling for onClose - if no specific callback was supplied, default to the
    // onCancel callback.
    options.onClose = customOptions.onClose || options.onCancel;

    var confirmScope = $rootScope.$new();

    confirmScope.message = message;
    confirmScope.defaultFocusedButton = options.defaultFocusedButton;
    confirmScope.confirmButtonText = options.confirmButtonText;
    confirmScope.cancelButtonText = options.cancelButtonText;
    confirmScope.title = options.title;
    confirmScope.onConfirm = function () {
      destroy();
      options.onConfirm();
    };
    confirmScope.onCancel = function () {
      destroy();
      options.onCancel();
    };
    confirmScope.onClose = function () {
      destroy();
      options.onClose();
    };

    function showModal(confirmScope) {
      var modalInstance = $compile(_confirm_modal2.default)(confirmScope);
      modalPopover = new _modal_overlay.ModalOverlay(modalInstance);
    }

    if (modalPopover) {
      confirmQueue.unshift(confirmScope);
    } else {
      showModal(confirmScope);
    }

    function destroy() {
      modalPopover.destroy();
      modalPopover = undefined;
      _angular2.default.element(document.body).off('keydown');
      confirmScope.$destroy();

      if (confirmQueue.length > 0) {
        showModal(confirmQueue.pop());
      }
    }
  };
});

/***/ }),
/* 486 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var relativeOptions = exports.relativeOptions = [{ text: 'Seconds ago', value: 's' }, { text: 'Minutes ago', value: 'm' }, { text: 'Hours ago', value: 'h' }, { text: 'Days ago', value: 'd' }, { text: 'Weeks ago', value: 'w' }, { text: 'Months ago', value: 'M' }, { text: 'Years ago', value: 'y' }, { text: 'Seconds from now', value: 's+' }, { text: 'Minutes from now', value: 'm+' }, { text: 'Hours from now', value: 'h+' }, { text: 'Days from now', value: 'd+' }, { text: 'Weeks from now', value: 'w+' }, { text: 'Months from now', value: 'M+' }, { text: 'Years from now', value: 'y+' }];

/***/ }),
/* 487 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

function makeDirectiveDef(id, compare) {
  return function ($parse) {
    return {
      require: 'ngModel',
      link: function link($scope, $el, $attr, ngModel) {
        var getBound = function getBound() {
          return $parse($attr[id])();
        };
        var defaultVal = {
          'greaterThan': -Infinity,
          'greaterOrEqualThan': -Infinity,
          'lessThan': Infinity
        }[id];

        ngModel.$parsers.push(validate);
        ngModel.$formatters.push(validate);

        $scope.$watch(getBound, function () {
          validate(ngModel.$viewValue);
        });

        function validate(val) {
          var bound = !isNaN(getBound()) ? +getBound() : defaultVal;
          var valid = !isNaN(bound) && !isNaN(val) && compare(val, bound);
          ngModel.$setValidity(id, valid);
          return val;
        }
      }
    };
  };
}

_modules.uiModules.get('kibana').directive('greaterThan', makeDirectiveDef('greaterThan', function (a, b) {
  return a > b;
})).directive('lessThan', makeDirectiveDef('lessThan', function (a, b) {
  return a < b;
})).directive('greaterOrEqualThan', makeDirectiveDef('greaterOrEqualThan', function (a, b) {
  return a >= b;
}));

/***/ }),
/* 488 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _parse_interval = __webpack_require__(489);

var _modules = __webpack_require__(2);

_modules.uiModules.get('kibana').directive('validateDateInterval', function () {
  return {
    restrict: 'A',
    require: 'ngModel',
    link: function link($scope, $el, attrs, ngModelCntrl) {

      ngModelCntrl.$parsers.push(check);
      ngModelCntrl.$formatters.push(check);

      function check(value) {
        ngModelCntrl.$setValidity('dateInterval', (0, _parse_interval.parseInterval)(value) != null);
        return value;
      }
    }
  };
});

/***/ }),
/* 489 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseInterval = parseInterval;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

var _datemath = __webpack_require__(90);

var _datemath2 = _interopRequireDefault(_datemath);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Assume interval is in the form (value)(unit), such as "1h"
var INTERVAL_STRING_RE = new RegExp('^([0-9\\.]*)\\s*(' + _datemath2.default.units.join('|') + ')$');

function parseInterval(interval) {
  var matches = String(interval).trim().match(INTERVAL_STRING_RE);

  if (!matches) return null;

  try {
    var value = parseFloat(matches[1]) || 1;
    var unit = matches[2];

    var duration = _moment2.default.duration(value, unit);

    // There is an error with moment, where if you have a fractional interval between 0 and 1, then when you add that
    // interval to an existing moment object, it will remain unchanged, which causes problems in the ordered_x_keys
    // code. To counteract this, we find the first unit that doesn't result in a value between 0 and 1.
    // For example, if you have '0.5d', then when calculating the x-axis series, we take the start date and begin
    // adding 0.5 days until we hit the end date. However, since there is a bug in moment, when you add 0.5 days to
    // the start date, you get the same exact date (instead of being ahead by 12 hours). So instead of returning
    // a duration corresponding to 0.5 hours, we return a duration corresponding to 12 hours.
    var selectedUnit = _lodash2.default.find(_datemath2.default.units, function (unit) {
      return Math.abs(duration.as(unit)) >= 1;
    });

    return _moment2.default.duration(duration.as(selectedUnit), selectedUnit);
  } catch (e) {
    return null;
  }
}

/***/ }),
/* 490 */,
/* 491 */,
/* 492 */,
/* 493 */,
/* 494 */,
/* 495 */,
/* 496 */,
/* 497 */,
/* 498 */,
/* 499 */,
/* 500 */,
/* 501 */,
/* 502 */,
/* 503 */,
/* 504 */,
/* 505 */,
/* 506 */,
/* 507 */,
/* 508 */,
/* 509 */,
/* 510 */,
/* 511 */,
/* 512 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _outside_click_detector = __webpack_require__(2523);

Object.defineProperty(exports, 'KuiOutsideClickDetector', {
  enumerable: true,
  get: function get() {
    return _outside_click_detector.KuiOutsideClickDetector;
  }
});

/***/ }),
/* 513 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _module = _modules.uiModules.get('kibana');

_module.directive('cssTruncate', function () {
  return {
    restrict: 'A',
    scope: {},
    link: function link($scope, $elem, attrs) {

      $elem.css({
        overflow: 'hidden',
        'white-space': 'nowrap',
        'text-overflow': 'ellipsis',
        'word-break': 'break-all'
      });

      if (attrs.cssTruncateExpandable != null) {
        $scope.$watch(function () {
          return $elem.html();
        }, function () {
          if ($elem[0].offsetWidth < $elem[0].scrollWidth) {
            $elem.css({ 'cursor': 'pointer' });
            $elem.bind('click', function () {
              $scope.toggle();
            });
          }
        });
      }

      $scope.toggle = function () {
        if ($elem.css('white-space') !== 'normal') {
          $elem.css({ 'white-space': 'normal' });
        } else {
          $elem.css({ 'white-space': 'nowrap' });
        }
      };

      $scope.$on('$destroy', function () {
        $elem.unbind('click');
        $elem.unbind('mouseenter');
      });
    }
  };
});

/***/ }),
/* 514 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

__webpack_require__(249);

var _boolean_field_name_icon = __webpack_require__(2621);

var _boolean_field_name_icon2 = _interopRequireDefault(_boolean_field_name_icon);

var _conflict_field_name_icon = __webpack_require__(2622);

var _conflict_field_name_icon2 = _interopRequireDefault(_conflict_field_name_icon);

var _date_field_name_icon = __webpack_require__(2623);

var _date_field_name_icon2 = _interopRequireDefault(_date_field_name_icon);

var _geo_point_field_name_icon = __webpack_require__(2624);

var _geo_point_field_name_icon2 = _interopRequireDefault(_geo_point_field_name_icon);

var _ip_field_name_icon = __webpack_require__(2625);

var _ip_field_name_icon2 = _interopRequireDefault(_ip_field_name_icon);

var _murmur3_field_name_icon = __webpack_require__(2626);

var _murmur3_field_name_icon2 = _interopRequireDefault(_murmur3_field_name_icon);

var _number_field_name_icon = __webpack_require__(2627);

var _number_field_name_icon2 = _interopRequireDefault(_number_field_name_icon);

var _source_field_name_icon = __webpack_require__(2628);

var _source_field_name_icon2 = _interopRequireDefault(_source_field_name_icon);

var _string_field_name_icon = __webpack_require__(2629);

var _string_field_name_icon2 = _interopRequireDefault(_string_field_name_icon);

var _unknown_field_name_icon = __webpack_require__(2630);

var _unknown_field_name_icon2 = _interopRequireDefault(_unknown_field_name_icon);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');

_module.directive('fieldName', function ($compile, $rootScope, $filter) {
  return {
    restrict: 'AE',
    scope: {
      'field': '=',
      'fieldName': '=',
      'fieldType': '='
    },
    link: function link($scope, $el) {
      var typeToIconMap = {
        boolean: _boolean_field_name_icon2.default,
        conflict: _conflict_field_name_icon2.default,
        date: _date_field_name_icon2.default,
        geo_point: _geo_point_field_name_icon2.default,
        ip: _ip_field_name_icon2.default,
        murmur3: _murmur3_field_name_icon2.default,
        number: _number_field_name_icon2.default,
        source: _source_field_name_icon2.default,
        string: _string_field_name_icon2.default
      };

      function typeIcon(fieldType) {
        if (typeToIconMap.hasOwnProperty(fieldType)) {
          return typeToIconMap[fieldType];
        }

        return _unknown_field_name_icon2.default;
      }

      $rootScope.$watchMulti.call($scope, ['field', 'fieldName', 'fieldType', 'field.rowCount'], function () {

        var type = $scope.field ? $scope.field.type : $scope.fieldType;
        var name = $scope.field ? $scope.field.name : $scope.fieldName;
        var results = $scope.field ? !$scope.field.rowCount && !$scope.field.scripted : false;
        var scripted = $scope.field ? $scope.field.scripted : false;

        var displayName = $filter('shortDots')(name);

        $el.attr('title', name).toggleClass('no-results', results).toggleClass('scripted', scripted).prepend(typeIcon(type)).append((0, _jquery2.default)('<span>').text(displayName).addClass('discover-field-name'));
      });
    }
  };
});

/***/ }),
/* 515 */,
/* 516 */,
/* 517 */,
/* 518 */,
/* 519 */,
/* 520 */,
/* 521 */,
/* 522 */,
/* 523 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _prop_filter = __webpack_require__(916);

var _modules = __webpack_require__(2);

// Gets all fields of a given type.
// You may also pass "*" to get all types
// Or an array of types to get all fields of that type

_modules.uiModules.get('kibana').filter('fieldType', function () {
  return (0, _prop_filter.propFilter)('type');
});

/***/ }),
/* 524 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _panel_registry = __webpack_require__(171);

var _panel_registry2 = _interopRequireDefault(_panel_registry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

__webpack_require__(2).get('apps/timelion', []).directive('chart', function (Private) {
  return {
    restrict: 'A',
    scope: {
      seriesList: '=chart', // The flot object, data, config and all
      search: '=', // The function to execute to kick off a search
      interval: '=' // Required for formatting x-axis ticks
    },
    link: function link($scope, $elem) {

      var panelRegistry = Private(_panel_registry2.default);
      var panelScope = $scope.$new(true);

      function render(seriesList) {
        panelScope.$destroy();

        if (!seriesList) return;

        seriesList.render = seriesList.render || {
          type: 'timechart'
        };

        var panelSchema = panelRegistry.byName[seriesList.render.type];

        if (!panelSchema) {
          $elem.text('No such panel type: ' + seriesList.render.type);
          return;
        }

        panelScope = $scope.$new(true);
        panelScope.seriesList = seriesList;
        panelScope.interval = $scope.interval;
        panelScope.search = $scope.search;

        panelSchema.render(panelScope, $elem);
      }

      $scope.$watch('seriesList', render);
    }
  };
});

/***/ }),
/* 525 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReactVisTypeProvider = exports.VislibVisTypeProvider = exports.AngularVisTypeProvider = exports.VisTypeProvider = undefined;

var _base_vis_type = __webpack_require__(930);

var _angular_vis_type = __webpack_require__(2946);

var _vislib_vis_type = __webpack_require__(2947);

var _react_vis_type = __webpack_require__(3038);

exports.VisTypeProvider = _base_vis_type.VisTypeProvider;
exports.AngularVisTypeProvider = _angular_vis_type.AngularVisTypeProvider;
exports.VislibVisTypeProvider = _vislib_vis_type.VislibVisTypeProvider;
exports.ReactVisTypeProvider = _react_vis_type.ReactVisTypeProvider;

/***/ }),
/* 526 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _vislib_basic_options = __webpack_require__(2948);

var _vislib_basic_options2 = _interopRequireDefault(_vislib_basic_options);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');

_module.directive('vislibBasicOptions', function () {
  return {
    restrict: 'E',
    template: _vislib_basic_options2.default,
    replace: true
  };
});

/***/ }),
/* 527 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesAggTypeProvider = AggTypesAggTypeProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _agg_params = __webpack_require__(528);

var _field_formats = __webpack_require__(64);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function AggTypesAggTypeProvider(Private) {
  var AggParams = Private(_agg_params.AggTypesAggParamsProvider);
  var fieldFormats = Private(_field_formats.RegistryFieldFormatsProvider);

  /**
   * Generic AggType Constructor
   *
   * Used to create the values exposed by the agg_types module.
   *
   * @class AggType
   * @private
   * @param {object} config - used to set the properties of the AggType
   */
  function AggType(config) {

    /**
     * the unique, unchanging, name that we have assigned this aggType
     *
     * @property name
     * @type {string}
     */
    this.name = config.name;

    /**
     * the name of the elasticsearch aggregation that this aggType represents. Usually just this.name
     *
     * @property name
     * @type {string}
     */
    this.dslName = config.dslName || config.name;

    /**
     * the user friendly name that will be shown in the ui for this aggType
     *
     * @property title
     * @type {string}
     */
    this.title = config.title;

    /**
     * a function that will be called when this aggType is assigned to
     * an aggConfig, and that aggConfig is being rendered (in a form, chart, etc.).
     *
     * @method makeLabel
     * @param {AggConfig} aggConfig - an agg config of this type
     * @returns {string} - label that can be used in the ui to descripe the aggConfig
     */
    this.makeLabel = config.makeLabel || _lodash2.default.constant(this.name);

    /**
     * Describes if this aggType creates data that is ordered, and if that ordered data
     * is some sort of time series.
     *
     * If the aggType does not create ordered data, set this to something "falsey".
     *
     * If this does create orderedData, then the value should be an object.
     *
     * If the orderdata is some sort of time series, `this.ordered` should be an object
     * with the property `date: true`
     *
     * @property ordered
     * @type {object|undefined}
     */
    this.ordered = config.ordered;

    /**
     * Flag that prevents this aggregation from being included in the dsl. This is only
     * used by the count aggregation (currently) since it doesn't really exist and it's output
     * is available on every bucket.
     *
     * @type {Boolean}
     */
    this.hasNoDsl = !!config.hasNoDsl;

    /**
     * The method to create a filter representation of the bucket
     * @param {object} aggConfig The instance of the aggConfig
     * @param {mixed} key The key for the bucket
     * @returns {object} The filter
     */
    this.createFilter = config.createFilter;

    /**
     * An instance of {{#crossLink "AggParams"}}{{/crossLink}}.
     *
     * @property params
     * @type {AggParams}
     */
    this.params = config.params || [];
    if (!(this.params instanceof AggParams)) {
      // always append the raw JSON param
      this.params.push({
        name: 'json',
        type: 'json',
        advanced: true
      });
      // always append custom label

      if (config.customLabels !== false) {
        this.params.push({
          name: 'customLabel',
          type: 'string',
          write: _lodash2.default.noop
        });
      }

      this.params = new AggParams(this.params);
    }

    /**
     * Designed for multi-value metric aggs, this method can return a
     * set of AggConfigs that should replace this aggConfig in requests
     *
     * @method getRequestAggs
     * @returns {array[AggConfig]|undefined} - an array of aggConfig objects
     *                                         that should replace this one,
     *                                         or undefined
     */
    this.getRequestAggs = config.getRequestAggs || _lodash2.default.noop;

    /**
     * Designed for multi-value metric aggs, this method can return a
     * set of AggConfigs that should replace this aggConfig in result sets
     * that walk the AggConfig set.
     *
     * @method getResponseAggs
     * @returns {array[AggConfig]|undefined} - an array of aggConfig objects
     *                                         that should replace this one,
     *                                         or undefined
     */
    this.getResponseAggs = config.getResponseAggs || _lodash2.default.noop;

    /**
     * A function that will be called each time an aggConfig of this type
     * is created, giving the agg type a chance to modify the agg config
     */
    this.decorateAggConfig = config.decorateAggConfig || null;

    /**
     * A function that needs to be called after the main request has been made
     * and should return an updated response
     * @param aggConfigs - agg config array used to produce main request
     * @param aggConfig - AggConfig that requested the post flight request
     * @param searchSourceAggs - SearchSource aggregation configuration
     * @param resp - Response to the main request
     * @param nestedSearchSource - the new SearchSource that will be used to make post flight request
     * @return {Promise}
     */
    this.postFlightRequest = config.postFlightRequest || _lodash2.default.identity;

    if (config.getFormat) {
      this.getFormat = config.getFormat;
    }
  }

  /**
   * Pick a format for the values produced by this agg type,
   * overriden by several metrics that always output a simple
   * number
   *
   * @param  {agg} agg - the agg to pick a format for
   * @return {FieldFromat}
   */
  AggType.prototype.getFormat = function (agg) {
    var field = agg.getField();
    return field ? field.format : fieldFormats.getDefaultInstance('string');
  };

  return AggType;
}

/***/ }),
/* 528 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesAggParamsProvider = AggTypesAggParamsProvider;

__webpack_require__(917);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _indexed_array = __webpack_require__(99);

var _field = __webpack_require__(2971);

var _optioned = __webpack_require__(2973);

var _regex = __webpack_require__(2974);

var _string = __webpack_require__(2976);

var _json = __webpack_require__(2978);

var _base = __webpack_require__(211);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function AggTypesAggParamsProvider(Private) {
  var paramTypeMap = {
    field: Private(_field.FieldParamTypeProvider),
    optioned: Private(_optioned.OptionedParamTypeProvider),
    regex: Private(_regex.RegexParamTypeProvider),
    string: Private(_string.StringParamTypeProvider),
    json: Private(_json.JsonParamTypeProvider),
    _default: Private(_base.BaseParamTypeProvider)
  };

  /**
   * Wraps a list of {{#crossLink "AggParam"}}{{/crossLink}} objects; owned by an {{#crossLink "AggType"}}{{/crossLink}}
   *
   * used to create:
   *   - `FieldAggParam`  When the config has `name: "field"`
   *   - `*AggParam`  When the type matches something in the map above
   *   - `BaseAggParam`  All other params
   *
   * @class AggParams
   * @constructor
   * @extends IndexedArray
   * @param {object[]} params - array of params that get new-ed up as AggParam objects as descibed above
   */
  _lodash2.default.class(AggParams).inherits(_indexed_array.IndexedArray);
  function AggParams(params) {
    AggParams.Super.call(this, {
      index: ['name'],
      initialSet: params.map(function (config) {
        var type = config.name === 'field' ? config.name : config.type;
        var Class = paramTypeMap[type] || paramTypeMap._default;
        return new Class(config);
      })
    });
  }

  /**
   * Reads an aggConfigs
   *
   * @method write
   * @param  {AggConfig} aggConfig
   *         the AggConfig object who's type owns these aggParams and contains the param values for our param defs
   * @param  {object} [locals]
   *         an array of locals that will be available to the write function (can be used to enhance
   *         the quality of things like date_histogram's "auto" interval)
   * @return {object} output
   *         output of the write calls, reduced into a single object. A `params: {}` property is exposed on the
   *         output object which is used to create the agg dsl for the search request. All other properties
   *         are dependent on the AggParam#write methods which should be studied for each AggType.
   */
  AggParams.prototype.write = function (aggConfig, locals) {
    var output = { params: {} };
    locals = locals || {};

    this.forEach(function (param) {
      if (param.write) {
        param.write(aggConfig, output, locals);
      } else {
        output.params[param.name] = aggConfig.params[param.name];
      }
    });

    return output;
  };

  return AggParams;
}

/***/ }),
/* 529 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _vislib = __webpack_require__(2985);

// eslint-disable-next-line @elastic/kibana-custom/no-default-export
exports.default = _vislib.VislibProvider;
module.exports = exports['default'];

/***/ }),
/* 530 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.VislibLibDataProvider = VislibLibDataProvider;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _inject_zeros = __webpack_require__(2997);

var _ordered_x_keys = __webpack_require__(936);

var _labels = __webpack_require__(3002);

var _color = __webpack_require__(3006);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function VislibLibDataProvider(Private) {

  var _injectZeros = Private(_inject_zeros.VislibComponentsZeroInjectionInjectZerosProvider);
  var orderKeys = Private(_ordered_x_keys.VislibComponentsZeroInjectionOrderedXKeysProvider);
  var _getLabels2 = Private(_labels.VislibComponentsLabelsLabelsProvider);
  var color = Private(_color.VislibComponentsColorColorProvider);

  /**
   * Provides an API for pulling values off the data
   * and calculating values using the data
   *
   * @class Data
   * @constructor
   * @param data {Object} Elasticsearch query results
   * @param attr {Object|*} Visualization options
   */

  var Data = function () {
    function Data(data, uiState) {
      _classCallCheck(this, Data);

      this.uiState = uiState;
      this.data = this.copyDataObj(data);
      this.type = this.getDataType();

      this.labels = this._getLabels(this.data);
      this.color = this.labels ? color(this.labels, uiState.get('vis.colors')) : undefined;
      this._normalizeOrdered();
    }

    _createClass(Data, [{
      key: 'copyDataObj',
      value: function copyDataObj(data) {
        var copyChart = function copyChart(data) {
          var newData = {};
          Object.keys(data).forEach(function (key) {
            if (key !== 'series') {
              newData[key] = data[key];
            } else {
              newData[key] = data[key].map(function (seri) {
                return {
                  label: seri.label,
                  aggLabel: seri.aggLabel,
                  aggId: seri.aggId,
                  values: seri.values.map(function (val) {
                    var newVal = _lodash2.default.clone(val);
                    newVal.aggConfig = val.aggConfig;
                    newVal.aggConfigResult = val.aggConfigResult;
                    newVal.extraMetrics = val.extraMetrics;
                    newVal.series = val.series || seri.label;
                    return newVal;
                  })
                };
              });
            }
          });
          return newData;
        };

        if (!data.series) {
          var newData = {};
          Object.keys(data).forEach(function (key) {
            if (!['rows', 'columns'].includes(key)) {
              newData[key] = data[key];
            } else {
              newData[key] = data[key].map(function (chart) {
                return copyChart(chart);
              });
            }
          });
          return newData;
        }
        return copyChart(data);
      }
    }, {
      key: '_getLabels',
      value: function _getLabels(data) {
        return this.type === 'series' ? _getLabels2(data) : this.pieNames();
      }
    }, {
      key: 'getDataType',
      value: function getDataType() {
        var data = this.getVisData();
        var type = void 0;

        data.forEach(function (obj) {
          if (obj.series) {
            type = 'series';
          } else if (obj.slices) {
            type = 'slices';
          } else if (obj.geoJson) {
            type = 'geoJson';
          }
        });

        return type;
      }

      /**
       * Returns an array of the actual x and y data value objects
       * from data with series keys
       *
       * @method chartData
       * @returns {*} Array of data objects
       */

    }, {
      key: 'chartData',
      value: function chartData() {
        if (!this.data.series) {
          var arr = this.data.rows ? this.data.rows : this.data.columns;
          return _lodash2.default.toArray(arr);
        }
        return [this.data];
      }
    }, {
      key: 'shouldBeStacked',
      value: function shouldBeStacked(seriesConfig) {
        if (!seriesConfig) return false;
        return seriesConfig.mode === 'stacked';
      }
    }, {
      key: 'getStackedSeries',
      value: function getStackedSeries(chartConfig, axis, series) {
        var _this = this;

        var first = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

        var matchingSeries = [];
        chartConfig.series.forEach(function (seriArgs, i) {
          var matchingAxis = seriArgs.valueAxis === axis.axisConfig.get('id') || !seriArgs.valueAxis && first;
          if (matchingAxis && (_this.shouldBeStacked(seriArgs) || axis.axisConfig.get('scale.stacked'))) {
            matchingSeries.push(series[i]);
          }
        });
        return matchingSeries;
      }
    }, {
      key: 'stackChartData',
      value: function stackChartData(handler, data, chartConfig) {
        var _this2 = this;

        var stackedData = {};
        handler.valueAxes.forEach(function (axis, i) {
          var id = axis.axisConfig.get('id');
          stackedData[id] = _this2.getStackedSeries(chartConfig, axis, data, i === 0);
          stackedData[id] = _this2.injectZeros(stackedData[id], handler.visConfig.get('orderBucketsBySum', false));
          axis.axisConfig.set('stackedSeries', stackedData[id].length);
          axis.stack(_lodash2.default.map(stackedData[id], 'values'));
        });
        return stackedData;
      }
    }, {
      key: 'stackData',
      value: function stackData(handler) {
        var _this3 = this;

        var data = this.data;
        if (data.rows || data.columns) {
          var charts = data.rows ? data.rows : data.columns;
          charts.forEach(function (chart, i) {
            _this3.stackChartData(handler, chart.series, handler.visConfig.get('charts[' + i + ']'));
          });
        } else {
          this.stackChartData(handler, data.series, handler.visConfig.get('charts[0]'));
        }
      }

      /**
       * Returns an array of chart data objects
       *
       * @method getVisData
       * @returns {*} Array of chart data objects
       */

    }, {
      key: 'getVisData',
      value: function getVisData() {
        var visData = void 0;

        if (this.data.rows) {
          visData = this.data.rows;
        } else if (this.data.columns) {
          visData = this.data.columns;
        } else {
          visData = [this.data];
        }

        return visData;
      }

      /**
       * get min and max for all cols, rows of data
       *
       * @method getMaxMin
       * @return {Object}
       */

    }, {
      key: 'getGeoExtents',
      value: function getGeoExtents() {
        var visData = this.getVisData();

        return _lodash2.default.reduce(_lodash2.default.pluck(visData, 'geoJson.properties'), function (minMax, props) {
          return {
            min: Math.min(props.min, minMax.min),
            max: Math.max(props.max, minMax.max)
          };
        }, { min: Infinity, max: -Infinity });
      }

      /**
       * Returns array of chart data objects for pie data objects
       *
       * @method pieData
       * @returns {*} Array of chart data objects
       */

    }, {
      key: 'pieData',
      value: function pieData() {
        if (!this.data.slices) {
          return this.data.rows ? this.data.rows : this.data.columns;
        }
        return [this.data];
      }

      /**
       * Get attributes off the data, e.g. `tooltipFormatter` or `xAxisFormatter`
       * pulls the value off the first item in the array
       * these values are typically the same between data objects of the same chart
       * TODO: May need to verify this or refactor
       *
       * @method get
       * @param thing {String} Data object key
       * @returns {*} Data object value
       */

    }, {
      key: 'get',
      value: function get(thing, def) {
        var source = (this.data.rows || this.data.columns || [this.data])[0];
        return _lodash2.default.get(source, thing, def);
      }

      /**
       * Returns true if null values are present
       * @returns {*}
       */

    }, {
      key: 'hasNullValues',
      value: function hasNullValues() {
        var chartData = this.chartData();

        return chartData.some(function (chart) {
          return chart.series.some(function (obj) {
            return obj.values.some(function (d) {
              return d.y === null;
            });
          });
        });
      }

      /**
       * Return an array of all value objects
       * Pluck the data.series array from each data object
       * Create an array of all the value objects from the series array
       *
       * @method flatten
       * @returns {Array} Value objects
       */

    }, {
      key: 'flatten',
      value: function flatten() {
        return (0, _lodash2.default)(this.chartData()).pluck('series').flattenDeep().pluck('values').flattenDeep().value();
      }

      /**
       * Validates that the Y axis min value defined by user input
       * is a number.
       *
       * @param val {Number} Y axis min value
       * @returns {Number} Y axis min value
       */

    }, {
      key: 'validateUserDefinedYMin',
      value: function validateUserDefinedYMin(val) {
        if (!_lodash2.default.isNumber(val)) {
          throw new Error('validateUserDefinedYMin expects a number');
        }
        return val;
      }

      /**
       * Helper function for getNames
       * Returns an array of objects with a name (key) value and an index value.
       * The index value allows us to sort the names in the correct nested order.
       *
       * @method returnNames
       * @param array {Array} Array of data objects
       * @param index {Number} Number of times the object is nested
       * @param columns {Object} Contains name formatter information
       * @returns {Array} Array of labels (strings)
       */

    }, {
      key: 'returnNames',
      value: function returnNames(array, index, columns) {
        var names = [];
        var self = this;

        _lodash2.default.forEach(array, function (obj) {
          names.push({
            label: obj.name,
            values: obj,
            index: index
          });

          if (obj.children) {
            var plusIndex = index + 1;

            _lodash2.default.forEach(self.returnNames(obj.children, plusIndex, columns), function (namedObj) {
              names.push(namedObj);
            });
          }
        });

        return names;
      }

      /**
       * Flattens hierarchical data into an array of objects with a name and index value.
       * The indexed value determines the order of nesting in the data.
       * Returns an array with names sorted by the index value.
       *
       * @method getNames
       * @param data {Object} Chart data object
       * @param columns {Object} Contains formatter information
       * @returns {Array} Array of names (strings)
       */

    }, {
      key: 'getNames',
      value: function getNames(data, columns) {
        var slices = data.slices;

        if (slices.children) {
          var namedObj = this.returnNames(slices.children, 0, columns);

          return (0, _lodash2.default)(namedObj).sortBy(function (obj) {
            return obj.index;
          }).unique(function (d) {
            return d.label;
          }).value();
        }
      }

      /**
       * Removes zeros from pie chart data
       * @param slices
       * @returns {*}
       */

    }, {
      key: '_removeZeroSlices',
      value: function _removeZeroSlices(slices) {
        var self = this;

        if (!slices.children) return slices;

        slices = _lodash2.default.clone(slices);
        slices.children = slices.children.reduce(function (children, child) {
          if (child.size !== 0) {
            children.push(self._removeZeroSlices(child));
          }
          return children;
        }, []);

        return slices;
      }

      /**
       * Returns an array of names ordered by appearance in the nested array
       * of objects
       *
       * @method pieNames
       * @returns {Array} Array of unique names (strings)
       */

    }, {
      key: 'pieNames',
      value: function pieNames(data) {
        var self = this;
        var names = [];

        _lodash2.default.forEach(data, function (obj) {
          var columns = obj.raw ? obj.raw.columns : undefined;
          obj.slices = self._removeZeroSlices(obj.slices);

          _lodash2.default.forEach(self.getNames(obj, columns), function (name) {
            names.push(name);
          });
        });

        return _lodash2.default.uniq(names, 'label');
      }

      /**
       * Inject zeros into the data
       *
       * @method injectZeros
       * @returns {Object} Data object with zeros injected
       */

    }, {
      key: 'injectZeros',
      value: function injectZeros(data) {
        var orderBucketsBySum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        return _injectZeros(data, this.data, orderBucketsBySum);
      }

      /**
       * Returns an array of all x axis values from the data
       *
       * @method xValues
       * @returns {Array} Array of x axis values
       */

    }, {
      key: 'xValues',
      value: function xValues() {
        var orderBucketsBySum = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        return orderKeys(this.data, orderBucketsBySum);
      }

      /**
       * Return an array of unique labels
       * Curently, only used for vertical bar and line charts,
       * or any data object with series values
       *
       * @method getLabels
       * @returns {Array} Array of labels (strings)
       */

    }, {
      key: 'getLabels',
      value: function getLabels() {
        return _getLabels2(this.data);
      }

      /**
       * Returns a function that does color lookup on labels
       *
       * @method getColorFunc
       * @returns {Function} Performs lookup on string and returns hex color
       */

    }, {
      key: 'getColorFunc',
      value: function getColorFunc() {
        if (this.type === 'slices') {
          return this.getPieColorFunc();
        }
        var defaultColors = this.uiState.get('vis.defaultColors');
        var overwriteColors = this.uiState.get('vis.colors');
        var colors = defaultColors ? _lodash2.default.defaults({}, overwriteColors, defaultColors) : overwriteColors;
        return color(this.getLabels(), colors);
      }

      /**
       * Returns a function that does color lookup on names for pie charts
       *
       * @method getPieColorFunc
       * @returns {Function} Performs lookup on string and returns hex color
       */

    }, {
      key: 'getPieColorFunc',
      value: function getPieColorFunc() {
        return color(this.pieNames(this.getVisData()).map(function (d) {
          return d.label;
        }), this.uiState.get('vis.colors'));
      }

      /**
       * ensure that the datas ordered property has a min and max
       * if the data represents an ordered date range.
       *
       * @return {undefined}
       */

    }, {
      key: '_normalizeOrdered',
      value: function _normalizeOrdered() {
        var data = this.getVisData();
        var self = this;

        data.forEach(function (d) {
          if (!d.ordered || !d.ordered.date) return;

          var missingMin = d.ordered.min == null;
          var missingMax = d.ordered.max == null;

          if (missingMax || missingMin) {
            var extent = _d2.default.extent(self.xValues());
            if (missingMin) d.ordered.min = extent[0];
            if (missingMax) d.ordered.max = extent[1];
          }
        });
      }

      /**
       * Calculates min and max values for all map data
       * series.rows is an array of arrays
       * each row is an array of values
       * last value in row array is bucket count
       *
       * @method mapDataExtents
       * @param series {Array} Array of data objects
       * @returns {Array} min and max values
       */

    }, {
      key: 'mapDataExtents',
      value: function mapDataExtents(series) {
        var values = _lodash2.default.map(series.rows, function (row) {
          return row[row.length - 1];
        });
        return [_lodash2.default.min(values), _lodash2.default.max(values)];
      }

      /**
       * Get the maximum number of series, considering each chart
       * individually.
       *
       * @return {number} - the largest number of series from all charts
       */

    }, {
      key: 'maxNumberOfSeries',
      value: function maxNumberOfSeries() {
        return this.chartData().reduce(function (max, chart) {
          return Math.max(max, chart.series.length);
        }, 0);
      }
    }]);

    return Data;
  }();

  return Data;
}

/***/ }),
/* 531 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _tooltip = __webpack_require__(3009);

Object.defineProperty(exports, 'Tooltip', {
  enumerable: true,
  get: function get() {
    return _tooltip.Tooltip;
  }
});
Object.defineProperty(exports, 'TooltipProvider', {
  enumerable: true,
  get: function get() {
    return _tooltip.TooltipProvider;
  }
});

/***/ }),
/* 532 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.VislibVisualizationsChartProvider = VislibVisualizationsChartProvider;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _data_label = __webpack_require__(3012);

var _dispatch = __webpack_require__(3013);

var _tooltip = __webpack_require__(531);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function VislibVisualizationsChartProvider(Private) {

  var Dispatch = Private(_dispatch.VislibLibDispatchProvider);
  var Tooltip = Private(_tooltip.TooltipProvider);
  /**
   * The Base Class for all visualizations.
   *
   * @class Chart
   * @constructor
   * @param handler {Object} Reference to the Handler Class Constructor
   * @param el {HTMLElement} HTML element to which the chart will be appended
   * @param chartData {Object} Elasticsearch query results for this specific chart
   */

  var Chart = function () {
    function Chart(handler, el, chartData) {
      _classCallCheck(this, Chart);

      this.handler = handler;
      this.chartEl = el;
      this.chartData = chartData;
      this.tooltips = [];

      var events = this.events = new Dispatch(handler);

      if (this.handler.visConfig && this.handler.visConfig.get('addTooltip', false)) {
        var $el = this.handler.el;
        var formatter = this.handler.data.get('tooltipFormatter');

        // Add tooltip
        this.tooltip = new Tooltip('chart', $el, formatter, events);
        this.tooltips.push(this.tooltip);
      }

      this._addIdentifier = _lodash2.default.bind(this._addIdentifier, this);
    }

    /**
     * Renders the chart(s)
     *
     * @method render
     * @returns {HTMLElement} Contains the D3 chart
     */


    _createClass(Chart, [{
      key: 'render',
      value: function render() {
        var selection = _d2.default.select(this.chartEl);

        selection.selectAll('*').remove();
        selection.call(this.draw());
      }

      /**
       * Append the data label to the element
       *
       * @method _addIdentifier
       * @param selection {Object} d3 select object
       */

    }, {
      key: '_addIdentifier',
      value: function _addIdentifier(selection, labelProp) {
        labelProp = labelProp || 'label';
        var labels = this.handler.data.labels;

        function resolveLabel(datum) {
          if (labels.length === 1) return labels[0];
          if (datum[0]) return datum[0][labelProp];
          return datum[labelProp];
        }

        selection.each(function (datum) {
          var label = resolveLabel(datum);
          if (label != null) (0, _data_label.dataLabel)(this, label);
        });
      }

      /**
       * Removes all DOM elements from the root element
       *
       * @method destroy
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        var selection = _d2.default.select(this.chartEl);
        this.events.removeAllListeners();
        this.tooltips.forEach(function (tooltip) {
          tooltip.destroy();
        });
        selection.remove();
      }
    }]);

    return Chart;
  }();

  return Chart;
}

/***/ }),
/* 533 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getHeatmapColors = getHeatmapColors;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _colormaps = __webpack_require__(212);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function enforceBounds(x) {
  if (x < 0) {
    return 0;
  } else if (x > 1) {
    return 1;
  } else {
    return x;
  }
}

function interpolateLinearly(x, values) {
  // Split values into four lists
  var xValues = [];
  var rValues = [];
  var gValues = [];
  var bValues = [];
  values.forEach(function (value) {
    xValues.push(value[0]);
    rValues.push(value[1][0]);
    gValues.push(value[1][1]);
    bValues.push(value[1][2]);
  });

  var i = 1;
  while (xValues[i] < x) {
    i++;
  }var width = Math.abs(xValues[i - 1] - xValues[i]);
  var scalingFactor = (x - xValues[i - 1]) / width;
  // Get the new color values though interpolation
  var r = rValues[i - 1] + scalingFactor * (rValues[i] - rValues[i - 1]);
  var g = gValues[i - 1] + scalingFactor * (gValues[i] - gValues[i - 1]);
  var b = bValues[i - 1] + scalingFactor * (bValues[i] - bValues[i - 1]);
  return [enforceBounds(r), enforceBounds(g), enforceBounds(b)];
}

function getHeatmapColors(value, colorSchemaName) {
  if (!_lodash2.default.isNumber(value) || value < 0 || value > 1) {
    throw new Error('heatmap_color expects a number from 0 to 1 as first parameter');
  }

  var colorSchema = _colormaps.vislibColorMaps[colorSchemaName];
  if (!colorSchema) {
    throw new Error('invalid colorSchemaName provided');
  }

  var color = interpolateLinearly(value, colorSchema);
  var r = Math.round(255 * color[0]);
  var g = Math.round(255 * color[1]);
  var b = Math.round(255 * color[2]);
  return 'rgb(' + r + ',' + g + ',' + b + ')';
}

function drawColormap(colorSchema) {
  var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
  var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;

  var canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  var ctx = canvas.getContext('2d');
  for (var i = 0; i <= width; i++) {
    ctx.fillStyle = getHeatmapColors(i / width, colorSchema);
    ctx.fillRect(i, 0, 1, height);
  }
  return canvas;
}

getHeatmapColors.prototype.drawColormap = drawColormap;

/***/ }),
/* 534 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dashboardContextProvider = dashboardContextProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _query_filter = __webpack_require__(119);

__webpack_require__(237);

var _lucene_string_to_dsl = __webpack_require__(474);

var _migrate_filter = __webpack_require__(774);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function dashboardContextProvider(Private, getAppState) {
  return function () {
    var appState = getAppState();
    var queryFilter = Private(_query_filter.FilterBarQueryFilterProvider);
    var bool = { must: [], must_not: [] };
    if (!appState) return { bool: bool };
    var filterBarFilters = queryFilter.getFilters();
    var queryBarQuery = appState.query;

    if (queryBarQuery.language === 'lucene') {
      // Add the query bar filter, its handled differently.
      var query = (0, _lucene_string_to_dsl.luceneStringToDsl)(queryBarQuery.query);
      if (query) bool.must.push(query);
    }

    // Add each of the filter bar filters
    _lodash2.default.each(filterBarFilters, function (filter) {
      var esFilter = _lodash2.default.omit(filter, function (val, key) {
        if (key === 'meta' || key[0] === '$') return true;
        return false;
      });

      if (filter.meta.disabled) return;
      if (filter.meta.negate) {
        bool.must_not = bool.must_not || [];
        if (esFilter.query || esFilter) bool.must_not.push((0, _migrate_filter.migrateFilter)(esFilter.query || esFilter));
      } else {
        bool.must = bool.must || [];
        if (esFilter.query || esFilter) bool.must.push((0, _migrate_filter.migrateFilter)(esFilter.query || esFilter));
      }
    });

    return { bool: bool };
  };
} // This file is used by Timelion and TSVB

/***/ }),
/* 535 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(3051);

__webpack_require__(62);

var _modules = __webpack_require__(2);

var _saved_object_loader = __webpack_require__(355);

var _saved_object_registry = __webpack_require__(210);

var _module = _modules.uiModules.get('discover/saved_searches', ['kibana/notify']);

// Register this service with the saved object registry so it can be
// edited by the object editor.
_saved_object_registry.savedObjectManagementRegistry.register({
  service: 'savedSearches',
  title: 'searches'
});

_module.service('savedSearches', function (Promise, config, kbnIndex, createNotifier, SavedSearch, kbnUrl, $http, chrome) {
  var savedSearchLoader = new _saved_object_loader.SavedObjectLoader(SavedSearch, kbnIndex, kbnUrl, $http, chrome);
  // Customize loader properties since adding an 's' on type doesn't work for type 'search' .
  savedSearchLoader.loaderProperties = {
    name: 'searches',
    noun: 'Saved Search',
    nouns: 'saved searches'
  };

  savedSearchLoader.urlFor = function (id) {
    return kbnUrl.eval('#/discover/{{id}}', { id: id });
  };

  return savedSearchLoader;
});

/***/ }),
/* 536 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.createNumeralFormat = createNumeralFormat;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _numeral = __webpack_require__(449);

var _numeral2 = _interopRequireDefault(_numeral);

var _languages = __webpack_require__(3054);

var _languages2 = _interopRequireDefault(_languages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var numeralInst = (0, _numeral2.default)();

_languages2.default.forEach(function (numeralLanguage) {
  _numeral2.default.language(numeralLanguage.id, numeralLanguage.lang);
});

function createNumeralFormat(FieldFormat, opts) {
  var NumeralFormat = function (_FieldFormat) {
    _inherits(NumeralFormat, _FieldFormat);

    function NumeralFormat(params, getConfig) {
      _classCallCheck(this, NumeralFormat);

      var _this = _possibleConstructorReturn(this, (NumeralFormat.__proto__ || Object.getPrototypeOf(NumeralFormat)).call(this, params));

      _this.getConfig = getConfig;
      return _this;
    }

    _createClass(NumeralFormat, [{
      key: 'getParamDefaults',
      value: function getParamDefaults() {
        if (_lodash2.default.has(opts, 'getParamDefaults')) {
          return opts.getParamDefaults(this.getConfig);
        }

        return {
          pattern: this.getConfig('format:' + opts.id + ':defaultPattern')
        };
      }
    }, {
      key: '_convert',
      value: function _convert(val) {
        if (val === -Infinity) return '-';
        if (val === +Infinity) return '+';
        if (typeof val !== 'number') {
          val = parseFloat(val);
        }

        if (isNaN(val)) return '';

        var previousLocale = _numeral2.default.language();
        var defaultLocale = this.getConfig && this.getConfig('format:number:defaultLocale') || 'en';
        _numeral2.default.language(defaultLocale);

        var formatted = numeralInst.set(val).format(this.param('pattern'));

        _numeral2.default.language(previousLocale);

        return opts.afterConvert ? opts.afterConvert.call(this, formatted) : formatted;
      }
    }]);

    return NumeralFormat;
  }(FieldFormat);

  NumeralFormat.id = opts.id;
  NumeralFormat.title = opts.title;
  NumeralFormat.fieldType = 'number';


  if (opts.prototype) {
    _lodash2.default.assign(NumeralFormat.prototype, opts.prototype);
  }

  return NumeralFormat;
}

/***/ }),
/* 537 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesIndexProvider = AggTypesIndexProvider;

var _indexed_array = __webpack_require__(99);

__webpack_require__(528);

var _count = __webpack_require__(3067);

var _avg = __webpack_require__(3068);

var _sum = __webpack_require__(3069);

var _median = __webpack_require__(3070);

var _min = __webpack_require__(3077);

var _max = __webpack_require__(3078);

var _top_hit = __webpack_require__(3079);

var _std_deviation = __webpack_require__(3082);

var _cardinality = __webpack_require__(3083);

var _percentiles = __webpack_require__(956);

var _geo_bounds = __webpack_require__(3084);

var _geo_centroid = __webpack_require__(3085);

var _percentile_ranks = __webpack_require__(3086);

var _derivative = __webpack_require__(3088);

var _cumulative_sum = __webpack_require__(3094);

var _moving_avg = __webpack_require__(3095);

var _serial_diff = __webpack_require__(3096);

var _date_histogram = __webpack_require__(3097);

var _histogram = __webpack_require__(3104);

var _range = __webpack_require__(3109);

var _date_range = __webpack_require__(3113);

var _ip_range = __webpack_require__(3116);

var _terms = __webpack_require__(3119);

var _filter = __webpack_require__(3123);

var _filters = __webpack_require__(3124);

var _significant_terms = __webpack_require__(3127);

var _geo_hash = __webpack_require__(3128);

var _bucket_sum = __webpack_require__(3131);

var _bucket_avg = __webpack_require__(3135);

var _bucket_min = __webpack_require__(3136);

var _bucket_max = __webpack_require__(3137);

__webpack_require__(911);

function AggTypesIndexProvider(Private) {

  var aggs = {
    metrics: [Private(_count.AggTypesMetricsCountProvider), Private(_avg.AggTypesMetricsAvgProvider), Private(_sum.AggTypesMetricsSumProvider), Private(_median.AggTypesMetricsMedianProvider), Private(_min.AggTypesMetricsMinProvider), Private(_max.AggTypesMetricsMaxProvider), Private(_std_deviation.AggTypesMetricsStdDeviationProvider), Private(_cardinality.AggTypesMetricsCardinalityProvider), Private(_percentiles.AggTypesMetricsPercentilesProvider), Private(_percentile_ranks.AggTypesMetricsPercentileRanksProvider), Private(_top_hit.AggTypesMetricsTopHitProvider), Private(_derivative.AggTypesMetricsDerivativeProvider), Private(_cumulative_sum.AggTypesMetricsCumulativeSumProvider), Private(_moving_avg.AggTypesMetricsMovingAvgProvider), Private(_serial_diff.AggTypesMetricsSerialDiffProvider), Private(_bucket_avg.AggTypesMetricsBucketAvgProvider), Private(_bucket_sum.AggTypesMetricsBucketSumProvider), Private(_bucket_min.AggTypesMetricsBucketMinProvider), Private(_bucket_max.AggTypesMetricsBucketMaxProvider), Private(_geo_bounds.AggTypesMetricsGeoBoundsProvider), Private(_geo_centroid.AggTypesMetricsGeoCentroidProvider)],
    buckets: [Private(_date_histogram.AggTypesBucketsDateHistogramProvider), Private(_histogram.AggTypesBucketsHistogramProvider), Private(_range.AggTypesBucketsRangeProvider), Private(_date_range.AggTypesBucketsDateRangeProvider), Private(_ip_range.AggTypesBucketsIpRangeProvider), Private(_terms.AggTypesBucketsTermsProvider), Private(_filter.AggTypesBucketsFilterProvider), Private(_filters.AggTypesBucketsFiltersProvider), Private(_significant_terms.AggTypesBucketsSignificantTermsProvider), Private(_geo_hash.AggTypesBucketsGeoHashProvider)]
  };

  Object.keys(aggs).forEach(function (type) {
    aggs[type].forEach(function (agg) {
      agg.type = type;
    });
  });

  /**
   * IndexedArray of Aggregation Types.
   *
   * These types form two groups, metric and buckets.
   *
   * @module agg_types
   * @type {IndexedArray}
   */
  return new _indexed_array.IndexedArray({

    /**
     * @type {Array}
     */
    index: ['name'],

    /**
     * [group description]
     * @type {Array}
     */
    group: ['type'],
    initialSet: aggs.metrics.concat(aggs.buckets)
  });
}

/***/ }),
/* 538 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesMetricsGetResponseAggConfigClassProvider = AggTypesMetricsGetResponseAggConfigClassProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function AggTypesMetricsGetResponseAggConfigClassProvider() {

  /**
   * Get the ResponseAggConfig class for an aggConfig,
   * which might be cached on the aggConfig or created.
   *
   * @param  {AggConfig} agg - the AggConfig the VAC should inherit from
   * @param  {object} props - properties that the VAC should have
   * @return {Constructor} - a constructor for VAC objects that will inherit the aggConfig
   */
  return function getResponseConfigClass(agg, props) {
    if (agg.$$_ResponseAggConfigClass) {
      return agg.$$_ResponseAggConfigClass;
    } else {
      return agg.$$_ResponseAggConfigClass = create(agg, props);
    }
  };

  function create(parentAgg, props) {

    /**
     * AggConfig "wrapper" for multi-value metric aggs which
     * need to modify AggConfig behavior for each value produced.
     *
     * @param {string|number} key - the key or index that identifies
     *                            this part of the multi-value
     */
    function ResponseAggConfig(key) {
      this.key = key;
      this.parentId = this.id;

      var subId = String(key);
      if (subId.indexOf('.') > -1) {
        this.id = this.parentId + '[\'' + subId.replace(/'/g, '\\\'') + '\']';
      } else {
        this.id = this.parentId + '.' + subId;
      }
    }

    ResponseAggConfig.prototype = Object.create(parentAgg, {
      constructor: ResponseAggConfig
    });

    _lodash2.default.assign(ResponseAggConfig.prototype, props);

    return ResponseAggConfig;
  }
}

/***/ }),
/* 539 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeGeoHash = decodeGeoHash;
exports.geohashColumns = geohashColumns;
/*
 * Decodes geohash to object containing
 * top-left and bottom-right corners of
 * rectangle and center point.
 *
 * geohash.js
 * Geohash library for Javascript
 * (c) 2008 David Troy
 * Distributed under the MIT License
 *
 * @method refine_interval
 * @param interval {Array} [long, lat]
 * @param cd {Number}
 * @param mask {Number}
 * @return {Object} interval
 */
function decodeGeoHash(geohash) {
  var BITS = [16, 8, 4, 2, 1];
  var BASE32 = '0123456789bcdefghjkmnpqrstuvwxyz';
  var is_even = 1;
  var lat = [];
  var lon = [];
  lat[0] = -90.0;
  lat[1] = 90.0;
  lon[0] = -180.0;
  lon[1] = 180.0;
  var lat_err = 90.0;
  var lon_err = 180.0;
  for (var i = 0; i < geohash.length; i++) {
    var c = geohash[i];
    var cd = BASE32.indexOf(c);
    for (var j = 0; j < 5; j++) {
      var mask = BITS[j];
      if (is_even) {
        lon_err /= 2;
        refine_interval(lon, cd, mask);
      } else {
        lat_err /= 2;
        refine_interval(lat, cd, mask);
      }
      is_even = !is_even;
    }
  }
  lat[2] = (lat[0] + lat[1]) / 2;
  lon[2] = (lon[0] + lon[1]) / 2;
  return { latitude: lat, longitude: lon };
}

function refine_interval(interval, cd, mask) {
  if (cd & mask) {
    interval[0] = (interval[0] + interval[1]) / 2;
  } else {
    interval[1] = (interval[0] + interval[1]) / 2;
  }
}

/**
 * Get the number of geohash cells for a given precision
 *
 * @param {number} precision the geohash precision (1<=precision<=12).
 * @param {number} axis constant for the axis 0=lengthwise (ie. columns, along longitude), 1=heightwise (ie. rows, along latitude).
 * @returns {number} Number of geohash cells (rows or columns) at that precision
 */
function geohashCells(precision, axis) {
  var cells = 1;
  for (var i = 1; i <= precision; i += 1) {
    //On odd precisions, rows divide by 4 and columns by 8. Vice-versa on even precisions.
    cells *= i % 2 === axis ? 4 : 8;
  }
  return cells;
}

/**
 * Get the number of geohash columns (world-wide) for a given precision
 * @param precision the geohash precision
 * @returns {number} the number of columns
 */
function geohashColumns(precision) {
  return geohashCells(precision, 0);
}

/***/ }),
/* 540 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UrlPatternMatcher = UrlPatternMatcher;
var _ = __webpack_require__(1);
var engine = __webpack_require__(140);

var URL_PATH_END_MARKER = exports.URL_PATH_END_MARKER = "__url_path_end__";

function AcceptEndpointComponent(endpoint, parent) {
  engine.SharedComponent.call(this, endpoint.id, parent);
  this.endpoint = endpoint;
}

AcceptEndpointComponent.prototype = _.create(engine.SharedComponent.prototype, { "constructor": AcceptEndpointComponent });

(function (cls) {

  cls.match = function (token, context, editor) {
    if (token !== URL_PATH_END_MARKER) {
      return null;
    }
    if (this.endpoint.methods && -1 === _.indexOf(this.endpoint.methods, context.method)) {
      return null;
    }
    var r = Object.getPrototypeOf(cls).match.call(this, token, context, editor);
    r.context_values = r.context_values || {};
    r.context_values['endpoint'] = this.endpoint;
    if (_.isNumber(this.endpoint.priority)) {
      r.priority = this.endpoint.priority;
    }
    return r;
  };
})(AcceptEndpointComponent.prototype);

/**
 * @param parametrizedComponentFactories a dict of the following structure
 * that will be used as a fall back for pattern parameters (i.e.: {indices})
 * {
   *   indices: function (part, parent) {
   *      return new SharedComponent(part, parent)
   *   }
   * }
 * @constructor
 */
function UrlPatternMatcher(parametrizedComponentFactories) {
  // This is not really a component, just a handy container to make iteration logic simpler
  this.rootComponent = new engine.SharedComponent("ROOT");
  this.parametrizedComponentFactories = parametrizedComponentFactories || {};
}

(function (cls) {
  cls.addEndpoint = function (pattern, endpoint) {
    var c,
        active_component = this.rootComponent,
        endpointComponents = endpoint.url_components || {};
    var partList = pattern.split("/");
    _.each(partList, function (part, partIndex) {
      if (part.search(/^{.+}$/) >= 0) {
        part = part.substr(1, part.length - 2);
        if (active_component.getComponent(part)) {
          // we already have something for this, reuse
          active_component = active_component.getComponent(part);
          return;
        }
        // a new path, resolve.

        if (c = endpointComponents[part]) {
          // endpoint specific. Support list
          if (Array.isArray(c)) {
            c = new engine.ListComponent(part, c, active_component);
          } else if (_.isObject(c) && c.type === "list") {
            c = new engine.ListComponent(part, c.list, active_component, c.multi_valued, c.allow_non_valid);
          } else {
            console.warn("incorrectly configured url component ", part, " in endpoint", endpoint);
            c = new engine.SharedComponent(part);
          }
        } else if (c = this.parametrizedComponentFactories[part]) {
          // c is a f
          c = c(part, active_component);
        } else {
          // just accept whatever with not suggestions
          c = new engine.SimpleParamComponent(part, active_component);
        }

        active_component = c;
      } else {
        // not pattern
        var lookAhead = part,
            s;

        for (partIndex++; partIndex < partList.length; partIndex++) {
          s = partList[partIndex];
          if (s.indexOf("{") >= 0) {
            break;
          }
          lookAhead += "/" + s;
        }

        if (active_component.getComponent(part)) {
          // we already have something for this, reuse
          active_component = active_component.getComponent(part);
          active_component.addOption(lookAhead);
        } else {
          c = new engine.ConstantComponent(part, active_component, lookAhead);
          active_component = c;
        }
      }
    }, this);
    // mark end of endpoint path
    new AcceptEndpointComponent(endpoint, active_component);
  };

  cls.getTopLevelComponents = function () {
    return this.rootComponent.next;
  };
})(UrlPatternMatcher.prototype);

/***/ }),
/* 541 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getUnmatchedEndpointComponents = getUnmatchedEndpointComponents;
exports.getEndpointDescriptionByEndpoint = getEndpointDescriptionByEndpoint;
exports.getEndpointBodyCompleteComponents = getEndpointBodyCompleteComponents;
exports.getTopLevelUrlCompleteComponents = getTopLevelUrlCompleteComponents;
exports.getGlobalAutocompleteComponents = getGlobalAutocompleteComponents;
exports.setActiveApi = setActiveApi;
var $ = __webpack_require__(7);
var _ = __webpack_require__(1);
var mappings = __webpack_require__(266);
var Api = __webpack_require__(3167);
var autocomplete_engine = __webpack_require__(140);

var ACTIVE_API = new Api();

function nonValidIndexType(token) {
  return !(token === "_all" || token[0] !== "_");
}

function IndexAutocompleteComponent(name, parent, multi_valued) {
  autocomplete_engine.ListComponent.call(this, name, mappings.getIndices, parent, multi_valued);
}

IndexAutocompleteComponent.prototype = _.create(autocomplete_engine.ListComponent.prototype, { 'constructor': IndexAutocompleteComponent });

(function (cls) {
  cls.validateTokens = function (tokens) {
    if (!this.multi_valued && tokens.length > 1) {
      return false;
    }
    return !_.find(tokens, nonValidIndexType);
  };

  cls.getDefaultTermMeta = function () {
    return "index";
  };

  cls.getContextKey = function () {
    return "indices";
  };
})(IndexAutocompleteComponent.prototype);

function TypeGenerator(context) {
  return mappings.getTypes(context.indices);
}

function TypeAutocompleteComponent(name, parent, multi_valued) {
  autocomplete_engine.ListComponent.call(this, name, TypeGenerator, parent, multi_valued);
}

TypeAutocompleteComponent.prototype = _.create(autocomplete_engine.ListComponent.prototype, { 'constructor': TypeAutocompleteComponent });

(function (cls) {
  cls.validateTokens = function (tokens) {
    if (!this.multi_valued && tokens.length > 1) {
      return false;
    }

    return !_.find(tokens, nonValidIndexType);
  };

  cls.getDefaultTermMeta = function () {
    return "type";
  };

  cls.getContextKey = function () {
    return "types";
  };
})(TypeAutocompleteComponent.prototype);

function FieldGenerator(context) {
  return _.map(mappings.getFields(context.indices, context.types), function (field) {
    return { name: field.name, meta: field.type };
  });
}

function FieldAutocompleteComponent(name, parent, multi_valued) {
  autocomplete_engine.ListComponent.call(this, name, FieldGenerator, parent, multi_valued);
}

FieldAutocompleteComponent.prototype = _.create(autocomplete_engine.ListComponent.prototype, { 'constructor': FieldAutocompleteComponent });

(function (cls) {
  cls.validateTokens = function (tokens) {
    if (!this.multi_valued && tokens.length > 1) {
      return false;
    }

    return !_.find(tokens, function (token) {
      return token.match(/[^\w.?*]/);
    });
  };

  cls.getDefaultTermMeta = function () {
    return "field";
  };

  cls.getContextKey = function () {
    return "fields";
  };
})(FieldAutocompleteComponent.prototype);

function IdAutocompleteComponent(name, parent, multi) {
  autocomplete_engine.SharedComponent.call(this, name, parent);
  this.multi_match = multi;
}

IdAutocompleteComponent.prototype = _.create(autocomplete_engine.SharedComponent.prototype, { 'constructor': IdAutocompleteComponent });

(function (cls) {
  cls.match = function (token, context, editor) {
    if (!token) {
      return null;
    }
    if (!this.multi_match && Array.isArray(token)) {
      return null;
    }
    token = Array.isArray(token) ? token : [token];
    if (_.find(token, function (t) {
      return t.match(/[\/,]/);
    })) {
      return null;
    }
    var r = Object.getPrototypeOf(cls).match.call(this, token, context, editor);
    r.context_values = r.context_values || {};
    r.context_values['id'] = token;
    return r;
  };
})(IdAutocompleteComponent.prototype);

var parametrizedComponentFactories = {

  'index': function index(name, parent) {
    return new IndexAutocompleteComponent(name, parent, false);
  },
  'indices': function indices(name, parent) {
    return new IndexAutocompleteComponent(name, parent, true);
  },
  'type': function type(name, parent) {
    return new TypeAutocompleteComponent(name, parent, false);
  },
  'types': function types(name, parent) {
    return new TypeAutocompleteComponent(name, parent, true);
  },
  'id': function id(name, parent) {
    return new IdAutocompleteComponent(name, parent);
  },
  'ids': function ids(name, parent) {
    return new IdAutocompleteComponent(name, parent, true);
  },
  'fields': function fields(name, parent) {
    return new FieldAutocompleteComponent(name, parent, true);
  },
  'field': function field(name, parent) {
    return new FieldAutocompleteComponent(name, parent, false);
  },
  'nodes': function nodes(name, parent) {
    return new autocomplete_engine.ListComponent(name, ["_local", "_master", "data:true", "data:false", "master:true", "master:false"], parent);
  },
  'node': function node(name, parent) {
    return new autocomplete_engine.ListComponent(name, [], parent, false);
  }
};

function getUnmatchedEndpointComponents() {
  return ACTIVE_API.getUnmatchedEndpointComponents();
}

function getEndpointDescriptionByEndpoint(endpoint) {
  return ACTIVE_API.getEndpointDescriptionByEndpoint(endpoint);
}

function getEndpointBodyCompleteComponents(endpoint) {
  var desc = getEndpointDescriptionByEndpoint(endpoint);
  if (!desc) {
    throw new Error("failed to resolve endpoint ['" + endpoint + "']");
  }
  return desc.bodyAutocompleteRootComponents;
}

function getTopLevelUrlCompleteComponents() {
  return ACTIVE_API.getTopLevelUrlCompleteComponents();
}

function getGlobalAutocompleteComponents(term, throwOnMissing) {
  return ACTIVE_API.getGlobalAutocompleteComponents(term, throwOnMissing);
}

function loadApisFromJson(json, urlParametrizedComponentFactories, bodyParametrizedComponentFactories) {
  urlParametrizedComponentFactories = urlParametrizedComponentFactories || parametrizedComponentFactories;
  bodyParametrizedComponentFactories = bodyParametrizedComponentFactories || urlParametrizedComponentFactories;
  var api = new Api(urlParametrizedComponentFactories, bodyParametrizedComponentFactories);
  var names = [];
  _.each(json, function (apiJson, name) {
    names.unshift(name);
    _.each(apiJson.globals || {}, function (globalJson, globalName) {
      api.addGlobalAutocompleteRules(globalName, globalJson);
    });
    _.each(apiJson.endpoints || {}, function (endpointJson, endpointName) {
      api.addEndpointDescription(endpointName, endpointJson);
    });
  });
  api.name = names.join(",");
  return api;
}

function setActiveApi(api) {
  if (_.isString(api)) {
    $.ajax({
      url: '../api/console/api_server?sense_version=' + encodeURIComponent('@@SENSE_VERSION') + "&apis=" + encodeURIComponent(api),
      dataType: "json" // disable automatic guessing
    }).then(function (data) {
      setActiveApi(loadApisFromJson(data));
    }, function (jqXHR) {
      console.log("failed to load API '" + api + "': " + jqXHR.responseText);
    });
    return;
  }
  console.log("setting active api to [" + api.name + "]");

  ACTIVE_API = api;
}

setActiveApi('es_5_0');

var _test = exports._test = {
  loadApisFromJson: loadApisFromJson
};

/***/ }),
/* 542 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = SenseEditor;

var _chrome = __webpack_require__(17);

var _chrome2 = _interopRequireDefault(_chrome);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ = __webpack_require__(1);
var ace = __webpack_require__(51);
var $ = __webpack_require__(7);
var curl = __webpack_require__(966);
var RowParser = __webpack_require__(967);
var InputMode = __webpack_require__(3161);
var utils = __webpack_require__(265);
var es = __webpack_require__(361);


var smartResize = __webpack_require__(971);

function createInstance($el) {
  var aceEditor = ace.edit($el[0]);

  // we must create a custom class for each instance, so that the prototype
  // can be the unique aceEditor it extends
  var CustomSenseEditor = function CustomSenseEditor() {};
  CustomSenseEditor.prototype = {};

  function bindProp(key) {
    Object.defineProperty(CustomSenseEditor.prototype, key, {
      get: function get() {
        return aceEditor[key];
      },
      set: function set(val) {
        aceEditor[key] = val;
      }
    });
  }

  // iterate all of the accessible properties/method, on the prototype and beyond
  for (var key in aceEditor) {
    switch (_typeof(aceEditor[key])) {
      case 'function':
        CustomSenseEditor.prototype[key] = _.bindKey(aceEditor, key);
        break;
      default:
        bindProp(key);
        break;
    }
  }

  var editor = new CustomSenseEditor();
  editor.__ace = aceEditor;
  return editor;
}

function SenseEditor($el) {
  var editor = createInstance($el);
  var CURRENT_REQ_RANGE = null;

  editor.$el = $el;
  // place holder for an action bar, needs to be set externally.
  editor.$actions = null;

  // mixin the RowParser
  editor.parser = new RowParser(editor);
  editor.resize = smartResize(editor);

  // dirty check for tokenizer state, uses a lot less cycles
  // than listening for tokenizerUpdate
  var onceDoneTokenizing = function onceDoneTokenizing(func, cancelAlreadyScheduledCalls) {
    var session = editor.getSession();
    var timer = false;
    var checkInterval = 25;

    return function () {
      var self = this;
      var args = [].slice.call(arguments, 0);

      if (cancelAlreadyScheduledCalls) {
        timer = clearTimeout(timer);
      }

      setTimeout(function check() {
        if (session.bgTokenizer.running) {
          timer = setTimeout(check, checkInterval);
        } else {
          func.apply(self, args);
        }
      });
    };
  };

  editor.setShowPrintMargin(false);
  (function (session) {
    session.setMode(new InputMode.Mode());
    session.setFoldStyle('markbeginend');
    session.setTabSize(2);
    session.setUseWrapMode(true);
  })(editor.getSession());

  editor.prevRequestStart = function (rowOrPos) {
    rowOrPos = _.isUndefined(rowOrPos) || rowOrPos == null ? editor.getCursorPosition() : rowOrPos;

    var curRow = _.isObject(rowOrPos) ? rowOrPos.row : rowOrPos;
    while (curRow > 0 && !editor.parser.isStartRequestRow(curRow, editor)) {
      curRow--;
    }return {
      row: curRow,
      column: 0
    };
  };

  editor.nextRequestStart = function (rowOrPos) {
    rowOrPos = _.isUndefined(rowOrPos) || rowOrPos == null ? editor.getCursorPosition() : rowOrPos;
    var session = editor.getSession();
    var curRow = _.isObject(rowOrPos) ? rowOrPos.row : rowOrPos;
    var maxLines = session.getLength();
    for (; curRow < maxLines - 1; curRow++) {
      if (editor.parser.isStartRequestRow(curRow, editor)) {
        break;
      }
    }
    return {
      row: curRow,
      column: 0
    };
  };

  editor.autoIndent = onceDoneTokenizing(function () {
    editor.getRequestRange(function (req_range) {
      if (!req_range) {
        return;
      }
      editor.getRequest(function (parsed_req) {
        if (parsed_req.data && parsed_req.data.length > 0) {
          var indent = parsed_req.data.length == 1; // unindent multi docs by default
          var formatted_data = utils.reformatData(parsed_req.data, indent);
          if (!formatted_data.changed) {
            // toggle.
            indent = !indent;
            formatted_data = utils.reformatData(parsed_req.data, indent);
          }
          parsed_req.data = formatted_data.data;

          editor.replaceRequestRange(parsed_req, req_range);
        }
      });
    });
  }, true);

  editor.update = function (data, callback) {
    callback = typeof callback === 'function' ? callback : null;
    var session = editor.getSession();

    session.setValue(data);
    if (callback) {
      // force update of tokens, but not on this thread to allow for ace rendering.
      setTimeout(function () {
        var i;
        for (i = 0; i < session.getLength(); i++) {
          session.getTokens(i);
        }
        callback();
      });
    }
  };

  editor.replaceRequestRange = function (newRequest, requestRange) {
    var text = utils.textFromRequest(newRequest);
    if (requestRange) {
      var pos = editor.getCursorPosition();
      editor.getSession().replace(requestRange, text);
      var max_row = Math.max(requestRange.start.row + text.split('\n').length - 1, 0);
      pos.row = Math.min(pos.row, max_row);
      editor.moveCursorToPosition(pos);
      // ACE UPGRADE - check if needed - at the moment the above may trigger a selection.
      editor.clearSelection();
    } else {
      // just insert where we are
      editor.insert(text);
    }
  };

  editor.iterForCurrentLoc = function () {
    var pos = editor.getCursorPosition();
    return editor.iterForPosition(pos.row, pos.column, editor);
  };

  editor.iterForPosition = function (row, column) {
    return new (ace.require("ace/token_iterator").TokenIterator)(editor.getSession(), row, column);
  };

  editor.getRequestRange = onceDoneTokenizing(function (row, cb) {
    if (_.isUndefined(cb)) {
      cb = row;
      row = null;
    }
    if (typeof cb !== 'function') {
      return;
    }

    if (editor.parser.isInBetweenRequestsRow(row)) {
      cb(null);
      return;
    }

    var reqStart = editor.prevRequestStart(row, editor);
    var reqEnd = editor.nextRequestEnd(reqStart, editor);
    cb(new (ace.require("ace/range").Range)(reqStart.row, reqStart.column, reqEnd.row, reqEnd.column));
  });

  editor.getEngulfingRequestsRange = onceDoneTokenizing(function (range, cb) {
    if (_.isUndefined(cb)) {
      cb = range;
      range = null;
    }

    range = range || editor.getSelectionRange();

    var session = editor.getSession();
    var startRow = range.start.row;
    var endRow = range.end.row;
    var maxLine = Math.max(0, session.getLength() - 1);

    // move start row to the previous request start if in body, o.w. forward
    if (editor.parser.isInBetweenRequestsRow(startRow)) {
      //for (; startRow <= endRow; startRow++) {
      //  if (editor.parser.isStartRequestRow(startRow)) {
      //    break;
      //  }
      //}
    } else {
      for (; startRow >= 0; startRow--) {
        if (editor.parser.isStartRequestRow(startRow)) {
          break;
        }
      }
    }

    if (startRow < 0 || startRow > endRow) {
      cb(null);
      return;
    }
    // move end row to the previous request end if between requests, o.w. walk forward
    if (editor.parser.isInBetweenRequestsRow(endRow)) {
      for (; endRow >= startRow; endRow--) {
        if (editor.parser.isEndRequestRow(endRow)) {
          break;
        }
      }
    } else {

      for (; endRow <= maxLine; endRow++) {
        if (editor.parser.isEndRequestRow(endRow)) {
          break;
        }
      }
    }

    if (endRow < startRow || endRow > maxLine) {
      cb(null);
      return;
    }

    var endColumn = (session.getLine(endRow) || "").replace(/\s+$/, "").length;
    cb(new (ace.require("ace/range").Range)(startRow, 0, endRow, endColumn));
  });

  editor.getRequestInRange = onceDoneTokenizing(function (range, cb) {
    var request = {
      method: "",
      data: [],
      url: null,
      range: range
    };

    var pos = range.start;
    var tokenIter = editor.iterForPosition(pos.row, pos.column, editor);
    var t = tokenIter.getCurrentToken();
    if (editor.parser.isEmptyToken(t)) {
      // if the row starts with some spaces, skip them.
      t = editor.parser.nextNonEmptyToken(tokenIter);
    }
    request.method = t.value;
    t = editor.parser.nextNonEmptyToken(tokenIter);
    if (!t || t.type == "method") {
      return null;
    }
    request.url = "";
    while (t && t.type && t.type.indexOf("url") == 0) {
      request.url += t.value;
      t = tokenIter.stepForward();
    }
    if (editor.parser.isEmptyToken(t)) {
      // if the url row ends with some spaces, skip them.
      t = editor.parser.nextNonEmptyToken(tokenIter);
    }

    var bodyStartRow = (t ? 0 : 1) + tokenIter.getCurrentTokenRow(); // artificially increase end of docs.
    var dataEndPos;
    while (bodyStartRow < range.end.row || bodyStartRow == range.end.row && 0 < range.end.column) {
      dataEndPos = editor.nextDataDocEnd({
        row: bodyStartRow,
        column: 0
      });
      var bodyRange = new (ace.require("ace/range").Range)(bodyStartRow, 0, dataEndPos.row, dataEndPos.column);
      var data = editor.getSession().getTextRange(bodyRange);
      request.data.push(data.trim());
      bodyStartRow = dataEndPos.row + 1;
    }

    cb(request);
  });

  editor.getRequestsInRange = function (range, includeNonRequestBlocks, cb) {
    if (_.isUndefined(includeNonRequestBlocks)) {
      includeNonRequestBlocks = false;
      cb = range;
      range = null;
    } else if (_.isUndefined(cb)) {
      cb = includeNonRequestBlocks;
      includeNonRequestBlocks = false;
    }

    function explicitRangeToRequests(requestsRange, tempCb) {
      if (!requestsRange) {
        tempCb([]);
        return;
      }

      var startRow = requestsRange.start.row;
      var endRow = requestsRange.end.row;

      // move to the next request start (during the second iterations this may not be exactly on a request
      var currentRow = startRow;
      for (; currentRow <= endRow; currentRow++) {
        if (editor.parser.isStartRequestRow(currentRow)) {
          break;
        }
      }

      var nonRequestPrefixBlock = null;
      if (includeNonRequestBlocks && currentRow != startRow) {
        nonRequestPrefixBlock = editor.getSession().getLines(startRow, currentRow - 1).join("\n");
      }

      if (currentRow > endRow) {
        tempCb(nonRequestPrefixBlock ? [nonRequestPrefixBlock] : []);
        return;
      }

      editor.getRequest(currentRow, function (request) {
        explicitRangeToRequests({
          start: {
            row: request.range.end.row + 1
          },
          end: {
            row: requestsRange.end.row
          }
        }, function (rest_of_requests) {
          rest_of_requests.unshift(request);
          if (nonRequestPrefixBlock != null) {
            rest_of_requests.unshift(nonRequestPrefixBlock);
          }
          tempCb(rest_of_requests);
        });
      });
    }

    editor.getEngulfingRequestsRange(range, function (requestRange) {
      explicitRangeToRequests(requestRange, cb);
    });
  };

  editor.getRequest = onceDoneTokenizing(function (row, cb) {
    if (_.isUndefined(cb)) {
      cb = row;
      row = null;
    }
    if (typeof cb !== 'function') {
      return;
    }
    if (editor.parser.isInBetweenRequestsRow(row)) {
      cb(null);
      return;
    }
    editor.getRequestRange(row, function (range) {
      editor.getRequestInRange(range, cb);
    });
  });

  editor.moveToPreviousRequestEdge = onceDoneTokenizing(function () {
    var pos = editor.getCursorPosition();
    for (pos.row--; pos.row > 0 && !editor.parser.isRequestEdge(pos.row); pos.row--) {}
    editor.moveCursorTo(pos.row, 0);
  });

  editor.moveToNextRequestEdge = onceDoneTokenizing(function (moveOnlyIfNotOnEdge) {
    var pos = editor.getCursorPosition();
    var maxRow = editor.getSession().getLength();
    if (!moveOnlyIfNotOnEdge) {
      pos.row++;
    }
    for (; pos.row < maxRow && !editor.parser.isRequestEdge(pos.row); pos.row++) {}
    editor.moveCursorTo(pos.row, 0);
  });

  editor.nextRequestEnd = function (pos) {
    pos = pos || editor.getCursorPosition();
    var session = editor.getSession();
    var curRow = pos.row;
    var maxLines = session.getLength();
    for (; curRow < maxLines - 1; curRow++) {
      var curRowMode = editor.parser.getRowParseMode(curRow, editor);
      if ((curRowMode & editor.parser.MODE.REQUEST_END) > 0) {
        break;
      }
      if (curRow != pos.row && (curRowMode & editor.parser.MODE.REQUEST_START) > 0) {
        break;
      }
    }

    var column = (session.getLine(curRow) || "").replace(/\s+$/, "").length;

    return {
      row: curRow,
      column: column
    };
  };

  editor.nextDataDocEnd = function (pos) {
    pos = pos || editor.getCursorPosition();
    var session = editor.getSession();
    var curRow = pos.row;
    var maxLines = session.getLength();
    for (; curRow < maxLines - 1; curRow++) {
      var curRowMode = editor.parser.getRowParseMode(curRow, editor);
      if ((curRowMode & RowParser.REQUEST_END) > 0) {
        break;
      }
      if ((curRowMode & editor.parser.MODE.MULTI_DOC_CUR_DOC_END) > 0) {
        break;
      }
      if (curRow != pos.row && (curRowMode & editor.parser.MODE.REQUEST_START) > 0) {
        break;
      }
    }

    var column = (session.getLine(curRow) || "").length;

    return {
      row: curRow,
      column: column
    };
  };

  // overwrite the actual aceEditor's onPaste method
  var origOnPaste = editor.__ace.onPaste;
  editor.__ace.onPaste = function (text) {
    if (text && curl.detectCURL(text)) {
      editor.handleCURLPaste(text);
      return;
    }
    origOnPaste.call(this, text);
  };

  editor.handleCURLPaste = function (text) {
    var curlInput = curl.parseCURL(text);

    editor.insert(curlInput);
  };

  editor.highlightCurrentRequestsAndUpdateActionBar = onceDoneTokenizing(function () {
    var session = editor.getSession();
    editor.getEngulfingRequestsRange(function (new_current_req_range) {
      if (new_current_req_range == null && CURRENT_REQ_RANGE == null) {
        return;
      }
      if (new_current_req_range != null && CURRENT_REQ_RANGE != null && new_current_req_range.start.row == CURRENT_REQ_RANGE.start.row && new_current_req_range.end.row == CURRENT_REQ_RANGE.end.row) {
        // same request, now see if we are on the first line and update the action bar
        var cursorRow = editor.getCursorPosition().row;
        if (cursorRow == CURRENT_REQ_RANGE.start.row) {
          editor.updateActionsBar();
        }
        return; // nothing to do..
      }

      if (CURRENT_REQ_RANGE) {
        session.removeMarker(CURRENT_REQ_RANGE.marker_id);
      }

      CURRENT_REQ_RANGE = new_current_req_range;
      if (CURRENT_REQ_RANGE) {
        CURRENT_REQ_RANGE.marker_id = session.addMarker(CURRENT_REQ_RANGE, "ace_snippet-marker", "fullLine");
      }
      editor.updateActionsBar();
    });
  }, true);

  editor.getRequestsAsCURL = function (range, cb) {
    if (_.isUndefined(cb)) {
      cb = range;
      range = null;
    }

    if (_.isUndefined(cb)) {
      cb = $.noop;
    }

    editor.getRequestsInRange(range, true, function (requests) {

      var result = _.map(requests, function requestToCurl(req) {

        if (typeof req === "string") {
          // no request block
          return req;
        }

        var es_path = req.url,
            es_method = req.method,
            es_data = req.data;

        var elasticsearchBaseUrl = _chrome2.default.getInjected('elasticsearchUrl');
        var url = es.constructESUrl(elasticsearchBaseUrl, es_path);

        var ret = 'curl -X' + es_method + ' "' + url + '"';
        if (es_data && es_data.length) {
          ret += " -H 'Content-Type: application/json' -d'\n";
          var data_as_string = utils.collapseLiteralStrings(es_data.join("\n"));
          // since Sense doesn't allow single quote json string any single qoute is within a string.
          ret += data_as_string.replace(/'/g, '\\"');
          if (es_data.length > 1) {
            ret += "\n";
          } // end with a new line
          ret += "'";
        }
        return ret;
      });

      cb(result.join("\n"));
    });
  };

  editor.getSession().on('tokenizerUpdate', function () {
    editor.highlightCurrentRequestsAndUpdateActionBar();
  });

  editor.getSession().selection.on('changeCursor', function () {
    editor.highlightCurrentRequestsAndUpdateActionBar();
  });

  editor.updateActionsBar = function () {
    var set = function set(top) {
      if (top == null) {
        editor.$actions.css('visibility', 'hidden');
      } else {
        editor.$actions.css({
          top: top,
          visibility: 'visible'
        });
      }
    };

    var hide = function hide() {
      set();
    };

    return function () {
      if (!editor.$actions) {
        return;
      }
      if (CURRENT_REQ_RANGE) {
        // elements are positioned relative to the editor's container
        // pageY is relative to page, so subtract the offset
        // from pageY to get the new top value
        var offsetFromPage = editor.$el.offset().top;
        var startRow = CURRENT_REQ_RANGE.start.row;
        var startColumn = CURRENT_REQ_RANGE.start.column;
        var session = editor.session;
        var firstLine = session.getLine(startRow);

        if (firstLine.length > session.getWrapLimit() - 5) {
          // overlap first row
          if (startRow > 0) {
            startRow--;
          } else {
            startRow++;
          }
        }

        var topOfReq = editor.renderer.textToScreenCoordinates(startRow, startColumn).pageY - offsetFromPage;

        if (topOfReq >= 0) {
          return set(topOfReq);
        }

        var bottomOfReq = editor.renderer.textToScreenCoordinates(CURRENT_REQ_RANGE.end.row, CURRENT_REQ_RANGE.end.column).pageY - offsetFromPage;

        if (bottomOfReq >= 0) {
          return set(0);
        }
      }

      hide();
    };
  }();

  editor.getSession().on("changeScrollTop", editor.updateActionsBar);

  return editor;
}
module.exports = exports['default'];

/***/ }),
/* 543 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var $ = __webpack_require__(7);
var storage = __webpack_require__(269);

var history = {
  restoreFromHistory: function restoreFromHistory() {
    // default method for history.restoreFromHistory
    // replace externally to do something when the user chooses
    // to relive a bit of history
    throw new Error('not implemented');
  },
  getHistoryKeys: function getHistoryKeys() {
    return storage.keys().filter(function (key) {
      return key.indexOf('hist_elem') === 0;
    }).sort().reverse();
  },
  getHistory: function getHistory() {
    return history.getHistoryKeys().map(function (key) {
      return storage.get(key);
    });
  },
  addToHistory: function addToHistory(endpoint, method, data) {
    var keys = history.getHistoryKeys();
    keys.splice(0, 500); // only maintain most recent X;
    $.each(keys, function (i, k) {
      storage.delete(k);
    });

    var timestamp = new Date().getTime();
    var k = "hist_elem_" + timestamp;
    storage.set(k, {
      time: timestamp,
      endpoint: endpoint,
      method: method,
      data: data
    });
  },
  updateCurrentState: function updateCurrentState(content) {
    var timestamp = new Date().getTime();
    storage.set("editor_state", {
      time: timestamp,
      content: content
    });
  },
  getSavedEditorState: function getSavedEditorState() {
    var saved = storage.get('editor_state');
    if (!saved) return;
    var time = saved.time,
        content = saved.content;

    return { time: time, content: content };
  },
  clearHistory: function clearHistory() {
    history.getHistoryKeys().forEach(function (key) {
      return storage.delete(key);
    });
  }
};

exports.default = history;
module.exports = exports['default'];

/***/ }),
/* 544 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initializeOutput = initializeOutput;
exports.default = getOutput;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ace = __webpack_require__(51);
var settings = __webpack_require__(267);
var OutputMode = __webpack_require__(3166);
var smartResize = __webpack_require__(971);

var output = void 0;
function initializeOutput($el) {
  output = ace.require('ace/ace').edit($el[0]);

  var outputMode = new OutputMode.Mode();

  output.resize = smartResize(output);
  output.update = function (val, mode, cb) {
    if (typeof mode === 'function') {
      cb = mode;
      mode = void 0;
    }

    var session = output.getSession();

    session.setMode(val ? mode || outputMode : 'ace/mode/text');
    session.setValue(val);
    if (typeof cb === 'function') {
      setTimeout(cb);
    }
  };

  output.append = function (val, fold_previous, cb) {
    if (typeof fold_previous === 'function') {
      cb = fold_previous;
      fold_previous = true;
    }
    if (_lodash2.default.isUndefined(fold_previous)) {
      fold_previous = true;
    }
    var session = output.getSession();
    var lastLine = session.getLength();
    if (fold_previous) {
      output.moveCursorTo(Math.max(0, lastLine - 1), 0);
      session.toggleFold(false);
    }
    session.insert({ row: lastLine, column: 0 }, "\n" + val);
    output.moveCursorTo(lastLine + 1, 0);
    if (typeof cb === 'function') {
      setTimeout(cb);
    }
  };

  output.$el = $el;

  (function (session) {
    session.setMode("ace/mode/text");
    session.setFoldStyle('markbeginend');
    session.setTabSize(2);
    session.setUseWrapMode(true);
  })(output.getSession());

  output.setShowPrintMargin(false);
  output.setReadOnly(true);

  if (settings) {
    settings.applyCurrentSettings(output);
  }

  return output;
}

function getOutput() {
  return output;
}

/***/ }),
/* 545 */,
/* 546 */,
/* 547 */,
/* 548 */,
/* 549 */,
/* 550 */,
/* 551 */,
/* 552 */,
/* 553 */,
/* 554 */,
/* 555 */,
/* 556 */,
/* 557 */,
/* 558 */,
/* 559 */,
/* 560 */,
/* 561 */,
/* 562 */,
/* 563 */,
/* 564 */,
/* 565 */,
/* 566 */,
/* 567 */,
/* 568 */,
/* 569 */,
/* 570 */,
/* 571 */,
/* 572 */,
/* 573 */,
/* 574 */,
/* 575 */,
/* 576 */,
/* 577 */,
/* 578 */,
/* 579 */,
/* 580 */,
/* 581 */,
/* 582 */,
/* 583 */,
/* 584 */,
/* 585 */,
/* 586 */,
/* 587 */,
/* 588 */,
/* 589 */,
/* 590 */,
/* 591 */,
/* 592 */,
/* 593 */,
/* 594 */,
/* 595 */,
/* 596 */,
/* 597 */,
/* 598 */,
/* 599 */,
/* 600 */,
/* 601 */,
/* 602 */,
/* 603 */,
/* 604 */,
/* 605 */,
/* 606 */,
/* 607 */,
/* 608 */,
/* 609 */,
/* 610 */,
/* 611 */,
/* 612 */,
/* 613 */,
/* 614 */,
/* 615 */,
/* 616 */,
/* 617 */,
/* 618 */,
/* 619 */,
/* 620 */,
/* 621 */,
/* 622 */,
/* 623 */,
/* 624 */,
/* 625 */,
/* 626 */,
/* 627 */,
/* 628 */,
/* 629 */,
/* 630 */,
/* 631 */,
/* 632 */,
/* 633 */,
/* 634 */,
/* 635 */,
/* 636 */,
/* 637 */,
/* 638 */,
/* 639 */,
/* 640 */,
/* 641 */,
/* 642 */,
/* 643 */,
/* 644 */,
/* 645 */,
/* 646 */,
/* 647 */,
/* 648 */,
/* 649 */,
/* 650 */,
/* 651 */,
/* 652 */,
/* 653 */,
/* 654 */,
/* 655 */,
/* 656 */,
/* 657 */,
/* 658 */,
/* 659 */,
/* 660 */,
/* 661 */,
/* 662 */,
/* 663 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GlobalStateProvider = GlobalStateProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _query_string = __webpack_require__(1281);

var _state = __webpack_require__(436);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana/global_state');

function GlobalStateProvider(Private) {
  var State = Private(_state.StateProvider);

  _lodash2.default.class(GlobalState).inherits(State);
  function GlobalState(defaults) {
    GlobalState.Super.call(this, '_g', defaults);
  }

  // if the url param is missing, write it back
  GlobalState.prototype._persistAcrossApps = true;

  GlobalState.prototype.removeFromUrl = function (url) {
    return _query_string.QueryString.replaceParamInUrl(url, this._urlParam, null);
  };

  return new GlobalState();
}

_module.service('globalState', function (Private) {
  return Private(GlobalStateProvider);
});

/***/ }),
/* 664 */,
/* 665 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pkg = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _path = __webpack_require__(296);

var pkg = exports.pkg = _extends({
  __filename: /*require.resolve*/(433),
  __dirname: (0, _path.dirname)(/*require.resolve*/(433))
}, __webpack_require__(433));

/***/ }),
/* 666 */,
/* 667 */,
/* 668 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.modifyUrl = modifyUrl;

var _url = __webpack_require__(71);

/**
 *  Takes a URL and a function that takes the meaningful parts
 *  of the URL as a key-value object, modifies some or all of
 *  the parts, and returns the modified parts formatted again
 *  as a url.
 *
 *  Url Parts sent:
 *    - protocol
 *    - slashes (does the url have the //)
 *    - auth
 *    - hostname (just the name of the host, no port or auth information)
 *    - port
 *    - pathmame (the path after the hostname, no query or hash, starts
 *        with a slash if there was a path)
 *    - query (always an object, even when no query on original url)
 *    - hash
 *
 *  Why?
 *    - The default url library in node produces several conflicting
 *      properties on the "parsed" output. Modifying any of these might
 *      lead to the modifications being ignored (depending on which
 *      property was modified)
 *    - It's not always clear wither to use path/pathname, host/hostname,
 *      so this trys to add helpful constraints
 *
 *  @param  {String} url - the url to parse
 *  @param  {Function<Object|undefined>} block - a function that will modify the parsed url, or return a new one
 *  @return {String} the modified and reformatted url
 */
function modifyUrl(url, block) {
  if (typeof block !== 'function') {
    throw new TypeError('You must pass a block to define the modifications desired');
  }

  var parsed = (0, _url.parse)(url, true);

  // copy over the most specific version of each
  // property. By default, the parsed url includes
  // several conflicting properties (like path and
  // pathname + search, or search and query) and keeping
  // track of which property is actually used when they
  // are formatted is harder than necessary
  var meaningfulParts = {
    protocol: parsed.protocol,
    slashes: parsed.slashes,
    auth: parsed.auth,
    hostname: parsed.hostname,
    port: parsed.port,
    pathname: parsed.pathname,
    query: parsed.query || {},
    hash: parsed.hash
  };

  // the block modifies the meaningfulParts object, or returns a new one
  var modifiedParts = block(meaningfulParts) || meaningfulParts;

  // format the modified/replaced meaningfulParts back into a url
  return (0, _url.format)({
    protocol: modifiedParts.protocol,
    slashes: modifiedParts.slashes,
    auth: modifiedParts.auth,
    hostname: modifiedParts.hostname,
    port: modifiedParts.port,
    pathname: modifiedParts.pathname,
    query: modifiedParts.query,
    hash: modifiedParts.hash
  });
}

/***/ }),
/* 669 */,
/* 670 */,
/* 671 */,
/* 672 */,
/* 673 */,
/* 674 */,
/* 675 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createReduceStream = createReduceStream;

var _stream = __webpack_require__(166);

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

/**
 *  Create a transform stream that consumes each chunk it receives
 *  and passes it to the reducer, which will return the new value
 *  for the stream. Once all chunks have been received the reduce
 *  stream provides the result of final call to the reducer to
 *  subscribers.
 *
 *  @param  {Function}
 *  @param  {any} initial Initial value for the stream, if undefined
 *                        then the first chunk provided is used as the
 *                        initial value.
 *  @return {Transform}
 */
function createReduceStream(reducer, initial) {
  var i = -1;
  var value = initial;

  // if the reducer throws an error then the value is
  // considered invalid and the stream will never provide
  // it to subscribers. We will also stop calling the
  // reducer for any new data that is provided to us
  var failed = false;

  if (typeof reducer !== 'function') {
    throw new TypeError('reducer must be a function');
  }

  return new _stream.Transform({
    readableObjectMode: true,
    writableObjectMode: true,
    transform: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(chunk, enc, callback) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;

                if (!failed) {
                  _context.next = 3;
                  break;
                }

                return _context.abrupt('return', callback());

              case 3:

                i += 1;

                if (!(i === 0 && initial === undefined)) {
                  _context.next = 8;
                  break;
                }

                value = chunk;
                _context.next = 11;
                break;

              case 8:
                _context.next = 10;
                return reducer(value, chunk, enc);

              case 10:
                value = _context.sent;

              case 11:

                callback();
                _context.next = 18;
                break;

              case 14:
                _context.prev = 14;
                _context.t0 = _context['catch'](0);

                failed = true;
                callback(_context.t0);

              case 18:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this, [[0, 14]]);
      }));

      function transform(_x, _x2, _x3) {
        return _ref.apply(this, arguments);
      }

      return transform;
    }(),
    flush: function flush(callback) {
      if (!failed) {
        this.push(value);
      }

      callback();
    }
  });
}

/***/ }),
/* 676 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1324);

/***/ }),
/* 677 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1326);

/***/ }),
/* 678 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UtilsDiffTimePickerValsProvider = UtilsDiffTimePickerValsProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _angular = __webpack_require__(16);

var _angular2 = _interopRequireDefault(_angular);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function UtilsDiffTimePickerValsProvider() {

  var valueOf = function valueOf(o) {
    if (o) return o.valueOf();
  };

  return function (rangeA, rangeB) {
    if (_lodash2.default.isObject(rangeA) && _lodash2.default.isObject(rangeB)) {
      if (valueOf(rangeA.to) !== valueOf(rangeB.to) || valueOf(rangeA.from) !== valueOf(rangeB.from) || valueOf(rangeA.value) !== valueOf(rangeB.value) || valueOf(rangeA.pause) !== valueOf(rangeB.pause)) {
        return true;
      }
    } else {
      return !_angular2.default.equals(rangeA, rangeB);
    }

    return false;
  };
}

/***/ }),
/* 679 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RouteSetupManager = exports.WAIT_FOR_URL_CHANGE_TOKEN = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Throw this inside of an Angular route resolver after calling `kbnUrl.change`
// so that the $router can observe the $location update. Otherwise, the location
// route setup work will resovle before the route update occurs.
var WAIT_FOR_URL_CHANGE_TOKEN = exports.WAIT_FOR_URL_CHANGE_TOKEN = new Error('WAIT_FOR_URL_CHANGE_TOKEN');

var RouteSetupManager = exports.RouteSetupManager = function () {
  function RouteSetupManager() {
    _classCallCheck(this, RouteSetupManager);

    this.setupWork = [];
    this.onSetupComplete = [];
    this.onSetupError = [];
    this.onWorkComplete = [];
    this.onWorkError = [];
  }

  _createClass(RouteSetupManager, [{
    key: 'addSetupWork',
    value: function addSetupWork(fn) {
      this.setupWork.push(fn);
    }
  }, {
    key: 'afterSetupWork',
    value: function afterSetupWork(onComplete, onError) {
      this.onSetupComplete.push(onComplete);
      this.onSetupError.push(onError);
    }
  }, {
    key: 'afterWork',
    value: function afterWork(onComplete, onError) {
      this.onWorkComplete.push(onComplete);
      this.onWorkError.push(onError);
    }

    /**
     * Do each setupWork function by injecting it with angular dependencies
     * and accepting promises from it.
     * @return {[type]} [description]
     */

  }, {
    key: 'doWork',
    value: function doWork(Promise, $injector, userWork) {
      var _this = this;

      var invokeEach = function invokeEach(arr, locals) {
        return Promise.map(arr, function (fn) {
          if (!fn) return;
          return $injector.invoke(fn, null, locals);
        });
      };

      // call each error handler in order, until one of them resolves
      // or we run out of handlers
      var callErrorHandlers = function callErrorHandlers(handlers, origError) {
        if (!_lodash2.default.size(handlers)) throw origError;

        // clone so we don't discard handlers or loose them
        handlers = handlers.slice(0);

        var next = function next(err) {
          if (!handlers.length) throw err;

          var handler = handlers.shift();
          if (!handler) return next(err);

          return Promise.try(function () {
            return $injector.invoke(handler, null, { err: err });
          }).catch(next);
        };

        return next(origError);
      };

      return invokeEach(this.setupWork).then(function () {
        return invokeEach(_this.onSetupComplete);
      }, function (err) {
        return callErrorHandlers(_this.onSetupError, err);
      }).then(function () {
        // wait for the queue to fill up, then do all the work
        var defer = Promise.defer();
        userWork.resolveWhenFull(defer);

        return defer.promise.then(function () {
          return Promise.all(userWork.doWork());
        });
      }).catch(function (error) {
        if (error === WAIT_FOR_URL_CHANGE_TOKEN) {
          // prevent moving forward, return a promise that never resolves
          // so that the $router can observe the $location update
          return Promise.halt();
        }

        throw error;
      }).then(function () {
        return invokeEach(_this.onWorkComplete);
      }, function (err) {
        return callErrorHandlers(_this.onWorkError, err);
      });
    }
  }]);

  return RouteSetupManager;
}();

/***/ }),
/* 680 */,
/* 681 */,
/* 682 */,
/* 683 */,
/* 684 */,
/* 685 */,
/* 686 */,
/* 687 */,
/* 688 */,
/* 689 */,
/* 690 */,
/* 691 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1415);

/***/ }),
/* 692 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _storage = __webpack_require__(1417);

Object.defineProperty(exports, 'Storage', {
  enumerable: true,
  get: function get() {
    return _storage.Storage;
  }
});

/***/ }),
/* 693 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _kbn_href = __webpack_require__(694);

(0, _kbn_href.kbnUrlDirective)('kbnSrc');

/***/ }),
/* 694 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.kbnUrlDirective = kbnUrlDirective;

var _modules = __webpack_require__(2);

var _lodash = __webpack_require__(1);

function kbnUrlDirective(name) {
  var attr = (0, _lodash.kebabCase)((0, _lodash.words)(name).slice(1));

  _modules.uiModules.get('kibana').directive(name, function (Private, chrome) {
    return {
      restrict: 'A',
      link: function link($scope, $el, $attr) {
        $attr.$observe(name, function (val) {
          $attr.$set(attr, chrome.addBasePath(val));
        });
      }
    };
  });
}

kbnUrlDirective('kbnHref');

/***/ }),
/* 695 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.UrlOverflowServiceProvider = UrlOverflowServiceProvider;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var URL_MAX_IE = 2000;
var URL_MAX_OTHERS = 25000;
var IE_REGEX = exports.IE_REGEX = /(; ?MSIE |Edge\/\d|Trident\/[\d+\.]+;.*rv:*11\.\d+)/;

var UrlOverflowService = exports.UrlOverflowService = function () {
  function UrlOverflowService() {
    var _this = this;

    _classCallCheck(this, UrlOverflowService);

    var key = 'error/url-overflow/url';
    var store = window.sessionStorage || {
      getItem: function getItem() {},
      setItem: function setItem() {},
      removeItem: function removeItem() {}
    };

    // FIXME: Couldn't find a way to test for browser compatibility without
    // complex redirect and cookie based "feature-detection" page, so going
    // with user-agent detection for now.
    this._ieLike = IE_REGEX.test(window.navigator.userAgent);

    this._val = store.getItem(key);
    this._sync = function () {
      if (_this._val == null) store.removeItem(key);else store.setItem(key, _this._val);
    };
  }

  _createClass(UrlOverflowService, [{
    key: 'failLength',
    value: function failLength() {
      return this._ieLike ? URL_MAX_IE : URL_MAX_OTHERS;
    }
  }, {
    key: 'set',
    value: function set(v) {
      this._val = v;
      this._sync();
    }
  }, {
    key: 'get',
    value: function get() {
      return this._val;
    }
  }, {
    key: 'check',
    value: function check(absUrl) {
      if (!this.get()) {
        var urlLength = absUrl.length;
        var remaining = this.failLength() - urlLength;

        if (remaining > 0) {
          return remaining;
        }

        this.set(absUrl);
      }

      throw new Error('\n      The URL has gotten too big and kibana can no longer\n      continue. Please refresh to return to your previous state.\n    ');
    }
  }, {
    key: 'clear',
    value: function clear() {
      this._val = undefined;
      this._sync();
    }
  }]);

  return UrlOverflowService;
}();

function UrlOverflowServiceProvider() {
  return new UrlOverflowService();
}

/***/ }),
/* 696 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

_modules.uiModules.get('kibana').filter('uriescape', function () {
  return function (str) {
    return encodeURIComponent(str);
  };
});

/***/ }),
/* 697 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _risonNode = __webpack_require__(132);

var _risonNode2 = _interopRequireDefault(_risonNode);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');

_module.filter('rison', function () {
  return function (str) {
    return _risonNode2.default.encode(str);
  };
});

_module.filter('risonDecode', function () {
  return function (str) {
    return _risonNode2.default.decode(str);
  };
});

/***/ }),
/* 698 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PersistedState = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @name PersistedState
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @extends Events
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _toPath = __webpack_require__(666);

var _toPath2 = _interopRequireDefault(_toPath);

var _errors = __webpack_require__(37);

var _simple_emitter = __webpack_require__(437);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function prepSetParams(key, value, path) {
  // key must be the value, set the entire state using it
  if (_lodash2.default.isUndefined(value) && (_lodash2.default.isPlainObject(key) || path.length > 0)) {
    // setting entire tree, swap the key and value to write to the state
    value = key;
    key = undefined;
  }

  // ensure the value being passed in is never mutated
  return {
    value: _lodash2.default.cloneDeep(value),
    key: key
  };
}

var PersistedState = exports.PersistedState = function () {

  /**
   *
   * @param value
   * @param path
   * @param parent
   * @param silent
   * @param EmitterClass {SimpleEmitter} - a SimpleEmitter class that this class will extend. Can be used to
   * inherit a custom event emitter. For example, the EventEmitter is an "angular-ized" version
   * for angular components which automatically triggers a digest loop for every registered
   * handler.  TODO: Get rid of the need for EventEmitter by wrapping handlers that require it
   * in a special function that will handler triggering the digest loop.
   */
  function PersistedState(value, path, parent, silent) {
    var _this = this;

    var EmitterClass = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _simple_emitter.SimpleEmitter;

    _classCallCheck(this, PersistedState);

    EmitterClass.call(this);

    this._EmitterClass = EmitterClass;
    this._path = this._setPath(path);
    this._parent = parent || false;

    _lodash2.default.forOwn(EmitterClass.prototype, function (method, methodName) {
      _this[methodName] = function () {
        return EmitterClass.prototype[methodName].apply(this._parent || this, arguments);
      };
    });

    // Some validations
    if (this._parent) {
      if (this._path.length <= 0) {
        throw new _errors.PersistedStateError('PersistedState child objects must contain a path');
      }
      if (!(this._parent instanceof PersistedState)) {
        throw new _errors.PersistedStateError('Parent object must be an instance of PersistedState');
      }
    } else if (!this._path.length && value && !_lodash2.default.isPlainObject(value)) {
      throw new _errors.PersistedStateError('State value must be a plain object');
    }

    value = value || this._getDefault();

    // copy passed state values and create internal trackers
    silent ? this.setSilent(value) : this.set(value);
    this._initialized = true; // used to track state changes
  }

  _createClass(PersistedState, [{
    key: 'get',
    value: function get(key, def) {
      return _lodash2.default.cloneDeep(this._get(key, def));
    }
  }, {
    key: 'set',
    value: function set(key, value) {
      var params = prepSetParams(key, value, this._path);
      var val = this._set(params.key, params.value);
      this.emit('set');
      return val;
    }
  }, {
    key: 'setSilent',
    value: function setSilent(key, value) {
      var params = prepSetParams(key, value, this._path);
      return this._set(params.key, params.value, true);
    }
  }, {
    key: 'reset',
    value: function reset(path) {
      var keyPath = this._getIndex(path);
      var origValue = _lodash2.default.get(this._defaultState, keyPath);
      var currentValue = _lodash2.default.get(this._mergedState, keyPath);

      if (_lodash2.default.isUndefined(origValue)) {
        this._cleanPath(path, this._mergedState);
      } else {
        _lodash2.default.set(this._mergedState, keyPath, origValue);
      }

      // clean up the changedState and defaultChildState trees
      this._cleanPath(path, this._changedState);
      this._cleanPath(path, this._defaultChildState);

      if (!_lodash2.default.isEqual(currentValue, origValue)) this.emit('change');
    }

    /**
     *
     * @param path {String}
     * @param value {Object} The uiState to store.
     * @param silent {Boolean}
     * @returns {PersistedState}
     */

  }, {
    key: 'createChild',
    value: function createChild(path, value, silent) {
      this._setChild(this._getIndex(path), value, this._parent || this);
      return new PersistedState(value, this._getIndex(path), this._parent || this, silent, this._EmitterClass);
    }
  }, {
    key: 'removeChild',
    value: function removeChild(path) {
      var origValue = _lodash2.default.get(this._defaultState, this._getIndex(path));

      if (_lodash2.default.isUndefined(origValue)) {
        this.reset(path);
      } else {
        this.set(path, origValue);
      }
    }
  }, {
    key: 'getChanges',
    value: function getChanges() {
      return _lodash2.default.cloneDeep(this._changedState);
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      return this.get();
    }
  }, {
    key: 'toString',
    value: function toString() {
      return JSON.stringify(this.toJSON());
    }
  }, {
    key: 'fromString',
    value: function fromString(input) {
      return this.set(JSON.parse(input));
    }
  }, {
    key: '_getIndex',
    value: function _getIndex(key) {
      if (_lodash2.default.isUndefined(key)) return this._path;
      return (this._path || []).concat((0, _toPath2.default)(key));
    }
  }, {
    key: '_getPartialIndex',
    value: function _getPartialIndex(key) {
      var keyPath = this._getIndex(key);
      return keyPath.slice(this._path.length);
    }
  }, {
    key: '_cleanPath',
    value: function _cleanPath(path, stateTree) {
      var partialPath = this._getPartialIndex(path);
      var remove = true;

      // recursively delete value tree, when no other keys exist
      while (partialPath.length > 0) {
        var lastKey = partialPath.splice(partialPath.length - 1, 1)[0];
        var statePath = this._path.concat(partialPath);
        var stateVal = statePath.length > 0 ? _lodash2.default.get(stateTree, statePath) : stateTree;

        // if stateVal isn't an object, do nothing
        if (!_lodash2.default.isPlainObject(stateVal)) return;

        if (remove) delete stateVal[lastKey];
        if (Object.keys(stateVal).length > 0) remove = false;
      }
    }
  }, {
    key: '_getDefault',
    value: function _getDefault() {
      var def = this._hasPath() ? undefined : {};
      return this._parent ? this.get() : def;
    }
  }, {
    key: '_setPath',
    value: function _setPath(path) {
      var isString = _lodash2.default.isString(path);
      var isArray = Array.isArray(path);

      if (!isString && !isArray) return [];
      return isString ? [this._getIndex(path)] : path;
    }
  }, {
    key: '_setChild',
    value: function _setChild(path, value, parent) {
      parent._defaultChildState = parent._defaultChildState || {};
      _lodash2.default.set(parent._defaultChildState, path, value);
    }
  }, {
    key: '_hasPath',
    value: function _hasPath() {
      return this._path.length > 0;
    }
  }, {
    key: '_get',
    value: function _get(key, def) {
      // delegate to parent instance
      if (this._parent) return this._parent._get(this._getIndex(key), def);

      // no path and no key, get the whole state
      if (!this._hasPath() && _lodash2.default.isUndefined(key)) {
        return this._mergedState;
      }

      return _lodash2.default.get(this._mergedState, this._getIndex(key), def);
    }
  }, {
    key: '_set',
    value: function _set(key, value, silent, initialChildState) {
      var self = this;
      var stateChanged = false;
      var initialState = !this._initialized;
      var keyPath = this._getIndex(key);
      var hasKeyPath = keyPath.length > 0;

      // if this is the initial state value, save value as the default
      if (initialState) {
        this._changedState = {};
        if (!this._hasPath() && _lodash2.default.isUndefined(key)) this._defaultState = value;else this._defaultState = _lodash2.default.set({}, keyPath, value);
      }

      // delegate to parent instance, passing child's default value
      if (this._parent) {
        return this._parent._set(keyPath, value, silent, initialState);
      }

      // everything in here affects only the parent state
      if (!initialState) {
        // no path and no key, set the whole state
        if (!this._hasPath() && _lodash2.default.isUndefined(key)) {
          // compare changedState and new state, emit an event when different
          stateChanged = !_lodash2.default.isEqual(this._changedState, value);
          if (!initialChildState) {
            this._changedState = value;
            this._mergedState = _lodash2.default.cloneDeep(value);
          }
        } else {
          // check for changes at path, emit an event when different
          var curVal = hasKeyPath ? this.get(keyPath) : this._mergedState;
          stateChanged = !_lodash2.default.isEqual(curVal, value);

          if (!initialChildState) {
            // arrays are merge by index, not desired - ensure they are replaced
            if (Array.isArray(_lodash2.default.get(this._mergedState, keyPath))) {
              if (hasKeyPath) _lodash2.default.set(this._mergedState, keyPath, undefined);else this._mergedState = undefined;
            }

            if (hasKeyPath) _lodash2.default.set(this._changedState, keyPath, value);else this._changedState = _lodash2.default.isPlainObject(value) ? value : {};
          }
        }
      }

      // update the merged state value
      var targetObj = this._mergedState || _lodash2.default.cloneDeep(this._defaultState);
      var sourceObj = _lodash2.default.merge({}, this._defaultChildState, this._changedState);

      // handler arguments are (targetValue, sourceValue, key, target, source)
      var mergeMethod = function mergeMethod(targetValue, sourceValue, mergeKey) {
        // if not initial state, skip default merge method (ie. return value, see note below)
        if (!initialState && !initialChildState && _lodash2.default.isEqual(keyPath, self._getIndex(mergeKey))) {
          // use the sourceValue or fall back to targetValue
          return !_lodash2.default.isUndefined(sourceValue) ? sourceValue : targetValue;
        }
      };

      // If `mergeMethod` is provided it is invoked to produce the merged values of the
      // destination and source properties.
      // If `mergeMethod` returns `undefined` the default merging method is used
      this._mergedState = _lodash2.default.merge(targetObj, sourceObj, mergeMethod);

      // sanity check; verify that there are actually changes
      if (_lodash2.default.isEqual(this._mergedState, this._defaultState)) this._changedState = {};

      if (!silent && stateChanged) this.emit('change');

      return this;
    }
  }]);

  return PersistedState;
}();

/***/ }),
/* 699 */,
/* 700 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unhashQueryString = unhashQueryString;

var _lodash = __webpack_require__(1);

function unhashQueryString(parsedQueryString, states) {
  return (0, _lodash.mapValues)(parsedQueryString, function (val, key) {
    var state = states.find(function (s) {
      return key === s.getQueryParamName();
    });
    return state ? state.translateHashToRison(val) : val;
  });
}

/***/ }),
/* 701 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prependPath = prependPath;

var _url = __webpack_require__(71);

var _lodash = __webpack_require__(1);

/**
 *
 * @param {string} relativePath - a relative path that must start with a "/".
 * @param {string} newPath - the new path to prefix. ex: 'xyz'
 * @return {string} the url with the basePath prepended. ex. '/xyz/app/kibana#/management'. If
 * the relative path isn't in the right format (e.g. doesn't start with a "/") the relativePath is returned
 * unchanged.
 */
function prependPath(relativePath) {
  var newPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  if (!relativePath || !(0, _lodash.isString)(relativePath)) {
    return relativePath;
  }

  var parsed = (0, _url.parse)(relativePath, true, true);
  if (!parsed.host && parsed.pathname) {
    if (parsed.pathname[0] === '/') {
      parsed.pathname = newPath + parsed.pathname;
    }
  }

  return (0, _url.format)({
    protocol: parsed.protocol,
    host: parsed.host,
    pathname: parsed.pathname,
    query: parsed.query,
    hash: parsed.hash
  });
}

/***/ }),
/* 702 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.absoluteToParsedUrl = absoluteToParsedUrl;

var _extract_app_path_and_id = __webpack_require__(1462);

var _kibana_parsed_url = __webpack_require__(703);

var _url = __webpack_require__(71);

/**
 *
 * @param absoluteUrl - an absolute url, e.g. https://localhost:5601/gra/app/kibana#/visualize/edit/viz_id?hi=bye
 * @param basePath - An optional base path for kibana. If supplied, should start with a "/".
 * e.g. in https://localhost:5601/gra/app/kibana#/visualize/edit/viz_id the basePath is
 * "/gra".
 * @return {KibanaParsedUrl}
 */
function absoluteToParsedUrl(absoluteUrl) {
  var basePath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  var _extractAppPathAndId = (0, _extract_app_path_and_id.extractAppPathAndId)(absoluteUrl, basePath),
      appPath = _extractAppPathAndId.appPath,
      appId = _extractAppPathAndId.appId;

  var _parse = (0, _url.parse)(absoluteUrl),
      hostname = _parse.hostname,
      port = _parse.port,
      protocol = _parse.protocol;

  return new _kibana_parsed_url.KibanaParsedUrl({ basePath: basePath, appId: appId, appPath: appPath, hostname: hostname, port: port, protocol: protocol });
}

/***/ }),
/* 703 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KibanaParsedUrl = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _url = __webpack_require__(71);

var _prepend_path = __webpack_require__(701);

var _utils = __webpack_require__(199);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Represents the pieces that make up a url in Kibana, offering some helpful functionality for
 * translating those pieces into absolute or relative urls. A Kibana url with a basePath looks like this:
 * http://localhost:5601/basePath/app/appId#/an/appPath?with=query&params
 * basePath is "/basePath"
 * appId is "appId"
 * appPath is "/an/appPath?with=query&params"
 *
 * Almost all urls in Kibana should have this structure, including the "/app" portion in front of the appId
 * (one exception is the login link).
 */
var KibanaParsedUrl = exports.KibanaParsedUrl = function () {
  /**
   * @param {Object} options
   * @property {string} options.basePath - An optional base path for kibana. If supplied, should start with a "/".
   * e.g. in https://localhost:5601/gra/app/kibana#/visualize/edit/viz_id the basePath is
   * "/gra".
   * @property {string} options.appId - the app id.
   * e.g. in https://localhost:5601/gra/app/kibana#/visualize/edit/viz_id the app id is "kibana".
   * @property {string} options.appPath - the path for a page in the the app. Should start with a "/". Don't include the hash sign. Can
   * include all query parameters.
   * e.g. in https://localhost:5601/gra/app/kibana#/visualize/edit/viz_id?g=state the appPath is
   * "/visualize/edit/viz_id?g=state"
   * @property {string} options.hostname - Optional hostname. Uses current window location's hostname if no host or
   * protocol information is supplied.
   * @property {string} options.port - Optional port. Uses current window location's port if no host or protocol
   * information is supplied.
   * @property {string} options.protocol - Optional protocol. Uses current window location's protocol if no host or
   * protocol information is supplied.
   */
  function KibanaParsedUrl(options) {
    _classCallCheck(this, KibanaParsedUrl);

    var appId = options.appId,
        _options$basePath = options.basePath,
        basePath = _options$basePath === undefined ? '' : _options$basePath,
        _options$appPath = options.appPath,
        appPath = _options$appPath === undefined ? '' : _options$appPath,
        hostname = options.hostname,
        protocol = options.protocol,
        port = options.port;

    // We'll use window defaults

    var hostOrProtocolSpecified = hostname || protocol || port;

    this.basePath = basePath;
    this.appId = appId;
    this.appPath = appPath;
    this.hostname = hostOrProtocolSpecified ? hostname : window.location.hostname;
    this.port = hostOrProtocolSpecified ? port : window.location.port;
    this.protocol = hostOrProtocolSpecified ? protocol : window.location.protocol;
  }

  _createClass(KibanaParsedUrl, [{
    key: 'getGlobalState',
    value: function getGlobalState() {
      if (!this.appPath) {
        return '';
      }
      var parsedUrl = (0, _url.parse)(this.appPath, true);
      var query = parsedUrl.query || {};
      return query._g || '';
    }
  }, {
    key: 'setGlobalState',
    value: function setGlobalState(newGlobalState) {
      if (!this.appPath) {
        return;
      }

      this.appPath = (0, _utils.modifyUrl)(this.appPath, function (parsed) {
        parsed.query._g = newGlobalState;
      });
    }
  }, {
    key: 'addQueryParameter',
    value: function addQueryParameter(name, val) {
      this.appPath = (0, _utils.modifyUrl)(this.appPath, function (parsed) {
        parsed.query[name] = val;
      });
    }
  }, {
    key: 'getHashedAppPath',
    value: function getHashedAppPath() {
      return '#' + this.appPath;
    }
  }, {
    key: 'getAppBasePath',
    value: function getAppBasePath() {
      return '/' + this.appId;
    }
  }, {
    key: 'getAppRootPath',
    value: function getAppRootPath() {
      return '/app' + this.getAppBasePath() + this.getHashedAppPath();
    }
  }, {
    key: 'getRootRelativePath',
    value: function getRootRelativePath() {
      return (0, _prepend_path.prependPath)(this.getAppRootPath(), this.basePath);
    }
  }, {
    key: 'getAbsoluteUrl',
    value: function getAbsoluteUrl() {
      var _this = this;

      return (0, _utils.modifyUrl)(this.getRootRelativePath(), function (parsed) {
        parsed.protocol = _this.protocol;
        parsed.port = _this.port;
        parsed.hostname = _this.hostname;
      });
    }
  }]);

  return KibanaParsedUrl;
}();

/***/ }),
/* 704 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _theme = __webpack_require__(1468);

Object.defineProperty(exports, 'registerTheme', {
  enumerable: true,
  get: function get() {
    return _theme.registerTheme;
  }
});
Object.defineProperty(exports, 'applyTheme', {
  enumerable: true,
  get: function get() {
    return _theme.applyTheme;
  }
});
Object.defineProperty(exports, 'getCurrentTheme', {
  enumerable: true,
  get: function get() {
    return _theme.getCurrentTheme;
  }
});

/***/ }),
/* 705 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DocTitleProvider = DocTitleProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_modules.uiModules.get('kibana').run(function ($rootScope, docTitle) {
  // always bind to the route events
  $rootScope.$on('$routeChangeStart', docTitle.reset);
  $rootScope.$on('$routeChangeError', docTitle.update);
  $rootScope.$on('$routeChangeSuccess', docTitle.update);
}).service('docTitle', function () {
  var baseTitle = document.title;
  var self = this;

  var lastChange = void 0;

  function render() {
    lastChange = lastChange || [];

    var parts = [lastChange[0]];

    if (!lastChange[1]) parts.push(baseTitle);

    return (0, _lodash2.default)(parts).flattenDeep().compact().join(' - ');
  }

  self.change = function (title, complete) {
    lastChange = [title, complete];
    self.update();
  };

  self.reset = function () {
    lastChange = null;
  };

  self.update = function () {
    document.title = render();
  };
});

// return a "private module" so that it can be used both ways
function DocTitleProvider(docTitle) {
  return docTitle;
}

/***/ }),
/* 706 */,
/* 707 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1526);

__webpack_require__(2015);

__webpack_require__(2618);

__webpack_require__(2925);

__webpack_require__(302);

/***/ }),
/* 708 */,
/* 709 */,
/* 710 */,
/* 711 */,
/* 712 */,
/* 713 */,
/* 714 */,
/* 715 */,
/* 716 */,
/* 717 */,
/* 718 */,
/* 719 */,
/* 720 */,
/* 721 */,
/* 722 */,
/* 723 */,
/* 724 */,
/* 725 */,
/* 726 */,
/* 727 */,
/* 728 */,
/* 729 */,
/* 730 */,
/* 731 */,
/* 732 */,
/* 733 */,
/* 734 */,
/* 735 */,
/* 736 */,
/* 737 */,
/* 738 */,
/* 739 */,
/* 740 */,
/* 741 */,
/* 742 */,
/* 743 */,
/* 744 */,
/* 745 */,
/* 746 */,
/* 747 */,
/* 748 */,
/* 749 */,
/* 750 */,
/* 751 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.KbnTopNavControllerProvider = KbnTopNavControllerProvider;

var _lodash = __webpack_require__(1);

var _chrome = __webpack_require__(17);

var _chrome2 = _interopRequireDefault(_chrome);

var _filter = __webpack_require__(2018);

var _filter2 = _interopRequireDefault(_filter);

var _interval = __webpack_require__(2019);

var _interval2 = _interopRequireDefault(_interval);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function KbnTopNavControllerProvider($compile) {
  return function () {
    function KbnTopNavController() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      _classCallCheck(this, KbnTopNavController);

      if (opts instanceof KbnTopNavController) {
        return opts;
      }

      this.opts = [];
      this.menuItems = [];
      this.currentKey = null;
      this.templates = {
        interval: _interval2.default,
        filter: _filter2.default
      };
      this.locals = new Map();

      this.addItems(opts);
    }

    _createClass(KbnTopNavController, [{
      key: 'isVisible',
      value: function isVisible() {
        return _chrome2.default.getVisible();
      }
    }, {
      key: 'addItems',
      value: function addItems(rawOpts) {
        var _this = this;

        if (!(0, _lodash.isArray)(rawOpts)) rawOpts = [rawOpts];

        rawOpts.forEach(function (rawOpt) {
          var opt = _this._applyOptDefault(rawOpt);
          if (!opt.key) throw new TypeError('KbnTopNav: menu items must have a key');
          _this.opts.push(opt);
          if (!opt.hideButton()) _this.menuItems.push(opt);
          if (opt.template) _this.templates[opt.key] = opt.template;
          if (opt.locals) {
            _this.locals.set(opt.key, opt.locals);
          }
        });
      }

      // change the current key and rerender

    }, {
      key: 'setCurrent',
      value: function setCurrent(key) {
        if (key && !this.templates.hasOwnProperty(key)) {
          throw new TypeError('KbnTopNav: unknown template key "' + key + '"');
        }

        this.currentKey = key || null;
        this._render();
      }

      // little usability helpers

    }, {
      key: 'getCurrent',
      value: function getCurrent() {
        return this.currentKey;
      }
    }, {
      key: 'isCurrent',
      value: function isCurrent(key) {
        return this.getCurrent() === key;
      }
    }, {
      key: 'open',
      value: function open(key) {
        this.setCurrent(key);
      }
    }, {
      key: 'close',
      value: function close(key) {
        (!key || this.isCurrent(key)) && this.setCurrent(null);
      }
    }, {
      key: 'toggle',
      value: function toggle(key) {
        this.setCurrent(this.isCurrent(key) ? null : key);
      }
    }, {
      key: 'click',
      value: function click(key) {
        this.handleClick(this.getItem(key));
      }
    }, {
      key: 'getItem',
      value: function getItem(key) {
        return this.menuItems.find(function (i) {
          return i.key === key;
        });
      }
    }, {
      key: 'handleClick',
      value: function handleClick(menuItem) {
        if (menuItem.disableButton()) {
          return false;
        }
        menuItem.run(menuItem, this);
      }
      // apply the defaults to individual options

    }, {
      key: '_applyOptDefault',
      value: function _applyOptDefault() {
        var _this2 = this;

        var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var defaultedOpt = _extends({
          label: (0, _lodash.capitalize)(opt.key),
          hasFunction: !!opt.run,
          description: opt.run ? opt.key : 'Toggle ' + opt.key + ' view',
          run: function run(item) {
            return _this2.toggle(item.key);
          }
        }, opt);

        defaultedOpt.hideButton = (0, _lodash.isFunction)(opt.hideButton) ? opt.hideButton : function () {
          return !!opt.hideButton;
        };
        defaultedOpt.disableButton = (0, _lodash.isFunction)(opt.disableButton) ? opt.disableButton : function () {
          return !!opt.disableButton;
        };
        defaultedOpt.tooltip = (0, _lodash.isFunction)(opt.tooltip) ? opt.tooltip : function () {
          return opt.tooltip;
        };

        return defaultedOpt;
      }

      // enable actual rendering

    }, {
      key: '_link',
      value: function _link($scope, $element) {
        this.$scope = $scope;
        this.$element = $element;
        this._render();
      }

      // render the current template to the $element if possible
      // function is idempotent

    }, {
      key: '_render',
      value: function _render() {
        var $scope = this.$scope,
            $element = this.$element,
            rendered = this.rendered,
            currentKey = this.currentKey;

        var templateToRender = currentKey && this.templates[currentKey];

        if (rendered) {
          if (rendered.key !== currentKey) {
            // we have an invalid render, clear it
            rendered.$childScope.$destroy();
            rendered.$el.remove();
            this.rendered = null;
          } else {
            // our previous render is still valid, keep it
            return;
          }
        }

        if (!templateToRender || !$scope || !$element) {
          // we either have nothing to render, or we can't render
          return;
        }

        var $childScope = $scope.$new();
        if (this.locals.has(currentKey)) {
          Object.assign($childScope, this.locals.get(currentKey));
        }
        var $el = $element.find('#template_wrapper').html(templateToRender).contents();
        $compile($el)($childScope);

        this.rendered = { $childScope: $childScope, $el: $el, key: currentKey };
      }
    }]);

    return KbnTopNavController;
  }();
}

/***/ }),
/* 752 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BoundToConfigObjProvider = BoundToConfigObjProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function BoundToConfigObjProvider(config) {

  /**
   * Create an object with properties that may be bound to config values.
   * The input object is basically cloned unless one of it's own properties
   * resolved to a string value that starts with an equal sign. When that is
   * found, that property is forever bound to the corresponding config key.
   *
   * example:
   *
   * // name is cloned, height is bound to the defaultHeight config key
   * { name: 'john', height: '=defaultHeight' };
   *
   * @param  {Object} input
   * @return {Object}
   */
  function BoundToConfigObj(input) {
    var self = this;

    _lodash2.default.forOwn(input, function (value, prop) {
      if (!_lodash2.default.isString(value) || value.charAt(0) !== '=') {
        self[prop] = value;
        return;
      }

      var configKey = value.substr(1);

      config.watch(configKey, function update(value) {
        self[prop] = value;
      });
    });
  }

  return BoundToConfigObj;
}

/***/ }),
/* 753 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(2024);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @name es
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @description This is the result of calling esFactory. esFactory is exposed by the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * elasticsearch.angular.js client.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var plugins = [function (Client, config) {
  // esFactory automatically injects the AngularConnector to the config
  // https://github.com/elastic/elasticsearch-js/blob/master/src/lib/connectors/angular.js
  var CustomAngularConnector = function (_config$connectionCla) {
    _inherits(CustomAngularConnector, _config$connectionCla);

    function CustomAngularConnector() {
      var _ref;

      var _temp, _this, _ret;

      _classCallCheck(this, CustomAngularConnector);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = CustomAngularConnector.__proto__ || Object.getPrototypeOf(CustomAngularConnector)).call.apply(_ref, [this].concat(args))), _this), _this.request = _lodash2.default.wrap(_this.request, function (request, params, cb) {
        if (String(params.method).toUpperCase() === 'GET') {
          params.query = _lodash2.default.defaults({ _: Date.now() }, params.query);
        }

        return request.call(this, params, cb);
      }), _temp), _possibleConstructorReturn(_this, _ret);
    }

    return CustomAngularConnector;
  }(config.connectionClass);

  config.connectionClass = CustomAngularConnector;
}];

_modules.uiModules.get('kibana', ['elasticsearch', 'kibana/config'])

//Elasticsearch client used for requesting data.  Connects to the /elasticsearch proxy,
//Uses a tribe node if configured, otherwise uses the base elasticsearch configuration
.service('es', function (esFactory, esUrl, esApiVersion, esRequestTimeout) {
  return esFactory({
    host: esUrl,
    log: 'info',
    requestTimeout: esRequestTimeout,
    apiVersion: esApiVersion,
    plugins: plugins
  });
});

/***/ }),
/* 754 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
// By default, ElasticSearch surrounds matched values in <em></em>. This is not ideal because it is possible that
// the value could contain <em></em> in the value. We define these custom tags that we would never expect to see
// inside a field value.
var highlightTags = exports.highlightTags = {
  pre: '@kibana-highlighted-field@',
  post: '@/kibana-highlighted-field@'
};

/***/ }),
/* 755 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = MappingSetupService;

var _angular = __webpack_require__(16);

var _angular2 = _interopRequireDefault(_angular);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line @elastic/kibana-custom/no-default-export
function MappingSetupService() {
  var mappingSetup = this;

  var json = {
    _serialize: function _serialize(val) {
      if (val != null) return _angular2.default.toJson(val);
    },
    _deserialize: function _deserialize(val) {
      if (val != null) return JSON.parse(val);
    }
  };

  mappingSetup.expandShorthand = function (sh) {
    return _lodash2.default.mapValues(sh || {}, function (val) {
      // allow shortcuts for the field types, by just setting the value
      // to the type name
      if (typeof val === 'string') val = { type: val };

      if (val.type === 'json') {
        val.type = 'text';
        val._serialize = json._serialize;
        val._deserialize = json._deserialize;
      }

      return val;
    });
  };
}
module.exports = exports['default'];

/***/ }),
/* 756 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SavedObjectsClient = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _chrome = __webpack_require__(17);

var _chrome2 = _interopRequireDefault(_chrome);

var _url = __webpack_require__(71);

var _case_conversion = __webpack_require__(2032);

var _saved_object = __webpack_require__(757);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var join = function join() {
  for (var _len = arguments.length, uriComponents = Array(_len), _key = 0; _key < _len; _key++) {
    uriComponents[_key] = arguments[_key];
  }

  return uriComponents.filter(Boolean).map(encodeURIComponent).join('/');
};

/**
 * Interval that requests are batched for
 * @type {integer}
 */
var BATCH_INTERVAL = 100;

var SavedObjectsClient = exports.SavedObjectsClient = function () {
  function SavedObjectsClient(options) {
    var _this = this;

    _classCallCheck(this, SavedObjectsClient);

    this.processBatchQueue = _lodash2.default.throttle(function () {
      var queue = _lodash2.default.cloneDeep(_this.batchQueue);
      _this.batchQueue = [];

      _this.bulkGet(queue).then(function (_ref) {
        var savedObjects = _ref.savedObjects;

        queue.forEach(function (queueItem) {
          var foundObject = savedObjects.find(function (savedObject) {
            return savedObject.id === queueItem.id & savedObject.type === queueItem.type;
          });

          if (!foundObject) {
            return queueItem.resolve(_this.createSavedObject(_lodash2.default.pick(queueItem, ['id', 'type'])));
          }

          queueItem.resolve(foundObject);
        });
      });
    }, BATCH_INTERVAL, { leading: false });
    var $http = options.$http,
        _options$basePath = options.basePath,
        basePath = _options$basePath === undefined ? _chrome2.default.getBasePath() : _options$basePath,
        _options$PromiseConst = options.PromiseConstructor,
        PromiseConstructor = _options$PromiseConst === undefined ? Promise : _options$PromiseConst,
        _options$onCreateFail = options.onCreateFailure,
        onCreateFailure = _options$onCreateFail === undefined ? function () {} : _options$onCreateFail;


    this._$http = $http;
    this._apiBaseUrl = basePath + '/api/saved_objects/';
    this._PromiseCtor = PromiseConstructor;
    this._onCreateFailure = onCreateFailure;
    this.batchQueue = [];
  }

  /**
  * Persists an object
  *
  * @param {string} type
  * @param {object} [attributes={}]
  * @param {object} [options={}]
  * @property {string} [options.id] - force id on creation, not recommended
  * @property {boolean} [options.overwrite=false]
  * @returns {promise} - SavedObject({ id, type, version, attributes })
  */


  _createClass(SavedObjectsClient, [{
    key: 'create',
    value: function create(type) {
      var _this2 = this;

      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (!type || !attributes) {
        return this._PromiseCtor.reject(new Error('requires type and attributes'));
      }

      var url = this._getUrl([type, options.id], _lodash2.default.pick(options, ['overwrite']));

      return this._request('POST', url, { attributes: attributes }).catch(this._onCreateFailure).then(function (resp) {
        return _this2.createSavedObject(resp);
      });
    }

    /**
     * Deletes an object
     *
     * @param {string} type
     * @param {string} id
     * @returns {promise}
     */

  }, {
    key: 'delete',
    value: function _delete(type, id) {
      if (!type || !id) {
        return this._PromiseCtor.reject(new Error('requires type and id'));
      }

      return this._request('DELETE', this._getUrl([type, id]));
    }

    /**
     * Search for objects
     *
     * @param {object} [options={}]
     * @property {string} options.type
     * @property {string} options.search
     * @property {string} options.searchFields - see Elasticsearch Simple Query String
     *                                        Query field argument for more information
     * @property {integer} [options.page=1]
     * @property {integer} [options.perPage=20]
     * @property {array} options.fields
     * @returns {promise} - { savedObjects: [ SavedObject({ id, type, version, attributes }) ]}
     */

  }, {
    key: 'find',
    value: function find() {
      var _this3 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var url = this._getUrl([], (0, _case_conversion.keysToSnakeCaseShallow)(options));

      return this._request('GET', url).then(function (resp) {
        resp.saved_objects = resp.saved_objects.map(function (d) {
          return _this3.createSavedObject(d);
        });
        return (0, _case_conversion.keysToCamelCaseShallow)(resp);
      });
    }

    /**
     * Fetches a single object
     *
     * @param {string} type
     * @param {string} id
     * @returns {promise} - SavedObject({ id, type, version, attributes })
     */

  }, {
    key: 'get',
    value: function get(type, id) {
      var _this4 = this;

      if (!type || !id) {
        return this._PromiseCtor.reject(new Error('requires type and id'));
      }

      return new this._PromiseCtor(function (resolve, reject) {
        _this4.batchQueue.push({ type: type, id: id, resolve: resolve, reject: reject });
        _this4.processBatchQueue();
      });
    }

    /**
     * Returns an array of objects by id
     *
     * @param {array} objects - an array ids, or an array of objects containing id and optionally type
     * @returns {promise} - { savedObjects: [ SavedObject({ id, type, version, attributes }) ] }
     * @example
     *
     * bulkGet([
     *   { id: 'one', type: 'config' },
     *   { id: 'foo', type: 'index-pattern' }
     * ])
     */

  }, {
    key: 'bulkGet',
    value: function bulkGet() {
      var _this5 = this;

      var objects = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var url = this._getUrl(['bulk_get']);
      var filteredObjects = objects.map(function (obj) {
        return _lodash2.default.pick(obj, ['id', 'type']);
      });

      return this._request('POST', url, filteredObjects).then(function (resp) {
        resp.saved_objects = resp.saved_objects.map(function (d) {
          return _this5.createSavedObject(d);
        });
        return (0, _case_conversion.keysToCamelCaseShallow)(resp);
      });
    }

    /**
     * Updates an object
     *
     * @param {string} type
     * @param {string} id
     * @param {object} options
     * @param {integer} options.version - ensures version matches that of persisted object
     * @returns {promise}
     */

  }, {
    key: 'update',
    value: function update(type, id, attributes) {
      var _this6 = this;

      var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
          version = _ref2.version;

      if (!type || !id || !attributes) {
        return this._PromiseCtor.reject(new Error('requires type, id and attributes'));
      }

      var body = {
        attributes: attributes,
        version: version
      };

      return this._request('PUT', this._getUrl([type, id]), body).then(function (resp) {
        return _this6.createSavedObject(resp);
      });
    }

    /**
     * Throttled processing of get requests into bulk requests at 100ms interval
     */

  }, {
    key: 'createSavedObject',
    value: function createSavedObject(options) {
      return new _saved_object.SavedObject(this, options);
    }
  }, {
    key: '_getUrl',
    value: function _getUrl(path, query) {
      if (!path && !query) {
        return this._apiBaseUrl;
      }

      return (0, _url.resolve)(this._apiBaseUrl, (0, _url.format)({
        pathname: join.apply(undefined, _toConsumableArray(path)),
        query: _lodash2.default.pick(query, function (value) {
          return value != null;
        })
      }));
    }
  }, {
    key: '_request',
    value: function _request(method, url, body) {
      var options = { method: method, url: url, data: body };

      if (method === 'GET' && body) {
        return this._PromiseCtor.reject(new Error('body not permitted for GET requests'));
      }

      return this._$http(options).then(function (resp) {
        return _lodash2.default.get(resp, 'data');
      }).catch(function (resp) {
        var respBody = _lodash2.default.get(resp, 'data', {});
        var err = new Error(respBody.message || respBody.error || resp.status + ' Response');

        err.statusCode = respBody.statusCode || resp.status;
        err.body = respBody;

        throw err;
      });
    }
  }]);

  return SavedObjectsClient;
}();

/***/ }),
/* 757 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SavedObject = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SavedObject = exports.SavedObject = function () {
  function SavedObject(client) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        id = _ref.id,
        type = _ref.type,
        version = _ref.version,
        attributes = _ref.attributes;

    _classCallCheck(this, SavedObject);

    this._client = client;
    this.id = id;
    this.type = type;
    this.attributes = attributes || {};
    this._version = version;
  }

  _createClass(SavedObject, [{
    key: 'get',
    value: function get(key) {
      return _lodash2.default.get(this.attributes, key);
    }
  }, {
    key: 'set',
    value: function set(key, value) {
      return _lodash2.default.set(this.attributes, key, value);
    }
  }, {
    key: 'has',
    value: function has(key) {
      return _lodash2.default.has(this.attributes, key);
    }
  }, {
    key: 'save',
    value: function save() {
      if (this.id) {
        return this._client.update(this.type, this.id, this.attributes);
      } else {
        return this._client.create(this.type, this.attributes);
      }
    }
  }, {
    key: 'delete',
    value: function _delete() {
      return this._client.delete(this.type, this.id);
    }
  }]);

  return SavedObject;
}();

/***/ }),
/* 758 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IndexPatternsIntervalsProvider = IndexPatternsIntervalsProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

var _indexed_array = __webpack_require__(99);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function IndexPatternsIntervalsProvider(timefilter) {

  var intervals = new _indexed_array.IndexedArray({
    index: ['name'],
    initialSet: [{
      name: 'hours',
      startOf: 'hour',
      display: 'Hourly'
    }, {
      name: 'days',
      startOf: 'day',
      display: 'Daily'
    }, {
      name: 'weeks',
      startOf: 'isoWeek',
      display: 'Weekly'
    }, {
      name: 'months',
      startOf: 'month',
      display: 'Monthly'
    }, {
      name: 'years',
      startOf: 'year',
      display: 'Yearly'
    }]
  });

  intervals.toIndexList = function (format, interval, a, b, sortDirection) {
    var bounds = void 0;

    // setup the range that the list will span, return two moment objects that
    // are in proper order. a and b can be numbers to specify to go before or after now (respectively)
    // a certain number of times, based on the interval
    var range = [[a, 'min', 'startOf'], [b, 'max', 'startOf']].map(function (v) {
      var val = v[0];
      var bound = v[1];
      var extend = v[2];

      // grab a bound from the time filter
      if (val == null) {
        bounds = bounds || timefilter.getBounds();
        val = bounds[bound];
      }

      if (_lodash2.default.isNumeric(val)) val = (0, _moment2.default)().add(val, interval.name);else if (!_moment2.default.isMoment(val)) val = (0, _moment2.default)(val);

      return val.clone().utc()[extend](interval.startOf);
    }).sort(function (a, b) {
      return a - b;
    });

    if (typeof interval === 'string') {
      interval = _lodash2.default.find(intervals, { name: interval });
      if (!interval) throw new Error('Interval must be one of ' + _lodash2.default.pluck(intervals, 'name'));
    }

    var indexList = [];
    var start = range.shift();
    // turn stop into milliseconds to that it's not constantly converted by the while condition
    var stop = range.shift().valueOf();

    var add = sortDirection === 'desc' ? 'unshift' : 'push';

    while (start <= stop) {
      var index = start.format(format);
      var next = (0, _moment2.default)(start).add(1, interval.name);
      var bound = (0, _moment2.default)(next).subtract(1, 'ms');

      var min = start.valueOf();
      var max = bound.valueOf();
      indexList[add]({
        index: index,
        min: min,
        max: max
      });

      start = next;
    }

    return indexList;
  };

  return intervals;
}

/***/ }),
/* 759 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IndexPatternsFieldListProvider = IndexPatternsFieldListProvider;

var _indexed_array = __webpack_require__(99);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _field = __webpack_require__(470);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function IndexPatternsFieldListProvider(Private) {
  var Field = Private(_field.IndexPatternsFieldProvider);

  _lodash2.default.class(FieldList).inherits(_indexed_array.IndexedArray);
  function FieldList(indexPattern, specs) {
    FieldList.Super.call(this, {
      index: ['name'],
      group: ['type'],
      initialSet: specs.map(function (field) {
        return new Field(indexPattern, field);
      })
    });
  }

  return FieldList;
}

/***/ }),
/* 760 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.IndexPatternsPatternCacheProvider = IndexPatternsPatternCacheProvider;
function IndexPatternsPatternCacheProvider() {

  var vals = {};

  var validId = function validId(id) {
    return (typeof id === 'undefined' ? 'undefined' : _typeof(id)) !== 'object';
  };

  this.get = function (id) {
    if (validId(id)) return vals[id];
  };

  this.set = function (id, prom) {
    if (validId(id)) vals[id] = prom;
    return prom;
  };

  this.clear = this.delete = function (id) {
    if (validId(id)) delete vals[id];
  };
}

/***/ }),
/* 761 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FieldsFetcherProvider = FieldsFetcherProvider;

var _fields_fetcher = __webpack_require__(2041);

var _index_patterns_api_client_provider = __webpack_require__(762);

function FieldsFetcherProvider(Private, config) {
  var apiClient = Private(_index_patterns_api_client_provider.IndexPatternsApiClientProvider);
  return (0, _fields_fetcher.createFieldsFetcher)(apiClient, config);
}

/***/ }),
/* 762 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IndexPatternsApiClientProvider = IndexPatternsApiClientProvider;

var _chrome = __webpack_require__(17);

var _chrome2 = _interopRequireDefault(_chrome);

var _index_patterns_api_client = __webpack_require__(2042);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function IndexPatternsApiClientProvider($http) {
  return (0, _index_patterns_api_client.createIndexPatternsApiClient)($http, _chrome2.default.getBasePath());
}

/***/ }),
/* 763 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RootSearchSourceProvider = RootSearchSourceProvider;

var _search_source = __webpack_require__(135);

function RootSearchSourceProvider(Private, $rootScope, timefilter) {
  var SearchSource = Private(_search_source.SearchSourceProvider);

  var globalSource = new SearchSource();
  globalSource.inherits(false); // this is the final source, it has no parents
  globalSource.filter(function (globalSource) {
    // dynamic time filter will be called in the _flatten phase of things
    return timefilter.get(globalSource.get('index'));
  });

  var appSource = void 0; // set in setAppSource()
  resetAppSource();

  // when the route changes, clear the appSource
  $rootScope.$on('$routeChangeStart', resetAppSource);

  /**
   * Get the current AppSource
   * @return {Promise} - resolved with the current AppSource
   */
  function getAppSource() {
    return appSource;
  }

  /**
   * Set the current AppSource
   * @param {SearchSource} source - The Source that represents the applications "root" search source object
   */
  function setAppSource(source) {
    appSource = source;

    // walk the parent chain until we get to the global source or nothing
    // that's where we will attach to the globalSource
    var literalRoot = source;
    while (literalRoot._parent && literalRoot._parent !== globalSource) {
      literalRoot = literalRoot._parent;
    }

    literalRoot.inherits(globalSource);
  }

  /**
   * Sets the appSource to be a new, empty, SearchSource
   * @return {undefined}
   */
  function resetAppSource() {
    setAppSource(new SearchSource());
  }

  return {
    get: getAppSource,
    set: setAppSource,

    getGlobalSource: function getGlobalSource() {
      return globalSource;
    }
  };
}

/***/ }),
/* 764 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.courierNotifier = undefined;

var _notifier = __webpack_require__(43);

var courierNotifier = exports.courierNotifier = new _notifier.Notifier({
  location: 'Courier Fetch'
});

/***/ }),
/* 765 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IsRequestProvider = IsRequestProvider;

var _request = __webpack_require__(766);

function IsRequestProvider(Private) {
  var SearchRequest = Private(_request.SearchRequestProvider);

  return function isRequest(obj) {
    return obj instanceof SearchRequest;
  };
}

/***/ }),
/* 766 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _search_request = __webpack_require__(767);

Object.defineProperty(exports, 'SearchRequestProvider', {
  enumerable: true,
  get: function get() {
    return _search_request.SearchRequestProvider;
  }
});

/***/ }),
/* 767 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.SearchRequestProvider = SearchRequestProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

var _request_queue = __webpack_require__(250);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function SearchRequestProvider(Promise) {

  return function () {
    function SearchRequest(source, defer) {
      _classCallCheck(this, SearchRequest);

      this.source = source;
      this.defer = defer || Promise.defer();
      this.abortedDefer = Promise.defer();
      this.type = 'search';
      _request_queue.requestQueue.push(this);
    }

    /**
     *  Called by the loopers to find requests that should be sent to the
     *  fetch() module. When a module is sent to fetch() it's _fetchRequested flag
     *  is set, and this consults that flag so requests are not send to fetch()
     *  multiple times.
     *
     *  @return {Boolean}
     */


    _createClass(SearchRequest, [{
      key: 'canStart',
      value: function canStart() {
        return !this._fetchRequested && !this.stopped && !this.source._fetchDisabled;
      }

      /**
       *  Used to find requests that were previously sent to the fetch() module but
       *  have not been started yet, so they can be started.
       *
       *  @return {Boolean}
       */

    }, {
      key: 'isFetchRequestedAndPending',
      value: function isFetchRequestedAndPending() {
        return this._fetchRequested && !this.started;
      }

      /**
       *  Called by the fetch() module when this request has been sent to
       *  be fetched. At that point the request is somewhere between `ready-to-start`
       *  and `started`. The fetch module then waits a short period of time to
       *  allow requests to build up in the request queue, and then immediately
       *  fetches all requests that return true from `isFetchRequestedAndPending()`
       *
       *  @return {undefined}
       */

    }, {
      key: '_setFetchRequested',
      value: function _setFetchRequested() {
        this._fetchRequested = true;
      }
    }, {
      key: 'start',
      value: function start() {
        if (this.started) {
          throw new TypeError('Unable to start request because it has already started');
        }

        this.started = true;
        this.moment = (0, _moment2.default)();

        return this.source.requestIsStarting(this);
      }
    }, {
      key: 'getFetchParams',
      value: function getFetchParams() {
        return this.source._flatten();
      }
    }, {
      key: 'filterError',
      value: function filterError() {
        return false;
      }
    }, {
      key: 'handleResponse',
      value: function handleResponse(resp) {
        this.success = true;
        this.resp = resp;
      }
    }, {
      key: 'handleFailure',
      value: function handleFailure(error) {
        this.success = false;
        this.resp = error && error.resp;
        return this.errorHandler(this, error);
      }
    }, {
      key: 'isIncomplete',
      value: function isIncomplete() {
        return false;
      }
    }, {
      key: 'continue',
      value: function _continue() {
        throw new Error('Unable to continue ' + this.type + ' request');
      }
    }, {
      key: 'retry',
      value: function retry() {
        var clone = this.clone();
        this.abort();
        return clone;
      }
    }, {
      key: '_markStopped',
      value: function _markStopped() {
        if (this.stopped) return;
        this.stopped = true;
        this.source.requestIsStopped(this);
        _lodash2.default.pull(_request_queue.requestQueue, this);
      }
    }, {
      key: 'abort',
      value: function abort() {
        this._markStopped();
        this.defer = null;
        this.aborted = true;
        this.abortedDefer.resolve();
        this.abortedDefer = null;
      }
    }, {
      key: 'whenAborted',
      value: function whenAborted(cb) {
        this.abortedDefer.promise.then(cb);
      }
    }, {
      key: 'complete',
      value: function complete() {
        this._markStopped();
        this.ms = this.moment.diff() * -1;
        this.defer.resolve(this.resp);
      }
    }, {
      key: 'getCompletePromise',
      value: function getCompletePromise() {
        return this.defer.promise;
      }
    }, {
      key: 'getCompleteOrAbortedPromise',
      value: function getCompleteOrAbortedPromise() {
        return Promise.race([this.defer.promise, this.abortedDefer.promise]);
      }
    }, {
      key: 'clone',
      value: function clone() {
        return new this.constructor(this.source, this.defer);
      }
    }, {
      key: 'setErrorHandler',
      value: function setErrorHandler(errorHandler) {
        this.errorHandler = errorHandler;
      }
    }]);

    return SearchRequest;
  }();
}

/***/ }),
/* 768 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toJson = toJson;
exports.replacer = replacer;

var _lodash = __webpack_require__(1);

/**
 * Serializes the given object into a JSON string
 *
 * All properties that begin with $ throughout the entire object are omitted.
 * If a custom JSON serializer function is passed, then the given object is
 * passed through it before being re-stringified with the native stringify.
 *
 * The space argument is passed unaltered to the native stringify.
 */
function toJson(object, jsonFn, space) {
  if (jsonFn) {
    // We reparse the stringified json so that we can lean on JSON.stringify's
    // avoiding-infinite-recursion capabilities when stripping out any
    // remaining properties that begin with a dollar sign ($)
    object = JSON.parse(jsonFn(object));
  }
  return JSON.stringify(object, replacer, space);
}

/**
 * Returns the given value if the key does not begin with a dollar sign ($)
 */
function replacer(key, value) {
  return (0, _lodash.isString)(key) && (0, _lodash.startsWith)(key, '$') ? undefined : value;
}

/***/ }),
/* 769 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DecorateQueryProvider = DecorateQueryProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function DecorateQueryProvider(config) {
  /**
   * Decorate queries with default parameters
   * @param {query} query object
   * @returns {object}
   */
  return function (query) {
    var queryOptions = config.get('query:queryString:options');

    if (_lodash2.default.has(query, 'query_string.query')) {
      _lodash2.default.extend(query.query_string, queryOptions);
    }

    return query;
  };
}

/***/ }),
/* 770 */,
/* 771 */,
/* 772 */,
/* 773 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildQueryFromFilters = buildQueryFromFilters;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _migrate_filter = __webpack_require__(774);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Create a filter that can be reversed for filters with negate set
 * @param {boolean} reverse This will reverse the filter. If true then
 *                          anything where negate is set will come
 *                          through otherwise it will filter out
 * @returns {function}
 */
var filterNegate = function filterNegate(reverse) {
  return function (filter) {
    if (_lodash2.default.isUndefined(filter.meta) || _lodash2.default.isUndefined(filter.meta.negate)) return !reverse;
    return filter.meta && filter.meta.negate === reverse;
  };
};

/**
 * Translate a filter into a query to support es 5+
 * @param  {Object} filter - The filter to translate
 * @return {Object} the query version of that filter
 */
var translateToQuery = function translateToQuery(filter) {
  if (!filter) return;

  if (filter.query) {
    return filter.query;
  }

  return filter;
};

/**
 * Clean out any invalid attributes from the filters
 * @param {object} filter The filter to clean
 * @returns {object}
 */
var cleanFilter = function cleanFilter(filter) {
  return _lodash2.default.omit(filter, ['meta', '$state']);
};

function buildQueryFromFilters(filters, decorateQuery, indexPattern) {
  _lodash2.default.each(filters, function (filter) {
    if (filter.query) {
      decorateQuery(filter.query);
    }
  });

  return {
    must: (filters || []).filter(filterNegate(false)).map(translateToQuery).map(cleanFilter).map(function (filter) {
      return (0, _migrate_filter.migrateFilter)(filter, indexPattern);
    }),
    filter: [],
    should: [],
    must_not: (filters || []).filter(filterNegate(true)).map(translateToQuery).map(cleanFilter).map(function (filter) {
      return (0, _migrate_filter.migrateFilter)(filter, indexPattern);
    })
  };
}

/***/ }),
/* 774 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrateFilter = migrateFilter;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _phrase = __webpack_require__(175);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function migrateFilter(filter, indexPattern) {
  if (filter.match) {
    var fieldName = Object.keys(filter.match)[0];

    if (isMatchPhraseFilter(filter, fieldName)) {
      var params = _lodash2.default.get(filter, ['match', fieldName]);
      if (indexPattern) {
        var field = indexPattern.fields.find(function (f) {
          return f.name === fieldName;
        });
        params.query = (0, _phrase.getConvertedValueForField)(field, params.query);
      }
      return {
        match_phrase: _defineProperty({}, fieldName, _lodash2.default.omit(params, 'type'))
      };
    }
  }

  return filter;
}

function isMatchPhraseFilter(filter, fieldName) {
  return _lodash2.default.get(filter, ['match', fieldName, 'type']) === 'phrase';
}

/***/ }),
/* 775 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DebounceProvider = DebounceProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Debounce service, angularized version of lodash debounce
// borrowed heavily from https://github.com/shahata/angular-debounce

var _module = _modules.uiModules.get('kibana');

_module.service('debounce', ['$timeout', function ($timeout) {
  return function (func, wait, options) {
    var timeout = void 0;
    var args = void 0;
    var self = void 0;
    var result = void 0;
    options = _lodash2.default.defaults(options || {}, {
      leading: false,
      trailing: true,
      invokeApply: true
    });

    function debounce() {
      self = this;
      args = arguments;

      var later = function later() {
        timeout = null;
        if (!options.leading || options.trailing) {
          result = func.apply(self, args);
        }
      };

      var callNow = options.leading && !timeout;

      if (timeout) {
        $timeout.cancel(timeout);
      }
      timeout = $timeout(later, wait, options.invokeApply);

      if (callNow) {
        result = func.apply(self, args);
      }

      return result;
    }

    debounce.cancel = function () {
      $timeout.cancel(timeout);
      timeout = null;
    };

    return debounce;
  };
}]);

function DebounceProvider(debounce) {
  return debounce;
}

/***/ }),
/* 776 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NL_RE = /\n/g;
var events = 'keydown keypress keyup change';

_modules.uiModules.get('kibana').directive('elasticTextarea', function () {
  return {
    restrict: 'A',
    link: function link($scope, $el) {

      function resize() {
        $el.attr('rows', _lodash2.default.size($el.val().match(NL_RE)) + 1);
      }

      $el.on(events, resize);
      $scope.$evalAsync(resize);
      $scope.$on('$destroy', function () {
        $el.off(events, resize);
      });
    }
  };
});

/***/ }),
/* 777 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toggleFilterDisabled = exports.enableFilter = exports.disableFilter = undefined;

var _disable_filter = __webpack_require__(778);

Object.defineProperty(exports, 'disableFilter', {
  enumerable: true,
  get: function get() {
    return _disable_filter.disableFilter;
  }
});
Object.defineProperty(exports, 'enableFilter', {
  enumerable: true,
  get: function get() {
    return _disable_filter.enableFilter;
  }
});
Object.defineProperty(exports, 'toggleFilterDisabled', {
  enumerable: true,
  get: function get() {
    return _disable_filter.toggleFilterDisabled;
  }
});

__webpack_require__(2107);

/***/ }),
/* 778 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.disableFilter = disableFilter;
exports.enableFilter = enableFilter;
exports.toggleFilterDisabled = toggleFilterDisabled;
function disableFilter(filter) {
  return setFilterDisabled(filter, true);
}

function enableFilter(filter) {
  return setFilterDisabled(filter, false);
}

function toggleFilterDisabled(filter) {
  var _filter$meta = filter.meta;
  _filter$meta = _filter$meta === undefined ? {} : _filter$meta;
  var _filter$meta$disabled = _filter$meta.disabled,
      disabled = _filter$meta$disabled === undefined ? false : _filter$meta$disabled;


  return setFilterDisabled(filter, !disabled);
}

function setFilterDisabled(filter, disabled) {
  var _filter$meta2 = filter.meta,
      meta = _filter$meta2 === undefined ? {} : _filter$meta2;


  return _extends({}, filter, {
    meta: _extends({}, meta, {
      disabled: disabled
    })
  });
}

/***/ }),
/* 779 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _angular = __webpack_require__(16);

var _angular2 = _interopRequireDefault(_angular);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_modules.uiModules.get('kibana').directive('jsonInput', function () {
  return {
    restrict: 'A',
    require: 'ngModel',
    link: function link(scope, $el, attrs, ngModelCntrl) {
      ngModelCntrl.$formatters.push(toJSON);
      ngModelCntrl.$parsers.push(fromJSON);

      function fromJSON(value) {
        try {
          value = JSON.parse(value);
          var validity = !scope.$eval(attrs.requireKeys) ? true : _lodash2.default.keys(value).length > 0;
          ngModelCntrl.$setValidity('json', validity);
        } catch (e) {
          ngModelCntrl.$setValidity('json', false);
        }
        return value;
      }

      function toJSON(value) {
        return _angular2.default.toJson(value, 2);
      }
    }
  };
});

/***/ }),
/* 780 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FILTER_OPERATOR_TYPES = exports.FILTER_OPERATORS = undefined;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FILTER_OPERATORS = exports.FILTER_OPERATORS = [{
  name: 'is',
  type: 'phrase',
  negate: false
}, {
  name: 'is not',
  type: 'phrase',
  negate: true
}, {
  name: 'is one of',
  type: 'phrases',
  negate: false,
  fieldTypes: ['string', 'number', 'date', 'ip', 'geo_point', 'geo_shape']
}, {
  name: 'is not one of',
  type: 'phrases',
  negate: true,
  fieldTypes: ['string', 'number', 'date', 'ip', 'geo_point', 'geo_shape']
}, {
  name: 'is between',
  type: 'range',
  negate: false,
  fieldTypes: ['number', 'date', 'ip']
}, {
  name: 'is not between',
  type: 'range',
  negate: true,
  fieldTypes: ['number', 'date', 'ip']
}, {
  name: 'exists',
  type: 'exists',
  negate: false
}, {
  name: 'does not exist',
  type: 'exists',
  negate: true
}];

var FILTER_OPERATOR_TYPES = exports.FILTER_OPERATOR_TYPES = (0, _lodash2.default)(FILTER_OPERATORS).map('type').uniq().value();

/***/ }),
/* 781 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.filterParamsPhraseController = filterParamsPhraseController;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _chrome = __webpack_require__(17);

var _chrome2 = _interopRequireDefault(_chrome);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var baseUrl = _chrome2.default.addBasePath('/api/kibana/suggestions/values');

function filterParamsPhraseController($http, $scope, config) {
  var _this = this;

  var shouldSuggestValues = this.shouldSuggestValues = config.get('filterEditor:suggestValues');

  this.compactUnion = _lodash2.default.flow(_lodash2.default.union, _lodash2.default.compact);

  this.getValueSuggestions = _lodash2.default.memoize(getValueSuggestions, getFieldQueryHash);

  this.refreshValueSuggestions = function (query) {
    return _this.getValueSuggestions($scope.field, query).then(function (suggestions) {
      return $scope.valueSuggestions = suggestions;
    });
  };

  this.refreshValueSuggestions();

  function getValueSuggestions(field, query) {
    if (!shouldSuggestValues || !_lodash2.default.get(field, 'aggregatable') || field.type !== 'string') {
      return Promise.resolve([]);
    }

    var params = {
      query: query,
      field: field.name
    };

    return $http.post(baseUrl + '/' + field.indexPattern.title, params).then(function (response) {
      return response.data;
    }).catch(function () {
      return [];
    });
  }

  function getFieldQueryHash(field) {
    var query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

    return field.indexPattern.id + '/' + field.name + '/' + query;
  }
}

/***/ }),
/* 782 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _filter_params_input_type = __webpack_require__(2131);

var _filter_params_input_type2 = _interopRequireDefault(_filter_params_input_type);

__webpack_require__(479);

__webpack_require__(480);

__webpack_require__(784);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');
_module.directive('filterParamsInputType', function () {
  return {
    restrict: 'E',
    template: _filter_params_input_type2.default,
    scope: {
      type: '=',
      placeholder: '@',
      value: '=',
      onChange: '&'
    },
    link: function link(scope) {
      scope.boolOptions = [true, false];
      scope.setDefaultBool = function () {
        if (scope.value == null) {
          scope.value = scope.boolOptions[0];
          scope.onChange({
            value: scope.value
          });
        }
      };
    }
  };
});

/***/ }),
/* 783 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Ipv4Address;
var NUM_BYTES = 4;
var BYTE_SIZE = 256;

function throwError(ipAddress) {
  throw Error('Invalid IPv4 address: ' + ipAddress);
}

function isIntegerInRange(integer, min, max) {
  return !isNaN(integer) && integer >= min && integer < max && integer % 1 === 0;
}

// eslint-disable-next-line @elastic/kibana-custom/no-default-export
function Ipv4Address(ipAddress) {
  this.value = ipAddress;

  if (typeof ipAddress === 'string') {
    this.value = 0;

    var bytes = ipAddress.split('.');
    if (bytes.length !== NUM_BYTES) throwError(ipAddress);

    for (var i = 0; i < bytes.length; i++) {
      var byte = Number(bytes[i]);
      if (!isIntegerInRange(byte, 0, BYTE_SIZE)) throwError(ipAddress);
      this.value += Math.pow(BYTE_SIZE, NUM_BYTES - 1 - i) * byte;
    }
  }

  if (!isIntegerInRange(this.value, 0, Math.pow(BYTE_SIZE, NUM_BYTES))) throwError(ipAddress);
}

Ipv4Address.prototype.toString = function () {
  var value = this.value;
  var bytes = [];
  for (var i = 0; i < NUM_BYTES; i++) {
    bytes.unshift(value % 256);
    value = Math.floor(value / 256);
  }
  return bytes.join('.');
};

Ipv4Address.prototype.valueOf = function () {
  return this.value;
};
module.exports = exports['default'];

/***/ }),
/* 784 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _module = _modules.uiModules.get('kibana');

_module.directive('stringToNumber', function () {
  return {
    require: 'ngModel',
    link: function link(scope, element, attrs, ngModel) {
      ngModel.$formatters.push(function (value) {
        return parseFloat(value);
      });
    }
  };
});

/***/ }),
/* 785 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildExistsFilter = buildExistsFilter;
function buildExistsFilter(field, indexPattern) {
  return {
    meta: {
      index: indexPattern.id
    },
    exists: {
      field: field.name
    }
  };
}

/***/ }),
/* 786 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildQueryFilter = buildQueryFilter;
function buildQueryFilter(query, index) {
  return {
    query: query,
    meta: {
      index: index
    }
  };
}

/***/ }),
/* 787 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FilterBarLibExtractTimeFilterProvider = FilterBarLibExtractTimeFilterProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function FilterBarLibExtractTimeFilterProvider(courier, Promise) {
  return Promise.method(function (filters) {
    // Assume all the index patterns are the same since they will be added
    // from the same visualization.
    var id = _lodash2.default.get(filters, '[0].meta.index');
    if (id == null) return;

    return courier.indexPatterns.get(id).then(function (indexPattern) {
      var filter = _lodash2.default.find(filters, function (obj) {
        var key = _lodash2.default.keys(obj.range)[0];
        return key === indexPattern.timeFieldName;
      });
      if (filter && filter.range) {
        return filter;
      }
    });
  });
}

/***/ }),
/* 788 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FilterBarLibFilterOutTimeBasedFilterProvider = FilterBarLibFilterOutTimeBasedFilterProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function FilterBarLibFilterOutTimeBasedFilterProvider(courier, Promise) {
  return Promise.method(function (filters) {
    var id = _lodash2.default.get(filters, '[0].meta.index');
    if (id == null) return;

    return courier.indexPatterns.get(id).then(function (indexPattern) {
      return _lodash2.default.filter(filters, function (filter) {
        return !(filter.range && filter.range[indexPattern.timeFieldName]);
      });
    });
  });
}

/***/ }),
/* 789 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FilterBarLibChangeTimeFilterProvider = FilterBarLibChangeTimeFilterProvider;

var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function FilterBarLibChangeTimeFilterProvider(timefilter) {
  return function (filter) {
    var key = _lodash2.default.keys(filter.range)[0];
    var values = filter.range[key];
    timefilter.time.from = (0, _moment2.default)(values.gt || values.gte);
    timefilter.time.to = (0, _moment2.default)(values.lt || values.lte);
    timefilter.time.mode = 'absolute';
  };
}

/***/ }),
/* 790 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.uniqFilters = uniqFilters;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _dedup_filters = __webpack_require__(791);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Remove duplicate filters from an array of filters
 * @param {array} filters The filters to remove duplicates from
 * @returns {object} The original filters array with duplicates removed
 */
function uniqFilters(filters, comparatorOptions) {
  var results = [];
  _lodash2.default.each(filters, function (filter) {
    results = _lodash2.default.union(results, (0, _dedup_filters.dedupFilters)(results, [filter], comparatorOptions));
  });
  return results;
}

/***/ }),
/* 791 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dedupFilters = dedupFilters;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _compare_filters = __webpack_require__(328);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Combine 2 filter collections, removing duplicates
 * @param {object} existing The filters to compare to
 * @param {object} filters The filters being added
 * @param {object} comparatorOptions Parameters to use for comparison
 * @returns {object} An array of filters that were not in existing
 */
function dedupFilters(existingFilters, filters, comparatorOptions) {
  if (!Array.isArray(filters)) filters = [filters];

  return _lodash2.default.filter(filters, function (filter) {
    return !_lodash2.default.find(existingFilters, function (existingFilter) {
      return (0, _compare_filters.compareFilters)(existingFilter, filter, comparatorOptions);
    });
  });
}

/***/ }),
/* 792 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ModalOverlay = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _angular = __webpack_require__(16);

var _angular2 = _interopRequireDefault(_angular);

var _modal_overlay = __webpack_require__(2166);

var _modal_overlay2 = _interopRequireDefault(_modal_overlay);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Appends the modal to the dom on instantiation, and removes it when destroy is called.
 */
var ModalOverlay = exports.ModalOverlay = function () {
  function ModalOverlay(modalElement) {
    _classCallCheck(this, ModalOverlay);

    this.overlayElement = _angular2.default.element(_modal_overlay2.default);
    this.overlayElement.append(modalElement);

    _angular2.default.element(document.body).append(this.overlayElement);
  }

  /**
   * Removes the overlay and modal from the dom.
   */


  _createClass(ModalOverlay, [{
    key: 'destroy',
    value: function destroy() {
      this.overlayElement.remove();
    }
  }]);

  return ModalOverlay;
}();

/***/ }),
/* 793 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(2171);

/***/ }),
/* 794 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');

_module.directive('inputDatetime', function () {
  return {
    restrict: 'A',
    require: 'ngModel',
    link: function link($scope, $elem, attrs, ngModel) {

      var format = 'YYYY-MM-DD HH:mm:ss.SSS';

      $elem.after('<div class="input-datetime-format">' + format + '</div>');

      // What should I make with the input from the user?
      var fromUser = function fromUser(text) {
        var parsed = (0, _moment2.default)(text, format);
        return parsed.isValid() ? parsed : undefined;
      };

      // How should I present the data back to the user in the input field?
      var toUser = function toUser(datetime) {
        return (0, _moment2.default)(datetime).format(format);
      };

      ngModel.$parsers.push(fromUser);
      ngModel.$formatters.push(toUser);
    }
  };
});

/***/ }),
/* 795 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _module = _modules.uiModules.get('kibana');

_module.constant('timeUnits', {
  s: 'second',
  m: 'minute',
  h: 'hour',
  d: 'day',
  w: 'week',
  M: 'month',
  y: 'year'
});

/***/ }),
/* 796 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(2188);

/***/ }),
/* 797 */,
/* 798 */,
/* 799 */,
/* 800 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _button = __webpack_require__(2264);

Object.defineProperty(exports, 'KuiButton', {
  enumerable: true,
  get: function get() {
    return _button.KuiButton;
  }
});
Object.defineProperty(exports, 'KuiLinkButton', {
  enumerable: true,
  get: function get() {
    return _button.KuiLinkButton;
  }
});
Object.defineProperty(exports, 'KuiSubmitButton', {
  enumerable: true,
  get: function get() {
    return _button.KuiSubmitButton;
  }
});

var _button_icon = __webpack_require__(801);

Object.defineProperty(exports, 'KuiButtonIcon', {
  enumerable: true,
  get: function get() {
    return _button_icon.KuiButtonIcon;
  }
});

var _button_group = __webpack_require__(2265);

Object.defineProperty(exports, 'KuiButtonGroup', {
  enumerable: true,
  get: function get() {
    return _button_group.KuiButtonGroup;
  }
});

/***/ }),
/* 801 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiButtonIcon = exports.ICON_TYPES = undefined;

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ICON_TYPES = ['create', 'delete', 'previous', 'next', 'loading', 'settings', 'menu'];

var KuiButtonIcon = function KuiButtonIcon(props) {
  var typeToClassNameMap = {
    create: 'fa-plus',
    delete: 'fa-trash',
    previous: 'fa-chevron-left',
    next: 'fa-chevron-right',
    loading: 'fa-spinner fa-spin',
    settings: 'fa-gear',
    menu: 'fa-bars'
  };

  var iconClasses = (0, _classnames2.default)('kuiButton__icon kuiIcon', props.className, _defineProperty({}, typeToClassNameMap[props.type], props.type));

  // Purely decorative icons should be hidden from screen readers. Button icons are purely
  // decorate since assisted users will want to click on the button itself, not the icon within.
  // (https://www.w3.org/WAI/GL/wiki/Using_aria-hidden%3Dtrue_on_an_icon_font_that_AT_should_ignore)
  return _react2.default.createElement('span', { 'aria-hidden': 'true', className: iconClasses });
};

KuiButtonIcon.propTypes = {
  type: _propTypes2.default.oneOf(ICON_TYPES),
  className: _propTypes2.default.string
};

exports.ICON_TYPES = ICON_TYPES;
exports.KuiButtonIcon = KuiButtonIcon;

/***/ }),
/* 802 */,
/* 803 */,
/* 804 */,
/* 805 */,
/* 806 */,
/* 807 */,
/* 808 */,
/* 809 */,
/* 810 */,
/* 811 */,
/* 812 */,
/* 813 */,
/* 814 */,
/* 815 */,
/* 816 */,
/* 817 */,
/* 818 */,
/* 819 */,
/* 820 */,
/* 821 */,
/* 822 */,
/* 823 */,
/* 824 */,
/* 825 */,
/* 826 */,
/* 827 */,
/* 828 */,
/* 829 */,
/* 830 */,
/* 831 */,
/* 832 */,
/* 833 */,
/* 834 */,
/* 835 */,
/* 836 */,
/* 837 */,
/* 838 */,
/* 839 */,
/* 840 */,
/* 841 */,
/* 842 */,
/* 843 */,
/* 844 */,
/* 845 */,
/* 846 */,
/* 847 */,
/* 848 */,
/* 849 */,
/* 850 */,
/* 851 */,
/* 852 */,
/* 853 */,
/* 854 */,
/* 855 */,
/* 856 */,
/* 857 */,
/* 858 */,
/* 859 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiContextMenuPanel = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _tabbable = __webpack_require__(314);

var _tabbable2 = _interopRequireDefault(_tabbable);

var _components = __webpack_require__(101);

var _services = __webpack_require__(120);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var transitionDirectionAndTypeToClassNameMap = {
  next: {
    in: 'kuiContextMenuPanel-txInLeft',
    out: 'kuiContextMenuPanel-txOutLeft'
  },
  previous: {
    in: 'kuiContextMenuPanel-txInRight',
    out: 'kuiContextMenuPanel-txOutRight'
  }
};

var KuiContextMenuPanel = exports.KuiContextMenuPanel = function (_Component) {
  _inherits(KuiContextMenuPanel, _Component);

  function KuiContextMenuPanel(props) {
    _classCallCheck(this, KuiContextMenuPanel);

    var _this = _possibleConstructorReturn(this, (KuiContextMenuPanel.__proto__ || Object.getPrototypeOf(KuiContextMenuPanel)).call(this, props));

    _this.incrementFocusedItemIndex = function (amount) {
      var nextFocusedItemIndex = void 0;

      if (_this.state.focusedItemIndex === undefined) {
        // If this is the beginning of the user's keyboard navigation of the menu, then we'll focus
        // either the first or last item.
        nextFocusedItemIndex = amount < 0 ? _this.menuItems.length - 1 : 0;
      } else {
        nextFocusedItemIndex = _this.state.focusedItemIndex + amount;

        if (nextFocusedItemIndex < 0) {
          nextFocusedItemIndex = _this.menuItems.length - 1;
        } else if (nextFocusedItemIndex === _this.menuItems.length) {
          nextFocusedItemIndex = 0;
        }
      }

      _this.setState({
        focusedItemIndex: nextFocusedItemIndex
      });
    };

    _this.onKeyDown = function (e) {
      // If this panel contains items you can use the left arrow key to go back at any time.
      // But if it doesn't contain items, then you have to focus on the back button specifically,
      // since there could be content inside the panel which requires use of the left arrow key,
      // e.g. text inputs.
      if (_this.props.items.length || document.activeElement === _this.backButton || document.activeElement === _this.panel) {
        if (e.keyCode === _services.cascadingMenuKeyCodes.LEFT) {
          if (_this.props.showPreviousPanel) {
            _this.props.showPreviousPanel();

            if (_this.props.onUseKeyboardToNavigate) {
              _this.props.onUseKeyboardToNavigate();
            }
          }
        }
      }

      if (_this.props.items.length) {
        switch (e.keyCode) {
          case _services.cascadingMenuKeyCodes.TAB:
            // We need to sync up with the user if s/he is tabbing through the items.
            var focusedItemIndex = _this.menuItems.indexOf(document.activeElement);

            _this.setState({
              focusedItemIndex: focusedItemIndex >= 0 && focusedItemIndex < _this.menuItems.length ? focusedItemIndex : undefined
            });
            break;

          case _services.cascadingMenuKeyCodes.UP:
            e.preventDefault();
            _this.incrementFocusedItemIndex(-1);

            if (_this.props.onUseKeyboardToNavigate) {
              _this.props.onUseKeyboardToNavigate();
            }
            break;

          case _services.cascadingMenuKeyCodes.DOWN:
            e.preventDefault();
            _this.incrementFocusedItemIndex(1);

            if (_this.props.onUseKeyboardToNavigate) {
              _this.props.onUseKeyboardToNavigate();
            }
            break;

          case _services.cascadingMenuKeyCodes.RIGHT:
            if (_this.props.showNextPanel) {
              e.preventDefault();
              _this.props.showNextPanel(_this.state.focusedItemIndex);

              if (_this.props.onUseKeyboardToNavigate) {
                _this.props.onUseKeyboardToNavigate();
              }
            }
            break;

          default:
            break;
        }
      }
    };

    _this.onTransitionComplete = function () {
      _this.setState({
        isTransitioning: false
      });

      if (_this.props.onTransitionComplete) {
        _this.props.onTransitionComplete();
      }
    };

    _this.menuItemRef = function (index, node) {
      // There's a weird bug where if you navigate to a panel without items, then this callback
      // is still invoked, so we have to do a truthiness check.
      if (node) {
        // Store all menu items.
        _this.menuItems[index] = node;
      }
    };

    _this.panelRef = function (node) {
      _this.panel = node;

      if (_this.panel) {
        if (_this.props.onHeightChange) {
          _this.props.onHeightChange(_this.panel.clientHeight);
        }
      }
    };

    _this.contentRef = function (node) {
      _this.content = node;
    };

    _this.menuItems = [];
    _this.state = {
      isTransitioning: Boolean(props.transitionType),
      focusedItemIndex: props.initialFocusedItemIndex
    };
    return _this;
  }

  _createClass(KuiContextMenuPanel, [{
    key: 'updateFocus',
    value: function updateFocus() {
      // If this panel has lost focus, then none of its content should be focused.
      if (!this.props.hasFocus) {
        if (this.panel.contains(document.activeElement)) {
          document.activeElement.blur();
        }
        return;
      }

      // Setting focus while transitioning causes the animation to glitch, so we have to wait
      // until it's finished before we focus anything.
      if (this.state.isTransitioning) {
        return;
      }

      // If there aren't any items then this is probably a form or something.
      if (!this.menuItems.length) {
        // If we've already focused on something inside the panel, everything's fine.
        if (this.panel.contains(document.activeElement)) {
          return;
        }

        // Otherwise let's focus the first tabbable item and expedite input from the user.
        if (this.content) {
          var tabbableItems = (0, _tabbable2.default)(this.content);
          if (tabbableItems.length) {
            tabbableItems[0].focus();
          }
        }
        return;
      }

      // If an item is focused, focus it.
      if (this.state.focusedItemIndex !== undefined) {
        this.menuItems[this.state.focusedItemIndex].focus();
        return;
      }

      // Focus on the panel as a last resort.
      if (!this.panel.contains(document.activeElement)) {
        this.panel.focus();
      }
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.updateFocus();
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      // Clear refs to menuItems if we're getting new ones.
      if (nextProps.items !== this.props.items) {
        this.menuItems = [];
      }

      if (nextProps.transitionType) {
        this.setState({
          isTransitioning: true
        });
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      this.updateFocus();
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          children = _props.children,
          className = _props.className,
          onClose = _props.onClose,
          title = _props.title,
          onHeightChange = _props.onHeightChange,
          transitionType = _props.transitionType,
          transitionDirection = _props.transitionDirection,
          onTransitionComplete = _props.onTransitionComplete,
          onUseKeyboardToNavigate = _props.onUseKeyboardToNavigate,
          hasFocus = _props.hasFocus,
          items = _props.items,
          initialFocusedItemIndex = _props.initialFocusedItemIndex,
          showNextPanel = _props.showNextPanel,
          showPreviousPanel = _props.showPreviousPanel,
          rest = _objectWithoutProperties(_props, ['children', 'className', 'onClose', 'title', 'onHeightChange', 'transitionType', 'transitionDirection', 'onTransitionComplete', 'onUseKeyboardToNavigate', 'hasFocus', 'items', 'initialFocusedItemIndex', 'showNextPanel', 'showPreviousPanel']);

      var panelTitle = void 0;

      if (title) {
        if (Boolean(onClose)) {
          panelTitle = _react2.default.createElement(
            'button',
            {
              className: 'kuiContextMenuPanelTitle',
              onClick: onClose,
              ref: function ref(node) {
                _this2.backButton = node;
              },
              'data-test-subj': 'contextMenuPanelTitleButton'
            },
            _react2.default.createElement(
              'span',
              { className: 'kuiContextMenu__itemLayout' },
              _react2.default.createElement('span', { className: 'kuiContextMenu__icon kuiIcon fa-angle-left' }),
              _react2.default.createElement(
                'span',
                { className: 'kuiContextMenu__text' },
                title
              )
            )
          );
        } else {
          panelTitle = _react2.default.createElement(
            _components.KuiPopoverTitle,
            null,
            _react2.default.createElement(
              'span',
              { className: 'kuiContextMenu__itemLayout' },
              title
            )
          );
        }
      }

      var classes = (0, _classnames2.default)('kuiContextMenuPanel', className, this.state.isTransitioning && transitionDirectionAndTypeToClassNameMap[transitionDirection] ? transitionDirectionAndTypeToClassNameMap[transitionDirection][transitionType] : undefined);

      var content = items.length ? items.map(function (MenuItem, index) {
        return (0, _react.cloneElement)(MenuItem, {
          buttonRef: _this2.menuItemRef.bind(_this2, index)
        });
      }) : children;

      return _react2.default.createElement(
        'div',
        _extends({
          ref: this.panelRef,
          className: classes,
          onKeyDown: this.onKeyDown,
          tabIndex: '0',
          onAnimationEnd: this.onTransitionComplete
        }, rest),
        panelTitle,
        _react2.default.createElement(
          'div',
          { ref: this.contentRef },
          content
        )
      );
    }
  }]);

  return KuiContextMenuPanel;
}(_react.Component);

KuiContextMenuPanel.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string,
  title: _propTypes2.default.string,
  onClose: _propTypes2.default.func,
  onHeightChange: _propTypes2.default.func,
  transitionType: _propTypes2.default.oneOf(['in', 'out']),
  transitionDirection: _propTypes2.default.oneOf(['next', 'previous']),
  onTransitionComplete: _propTypes2.default.func,
  onUseKeyboardToNavigate: _propTypes2.default.func,
  hasFocus: _propTypes2.default.bool,
  items: _propTypes2.default.array,
  showNextPanel: _propTypes2.default.func,
  showPreviousPanel: _propTypes2.default.func,
  initialFocusedItemIndex: _propTypes2.default.number
};
KuiContextMenuPanel.defaultProps = {
  hasFocus: true,
  items: []
};

/***/ }),
/* 860 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiContextMenuItem = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var KuiContextMenuItem = exports.KuiContextMenuItem = function (_Component) {
  _inherits(KuiContextMenuItem, _Component);

  function KuiContextMenuItem() {
    _classCallCheck(this, KuiContextMenuItem);

    return _possibleConstructorReturn(this, (KuiContextMenuItem.__proto__ || Object.getPrototypeOf(KuiContextMenuItem)).apply(this, arguments));
  }

  _createClass(KuiContextMenuItem, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          children = _props.children,
          className = _props.className,
          hasPanel = _props.hasPanel,
          icon = _props.icon,
          buttonRef = _props.buttonRef,
          disabled = _props.disabled,
          rest = _objectWithoutProperties(_props, ['children', 'className', 'hasPanel', 'icon', 'buttonRef', 'disabled']);

      var iconInstance = void 0;

      if (icon) {
        iconInstance = (0, _react.cloneElement)(icon, {
          className: (0, _classnames2.default)(icon.props.className, 'kuiContextMenu__icon')
        });
      }

      var arrow = void 0;

      if (hasPanel) {
        arrow = _react2.default.createElement('span', { className: 'kuiContextMenu__arrow kuiIcon fa-angle-right' });
      }

      var classes = (0, _classnames2.default)('kuiContextMenuItem', className, {
        'kuiContextMenuItem-disabled': disabled
      });

      return _react2.default.createElement(
        'button',
        _extends({
          className: classes,
          ref: buttonRef,
          disabled: disabled
        }, rest),
        _react2.default.createElement(
          'span',
          { className: 'kuiContextMenu__itemLayout' },
          iconInstance,
          _react2.default.createElement(
            'span',
            { className: 'kuiContextMenuItem__text' },
            children
          ),
          arrow
        )
      );
    }
  }]);

  return KuiContextMenuItem;
}(_react.Component);

KuiContextMenuItem.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string,
  icon: _propTypes2.default.element,
  onClick: _propTypes2.default.func,
  hasPanel: _propTypes2.default.bool,
  buttonRef: _propTypes2.default.func,
  disabled: _propTypes2.default.bool
};

/***/ }),
/* 861 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiEmptyTablePromptMessage = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiEmptyTablePromptMessage = function KuiEmptyTablePromptMessage(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiEmptyTablePrompt__message', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
};
exports.KuiEmptyTablePromptMessage = KuiEmptyTablePromptMessage;
KuiEmptyTablePromptMessage.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 862 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiCheckBox = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiCheckBox = function KuiCheckBox(_ref) {
  var className = _ref.className,
      isChecked = _ref.isChecked,
      isDisabled = _ref.isDisabled,
      onChange = _ref.onChange,
      rest = _objectWithoutProperties(_ref, ['className', 'isChecked', 'isDisabled', 'onChange']);

  var classes = (0, _classnames2.default)('kuiCheckBox', className);

  return _react2.default.createElement('input', _extends({
    type: 'checkbox',
    className: classes,
    checked: isChecked,
    disabled: isDisabled,
    onChange: onChange
  }, rest));
};

exports.KuiCheckBox = KuiCheckBox;
KuiCheckBox.defaultProps = {
  isChecked: false,
  isDisabled: false
};

KuiCheckBox.propTypes = {
  className: _propTypes2.default.string,
  isChecked: _propTypes2.default.bool,
  isDisabled: _propTypes2.default.bool,
  onChange: _propTypes2.default.func.isRequired
};

/***/ }),
/* 863 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiModal = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _focusTrapReact = __webpack_require__(864);

var _focusTrapReact2 = _interopRequireDefault(_focusTrapReact);

var _services = __webpack_require__(120);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var KuiModal = exports.KuiModal = function (_Component) {
  _inherits(KuiModal, _Component);

  function KuiModal() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, KuiModal);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = KuiModal.__proto__ || Object.getPrototypeOf(KuiModal)).call.apply(_ref, [this].concat(args))), _this), _this.onKeyDown = function (event) {
      if (event.keyCode === _services.keyCodes.ESCAPE) {
        _this.props.onClose();
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(KuiModal, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          className = _props.className,
          children = _props.children,
          onClose = _props.onClose,
          rest = _objectWithoutProperties(_props, ['className', 'children', 'onClose']);

      var classes = (0, _classnames2.default)('kuiModal', className);

      return _react2.default.createElement(
        _focusTrapReact2.default,
        {
          focusTrapOptions: {
            fallbackFocus: function fallbackFocus() {
              return _this2.modal;
            }
          }
        },
        _react2.default.createElement(
          'div',
          _extends({
            ref: function ref(node) {
              _this2.modal = node;
            },
            className: classes,
            onKeyDown: this.onKeyDown,
            tabIndex: 0
          }, rest),
          children
        )
      );
    }
  }]);

  return KuiModal;
}(_react.Component);

KuiModal.propTypes = {
  className: _propTypes2.default.string,
  children: _propTypes2.default.node,
  onClose: _propTypes2.default.func.isRequired
};

/***/ }),
/* 864 */,
/* 865 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.KuiModalFooter = KuiModalFooter;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function KuiModalFooter(_ref) {
  var className = _ref.className,
      children = _ref.children,
      rest = _objectWithoutProperties(_ref, ['className', 'children']);

  var classes = (0, _classnames2.default)('kuiModalFooter', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
}

KuiModalFooter.propTypes = {
  className: _propTypes2.default.string,
  children: _propTypes2.default.node
};

/***/ }),
/* 866 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.KuiModalHeader = KuiModalHeader;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function KuiModalHeader(_ref) {
  var className = _ref.className,
      children = _ref.children,
      rest = _objectWithoutProperties(_ref, ['className', 'children']);

  var classes = (0, _classnames2.default)('kuiModalHeader', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
}

KuiModalHeader.propTypes = {
  className: _propTypes2.default.string,
  children: _propTypes2.default.node
};

/***/ }),
/* 867 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.KuiModalHeaderTitle = KuiModalHeaderTitle;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function KuiModalHeaderTitle(_ref) {
  var className = _ref.className,
      children = _ref.children,
      rest = _objectWithoutProperties(_ref, ['className', 'children']);

  var classes = (0, _classnames2.default)('kuiModalHeader__title', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
}

KuiModalHeaderTitle.propTypes = {
  className: _propTypes2.default.string,
  children: _propTypes2.default.node
};

/***/ }),
/* 868 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.KuiModalBody = KuiModalBody;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function KuiModalBody(_ref) {
  var className = _ref.className,
      children = _ref.children,
      rest = _objectWithoutProperties(_ref, ['className', 'children']);

  var classes = (0, _classnames2.default)('kuiModalBody', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
}

KuiModalBody.propTypes = {
  className: _propTypes2.default.string,
  children: _propTypes2.default.node
};

/***/ }),
/* 869 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.KuiPagerButtonGroup = KuiPagerButtonGroup;

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _button = __webpack_require__(800);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function KuiPagerButtonGroup(_ref) {
  var className = _ref.className,
      onPrevious = _ref.onPrevious,
      onNext = _ref.onNext,
      hasNext = _ref.hasNext,
      hasPrevious = _ref.hasPrevious,
      rest = _objectWithoutProperties(_ref, ['className', 'onPrevious', 'onNext', 'hasNext', 'hasPrevious']);

  return _react2.default.createElement(
    _button.KuiButtonGroup,
    _extends({ isUnited: true, className: className }, rest),
    _react2.default.createElement(_button.KuiButton, {
      'aria-label': 'Show previous page',
      'data-test-subj': 'pagerPreviousButton',
      buttonType: 'basic',
      onClick: onPrevious,
      disabled: !hasPrevious,
      icon: _react2.default.createElement(_button.KuiButtonIcon, { type: 'previous' })
    }),
    _react2.default.createElement(_button.KuiButton, {
      'aria-label': 'Show next page',
      'data-test-subj': 'pagerNextButton',
      buttonType: 'basic',
      onClick: onNext,
      disabled: !hasNext,
      icon: _react2.default.createElement(_button.KuiButtonIcon, { type: 'next' })
    })
  );
}

KuiPagerButtonGroup.propTypes = {
  onPrevious: _propTypes2.default.func.isRequired,
  onNext: _propTypes2.default.func.isRequired,
  hasNext: _propTypes2.default.bool.isRequired,
  hasPrevious: _propTypes2.default.bool.isRequired,
  className: _propTypes2.default.string
};

/***/ }),
/* 870 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _panel_simple = __webpack_require__(2587);

Object.defineProperty(exports, 'KuiPanelSimple', {
  enumerable: true,
  get: function get() {
    return _panel_simple.KuiPanelSimple;
  }
});
Object.defineProperty(exports, 'SIZES', {
  enumerable: true,
  get: function get() {
    return _panel_simple.SIZES;
  }
});

/***/ }),
/* 871 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _table = __webpack_require__(2594);

Object.defineProperty(exports, 'KuiTable', {
  enumerable: true,
  get: function get() {
    return _table.KuiTable;
  }
});

var _table_header_cell = __webpack_require__(872);

Object.defineProperty(exports, 'KuiTableHeaderCell', {
  enumerable: true,
  get: function get() {
    return _table_header_cell.KuiTableHeaderCell;
  }
});

var _table_row = __webpack_require__(2595);

Object.defineProperty(exports, 'KuiTableRow', {
  enumerable: true,
  get: function get() {
    return _table_row.KuiTableRow;
  }
});

var _table_row_cell = __webpack_require__(873);

Object.defineProperty(exports, 'KuiTableRowCell', {
  enumerable: true,
  get: function get() {
    return _table_row_cell.KuiTableRowCell;
  }
});

var _controlled_table = __webpack_require__(2596);

Object.defineProperty(exports, 'KuiControlledTable', {
  enumerable: true,
  get: function get() {
    return _controlled_table.KuiControlledTable;
  }
});

var _table_info = __webpack_require__(2597);

Object.defineProperty(exports, 'KuiTableInfo', {
  enumerable: true,
  get: function get() {
    return _table_info.KuiTableInfo;
  }
});

var _table_row_check_box_cell = __webpack_require__(2598);

Object.defineProperty(exports, 'KuiTableRowCheckBoxCell', {
  enumerable: true,
  get: function get() {
    return _table_row_check_box_cell.KuiTableRowCheckBoxCell;
  }
});

var _table_header_check_box_cell = __webpack_require__(2599);

Object.defineProperty(exports, 'KuiTableHeaderCheckBoxCell', {
  enumerable: true,
  get: function get() {
    return _table_header_check_box_cell.KuiTableHeaderCheckBoxCell;
  }
});

var _table_body = __webpack_require__(2600);

Object.defineProperty(exports, 'KuiTableBody', {
  enumerable: true,
  get: function get() {
    return _table_body.KuiTableBody;
  }
});

var _table_header = __webpack_require__(2601);

Object.defineProperty(exports, 'KuiTableHeader', {
  enumerable: true,
  get: function get() {
    return _table_header.KuiTableHeader;
  }
});

var _listing_table = __webpack_require__(2602);

Object.defineProperty(exports, 'KuiListingTable', {
  enumerable: true,
  get: function get() {
    return _listing_table.KuiListingTable;
  }
});
Object.defineProperty(exports, 'KuiListingTableCreateButton', {
  enumerable: true,
  get: function get() {
    return _listing_table.KuiListingTableCreateButton;
  }
});
Object.defineProperty(exports, 'KuiListingTableDeleteButton', {
  enumerable: true,
  get: function get() {
    return _listing_table.KuiListingTableDeleteButton;
  }
});
Object.defineProperty(exports, 'KuiListingTableLoadingPrompt', {
  enumerable: true,
  get: function get() {
    return _listing_table.KuiListingTableLoadingPrompt;
  }
});
Object.defineProperty(exports, 'KuiListingTableNoMatchesPrompt', {
  enumerable: true,
  get: function get() {
    return _listing_table.KuiListingTableNoMatchesPrompt;
  }
});

/***/ }),
/* 872 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiTableHeaderCell = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _services = __webpack_require__(120);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiTableHeaderCell = function KuiTableHeaderCell(_ref) {
  var children = _ref.children,
      onSort = _ref.onSort,
      isSorted = _ref.isSorted,
      isSortAscending = _ref.isSortAscending,
      className = _ref.className,
      ariaLabel = _ref.ariaLabel,
      align = _ref.align,
      scope = _ref.scope,
      rest = _objectWithoutProperties(_ref, ['children', 'onSort', 'isSorted', 'isSortAscending', 'className', 'ariaLabel', 'align', 'scope']);

  var classes = (0, _classnames2.default)('kuiTableHeaderCell', className, {
    'kuiTableHeaderCell--alignRight': align === _services.RIGHT_ALIGNMENT
  });
  if (onSort) {
    var sortIconClasses = (0, _classnames2.default)('kuiTableSortIcon kuiIcon', {
      'fa-long-arrow-up': isSortAscending,
      'fa-long-arrow-down': !isSortAscending
    });

    var sortIcon = _react2.default.createElement('span', { className: sortIconClasses, 'aria-hidden': 'true' });

    var buttonClasses = (0, _classnames2.default)('kuiTableHeaderCellButton', {
      'kuiTableHeaderCellButton-isSorted': isSorted
    });

    var columnTitle = ariaLabel ? ariaLabel : children;
    var statefulAriaLabel = 'Sort ' + columnTitle + ' ' + (isSortAscending ? 'descending' : 'ascending');

    return _react2.default.createElement(
      'th',
      _extends({
        className: classes,
        scope: scope
      }, rest),
      _react2.default.createElement(
        'button',
        {
          className: buttonClasses,
          onClick: onSort,
          'aria-label': statefulAriaLabel
        },
        _react2.default.createElement(
          'span',
          { className: 'kuiTableHeaderCell__liner' },
          children,
          sortIcon
        )
      )
    );
  }

  return _react2.default.createElement(
    'th',
    _extends({
      className: classes,
      'aria-label': ariaLabel,
      scope: scope
    }, rest),
    _react2.default.createElement(
      'div',
      { className: 'kuiTableHeaderCell__liner' },
      children
    )
  );
};

exports.KuiTableHeaderCell = KuiTableHeaderCell;
KuiTableHeaderCell.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string,
  onSort: _propTypes2.default.func,
  isSorted: _propTypes2.default.bool,
  isSortAscending: _propTypes2.default.bool,
  align: _propTypes2.default.oneOf([_services.LEFT_ALIGNMENT, _services.RIGHT_ALIGNMENT]),
  scope: _propTypes2.default.oneOf(['col', 'row', 'colgroup', 'rowgroup'])
};

KuiTableHeaderCell.defaultProps = {
  align: _services.LEFT_ALIGNMENT,
  scope: 'col'
};

/***/ }),
/* 873 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiTableRowCell = exports.ALIGNMENT = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _services = __webpack_require__(120);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var ALIGNMENT = exports.ALIGNMENT = [_services.RIGHT_ALIGNMENT, _services.LEFT_ALIGNMENT];

var KuiTableRowCell = function KuiTableRowCell(_ref) {
  var children = _ref.children,
      align = _ref.align,
      className = _ref.className,
      textOnly = _ref.textOnly,
      rest = _objectWithoutProperties(_ref, ['children', 'align', 'className', 'textOnly']);

  var classes = (0, _classnames2.default)('kuiTableRowCell', className, {
    'kuiTableRowCell--alignRight': align === _services.RIGHT_ALIGNMENT,
    // We're doing this rigamarole instead of creating kuiTabelRowCell--textOnly for BWC
    // purposes for the time-being.
    'kuiTableRowCell--overflowingContent': !textOnly
  });

  return _react2.default.createElement(
    'td',
    _extends({ className: classes }, rest),
    _react2.default.createElement(
      'div',
      { className: 'kuiTableRowCell__liner' },
      children
    )
  );
};

exports.KuiTableRowCell = KuiTableRowCell;
KuiTableRowCell.propTypes = {
  align: _propTypes2.default.oneOf(ALIGNMENT),
  children: _propTypes2.default.node,
  className: _propTypes2.default.string,
  textOnly: _propTypes2.default.bool
};

KuiTableRowCell.defaultProps = {
  align: _services.LEFT_ALIGNMENT,
  textOnly: true
};

/***/ }),
/* 874 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _module = _modules.uiModules.get('kibana');

_module.directive('autoSelectIfOnlyOne', function () {
  return {
    restrict: 'A',
    require: 'ngModel',
    link: function link(scope, element, attributes, ngModelCtrl) {
      scope.$watchCollection(attributes.autoSelectIfOnlyOne, function (options) {
        if (options && options.length === 1) {
          ngModelCtrl.$setViewValue(options[0]);
          ngModelCtrl.$render();
        }
      });
    }
  };
});

/***/ }),
/* 875 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

_modules.uiModules.get('kibana').directive('confirmClick', function ($window) {
  return {
    restrict: 'A',
    link: function link($scope, $elem, attrs) {
      $elem.bind('click', function () {
        var message = attrs.confirmation || 'Are you sure?';
        if ($window.confirm(message)) {
          // eslint-disable-line no-alert
          var action = attrs.confirmClick;
          if (action) {
            $scope.$apply($scope.$eval(action));
          }
        }
      });

      $scope.$on('$destroy', function () {
        $elem.unbind('click');
      });
    }
  };
});

/***/ }),
/* 876 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');

var html = '<span class="dropzone" ng-transclude></span>';

_module.directive('fileUpload', function () {
  return {
    restrict: 'E',
    transclude: true,
    scope: {
      onRead: '&',
      onLocate: '&',
      uploadSelector: '@'
    },
    template: html,
    link: function link($scope, $elem, attrs) {
      var $button = $elem.find($scope.uploadSelector);
      var $dropzone = $elem.find('.dropzone');

      var handleFile = function handleFile(file) {
        if (_lodash2.default.isUndefined(file)) return;

        if (_lodash2.default.has(attrs, 'onRead')) {
          var reader = new FileReader();
          reader.onload = function (e) {
            $scope.$apply(function () {
              $scope.onRead({ fileContents: e.target.result });
            });
          };
          reader.readAsText(file);
        }

        if (_lodash2.default.has(attrs, 'onLocate')) {
          $scope.$apply(function () {
            $scope.onLocate({ file: file });
          });
        }
      };

      $dropzone.on('dragover', function (e) {
        e.preventDefault();
        e.stopPropagation();
      });

      $dropzone.on('dragenter', function (e) {
        e.preventDefault();
        e.stopPropagation();
      });

      $dropzone.on('drop', function (e) {
        e.stopPropagation();
        e.preventDefault();
        var file = _lodash2.default.get(e, 'originalEvent.dataTransfer.files[0]');

        if (file) {
          handleFile(file);
        }
      });

      if ($button) {
        var $fileInput = (0, _jquery2.default)('<input type="file" style="opacity: 0;' + ' display:none; position:absolute; right: -999999999px" id="testfile" />');
        $elem.append($fileInput);

        $fileInput.on('change', function (e) {
          var target = e.srcElement || e.target;
          if (_lodash2.default.get(target, 'files.length')) {
            handleFile(target.files[0]);
          }
        });

        $button.on('click', function () {
          $fileInput.val(null);
          $fileInput.trigger('click');
        });
      }
    }
  };
});

/***/ }),
/* 877 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');

_module.directive('kbnInfiniteScroll', function () {
  return {
    restrict: 'E',
    scope: {
      more: '='
    },
    link: function link($scope, $element) {
      var $window = (0, _jquery2.default)(window);
      var checkTimer = void 0;

      function onScroll() {
        if (!$scope.more) return;

        var winHeight = $window.height();
        var winBottom = winHeight + $window.scrollTop();
        var elTop = $element.offset().top;
        var remaining = elTop - winBottom;

        if (remaining <= winHeight * 0.50) {
          $scope[$scope.$$phase ? '$eval' : '$apply'](function () {
            $scope.more();
          });
        }
      }

      function scheduleCheck() {
        if (checkTimer) return;
        checkTimer = setTimeout(function () {
          checkTimer = null;
          onScroll();
        }, 50);
      }

      $window.on('scroll', scheduleCheck);
      $scope.$on('$destroy', function () {
        clearTimeout(checkTimer);
        $window.off('scroll', scheduleCheck);
      });
      scheduleCheck();
    }
  };
});

/***/ }),
/* 878 */,
/* 879 */,
/* 880 */,
/* 881 */,
/* 882 */,
/* 883 */,
/* 884 */,
/* 885 */,
/* 886 */,
/* 887 */,
/* 888 */,
/* 889 */,
/* 890 */,
/* 891 */,
/* 892 */,
/* 893 */,
/* 894 */,
/* 895 */,
/* 896 */,
/* 897 */,
/* 898 */,
/* 899 */,
/* 900 */,
/* 901 */,
/* 902 */,
/* 903 */,
/* 904 */,
/* 905 */,
/* 906 */,
/* 907 */,
/* 908 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _modules = __webpack_require__(2);

var _paginated_selectable_list = __webpack_require__(2917);

var _paginated_selectable_list2 = _interopRequireDefault(_paginated_selectable_list);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');

function throwError(message) {
  throw new Error(message);
}

_module.directive('paginatedSelectableList', function () {

  return {
    restrict: 'E',
    scope: {
      perPage: '=?',
      list: '=',
      listProperty: '@',
      userMakeUrl: '=?',
      userOnSelect: '=?',
      disableAutoFocus: '='
    },
    template: _paginated_selectable_list2.default,
    controller: function controller($scope) {
      // Should specify either user-make-url or user-on-select
      if (!$scope.userMakeUrl && !$scope.userOnSelect) {
        throwError('paginatedSelectableList directive expects a makeUrl or onSelect function');
      }

      // Should specify either user-make-url or user-on-select, but not both.
      if ($scope.userMakeUrl && $scope.userOnSelect) {
        throwError('paginatedSelectableList directive expects a makeUrl or onSelect attribute but not both');
      }

      $scope.perPage = $scope.perPage || 10;
      $scope.hits = $scope.list = _lodash2.default.sortBy($scope.list, $scope.accessor);
      $scope.hitCount = $scope.hits.length;

      /**
       * Boolean that keeps track of whether hits are sorted ascending (true)
       * or descending (false)
       * * @type {Boolean}
       */
      $scope.isAscending = true;

      /**
       * Sorts saved object finder hits either ascending or descending
       * @param  {Array} hits Array of saved finder object hits
       * @return {Array} Array sorted either ascending or descending
       */
      $scope.sortHits = function (hits) {
        var sortedList = _lodash2.default.sortBy(hits, $scope.accessor);

        $scope.isAscending = !$scope.isAscending;
        $scope.hits = $scope.isAscending ? sortedList : sortedList.reverse();
      };

      $scope.makeUrl = function (hit) {
        return $scope.userMakeUrl(hit);
      };

      $scope.onSelect = function (hit, $event) {
        return $scope.userOnSelect(hit, $event);
      };

      $scope.accessor = function (val) {
        var prop = $scope.listProperty;
        return prop ? _lodash2.default.get(val, prop) : val;
      };
    }
  };
});

/***/ }),
/* 909 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _risonNode = __webpack_require__(132);

var _risonNode2 = _interopRequireDefault(_risonNode);

var _key_map = __webpack_require__(483);

var _saved_object_registry = __webpack_require__(134);

var _modules = __webpack_require__(2);

var _saved_object_finder = __webpack_require__(2923);

var _saved_object_finder2 = _interopRequireDefault(_saved_object_finder);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');

_module.directive('savedObjectFinder', function ($location, $injector, kbnUrl, Private, config) {

  var services = Private(_saved_object_registry.SavedObjectRegistryProvider).byLoaderPropertiesName;

  return {
    restrict: 'E',
    scope: {
      type: '@',
      // optional make-url attr, sets the userMakeUrl in our scope
      userMakeUrl: '=?makeUrl',
      // optional on-choose attr, sets the userOnChoose in our scope
      userOnChoose: '=?onChoose',
      // optional useLocalManagement attr,  removes link to management section
      useLocalManagement: '=?useLocalManagement',
      /**
       * @type {function} - an optional function. If supplied an `Add new X` button is shown
       * and this function is called when clicked.
       */
      onAddNew: '=',
      /**
       * @{type} boolean - set this to true, if you don't want the search box above the
       * table to automatically gain focus once loaded
       */
      disableAutoFocus: '='
    },
    template: _saved_object_finder2.default,
    controllerAs: 'finder',
    controller: function controller($scope, $element) {
      var self = this;

      // the text input element
      var $input = $element.find('input[ng-model=filter]');

      // The number of items to show in the list
      $scope.perPage = config.get('savedObjects:perPage');

      // the list that will hold the suggestions
      var $list = $element.find('ul');

      // the current filter string, used to check that returned results are still useful
      var currentFilter = $scope.filter;

      // the most recently entered search/filter
      var prevSearch = void 0;

      // the list of hits, used to render display
      self.hits = [];

      self.service = services[$scope.type];
      self.properties = self.service.loaderProperties;

      filterResults();

      /**
       * Boolean that keeps track of whether hits are sorted ascending (true)
       * or descending (false) by title
       * @type {Boolean}
       */
      self.isAscending = true;

      /**
       * Sorts saved object finder hits either ascending or descending
       * @param  {Array} hits Array of saved finder object hits
       * @return {Array} Array sorted either ascending or descending
       */
      self.sortHits = function (hits) {
        self.isAscending = !self.isAscending;
        self.hits = self.isAscending ? _lodash2.default.sortBy(hits, 'title') : _lodash2.default.sortBy(hits, 'title').reverse();
      };

      /**
       * Passed the hit objects and will determine if the
       * hit should have a url in the UI, returns it if so
       * @return {string|null} - the url or nothing
       */
      self.makeUrl = function (hit) {
        if ($scope.userMakeUrl) {
          return $scope.userMakeUrl(hit);
        }

        if (!$scope.userOnChoose) {
          return hit.url;
        }

        return '#';
      };

      self.preventClick = function ($event) {
        $event.preventDefault();
      };

      /**
       * Called when a hit object is clicked, can override the
       * url behavior if necessary.
       */
      self.onChoose = function (hit, $event) {
        if ($scope.userOnChoose) {
          $scope.userOnChoose(hit, $event);
        }

        var url = self.makeUrl(hit);
        if (!url || url === '#' || url.charAt(0) !== '#') return;

        $event.preventDefault();

        // we want the '/path', not '#/path'
        kbnUrl.change(url.substr(1));
      };

      $scope.$watch('filter', function (newFilter) {
        // ensure that the currentFilter changes from undefined to ''
        // which triggers
        currentFilter = newFilter || '';
        filterResults();
      });

      $scope.pageFirstItem = 0;
      $scope.pageLastItem = 0;
      $scope.onPageChanged = function (page) {
        $scope.pageFirstItem = page.firstItem;
        $scope.pageLastItem = page.lastItem;
      };

      //manages the state of the keyboard selector
      self.selector = {
        enabled: false,
        index: -1
      };

      //key handler for the filter text box
      self.filterKeyDown = function ($event) {
        switch (_key_map.keyMap[$event.keyCode]) {
          case 'enter':
            if (self.hitCount !== 1) return;

            var hit = self.hits[0];
            if (!hit) return;

            self.onChoose(hit, $event);
            $event.preventDefault();
            break;
        }
      };

      //key handler for the list items
      self.hitKeyDown = function ($event, page, paginate) {
        switch (_key_map.keyMap[$event.keyCode]) {
          case 'tab':
            if (!self.selector.enabled) break;

            self.selector.index = -1;
            self.selector.enabled = false;

            //if the user types shift-tab return to the textbox
            //if the user types tab, set the focus to the currently selected hit.
            if ($event.shiftKey) {
              $input.focus();
            } else {
              $list.find('li.active a').focus();
            }

            $event.preventDefault();
            break;
          case 'down':
            if (!self.selector.enabled) break;

            if (self.selector.index + 1 < page.length) {
              self.selector.index += 1;
            }
            $event.preventDefault();
            break;
          case 'up':
            if (!self.selector.enabled) break;

            if (self.selector.index > 0) {
              self.selector.index -= 1;
            }
            $event.preventDefault();
            break;
          case 'right':
            if (!self.selector.enabled) break;

            if (page.number < page.count) {
              paginate.goToPage(page.number + 1);
              self.selector.index = 0;
              selectTopHit();
            }
            $event.preventDefault();
            break;
          case 'left':
            if (!self.selector.enabled) break;

            if (page.number > 1) {
              paginate.goToPage(page.number - 1);
              self.selector.index = 0;
              selectTopHit();
            }
            $event.preventDefault();
            break;
          case 'escape':
            if (!self.selector.enabled) break;

            $input.focus();
            $event.preventDefault();
            break;
          case 'enter':
            if (!self.selector.enabled) break;

            var hitIndex = (page.number - 1) * paginate.perPage + self.selector.index;
            var hit = self.hits[hitIndex];
            if (!hit) break;

            self.onChoose(hit, $event);
            $event.preventDefault();
            break;
          case 'shift':
            break;
          default:
            $input.focus();
            break;
        }
      };

      self.hitBlur = function () {
        self.selector.index = -1;
        self.selector.enabled = false;
      };

      self.manageObjects = function (type) {
        $location.url('/management/kibana/objects?_a=' + _risonNode2.default.encode({ tab: type }));
      };

      self.hitCountNoun = function () {
        return (self.hitCount === 1 ? self.properties.noun : self.properties.nouns).toLowerCase();
      };

      function selectTopHit() {
        setTimeout(function () {
          //triggering a focus event kicks off a new angular digest cycle.
          $list.find('a:first').focus();
        }, 0);
      }

      function filterResults() {
        if (!self.service) return;
        if (!self.properties) return;

        // track the filter that we use for this search,
        // but ensure that we don't search for the same
        // thing twice. This is called from multiple places
        // and needs to be smart about when it actually searches
        var filter = currentFilter;
        if (prevSearch === filter) return;

        prevSearch = filter;

        var isLabsEnabled = config.get('visualize:enableLabs');
        self.service.find(filter).then(function (hits) {

          hits.hits = hits.hits.filter(function (hit) {
            return isLabsEnabled || hit.type.stage !== 'lab';
          });
          hits.total = hits.hits.length;

          // ensure that we don't display old results
          // as we can't really cancel requests
          if (currentFilter === filter) {
            self.hitCount = hits.total;
            self.hits = _lodash2.default.sortBy(hits.hits, 'title');
          }
        });
      }
    }
  };
});

/***/ }),
/* 910 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _module = _modules.uiModules.get('kibana');

_module.directive('kbnScrollBottom', function () {
  return {
    restrict: 'A',
    link: function link($scope, $element, attr) {
      var checkTimer = void 0;

      function onScroll() {
        var position = $element.scrollTop() + $element.outerHeight();
        var height = $element[0].scrollHeight;
        var remaining = height - position;
        var margin = 50;

        if (!height || !position) return;
        if (remaining <= margin) {
          $scope.$eval(attr.kbnScrollBottom);
        }
      }

      function scheduleCheck() {
        if (checkTimer) return;
        checkTimer = setTimeout(function () {
          checkTimer = null;
          onScroll();
        }, 50);
      }

      $element.on('scroll', scheduleCheck);
      $scope.$on('$destroy', function () {
        clearTimeout(checkTimer);
        $element.off('scroll', scheduleCheck);
      });
      scheduleCheck();
    }
  };
});

/***/ }),
/* 911 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

_modules.uiModules.get('kibana').directive('validateAgg', function () {
  return {
    restrict: 'A',
    require: 'ngModel',
    scope: {
      'ngModel': '=',
      'agg': '='
    },
    link: function link($scope, elem, attr, ngModel) {
      function validateAgg(aggValue) {
        if (aggValue == null || aggValue === 'custom') {
          ngModel.$setValidity('aggInput', true);
          return aggValue;
        }

        try {
          $scope.agg.params.customMetric = null;
          $scope.agg.params.metricAgg = aggValue;
          $scope.agg.makeLabel();
          ngModel.$setValidity('aggInput', true);
        } catch (e) {
          ngModel.$setValidity('aggInput', false);
        }

        return aggValue;
      }

      // From User
      ngModel.$parsers.unshift(validateAgg);

      // To user
      ngModel.$formatters.unshift(validateAgg);
    }
  };
});

/***/ }),
/* 912 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _cidr_mask = __webpack_require__(913);

var _modules = __webpack_require__(2);

_modules.uiModules.get('kibana').directive('validateCidrMask', function () {
  return {
    restrict: 'A',
    require: 'ngModel',
    scope: {
      'ngModel': '='
    },
    link: function link($scope, elem, attr, ngModel) {
      ngModel.$parsers.unshift(validateCidrMask);
      ngModel.$formatters.unshift(validateCidrMask);

      function validateCidrMask(mask) {
        if (mask == null || mask === '') {
          ngModel.$setValidity('cidrMaskInput', true);
          return null;
        }

        try {
          mask = new _cidr_mask.CidrMask(mask);
          ngModel.$setValidity('cidrMaskInput', true);
          return mask.toString();
        } catch (e) {
          ngModel.$setValidity('cidrMaskInput', false);
        }
      }
    }
  };
});

/***/ }),
/* 913 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CidrMask = CidrMask;

var _ipv4_address = __webpack_require__(783);

var _ipv4_address2 = _interopRequireDefault(_ipv4_address);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NUM_BITS = 32;

function throwError(mask) {
  throw Error('Invalid CIDR mask: ' + mask);
}

function CidrMask(mask) {
  var splits = mask.split('\/');
  if (splits.length !== 2) throwError(mask);
  this.initialAddress = new _ipv4_address2.default(splits[0]);
  this.prefixLength = Number(splits[1]);
  if (this.prefixLength < 1 || this.prefixLength > NUM_BITS) throwError(mask);
}

CidrMask.prototype.getRange = function () {
  var variableBits = NUM_BITS - this.prefixLength;
  var fromAddress = this.initialAddress.valueOf() >> variableBits << variableBits >>> 0; // >>> 0 coerces to unsigned
  var numAddresses = Math.pow(2, variableBits);
  return {
    from: new _ipv4_address2.default(fromAddress).toString(),
    to: new _ipv4_address2.default(fromAddress + numAddresses - 1).toString()
  };
};

CidrMask.prototype.toString = function () {
  return this.initialAddress.toString() + '/' + this.prefixLength;
};

/***/ }),
/* 914 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// See https://github.com/elastic/elasticsearch/issues/6736

_modules.uiModules.get('kibana').directive('validateIndexPattern', function () {
  return {
    restrict: 'A',
    require: 'ngModel',
    link: function link($scope, elem, attr, ngModel) {
      var illegalCharacters = ['\\', '/', '?', '"', '<', '>', '|', ' '];

      var allowWildcard = !_lodash2.default.isUndefined(attr.validateIndexPatternAllowWildcard) && attr.validateIndexPatternAllowWildcard !== 'false';

      if (!allowWildcard) {
        illegalCharacters.push('*');
      }

      var isValid = function isValid(input) {
        if (input == null || input === '') return !attr.required === true;
        if (input === '.' || input === '..') return false;

        var match = _lodash2.default.find(illegalCharacters, function (character) {
          return input.indexOf(character) >= 0;
        });

        return !match;
      };

      ngModel.$validators.indexPattern = function (modelValue, viewValue) {
        return isValid(viewValue);
      };
    }
  };
});

/***/ }),
/* 915 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _module = _modules.uiModules.get('kibana');

_module.directive('validateJson', function () {
  return {
    restrict: 'A',
    require: 'ngModel',
    scope: {
      'ngModel': '=',
      'queryInput': '=?'
    },
    link: function link($scope, $elem, attr, ngModel) {
      $scope.$watch('ngModel', validator);

      function validator(newValue) {
        if (!newValue || newValue.length === 0) {
          setValid();
          return;
        }

        // We actually need a proper object in all JSON inputs
        newValue = (newValue || '').trim();
        if (newValue[0] === '{' || newValue[0] === '[') {
          try {
            JSON.parse(newValue);
            setValid();
          } catch (e) {
            setInvalid();
          }
        } else {
          setInvalid();
        }
      }

      function setValid() {
        ngModel.$setValidity('jsonInput', true);
      }

      function setInvalid() {
        ngModel.$setValidity('jsonInput', false);
      }
    }
  };
});

/***/ }),
/* 916 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.propFilter = propFilter;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Filters out a list by a given filter. This is currently used to impelment:
 *   - fieldType filters a list of fields by their type property
 *   - aggFilter filters a list of aggs by their name property
 *
 * @returns {function} - the filter function which can be registered with angular
 */
function propFilter(prop) {
  /**
   * List filtering function which accepts an array or list of values that a property
   * must contain
   *
   * @param  {array} list - array of items to filter
   * @param  {function|array|string} filters - the values to match against the list
   *   - if a function, it is expected to take the field property as argument and returns true to keep it.
   *   - Can be also an array, a single value as a string, or a comma-seperated list of items
   * @return {array} - the filtered list
   */
  return function (list, filters) {
    if (!filters) return filters;

    if (_lodash2.default.isFunction(filters)) {
      return list.filter(function (item) {
        return filters(item[prop]);
      });
    }

    if (!Array.isArray(filters)) filters = filters.split(',');
    if (_lodash2.default.contains(filters, '*')) return list;

    var options = filters.reduce(function (options, filter) {
      var type = 'include';
      var value = filter;

      if (filter.charAt(0) === '!') {
        type = 'exclude';
        value = filter.substr(1);
      }

      if (!options[type]) options[type] = [];
      options[type].push(value);
      return options;
    }, {});

    return list.filter(function (item) {
      var value = item[prop];

      var excluded = options.exclude && _lodash2.default.contains(options.exclude, value);
      if (excluded) return false;

      var included = !options.include || _lodash2.default.contains(options.include, value);
      if (included) return true;

      return false;
    });
  };
}

/***/ }),
/* 917 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _lodash = __webpack_require__(1);

_modules.uiModules.get('kibana').filter('label', function () {
  return function (str) {
    return (0, _lodash.words)(str).map(_lodash.capitalize).join(' ');
  };
});

/***/ }),
/* 918 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Gets all fields of a given type.
// You may also pass "*" to get all types
// Or an array of types to get all fields of that type

_modules.uiModules.get('kibana').filter('matchAny', function () {
  return function (items, rules) {
    if (!Array.isArray(rules)) {
      rules = [rules];
    }

    return _lodash2.default.filter(items, function (item) {
      for (var i = 0; i < rules.length; i++) {
        if (_lodash2.default.some([item], rules[i])) {
          return true;
        }
      }

      return false;
    });
  };
});

/***/ }),
/* 919 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_modules.uiModules.get('kibana').filter('moment', function (config) {
  return function (datetime) {
    var format = config.get('dateFormat');
    if (_moment2.default.isMoment(datetime)) return datetime.format(format);
    if (_lodash2.default.isDate(datetime)) return (0, _moment2.default)(datetime).format(format);
    return datetime;
  };
});

/***/ }),
/* 920 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

_modules.uiModules.get('kibana').filter('startFrom', function () {
  return function (input, start) {
    if (!input) return [];
    start = +start; //parse to int
    return input.slice(start);
  };
});

/***/ }),
/* 921 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _module = _modules.uiModules.get('kibana');

// Simple filter to allow using ng-bind-html without explicitly calling $sce.trustAsHtml in a controller
// (See http://goo.gl/mpj9o2)
_module.filter('trustAsHtml', function ($sce) {
  return $sce.trustAsHtml;
});

/***/ }),
/* 922 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Filters out all duplicate items in an array

_modules.uiModules.get('kibana').filter('unique', function () {
  return function (arr) {
    var list = _lodash2.default.unique(arr);
    return list;
  };
});

/***/ }),
/* 923 */,
/* 924 */,
/* 925 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

var _pegjs = __webpack_require__(770);

var _pegjs2 = _interopRequireDefault(_pegjs);

var _chain = __webpack_require__(2933);

var _chain2 = _interopRequireDefault(_chain);

__webpack_require__(2934);

var _timelion_expression_input = __webpack_require__(2936);

var _timelion_expression_input2 = _interopRequireDefault(_timelion_expression_input);

var _timelion_expression_input_helpers = __webpack_require__(2937);

var _eui = __webpack_require__(11);

var _arg_value_suggestions = __webpack_require__(2938);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * Timelion Expression Autocompleter
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * This directive allows users to enter multiline timelion expressions. If the user has entered
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * a valid expression and then types a ".", this directive will display a list of suggestions.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * Users can navigate suggestions using the arrow keys. When a user selects a suggestion, it's
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * inserted into the expression and the caret position is updated to be inside of the newly-
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * added function's parentheses.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * Beneath the hood, we use a PEG grammar to validate the Timelion expression and detect if
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * the caret is in a position within the expression that allows functions to be suggested.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * NOTE: This directive doesn't work well with contenteditable divs. Challenges include:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *   - You have to replace markup with newline characters and spaces when passing the expression
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *     to the grammar.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *   - You have to do the opposite when loading a saved expression, so that it appears correctly
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *     within the contenteditable (i.e. replace newlines with <br> markup).
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *   - The Range and Selection APIs ignore newlines when providing caret position, so there is
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *     literally no way to insert suggestions into the correct place in a multiline expression
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *     that has more than a single consecutive newline.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            */

var Parser = _pegjs2.default.buildParser(_chain2.default);
var app = __webpack_require__(2).get('apps/timelion', []);

app.directive('timelionExpressionInput', function ($document, $http, $interval, $timeout, Private) {
  return {
    restrict: 'E',
    scope: {
      rows: '=',
      sheet: '=',
      updateChart: '&',
      shouldPopoverSuggestions: '@'
    },
    replace: true,
    template: _timelion_expression_input2.default,
    link: function link(scope, elem) {
      var getSuggestions = function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          var suggestions;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return (0, _timelion_expression_input_helpers.suggest)(scope.sheet, functionReference.list, Parser, getCursorPosition(), argValueSuggestions);

                case 2:
                  suggestions = _context.sent;


                  // We're using ES6 Promises, not $q, so we have to wrap this in $apply.
                  scope.$apply(function () {
                    if (suggestions) {
                      scope.suggestions.setList(suggestions.list, suggestions.type);
                      scope.suggestions.show();
                      suggestibleFunctionLocation = suggestions.location;
                      $timeout(function () {
                        var suggestionsList = (0, _jquery2.default)('[data-suggestions-list]');
                        suggestionsList.scrollTop(0);
                      }, 0);
                      return;
                    }

                    suggestibleFunctionLocation = undefined;
                    scope.suggestions.reset();
                  });

                case 4:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        return function getSuggestions() {
          return _ref.apply(this, arguments);
        };
      }();

      var argValueSuggestions = Private(_arg_value_suggestions.ArgValueSuggestionsProvider);
      var expressionInput = elem.find('[data-expression-input]');
      var functionReference = {};
      var suggestibleFunctionLocation = {};

      scope.suggestions = new _timelion_expression_input_helpers.Suggestions();

      function init() {
        $http.get('../api/timelion/functions').then(function (resp) {
          Object.assign(functionReference, {
            byName: _lodash2.default.indexBy(resp.data, 'name'),
            list: resp.data
          });
        });
      }

      function setCaretOffset(caretOffset) {
        // Wait for Angular to update the input with the new expression and *then* we can set
        // the caret position.
        $timeout(function () {
          expressionInput.focus();
          expressionInput[0].selectionStart = expressionInput[0].selectionEnd = caretOffset;
          scope.$apply();
        }, 0);
      }

      function insertSuggestionIntoExpression(suggestionIndex) {
        if (scope.suggestions.isEmpty()) {
          return;
        }

        var _suggestibleFunctionL = suggestibleFunctionLocation,
            min = _suggestibleFunctionL.min,
            max = _suggestibleFunctionL.max;

        var insertedValue = void 0;
        var insertPositionMinOffset = 0;

        switch (scope.suggestions.type) {
          case _timelion_expression_input_helpers.SUGGESTION_TYPE.FUNCTIONS:
            {
              // Position the caret inside of the function parentheses.
              insertedValue = scope.suggestions.list[suggestionIndex].name + '()';

              // min advanced one to not replace function '.'
              insertPositionMinOffset = 1;
              break;
            }
          case _timelion_expression_input_helpers.SUGGESTION_TYPE.ARGUMENTS:
            {
              // Position the caret after the '='
              insertedValue = scope.suggestions.list[suggestionIndex].name + '=';
              break;
            }
          case _timelion_expression_input_helpers.SUGGESTION_TYPE.ARGUMENT_VALUE:
            {
              // Position the caret after the argument value
              insertedValue = '' + scope.suggestions.list[suggestionIndex].name;
              break;
            }
        }

        var updatedExpression = (0, _timelion_expression_input_helpers.insertAtLocation)(insertedValue, scope.sheet, min + insertPositionMinOffset, max);
        scope.sheet = updatedExpression;

        var newCaretOffset = min + insertedValue.length;
        setCaretOffset(newCaretOffset);
      }

      function scrollToSuggestionAt(index) {
        // We don't cache these because the list changes based on user input.
        var suggestionsList = (0, _jquery2.default)('[data-suggestions-list]');
        var suggestionListItem = (0, _jquery2.default)('[data-suggestion-list-item]')[index];
        // Scroll to the position of the item relative to the list, not to the window.
        suggestionsList.scrollTop(suggestionListItem.offsetTop - suggestionsList[0].offsetTop);
      }

      function getCursorPosition() {
        if (expressionInput.length) {
          return expressionInput[0].selectionStart;
        }
        return null;
      }

      function isNavigationalKey(keyCode) {
        var keyCodes = _lodash2.default.values(_eui.comboBoxKeyCodes);
        return keyCodes.includes(keyCode);
      }

      scope.onFocusInput = function () {
        // Wait for the caret position of the input to update and then we can get suggestions
        // (which depends on the caret position).
        $timeout(getSuggestions, 0);
      };

      scope.onBlurInput = function () {
        scope.suggestions.hide();
      };

      scope.onKeyDownInput = function (e) {
        // If we've pressed any non-navigational keys, then the user has typed something and we
        // can exit early without doing any navigation. The keyup handler will pull up suggestions.
        if (!isNavigationalKey(e.keyCode)) {
          return;
        }

        switch (e.keyCode) {
          case _eui.comboBoxKeyCodes.UP:
            if (scope.suggestions.isVisible) {
              // Up and down keys navigate through suggestions.
              e.preventDefault();
              scope.suggestions.stepForward();
              scrollToSuggestionAt(scope.suggestions.index);
            }
            break;

          case _eui.comboBoxKeyCodes.DOWN:
            if (scope.suggestions.isVisible) {
              // Up and down keys navigate through suggestions.
              e.preventDefault();
              scope.suggestions.stepBackward();
              scrollToSuggestionAt(scope.suggestions.index);
            }
            break;

          case _eui.comboBoxKeyCodes.TAB:
            // If there are no suggestions or none is selected, the user tabs to the next input.
            if (scope.suggestions.isEmpty() || scope.suggestions.index < 0) {
              // Before letting the tab be handled to focus the next element
              // we need to hide the suggestions, otherwise it will focus these
              // instead of the time interval select.
              scope.suggestions.hide();
              return;
            }

            // If we have suggestions, complete the selected one.
            e.preventDefault();
            insertSuggestionIntoExpression(scope.suggestions.index);
            break;

          case _eui.comboBoxKeyCodes.ENTER:
            if (e.metaKey || e.ctrlKey) {
              // Re-render the chart when the user hits CMD+ENTER.
              e.preventDefault();
              scope.updateChart();
            } else if (!scope.suggestions.isEmpty()) {
              // If the suggestions are open, complete the expression with the suggestion.
              e.preventDefault();
              insertSuggestionIntoExpression(scope.suggestions.index);
            }
            break;

          case _eui.comboBoxKeyCodes.ESCAPE:
            e.preventDefault();
            scope.suggestions.hide();
            break;
        }
      };

      scope.onKeyUpInput = function (e) {
        // If the user isn't navigating, then we should update the suggestions based on their input.
        if (!isNavigationalKey(e.keyCode)) {
          getSuggestions();
        }
      };

      scope.onClickExpression = function () {
        getSuggestions();
      };

      scope.onClickSuggestion = function (index) {
        insertSuggestionIntoExpression(index);
      };

      scope.getActiveSuggestionId = function () {
        if (scope.suggestions.isVisible && scope.suggestions.index > -1) {
          return 'timelionSuggestion' + scope.suggestions.index;
        }
        return '';
      };

      init();
    }
  };
});

/***/ }),
/* 926 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

var _timelion_interval = __webpack_require__(2941);

var _timelion_interval2 = _interopRequireDefault(_timelion_interval);

__webpack_require__(2942);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var app = __webpack_require__(2).get('apps/timelion', []);


app.directive('timelionInterval', function ($compile, $timeout) {
  return {
    restrict: 'E',
    scope: {
      // The interval model
      model: '='
    },
    template: _timelion_interval2.default,
    link: function link($scope, $elem) {
      $scope.intervalOptions = ['auto', '1s', '1m', '1h', '1d', '1w', '1M', '1y', 'other'];
      $scope.intervalLabels = {
        'auto': 'auto',
        '1s': '1 second',
        '1m': '1 minute',
        '1h': '1 hour',
        '1d': '1 day',
        '1w': '1 week',
        '1M': '1 month',
        '1y': '1 year',
        'other': 'other'
      };

      $scope.$watch('model', function (newVal, oldVal) {
        // Only run this on initialization
        if (newVal !== oldVal || oldVal == null) return;

        if (_lodash2.default.contains($scope.intervalOptions, newVal)) {
          $scope.interval = newVal;
        } else {
          $scope.interval = 'other';
        }

        if (newVal !== 'other') {
          $scope.otherInterval = newVal;
        }
      });

      $scope.$watch('interval', function (newVal, oldVal) {
        if (newVal === oldVal) return;

        if (newVal === 'other') {
          $scope.otherInterval = oldVal;
          $scope.model = $scope.otherInterval;
          $timeout(function () {
            (0, _jquery2.default)('input', $elem).select();
          }, 0);
        } else {
          $scope.otherInterval = $scope.interval;
          $scope.model = $scope.interval;
        }
      });

      $scope.$watch('otherInterval', function (newVal, oldVal) {
        if (newVal === oldVal) return;
        $scope.model = newVal;
      });
    }
  };
});

/***/ }),
/* 927 */,
/* 928 */,
/* 929 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = TimelionVisProvider;

var _vis_factory = __webpack_require__(47);

var _vis_category = __webpack_require__(41);

var _iconTimelion = __webpack_require__(3039);

var _iconTimelion2 = _interopRequireDefault(_iconTimelion);

var _vis_types = __webpack_require__(66);

var _timelion_request_handler = __webpack_require__(3040);

var _editor_size = __webpack_require__(357);

__webpack_require__(3041);

__webpack_require__(925);

__webpack_require__(3042);

var _timelion_vis = __webpack_require__(3043);

var _timelion_vis2 = _interopRequireDefault(_timelion_vis);

var _timelion_vis_params = __webpack_require__(3044);

var _timelion_vis_params2 = _interopRequireDefault(_timelion_vis_params);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// register the provider with the visTypes registry so that other know it exists
_vis_types.VisTypesRegistryProvider.register(TimelionVisProvider);

// Stylin


// we also need to load the controller and directive used by the template
function TimelionVisProvider(Private) {
  var VisFactory = Private(_vis_factory.VisFactoryProvider);
  var timelionRequestHandler = Private(_timelion_request_handler.TimelionRequestHandlerProvider);

  // return the visType object, which kibana will use to display and configure new
  // Vis object of this type.
  return VisFactory.createAngularVisualization({
    name: 'timelion',
    title: 'Timelion',
    image: _iconTimelion2.default,
    description: 'Build time-series using functional expressions',
    category: _vis_category.CATEGORY.TIME,
    visConfig: {
      defaults: {
        expression: '.es(*)',
        interval: 'auto'
      },
      template: _timelion_vis2.default
    },
    editorConfig: {
      optionsTemplate: _timelion_vis_params2.default,
      defaultSize: _editor_size.DefaultEditorSize.MEDIUM
    },
    requestHandler: timelionRequestHandler.handler,
    responseHandler: 'none',
    options: {
      showIndexSelection: false
    }
  });
}
module.exports = exports['default'];

/***/ }),
/* 930 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.VisTypeProvider = VisTypeProvider;

var _vis_category = __webpack_require__(41);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function VisTypeProvider() {
  var VisType = function () {
    function VisType(opts) {
      _classCallCheck(this, VisType);

      opts = opts || {};

      if (!opts.name) throw 'vis_type must define its name';
      if (!opts.title) throw 'vis_type must define its title';
      if (!opts.description) throw 'vis_type must define its description';
      if (!opts.icon && !opts.image) throw 'vis_type must define its icon or image';
      if (!opts.visualization) throw 'vis_type must define visualization controller';

      var _defaults = {
        // name, title, description, icon, image
        category: _vis_category.CATEGORY.OTHER,
        visualization: null, // must be a class with render/resize/destroy methods
        visConfig: {
          defaults: {} // default configuration
        },
        requestHandler: 'courier', // select one from registry or pass a function
        responseHandler: 'tabify',
        editor: 'default',
        editorConfig: {
          collections: {} // collections used for configuration (list of positions, ...)
        },
        options: { // controls the visualize editor
          showTimePicker: true,
          showQueryBar: true,
          showFilterBar: true,
          showIndexSelection: true,
          hierarchicalData: false // we should get rid of this i guess ?
        },
        stage: 'production',
        feedbackMessage: ''
      };

      _lodash2.default.defaultsDeep(this, opts, _defaults);

      this.requiresSearch = !(this.requestHandler === 'none');
    }

    _createClass(VisType, [{
      key: 'shouldMarkAsExperimentalInUI',
      value: function shouldMarkAsExperimentalInUI() {
        //we are not making a distinction in the UI if a plugin is experimental and/or labs.
        //we just want to indicate it is special. the current flask icon is sufficient for that.
        return this.stage === 'experimental' || this.stage === 'lab';
      }
    }]);

    return VisType;
  }();

  Object.defineProperty(VisType.prototype, 'schemas', {
    get: function get() {
      if (this.editorConfig && this.editorConfig.schemas) {
        return this.editorConfig.schemas;
      }

      return []; //throw `Can't get schemas from a visualization without using the default editor`;
    }
  });

  return VisType;
}

/***/ }),
/* 931 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggResponsePointSeriesProvider = AggResponsePointSeriesProvider;

var _get_series = __webpack_require__(2966);

var _get_aspects = __webpack_require__(2969);

var _init_y_axis = __webpack_require__(2980);

var _init_x_axis = __webpack_require__(2981);

var _ordered_date_axis = __webpack_require__(2982);

var _tooltip_formatter = __webpack_require__(2983);

function AggResponsePointSeriesProvider(Private) {

  var getSeries = Private(_get_series.PointSeriesGetSeriesProvider);
  var getAspects = Private(_get_aspects.PointSeriesGetAspectsProvider);
  var initYAxis = Private(_init_y_axis.PointSeriesInitYAxisProvider);
  var initXAxis = Private(_init_x_axis.PointSeriesInitXAxisProvider);
  var setupOrderedDateXAxis = Private(_ordered_date_axis.PointSeriesOrderedDateAxisProvider);
  var tooltipFormatter = Private(_tooltip_formatter.PointSeriesTooltipFormatter);

  return function pointSeriesChartDataFromTable(vis, table) {
    var chart = {};
    var aspects = chart.aspects = getAspects(vis, table);

    chart.tooltipFormatter = tooltipFormatter;

    initXAxis(chart);
    initYAxis(chart);

    var datedX = aspects.x.agg.type.ordered && aspects.x.agg.type.ordered.date;
    if (datedX) {
      setupOrderedDateXAxis(vis, chart);
    }

    chart.series = getSeries(table.rows, chart);

    delete chart.aspects;
    return chart;
  };
}

/***/ }),
/* 932 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VislibPieConfigProvider = VislibPieConfigProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function VislibPieConfigProvider() {

  return function (config) {
    if (!config.chart) {
      config.chart = _lodash2.default.defaults({}, config, {
        type: 'pie',
        labels: {
          show: false,
          truncate: 100
        }
      });
    }
    return config;
  };
}

/***/ }),
/* 933 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.VislibTypesPointSeries = VislibTypesPointSeries;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function VislibTypesPointSeries() {

  var createSerieFromParams = function createSerieFromParams(cfg, seri) {
    var matchingSeriesParams = cfg.seriesParams ? cfg.seriesParams.find(function (seriConfig) {
      return seri.aggId === seriConfig.data.id;
    }) : null;

    var interpolate = cfg.smoothLines ? 'cardinal' : cfg.interpolate;

    if (!matchingSeriesParams) {
      var stacked = ['stacked', 'percentage', 'wiggle', 'silhouette'].includes(cfg.mode);
      return {
        show: true,
        type: cfg.type || 'line',
        mode: stacked ? 'stacked' : 'normal',
        interpolate: interpolate,
        drawLinesBetweenPoints: cfg.drawLinesBetweenPoints,
        showCircles: cfg.showCircles,
        radiusRatio: cfg.radiusRatio,
        data: seri
      };
    }

    return _extends({}, matchingSeriesParams, {
      data: seri,
      radiusRatio: cfg.radiusRatio
    });
  };

  var createSeries = function createSeries(cfg, series) {
    return {
      type: 'point_series',
      addTimeMarker: cfg.addTimeMarker,
      series: _lodash2.default.map(series, function (seri) {
        return createSerieFromParams(cfg, seri);
      })
    };
  };

  var createCharts = function createCharts(cfg, data) {
    if (data.rows || data.columns) {
      var charts = data.rows ? data.rows : data.columns;
      return charts.map(function (chart) {
        return createSeries(cfg, chart.series);
      });
    }

    return [createSeries(cfg, data.series)];
  };
  /*
   * Create handlers for Area, Column, and Line charts which
   * are all nearly the same minus a few details
   */
  function create(opts) {
    opts = opts || {};

    return function (cfg, data) {
      var isUserDefinedYAxis = cfg.setYExtents;
      var config = _lodash2.default.cloneDeep(cfg);
      _lodash2.default.defaultsDeep(config, {
        chartTitle: {},
        mode: 'normal'
      }, opts);

      config.type = 'point_series';

      if (!config.tooltip) {
        config.tooltip = {
          show: cfg.addTooltip
        };
      }

      if (!config.valueAxes) {
        var mode = config.mode;
        if (['stacked', 'overlap'].includes(mode)) mode = 'normal';
        config.valueAxes = [{
          id: 'ValueAxis-1',
          type: 'value',
          scale: {
            type: config.scale,
            setYExtents: config.setYExtents,
            defaultYExtents: config.defaultYExtents,
            min: isUserDefinedYAxis ? config.yAxis.min : undefined,
            max: isUserDefinedYAxis ? config.yAxis.max : undefined,
            mode: mode
          },
          labels: {
            axisFormatter: data.data.yAxisFormatter || data.get('yAxisFormatter')
          },
          title: {
            text: data.get('yAxisLabel')
          }
        }];
      } else {
        config.valueAxes.forEach(function (axis) {
          if (axis.labels) {
            axis.labels.axisFormatter = data.data.yAxisFormatter || data.get('yAxisFormatter');
          }
        });
      }

      if (!config.categoryAxes) {
        config.categoryAxes = [{
          id: 'CategoryAxis-1',
          type: 'category',
          labels: {
            axisFormatter: data.data.xAxisFormatter || data.get('xAxisFormatter')
          },
          scale: {
            expandLastBucket: opts.expandLastBucket
          },
          title: {
            text: data.get('xAxisLabel')
          }
        }];
      } else {
        var categoryAxis1 = config.categoryAxes.find(function (categoryAxis) {
          return categoryAxis.id === 'CategoryAxis-1';
        });
        if (categoryAxis1) {
          categoryAxis1.title.text = data.get('xAxisLabel');
        }
      }

      if (!config.charts) {
        config.charts = createCharts(cfg, data.data);
      }

      if (typeof config.enableHover === 'undefined') config.enableHover = true;

      return config;
    };
  }

  return {
    line: create(),

    column: create({
      expandLastBucket: true
    }),

    area: create({
      alerts: [{
        type: 'warning',
        msg: 'Positive and negative values are not accurately represented by stacked ' + 'area charts. Either changing the chart mode to "overlap" or using a ' + 'bar chart is recommended.',
        test: function test(vis, data) {
          if (!data.shouldBeStacked() || data.maxNumberOfSeries() < 2) return;

          var hasPos = data.getYMax(data._getY) > 0;
          var hasNeg = data.getYMin(data._getY) < 0;
          return hasPos && hasNeg;
        }
      }, {
        type: 'warning',
        msg: 'Parts of or the entire area chart might not be displayed due to null ' + 'values in the data. A line chart is recommended when displaying data ' + 'with null values.',
        test: function test(vis, data) {
          return data.hasNullValues();
        }
      }]
    }),

    heatmap: function heatmap(cfg, data) {
      var defaults = create()(cfg, data);
      var seriesLimit = 25;
      var hasCharts = defaults.charts.length;
      var tooManySeries = defaults.charts.length && defaults.charts[0].series.length > seriesLimit;
      if (hasCharts && tooManySeries) {
        defaults.error = 'There are too many series defined.';
      }
      defaults.valueAxes[0].show = false;
      defaults.categoryAxes[0].style = {
        rangePadding: 0,
        rangeOuterPadding: 0
      };
      defaults.categoryAxes.push({
        id: 'CategoryAxis-2',
        type: 'category',
        position: 'left',
        values: data.getLabels(),
        scale: {
          inverted: true
        },
        labels: {
          filter: false,
          axisFormatter: function axisFormatter(val) {
            return val;
          }
        },
        style: {
          rangePadding: 0,
          rangeOuterPadding: 0
        },
        title: {
          text: data.get('zAxisLabel') || ''
        }
      });
      return defaults;
    }
  };
}

/***/ }),
/* 934 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VislibTypesProvider = VislibTypesProvider;

var _point_series = __webpack_require__(933);

var _pie = __webpack_require__(932);

var _gauge = __webpack_require__(2986);

function VislibTypesProvider(Private) {
  var pointSeries = Private(_point_series.VislibTypesPointSeries);

  /**
   * Handles the building of each visualization
   *
   * @return {Function} Returns an Object of Handler types
   */
  return {
    histogram: pointSeries.column,
    horizontal_bar: pointSeries.column,
    line: pointSeries.line,
    pie: Private(_pie.VislibPieConfigProvider),
    area: pointSeries.area,
    point_series: pointSeries.line,
    heatmap: pointSeries.heatmap,
    gauge: Private(_gauge.vislibGaugeProvider),
    goal: Private(_gauge.vislibGaugeProvider),
    metric: Private(_gauge.vislibGaugeProvider)
  };
}

/***/ }),
/* 935 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VislibLibLayoutLayoutTypesProvider = VislibLibLayoutLayoutTypesProvider;

var _column_layout = __webpack_require__(2987);

var _pie_layout = __webpack_require__(2992);

var _gauge_layout = __webpack_require__(2995);

function VislibLibLayoutLayoutTypesProvider(Private) {

  /**
   * Provides the HTML layouts for each visualization class
   *
   * @module vislib
   * @submodule LayoutTypeFactory
   * @param Private {Service} Loads any function as an angular module
   * @return {Function} Returns an Object of HTML layouts for each visualization class
   */
  return {
    pie: Private(_pie_layout.VislibLibLayoutTypesPieLayoutProvider),
    gauge: Private(_gauge_layout.GaugeLayoutProvider),
    goal: Private(_gauge_layout.GaugeLayoutProvider),
    metric: Private(_gauge_layout.GaugeLayoutProvider),
    point_series: Private(_column_layout.VislibLibLayoutTypesColumnLayoutProvider)
  };
}

/***/ }),
/* 936 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VislibComponentsZeroInjectionOrderedXKeysProvider = VislibComponentsZeroInjectionOrderedXKeysProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

var _uniq_keys = __webpack_require__(2998);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function VislibComponentsZeroInjectionOrderedXKeysProvider(Private) {
  var getUniqKeys = Private(_uniq_keys.VislibComponentsZeroInjectionUniqKeysProvider);

  /*
   * Accepts a Kibana data object and returns
   * an array of x axis values.
   * values sorted by timestamp if isDate and Date Histogram agg
   * else values sorted by index
   */

  return function (obj) {
    var orderBucketsBySum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (!_lodash2.default.isObject(obj)) {
      throw new Error('OrderedXKeysUtilService expects an object');
    }

    var uniqKeys = getUniqKeys(obj);
    var uniqKeysPairs = [].concat(_toConsumableArray(uniqKeys.entries()));

    var interval = _lodash2.default.get(obj, 'ordered.interval');
    var dateInterval = _moment2.default.isDuration(interval) ? interval : false;

    return (0, _lodash2.default)(uniqKeysPairs).sortBy(function (d) {
      if (d[1].isDate || d[1].isOrdered) {
        return +d[0];
      }
      return orderBucketsBySum ? -d[1].sum : d[1].index;
    }).map(function (d, i, list) {
      if (!d[1].isNumber) return d[0];

      var val = +d[0];
      if (interval == null) return val;

      var gapEdge = parseFloat(_lodash2.default.get(list, [i + 1, 0]));
      if (isNaN(gapEdge)) return val;

      var vals = [];
      var next = val;

      if (dateInterval) {
        next = (0, _moment2.default)(val);
        while (next < gapEdge) {
          vals.push(next.valueOf());
          next.add(dateInterval);
        }
      } else {
        while (next < gapEdge) {
          vals.push(next);
          next += interval;
        }
      }

      return vals;
    }).flatten().value();
  };
}

/***/ }),
/* 937 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createColorPalette = createColorPalette;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _seed_colors = __webpack_require__(938);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Generates an array of hex colors the length of the input number.
 * If the number is greater than the length of seed colors available,
 * new colors are generated up to the value of the input number.
 */

var offset = 300; // Hue offset to start at

var fraction = function fraction(goal) {
  var walkTree = function walkTree(numerator, denominator, bytes) {
    if (bytes.length) {
      return walkTree(numerator * 2 + (bytes.pop() ? 1 : -1), denominator * 2, bytes);
    } else {
      return numerator / denominator;
    }
  };

  var b = (goal + 2).toString(2).split('').map(function (num) {
    return parseInt(num, 10);
  });
  b.shift();

  return walkTree(1, 2, b);
};

function createColorPalette(num) {
  if (!_lodash2.default.isNumber(num)) {
    throw new TypeError('ColorPaletteUtilService expects a number');
  }

  var colors = _seed_colors.seedColors;

  var seedLength = _seed_colors.seedColors.length;

  _lodash2.default.times(num - seedLength, function (i) {
    colors.push(_d2.default.hsl((fraction(i + seedLength + 1) * 360 + offset) % 360, 0.5, 0.5).toString());
  });

  return colors;
}

/***/ }),
/* 938 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
* Using a random color generator presented awful colors and unpredictable color schemes.
* So we needed to come up with a color scheme of our own that creates consistent, pleasing color patterns.
* The order allows us to guarantee that 1st, 2nd, 3rd, etc values always get the same color.
*/

var seedColors = exports.seedColors = ['#00a69b', '#57c17b', '#6f87d8', '#663db8', '#bc52bc', '#9e3533', '#daa05d'];

/***/ }),
/* 939 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VislibVisualizationsVisTypesProvider = VislibVisualizationsVisTypesProvider;

var _point_series = __webpack_require__(3008);

var _pie_chart = __webpack_require__(3021);

var _gauge_chart = __webpack_require__(3022);

function VislibVisualizationsVisTypesProvider(Private) {

  /**
   * Provides the visualizations for the vislib
   *
   * @module vislib
   * @submodule VisTypeFactory
   * @param Private {Object} Loads any function as an angular module
   * @return {Function} Returns an Object of Visualization classes
   */
  return {
    pie: Private(_pie_chart.VislibVisualizationsPieChartProvider),
    point_series: Private(_point_series.VislibVisualizationsPointSeriesProvider),
    gauge: Private(_gauge_chart.GaugeChartProvider),
    goal: Private(_gauge_chart.GaugeChartProvider),
    metric: Private(_gauge_chart.GaugeChartProvider)
  };
}

/***/ }),
/* 940 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _binder = __webpack_require__(3010);

Object.defineProperty(exports, 'Binder', {
  enumerable: true,
  get: function get() {
    return _binder.Binder;
  }
});

/***/ }),
/* 941 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.truncateLabel = undefined;

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***
 *
 * @param text (d3 node containing text)
 * @param size (number of characters to leave)
 * @returns {text} the updated text
 */
var truncateLabel = function truncateLabel(text, size) {
  var node = _d2.default.select(text).node();
  var str = (0, _jquery2.default)(node).text();
  if (size === 0) return str;
  if (size >= str.length) return str;
  return str.substr(0, size) + '';
};

exports.truncateLabel = truncateLabel;

/***/ }),
/* 942 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 943 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.VislibLibAxisProvider = VislibLibAxisProvider;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

var _error_handler = __webpack_require__(944);

var _axis_title = __webpack_require__(3030);

var _axis_labels = __webpack_require__(3031);

var _axis_scale = __webpack_require__(3032);

var _axis_config = __webpack_require__(3033);

var _errors = __webpack_require__(37);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function VislibLibAxisProvider(Private) {
  var ErrorHandler = Private(_error_handler.VislibLibErrorHandlerProvider);
  var AxisTitle = Private(_axis_title.VislibLibAxisTitleProvider);
  var AxisLabels = Private(_axis_labels.VislibAxisLabelsProvider);
  var AxisScale = Private(_axis_scale.VislibAxisScaleProvider);
  var AxisConfig = Private(_axis_config.VislibLibAxisConfigProvider);

  var Axis = function (_ErrorHandler) {
    _inherits(Axis, _ErrorHandler);

    function Axis(visConfig, axisConfigArgs) {
      _classCallCheck(this, Axis);

      var _this = _possibleConstructorReturn(this, (Axis.__proto__ || Object.getPrototypeOf(Axis)).call(this));

      _this.visConfig = visConfig;

      _this.axisConfig = new AxisConfig(_this.visConfig, axisConfigArgs);
      if (_this.axisConfig.get('type') === 'category') {
        _this.values = _this.axisConfig.values;
        _this.ordered = _this.axisConfig.ordered;
      }
      _this.axisScale = new AxisScale(_this.axisConfig, visConfig);
      _this.axisTitle = new AxisTitle(_this.axisConfig);
      _this.axisLabels = new AxisLabels(_this.axisConfig, _this.axisScale);

      _this.stack = _d2.default.layout.stack().x(function (d) {
        return d.x;
      }).y(function (d) {
        if (_this.axisConfig.get('scale.offset') === 'expand') {
          return Math.abs(d.y);
        }
        return d.y;
      }).offset(_this.axisConfig.get('scale.offset', 'zero'));

      var stackedMode = ['normal', 'grouped'].includes(_this.axisConfig.get('scale.mode'));
      if (stackedMode) {
        _this.stack = _this._stackNegAndPosVals;
      }
      return _this;
    }

    _createClass(Axis, [{
      key: '_stackNegAndPosVals',
      value: function _stackNegAndPosVals(data) {
        var cache = {};
        data.forEach(function (series) {
          series.forEach(function (value) {
            if (!cache[value.x]) cache[value.x] = [0, 0];
            value.y0 = cache[value.x][value.y < 0 ? 0 : 1];
            cache[value.x][value.y < 0 ? 0 : 1] += value.y;
          });
        });
        return data;
      }
    }, {
      key: 'render',
      value: function render() {
        var elSelector = this.axisConfig.get('elSelector');
        var rootEl = this.axisConfig.get('rootEl');
        _d2.default.select(rootEl).selectAll(elSelector).call(this.draw());
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var elSelector = this.axisConfig.get('elSelector');
        var rootEl = this.axisConfig.get('rootEl');
        (0, _jquery2.default)(rootEl).find(elSelector).find('svg').remove();
        this.axisTitle.destroy();
      }
    }, {
      key: 'getAxis',
      value: function getAxis(length) {
        var scale = this.axisScale.getScale(length);
        var position = this.axisConfig.get('position');
        var axisFormatter = this.axisConfig.get('labels.axisFormatter');

        return _d2.default.svg.axis().scale(scale).tickFormat(axisFormatter).ticks(this.tickScale(length)).orient(position);
      }
    }, {
      key: 'getScale',
      value: function getScale() {
        return this.axisScale.scale;
      }
    }, {
      key: 'addInterval',
      value: function addInterval(interval) {
        return this.axisScale.addInterval(interval);
      }
    }, {
      key: 'substractInterval',
      value: function substractInterval(interval) {
        return this.axisScale.substractInterval(interval);
      }
    }, {
      key: 'tickScale',
      value: function tickScale(length) {
        var yTickScale = _d2.default.scale.linear().clamp(true).domain([20, 40, 1000]).range([0, 3, 11]);

        return Math.ceil(yTickScale(length));
      }
    }, {
      key: 'getLength',
      value: function getLength(el) {
        if (this.axisConfig.isHorizontal()) {
          return (0, _jquery2.default)(el).width();
        } else {
          return (0, _jquery2.default)(el).height();
        }
      }
    }, {
      key: 'adjustSize',
      value: function adjustSize() {
        var config = this.axisConfig;
        var style = config.get('style');
        var chartEl = this.visConfig.get('el');
        var position = config.get('position');
        var axisPadding = 5;

        return function (selection) {
          var text = selection.selectAll('.tick text');
          var lengths = [];

          text.each(function textWidths() {
            var _this2 = this;

            lengths.push(function () {
              if (config.isHorizontal()) {
                return _d2.default.select(_this2.parentNode).node().getBBox().height;
              } else {
                return _d2.default.select(_this2.parentNode).node().getBBox().width;
              }
            }());
          });
          var length = lengths.length > 0 ? _lodash2.default.max(lengths) : 0;
          length += axisPadding;

          if (config.isHorizontal()) {
            selection.attr('height', Math.ceil(length));
            if (position === 'top') {
              selection.select('g').attr('transform', 'translate(0, ' + (length - parseInt(style.lineWidth)) + ')');
              selection.select('path').attr('transform', 'translate(1,0)');
            }
            if (config.get('type') === 'value') {
              var spacerNodes = (0, _jquery2.default)(chartEl).find('.y-axis-spacer-block-' + position);
              var elHeight = (0, _jquery2.default)(chartEl).find('.axis-wrapper-' + position).height();
              spacerNodes.height(elHeight);
            }
          } else {
            var axisWidth = Math.ceil(length);
            selection.attr('width', axisWidth);
            if (position === 'left') {
              selection.select('g').attr('transform', 'translate(' + axisWidth + ',0)');
            }
          }
        };
      }
    }, {
      key: 'validate',
      value: function validate() {
        if (this.axisConfig.isLogScale() && this.axisConfig.isPercentage()) {
          throw new _errors.VislibError('Can\'t mix percentage mode with log scale.');
        }
      }
    }, {
      key: 'draw',
      value: function draw() {
        var svgs = [];
        var self = this;
        var config = this.axisConfig;
        var style = config.get('style');

        return function (selection) {
          var n = selection[0].length;
          if (config.get('show') && self.axisTitle && ['left', 'top'].includes(config.get('position'))) {
            self.axisTitle.render(selection);
          }
          selection.each(function () {
            var el = this;
            var div = _d2.default.select(el);
            var width = (0, _jquery2.default)(el).width();
            var height = (0, _jquery2.default)(el).height();
            var length = self.getLength(el, n);

            self.validate();

            var axis = self.getAxis(length);

            if (config.get('show')) {
              var svg = div.append('svg').attr('width', width).attr('height', height);

              svgs.push(svg);

              var axisClass = self.axisConfig.isHorizontal() ? 'x' : 'y';
              svg.append('g').attr('class', axisClass + ' axis ' + config.get('id')).call(axis);

              var container = svg.select('g.axis').node();
              if (container) {
                svg.select('path').style('stroke', style.color).style('stroke-width', style.lineWidth).style('stroke-opacity', style.opacity);
                svg.selectAll('line').style('stroke', style.tickColor).style('stroke-width', style.tickWidth).style('stroke-opacity', style.opacity);
              }
              if (self.axisLabels) self.axisLabels.render(svg);
            }
          });

          if (self.axisTitle && ['right', 'bottom'].includes(config.get('position'))) {
            self.axisTitle.render(selection);
          }

          svgs.forEach(function (svg) {
            return svg.call(self.adjustSize());
          });
        };
      }
    }]);

    return Axis;
  }(ErrorHandler);

  return Axis;
}

/***/ }),
/* 944 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.VislibLibErrorHandlerProvider = VislibLibErrorHandlerProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _errors = __webpack_require__(37);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function VislibLibErrorHandlerProvider() {

  /**
   * Common errors shared between constructors
   *
   * @class ErrorHandler
   * @constructor
   */
  var ErrorHandler = function () {
    function ErrorHandler() {
      _classCallCheck(this, ErrorHandler);
    }

    /**
     * Validates the height and width are > 0
     * min size must be at least 1 px
     *
     * @method validateWidthandHeight
     * @param width {Number} HTMLElement width
     * @param height {Number} HTMLElement height
     * @returns {HTMLElement} HTML div with an error message
     */


    _createClass(ErrorHandler, [{
      key: 'validateWidthandHeight',
      value: function validateWidthandHeight(width, height) {
        var badWidth = _lodash2.default.isNaN(width) || width <= 0;
        var badHeight = _lodash2.default.isNaN(height) || height <= 0;

        if (badWidth || badHeight) {
          throw new _errors.ContainerTooSmall();
        }
      }
    }]);

    return ErrorHandler;
  }();

  return ErrorHandler;
}

/***/ }),
/* 945 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.VislibLibChartTitleProvider = VislibLibChartTitleProvider;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _error_handler = __webpack_require__(944);

var _tooltip = __webpack_require__(531);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function VislibLibChartTitleProvider(Private) {
  var ErrorHandler = Private(_error_handler.VislibLibErrorHandlerProvider);
  var Tooltip = Private(_tooltip.TooltipProvider);

  var ChartTitle = function (_ErrorHandler) {
    _inherits(ChartTitle, _ErrorHandler);

    function ChartTitle(visConfig) {
      _classCallCheck(this, ChartTitle);

      var _this = _possibleConstructorReturn(this, (ChartTitle.__proto__ || Object.getPrototypeOf(ChartTitle)).call(this));

      _this.el = visConfig.get('el');
      _this.tooltip = new Tooltip('chart-title', _this.el, function (d) {
        return '<p>' + _lodash2.default.escape(d.label) + '</p>';
      });
      return _this;
    }

    _createClass(ChartTitle, [{
      key: 'render',
      value: function render() {
        var el = _d2.default.select(this.el).select('.chart-title').node();
        var width = el ? el.clientWidth : 0;
        var height = el ? el.clientHeight : 0;

        return _d2.default.select(this.el).selectAll('.chart-title').call(this.draw(width, height));
      }
    }, {
      key: 'truncate',
      value: function truncate(size) {
        var self = this;

        return function (selection) {
          selection.each(function () {
            var text = _d2.default.select(this);
            var n = text[0].length;
            var maxWidth = size / n * 0.9;
            var length = this.getComputedTextLength();
            var str = void 0;
            var avg = void 0;
            var end = void 0;

            if (length > maxWidth) {
              str = text.text();
              avg = length / str.length;
              end = Math.floor(maxWidth / avg) - 5;
              str = str.substr(0, end) + '...';
              self.addMouseEvents(text);

              return text.text(str);
            }

            return text.text();
          });
        };
      }
    }, {
      key: 'addMouseEvents',
      value: function addMouseEvents(target) {
        if (this.tooltip) {
          return target.call(this.tooltip.render());
        }
      }
    }, {
      key: 'draw',
      value: function draw(width, height) {
        var self = this;

        return function (selection) {
          selection.each(function () {
            var div = _d2.default.select(this);
            var dataType = this.parentNode.__data__.rows ? 'rows' : 'columns';
            var size = dataType === 'rows' ? height : width;
            var txtHtOffset = 11;

            self.validateWidthandHeight(width, height);

            div.append('svg').attr('width', width).attr('height', height).append('text').attr('transform', function () {
              if (dataType === 'rows') {
                return 'translate(' + txtHtOffset + ',' + height / 2 + ')rotate(270)';
              }
              return 'translate(' + width / 2 + ',' + txtHtOffset + ')';
            }).attr('text-anchor', 'middle').text(function (d) {
              return d.label;
            });

            // truncate long chart titles
            div.selectAll('text').call(self.truncate(size));
          });
        };
      }
    }]);

    return ChartTitle;
  }(ErrorHandler);

  return ChartTitle;
}

/***/ }),
/* 946 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _saved_object_registry = __webpack_require__(134);

__webpack_require__(947);

_saved_object_registry.SavedObjectRegistryProvider.register(function (savedDashboards) {
  return savedDashboards;
});

/***/ }),
/* 947 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(3050);

var _modules = __webpack_require__(2);

var _saved_object_loader = __webpack_require__(355);

var _saved_object_registry = __webpack_require__(210);

var _module = _modules.uiModules.get('app/dashboard');

// Register this service with the saved object registry so it can be
// edited by the object editor.
_saved_object_registry.savedObjectManagementRegistry.register({
  service: 'savedDashboards',
  title: 'dashboards'
});

// This is the only thing that gets injected into controllers
_module.service('savedDashboards', function (SavedDashboard, kbnIndex, kbnUrl, $http, chrome) {
  return new _saved_object_loader.SavedObjectLoader(SavedDashboard, kbnIndex, kbnUrl, $http, chrome);
});

/***/ }),
/* 948 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _saved_object_registry = __webpack_require__(134);

__webpack_require__(535);

_saved_object_registry.SavedObjectRegistryProvider.register(function (savedSearches) {
  return savedSearches;
});

/***/ }),
/* 949 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _field_formats = __webpack_require__(64);

var _url = __webpack_require__(3052);

var _bytes = __webpack_require__(3053);

var _date = __webpack_require__(3055);

var _relative_date = __webpack_require__(3056);

var _duration = __webpack_require__(950);

var _ip = __webpack_require__(3057);

var _number = __webpack_require__(3058);

var _percent = __webpack_require__(3059);

var _string = __webpack_require__(3060);

var _source = __webpack_require__(3061);

var _color = __webpack_require__(3062);

var _truncate = __webpack_require__(3063);

var _boolean = __webpack_require__(3064);

_field_formats.RegistryFieldFormatsProvider.register(_url.createUrlFormat);
_field_formats.RegistryFieldFormatsProvider.register(_bytes.createBytesFormat);
_field_formats.RegistryFieldFormatsProvider.register(_date.createDateFormat);
_field_formats.RegistryFieldFormatsProvider.register(_relative_date.createRelativeDateFormat);
_field_formats.RegistryFieldFormatsProvider.register(_duration.createDurationFormat);
_field_formats.RegistryFieldFormatsProvider.register(_ip.createIpFormat);
_field_formats.RegistryFieldFormatsProvider.register(_number.createNumberFormat);
_field_formats.RegistryFieldFormatsProvider.register(_percent.createPercentFormat);
_field_formats.RegistryFieldFormatsProvider.register(_string.createStringFormat);
_field_formats.RegistryFieldFormatsProvider.register(_source.createSourceFormat);
_field_formats.RegistryFieldFormatsProvider.register(_color.createColorFormat);
_field_formats.RegistryFieldFormatsProvider.register(_truncate.createTruncateFormat);
_field_formats.RegistryFieldFormatsProvider.register(_boolean.createBoolFormat);

/***/ }),
/* 950 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.createDurationFormat = createDurationFormat;

var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ratioToSeconds = {
  picoseconds: 0.000000000001,
  nanoseconds: 0.000000001,
  microseconds: 0.000001
};
var HUMAN_FRIENDLY = 'humanize';
var DEFAULT_OUTPUT_PRECISION = 2;
var DEFAULT_INPUT_FORMAT = { text: 'Seconds', kind: 'seconds' };
var inputFormats = [{ text: 'Picoseconds', kind: 'picoseconds' }, { text: 'Nanoseconds', kind: 'nanoseconds' }, { text: 'Microseconds', kind: 'microseconds' }, { text: 'Milliseconds', kind: 'milliseconds' }, DEFAULT_INPUT_FORMAT, { text: 'Minutes', kind: 'minutes' }, { text: 'Hours', kind: 'hours' }, { text: 'Days', kind: 'days' }, { text: 'Weeks', kind: 'weeks' }, { text: 'Months', kind: 'months' }, { text: 'Years', kind: 'years' }];
var DEFAULT_OUTPUT_FORMAT = { text: 'Human Readable', method: 'humanize' };
var outputFormats = [DEFAULT_OUTPUT_FORMAT, { text: 'Milliseconds', method: 'asMilliseconds' }, { text: 'Seconds', method: 'asSeconds' }, { text: 'Minutes', method: 'asMinutes' }, { text: 'Hours', method: 'asHours' }, { text: 'Days', method: 'asDays' }, { text: 'Weeks', method: 'asWeeks' }, { text: 'Months', method: 'asMonths' }, { text: 'Years', method: 'asYears' }];

function parseInputAsDuration(val, inputFormat) {
  var ratio = ratioToSeconds[inputFormat] || 1;
  var kind = inputFormat in ratioToSeconds ? 'seconds' : inputFormat;
  return _moment2.default.duration(val * ratio, kind);
}

function createDurationFormat(FieldFormat) {
  var _class, _temp;

  return _temp = _class = function (_FieldFormat) {
    _inherits(DurationFormat, _FieldFormat);

    function DurationFormat() {
      _classCallCheck(this, DurationFormat);

      return _possibleConstructorReturn(this, (DurationFormat.__proto__ || Object.getPrototypeOf(DurationFormat)).apply(this, arguments));
    }

    _createClass(DurationFormat, [{
      key: 'isHuman',
      value: function isHuman() {
        return this.param('outputFormat') === HUMAN_FRIENDLY;
      }
    }, {
      key: 'getParamDefaults',
      value: function getParamDefaults() {
        return {
          inputFormat: DEFAULT_INPUT_FORMAT.kind,
          outputFormat: DEFAULT_OUTPUT_FORMAT.method,
          outputPrecision: DEFAULT_OUTPUT_PRECISION
        };
      }
    }, {
      key: '_convert',
      value: function _convert(val) {
        var inputFormat = this.param('inputFormat');
        var outputFormat = this.param('outputFormat');
        var outputPrecision = this.param('outputPrecision');
        var human = this.isHuman();
        var prefix = val < 0 && human ? 'minus ' : '';
        var duration = parseInputAsDuration(val, inputFormat);
        var formatted = duration[outputFormat]();
        var precise = human ? formatted : formatted.toFixed(outputPrecision);
        return prefix + precise;
      }
    }]);

    return DurationFormat;
  }(FieldFormat), _class.id = 'duration', _class.title = 'Duration', _class.fieldType = 'number', _class.inputFormats = inputFormats, _class.outputFormats = outputFormats, _temp;
}

/***/ }),
/* 951 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.noWhiteSpace = noWhiteSpace;
var TAGS_WITH_WS = />\s+</g;

/**
 * Remove all of the whitespace between html tags
 * so that inline elements don't have extra spaces.
 *
 * If you have inline elements (span, a, em, etc.) and any
 * amount of whitespace around them in your markup, then the
 * browser will push them appart. This is ugly in certain
 * senarios and is only fixed by removing the whitespace
 * from the html in the first place (or ugly css hacks).
 *
 * @param  {string} html - the html to modify
 * @return {string} - modified html
 */
function noWhiteSpace(html) {
  return html.replace(TAGS_WITH_WS, '><');
}

/***/ }),
/* 952 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var DEFAULT_COLOR = exports.DEFAULT_COLOR = {
  range: Number.NEGATIVE_INFINITY + ':' + Number.POSITIVE_INFINITY,
  regex: '<insert regex>',
  text: '#000000',
  background: '#ffffff'
};

/***/ }),
/* 953 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _saved_object_registry = __webpack_require__(134);

__webpack_require__(358);

_saved_object_registry.SavedObjectRegistryProvider.register(function (savedVisualizations) {
  return savedVisualizations;
});

/***/ }),
/* 954 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * @name SavedVis
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * @extends SavedObject.
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * NOTE: It's a type of SavedObject, but specific to visualizations.
                                                                                                                                                                                                                                                                               */

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _vis = __webpack_require__(955);

var _modules = __webpack_require__(2);

var _vis_update_state = __webpack_require__(3141);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_modules.uiModules.get('app/visualize').factory('SavedVis', function (config, $injector, courier, Promise, savedSearches, Private) {
  var Vis = Private(_vis.VisProvider);

  _lodash2.default.class(SavedVis).inherits(courier.SavedObject);
  function SavedVis(opts) {
    var self = this;
    opts = opts || {};
    if ((typeof opts === 'undefined' ? 'undefined' : _typeof(opts)) !== 'object') opts = { id: opts };

    SavedVis.Super.call(self, {
      type: SavedVis.type,
      mapping: SavedVis.mapping,
      searchSource: SavedVis.searchSource,

      id: opts.id,
      indexPattern: opts.indexPattern,
      defaults: {
        title: 'New Visualization',
        visState: function () {
          if (!opts.type) return null;
          var def = {};
          def.type = opts.type;
          return def;
        }(),
        uiStateJSON: '{}',
        description: '',
        savedSearchId: opts.savedSearchId,
        version: 1
      },

      afterESResp: this._afterEsResp
    });
  }

  SavedVis.type = 'visualization';

  SavedVis.mapping = {
    title: 'text',
    visState: 'json',
    uiStateJSON: 'text',
    description: 'text',
    savedSearchId: 'keyword',
    version: 'integer'
  };

  // Order these fields to the top, the rest are alphabetical
  SavedVis.fieldOrder = ['title', 'description'];

  SavedVis.searchSource = true;

  SavedVis.prototype._afterEsResp = function () {
    var self = this;

    return self._getLinkedSavedSearch().then(function () {
      self.searchSource.size(0);

      return self.vis ? self._updateVis() : self._createVis();
    }).then(function () {
      self.searchSource.onRequestStart(function (searchSource, searchRequest) {
        return self.vis.onSearchRequestStart(searchSource, searchRequest);
      });

      self.searchSource.aggs(function () {
        return self.vis.aggs.toDsl();
      });

      return self;
    });
  };

  SavedVis.prototype._getLinkedSavedSearch = Promise.method(function () {
    var self = this;
    var linkedSearch = !!self.savedSearchId;
    var current = self.savedSearch;

    if (linkedSearch && current && current.id === self.savedSearchId) {
      return;
    }

    if (self.savedSearch) {
      self.searchSource.inherits(self.savedSearch.searchSource.getParent());
      self.savedSearch.destroy();
      self.savedSearch = null;
    }

    if (linkedSearch) {
      return savedSearches.get(self.savedSearchId).then(function (savedSearch) {
        self.savedSearch = savedSearch;
        self.searchSource.inherits(self.savedSearch.searchSource);
      });
    }
  });

  SavedVis.prototype._createVis = function () {
    var self = this;

    self.visState = (0, _vis_update_state.updateOldState)(self.visState);

    // visState doesn't yet exist when importing a visualization, so we can't
    // assume that exists at this point. If it does exist, then we're not
    // importing a visualization, so we want to sync the title.
    if (self.visState) {
      self.visState.title = self.title;
    }
    self.vis = new Vis(self.searchSource.get('index'), self.visState);

    return self.vis;
  };

  SavedVis.prototype._updateVis = function () {
    var self = this;

    self.vis.indexPattern = self.searchSource.get('index');
    self.visState.title = self.title;
    self.vis.setState(self.visState);
  };

  return SavedVis;
});

/***/ }),
/* 955 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _vis = __webpack_require__(3065);

Object.defineProperty(exports, 'VisProvider', {
  enumerable: true,
  get: function get() {
    return _vis.VisProvider;
  }
});

/***/ }),
/* 956 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesMetricsPercentilesProvider = AggTypesMetricsPercentilesProvider;

var _ordinal_suffix = __webpack_require__(3071);

var _percentiles = __webpack_require__(3072);

var _percentiles2 = _interopRequireDefault(_percentiles);

__webpack_require__(957);

var _metric_agg_type = __webpack_require__(40);

var _get_response_agg_config_class = __webpack_require__(538);

var _percentiles_get_value = __webpack_require__(958);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function AggTypesMetricsPercentilesProvider(Private) {
  var MetricAggType = Private(_metric_agg_type.AggTypesMetricsMetricAggTypeProvider);
  var getResponseAggConfigClass = Private(_get_response_agg_config_class.AggTypesMetricsGetResponseAggConfigClassProvider);

  // required by the percentiles editor

  var valueProps = {
    makeLabel: function makeLabel() {
      var label = this.params.customLabel || this.getFieldDisplayName();
      return (0, _ordinal_suffix.ordinalSuffix)(this.key) + ' percentile of ' + label;
    }
  };

  return new MetricAggType({
    name: 'percentiles',
    title: 'Percentiles',
    makeLabel: function makeLabel(agg) {
      return 'Percentiles of ' + agg.getFieldDisplayName();
    },
    params: [{
      name: 'field',
      filterFieldTypes: 'number'
    }, {
      name: 'percents',
      editor: _percentiles2.default,
      default: [1, 5, 25, 50, 75, 95, 99]
    }, {
      write: function write(agg, output) {
        output.params.keyed = false;
      }
    }],
    getResponseAggs: function getResponseAggs(agg) {
      var ValueAggConfig = getResponseAggConfigClass(agg, valueProps);

      return agg.params.percents.map(function (percent) {
        return new ValueAggConfig(percent);
      });
    },
    getValue: _percentiles_get_value.getPercentileValue
  });
}

/***/ }),
/* 957 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(3073);

/***/ }),
/* 958 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPercentileValue = getPercentileValue;

var _lodash = __webpack_require__(1);

function getPercentileValue(agg, bucket) {
  var values = bucket[agg.parentId] && bucket[agg.parentId].values;
  var percentile = (0, _lodash.find)(values, function (value) {
    return agg.key === value.key;
  });
  return percentile ? percentile.value : NaN;
}

/***/ }),
/* 959 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var safeMakeLabel = exports.safeMakeLabel = function safeMakeLabel(agg) {
  try {
    return agg.makeLabel();
  } catch (e) {
    return '- agg not valid -';
  }
};

/***/ }),
/* 960 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesBucketsIntervalOptionsProvider = AggTypesBucketsIntervalOptionsProvider;
function AggTypesBucketsIntervalOptionsProvider() {
  return [{
    display: 'Auto',
    val: 'auto',
    enabled: function enabled(agg) {
      // not only do we need a time field, but the selected field needs
      // to be the time field. (see #3028)
      return agg.fieldIsTimeField();
    }
  }, {
    display: 'Millisecond',
    val: 'ms'
  }, {
    display: 'Second',
    val: 's'
  }, {
    display: 'Minute',
    val: 'm'
  }, {
    display: 'Hourly',
    val: 'h'
  }, {
    display: 'Daily',
    val: 'd'
  }, {
    display: 'Weekly',
    val: 'w'
  }, {
    display: 'Monthly',
    val: 'M'
  }, {
    display: 'Yearly',
    val: 'y'
  }, {
    display: 'Custom',
    val: 'custom'
  }];
}

/***/ }),
/* 961 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dateRange = undefined;

var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var dateRange = exports.dateRange = {
  toString: function toString(range, format) {
    if (!range.from) {
      return 'Before ' + format(range.to);
    } else if (!range.to) {
      return 'After ' + format(range.from);
    } else {
      return format(range.from) + ' to ' + format(range.to);
    }
  },
  parse: function parse(rangeString, format) {
    var chunks = rangeString.split(' to ');
    if (chunks.length === 2) return { from: (0, _moment2.default)(chunks[0], format), to: (0, _moment2.default)(chunks[1], format) };

    chunks = rangeString.split('Before ');
    if (chunks.length === 2) return { to: (0, _moment2.default)(chunks[1], format) };

    chunks = rangeString.split('After ');
    if (chunks.length === 2) return { from: (0, _moment2.default)(chunks[1], format) };

    throw new Error('Error attempting to parse date range: ' + rangeString);
  }
};

/***/ }),
/* 962 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesBucketsCreateFilterTermsProvider = AggTypesBucketsCreateFilterTermsProvider;

var _phrase = __webpack_require__(175);

function AggTypesBucketsCreateFilterTermsProvider() {
  return function (aggConfig, key) {
    return (0, _phrase.buildPhraseFilter)(aggConfig.params.field, key, aggConfig.vis.indexPattern);
  };
}

/***/ }),
/* 963 */
/***/ (function(module, exports) {

module.exports = "<div>\n  <div class=\"vis-editor-agg-form-row\">\n    <div ng-if=\"agg.type.params.byName.order\" class=\"form-group\">\n      <label for=\"visEditorOrderByOrder{{agg.id}}\">Order</label>\n      <select\n        id=\"visEditorOrderByOrder{{agg.id}}\"\n        name=\"order\"\n        ng-model=\"agg.params.order\"\n        required\n        ng-options=\"opt as opt.display for opt in aggParam.options\"\n        class=\"form-control\">\n      </select>\n    </div>\n    <div class=\"form-group\">\n      <label for=\"visEditorOrderBySize{{agg.id}}\">Size</label>\n      <input\n        id=\"visEditorOrderBySize{{agg.id}}\"\n        name=\"size\"\n        ng-model=\"agg.params.size\"\n        required\n        class=\"form-control\"\n        type=\"number\"\n        min=\"1\"\n      >\n    </div>\n  </div>\n  <div class=\"vis-editor-agg-form-row\">\n    <div class=\"form-group\">\n      <label>\n        <input type=\"checkbox\"\n               class=\"kuiCheckBox\"\n               name=\"showOther\"\n               ng-model=\"agg.params.otherBucket\">\n        Group other values in separate bucket\n        <kbn-info info=\"Values not in the top N are grouped in this bucket.  To include documents with missing values, enable 'Show missing values'.\"></kbn-info>\n      </label>\n    </div>\n  </div>\n  <div class=\"vis-editor-agg-form-row\" ng-if=\"agg.params.otherBucket\">\n    <div class=\"form-group\">\n      <label>\n        Label for other bucket\n      </label>\n      <div>\n        <input\n          type=\"text\"\n          ng-model=\"agg.params.otherBucketLabel\"\n          class=\"form-control kuiSideBarInput\"\n        >\n      </div>\n    </div>\n  </div>\n  <div class=\"vis-editor-agg-form-row\">\n    <div class=\"form-group\">\n      <label>\n        <input type=\"checkbox\"\n               class=\"kuiCheckBox\"\n               name=\"showMissing\"\n               ng-model=\"agg.params.missingBucket\">\n        Show missing values\n        <kbn-info info=\"When enabled, include documents with missing values in the search.  If this bucket is in the top N, it appears in the chart.  If not in the top N, and you enable 'Group other values in separate bucket', Elasticsearch adds the missing values to the 'other' bucket.\"></kbn-info>\n      </label>\n    </div>\n  </div>\n  <div class=\"vis-editor-agg-form-row\" ng-show=\"agg.params.missingBucket\">\n    <div class=\"form-group\">\n      <label>\n        Label for missing values\n      </label>\n      <div>\n        <input\n          type=\"text\"\n          ng-model=\"agg.params.missingBucketLabel\"\n          class=\"form-control kuiSideBarInput\"\n        >\n      </div>\n    </div>\n  </div>\n</div>\n"

/***/ }),
/* 964 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UtilsBrushEventProvider = UtilsBrushEventProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

var _range = __webpack_require__(117);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function UtilsBrushEventProvider(timefilter) {
  return function ($state) {
    return function (event) {
      if (!event.data.xAxisField) {
        return;
      }

      var isDate = event.data.xAxisField.type === 'date';
      var isNumber = event.data.xAxisField.type === 'number';

      if (isDate && event.data.xAxisField.name === event.data.indexPattern.timeFieldName) {
        setTimefilter();
      } else if (isDate || isNumber) {
        setRange();
      }

      function setTimefilter() {
        var from = (0, _moment2.default)(event.range[0]);
        var to = (0, _moment2.default)(event.range[1]);

        if (to - from === 0) return;

        timefilter.time.from = from;
        timefilter.time.to = to;
        timefilter.time.mode = 'absolute';
      }

      function setRange() {
        if (event.range.length <= 1) return;

        var existingFilter = $state.filters.find(function (filter) {
          return filter.meta && filter.meta.key === event.data.xAxisField.name;
        });

        var min = event.range[0];
        var max = event.range[event.range.length - 1];
        var range = void 0;
        if (isDate) {
          range = {
            gte: (0, _moment2.default)(min).valueOf(),
            lt: (0, _moment2.default)(max).valueOf(),
            format: 'epoch_millis'
          };
        } else {
          range = {
            gte: min,
            lt: max
          };
        }

        if (_lodash2.default.has(existingFilter, 'range')) {
          existingFilter.range[event.data.xAxisField.name] = range;
        } else if (_lodash2.default.has(existingFilter, 'script.script.params.gte') && _lodash2.default.has(existingFilter, 'script.script.params.lt')) {
          existingFilter.script.script.params.gte = min;
          existingFilter.script.script.params.lt = max;
        } else {
          var newFilter = (0, _range.buildRangeFilter)(event.data.xAxisField, range, event.data.indexPattern, event.data.xAxisFormatter);
          $state.$newFilters = [newFilter];
        }
      }
    };
  };
}

/***/ }),
/* 965 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ParamComponent = ParamComponent;
exports.UrlParams = UrlParams;
var _ = __webpack_require__(1);
var engine = __webpack_require__(140);

function ParamComponent(name, parent, description) {
  engine.ConstantComponent.call(this, name, parent);
  this.description = description;
}

ParamComponent.prototype = _.create(engine.ConstantComponent.prototype, { "constructor": ParamComponent });

(function (cls) {
  cls.getTerms = function () {
    var t = { name: this.name };
    if (this.description === "__flag__") {
      t.meta = "flag";
    } else {
      t.meta = "param";
      t.insert_value = this.name + "=";
    }
    return [t];
  };
})(ParamComponent.prototype);

function UrlParams(description, defaults) {
  // This is not really a component, just a handy container to make iteration logic simpler
  this.rootComponent = new engine.SharedComponent("ROOT");
  if (_.isUndefined(defaults)) {
    defaults = {
      "pretty": "__flag__",
      "format": ["json", "yaml"],
      "filter_path": ""
    };
  }
  description = _.clone(description || {});
  _.defaults(description, defaults);
  _.each(description, function (p_description, param) {
    var component = new ParamComponent(param, this.rootComponent, p_description);
    if (Array.isArray(p_description)) {
      new engine.ListComponent(param, p_description, component);
    } else if (p_description === "__flag__") {
      new engine.ListComponent(param, ["true", "false"], component);
    }
  }, this);
}

(function (cls) {

  cls.getTopLevelComponents = function () {
    return this.rootComponent.next;
  };
})(UrlParams.prototype);

/***/ }),
/* 966 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.detectCURL = detectCURL;
exports.parseCURL = parseCURL;
function detectCURLinLine(line) {
  // returns true if text matches a curl request
  return line.match(/^\s*?curl\s+(-X[A-Z]+)?\s*['"]?.*?['"]?(\s*$|\s+?-d\s*?['"])/);
}

function detectCURL(text) {
  // returns true if text matches a curl request
  if (!text) return false;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = text.split("\n")[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var line = _step.value;

      if (detectCURLinLine(line)) {
        return true;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return false;
}

function parseCURL(text) {
  var state = 'NONE';
  var out = [];
  var body = [];
  var line = '';
  var lines = text.trim().split("\n");
  var matches;

  var EmptyLine = /^\s*$/;
  var Comment = /^\s*(?:#|\/{2,})(.*)\n?$/;
  var ExecutionComment = /^\s*#!/;
  var ClosingSingleQuote = /^([^']*)'/;
  var ClosingDoubleQuote = /^((?:[^\\"]|\\.)*)"/;
  var EscapedQuotes = /^((?:[^\\"']|\\.)+)/;

  var LooksLikeCurl = /^\s*curl\s+/;
  var CurlVerb = /-X ?(GET|HEAD|POST|PUT|DELETE)/;

  var HasProtocol = /[\s"']https?:\/\//;
  var CurlRequestWithProto = /[\s"']https?:\/\/[^\/ ]+\/+([^\s"']+)/;
  var CurlRequestWithoutProto = /[\s"'][^\/ ]+\/+([^\s"']+)/;
  var CurlData = /^.+\s(--data|-d)\s*/;
  var SenseLine = /^\s*(GET|HEAD|POST|PUT|DELETE)\s+\/?(.+)/;

  if (lines.length > 0 && ExecutionComment.test(lines[0])) {
    lines.shift();
  }

  function nextLine() {
    if (line.length > 0) {
      return true;
    }
    if (lines.length == 0) {
      return false;
    }
    line = lines.shift().replace(/[\r\n]+/g, "\n") + "\n";
    return true;
  }

  function unescapeLastBodyEl() {
    var str = body.pop().replace(/\\([\\"'])/g, "$1");
    body.push(str);
  }

  // Is the next char a single or double quote?
  // If so remove it
  function detectQuote() {
    if (line.substr(0, 1) == "'") {
      line = line.substr(1);
      state = 'SINGLE_QUOTE';
    } else if (line.substr(0, 1) == '"') {
      line = line.substr(1);
      state = 'DOUBLE_QUOTE';
    } else {
      state = 'UNQUOTED';
    }
  }

  // Body is finished - append to output with final LF
  function addBodyToOut() {
    if (body.length > 0) {
      out.push(body.join(""));
      body = [];
    }
    state = 'LF';
    out.push("\n");
  }

  // If the pattern matches, then the state is about to change,
  // so add the capture to the body and detect the next state
  // Otherwise add the whole line
  function consumeMatching(pattern) {
    var matches = line.match(pattern);
    if (matches) {
      body.push(matches[1]);
      line = line.substr(matches[0].length);
      detectQuote();
    } else {
      body.push(line);
      line = '';
    }
  }

  function parseCurlLine() {
    var verb = 'GET';
    var request = '';
    var matches;
    if (matches = line.match(CurlVerb)) {
      verb = matches[1];
    }

    // JS regexen don't support possesive quantifiers, so
    // we need two distinct patterns
    var pattern = HasProtocol.test(line) ? CurlRequestWithProto : CurlRequestWithoutProto;

    if (matches = line.match(pattern)) {
      request = matches[1];
    }

    out.push(verb + ' /' + request + "\n");

    if (matches = line.match(CurlData)) {
      line = line.substr(matches[0].length);
      detectQuote();
      if (EmptyLine.test(line)) {
        line = '';
      }
    } else {
      state = 'NONE';
      line = '';
      out.push('');
    }
  }

  while (nextLine()) {

    if (state == 'SINGLE_QUOTE') {
      consumeMatching(ClosingSingleQuote);
    } else if (state == 'DOUBLE_QUOTE') {
      consumeMatching(ClosingDoubleQuote);
      unescapeLastBodyEl();
    } else if (state == 'UNQUOTED') {
      consumeMatching(EscapedQuotes);
      if (body.length) {
        unescapeLastBodyEl();
      }
      if (state == 'UNQUOTED') {
        addBodyToOut();
        line = '';
      }
    }

    // the BODY state (used to match the body of a Sense request)
    // can be terminated early if it encounters
    // a comment or an empty line
    else if (state == 'BODY') {
        if (Comment.test(line) || EmptyLine.test(line)) {
          addBodyToOut();
        } else {
          body.push(line);
          line = '';
        }
      } else if (EmptyLine.test(line)) {
        if (state != 'LF') {
          out.push("\n");
          state = 'LF';
        }
        line = '';
      } else if (matches = line.match(Comment)) {
        out.push("#" + matches[1] + "\n");
        state = 'NONE';
        line = '';
      } else if (LooksLikeCurl.test(line)) {
        parseCurlLine();
      } else if (matches = line.match(SenseLine)) {
        out.push(matches[1] + ' /' + matches[2] + "\n");
        line = '';
        state = 'BODY';
      }

      // Nothing else matches, so output with a prefix of !!! for debugging purposes
      else {
          out.push('### ' + line);
          line = '';
        }
  }

  addBodyToOut();
  return out.join('').trim();
}

/***/ }),
/* 967 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var MODE = {
  REQUEST_START: 2,
  IN_REQUEST: 4,
  MULTI_DOC_CUR_DOC_END: 8,
  REQUEST_END: 16,
  BETWEEN_REQUESTS: 32

};

function RowParser(editor) {
  var defaultEditor = editor;

  this.getRowParseMode = function (row) {
    if (row == null || typeof row == "undefined") {
      row = editor.getCursorPosition().row;
    }

    var session = editor.getSession();
    if (row >= session.getLength() || row < 0) {
      return MODE.BETWEEN_REQUESTS;
    }
    var mode = session.getState(row);
    if (!mode) {
      return MODE.BETWEEN_REQUESTS;
    } // shouldn't really happen

    if (mode !== "start") {
      return MODE.IN_REQUEST;
    }
    var line = (session.getLine(row) || "").trim();
    if (!line || line[0] === '#') {
      return MODE.BETWEEN_REQUESTS;
    } // empty line or a comment waiting for a new req to start

    if (line.indexOf("}", line.length - 1) >= 0) {
      // check for a multi doc request (must start a new json doc immediately after this one end.
      row++;
      if (row < session.getLength()) {
        line = (session.getLine(row) || "").trim();
        if (line.indexOf("{") === 0) {
          // next line is another doc in a multi doc
          return MODE.MULTI_DOC_CUR_DOC_END | MODE.IN_REQUEST;
        }
      }
      return MODE.REQUEST_END | MODE.MULTI_DOC_CUR_DOC_END; // end of request
    }

    // check for single line requests
    row++;
    if (row >= session.getLength()) {
      return MODE.REQUEST_START | MODE.REQUEST_END;
    }
    line = (session.getLine(row) || "").trim();
    if (line.indexOf("{") !== 0) {
      // next line is another request
      return MODE.REQUEST_START | MODE.REQUEST_END;
    }

    return MODE.REQUEST_START;
  };

  this.rowPredicate = function (row, editor, value) {
    var mode = this.getRowParseMode(row, editor);
    return (mode & value) > 0;
  };

  this.isEndRequestRow = function (row, _e) {
    var editor = _e || defaultEditor;
    return this.rowPredicate(row, editor, MODE.REQUEST_END);
  };

  this.isRequestEdge = function (row, _e) {
    var editor = _e || defaultEditor;
    return this.rowPredicate(row, editor, MODE.REQUEST_END | MODE.REQUEST_START);
  };

  this.isStartRequestRow = function (row, _e) {
    var editor = _e || defaultEditor;
    return this.rowPredicate(row, editor, MODE.REQUEST_START);
  };

  this.isInBetweenRequestsRow = function (row, _e) {
    var editor = _e || defaultEditor;
    return this.rowPredicate(row, editor, MODE.BETWEEN_REQUESTS);
  };

  this.isInRequestsRow = function (row, _e) {
    var editor = _e || defaultEditor;
    return this.rowPredicate(row, editor, MODE.IN_REQUEST);
  };

  this.isMultiDocDocEndRow = function (row, _e) {
    var editor = _e || defaultEditor;
    return this.rowPredicate(row, editor, MODE.MULTI_DOC_CUR_DOC_END);
  };

  this.isEmptyToken = function (tokenOrTokenIter) {
    var token = tokenOrTokenIter && tokenOrTokenIter.getCurrentToken ? tokenOrTokenIter.getCurrentToken() : tokenOrTokenIter;
    return !token || token.type == "whitespace";
  };

  this.isUrlOrMethodToken = function (tokenOrTokenIter) {
    var t = tokenOrTokenIter.getCurrentToken ? tokenOrTokenIter.getCurrentToken() : tokenOrTokenIter;
    return t && t.type && (t.type == "method" || t.type.indexOf("url") === 0);
  };

  this.nextNonEmptyToken = function (tokenIter) {
    var t = tokenIter.stepForward();
    while (t && this.isEmptyToken(t)) {
      t = tokenIter.stepForward();
    }return t;
  };

  this.prevNonEmptyToken = function (tokenIter) {
    var t = tokenIter.stepBackward();
    // empty rows return null token.
    while ((t || tokenIter.getCurrentTokenRow() > 0) && this.isEmptyToken(t)) {
      t = tokenIter.stepBackward();
    }return t;
  };
}

RowParser.prototype.MODE = MODE;

exports.default = RowParser;
module.exports = exports["default"];

/***/ }),
/* 968 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(51).require;


/***/ }),
/* 969 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScriptHighlightRules = ScriptHighlightRules;

var ace = __webpack_require__(51);
var oop = ace.require("ace/lib/oop");
var TextHighlightRules = ace.require("ace/mode/text_highlight_rules").TextHighlightRules;

var painlessKeywords = "def|int|long|byte|String|float|double|char|null|if|else|while|do|for|continue|break|new|try|catch|throw|this|instanceof|return|ctx";

function ScriptHighlightRules() {
  this.name = "ScriptHighlightRules";
  this.$rules = {
    "start": [{
      token: "script.comment",
      regex: "\\/\\/.*$"
    }, {
      token: "script.string.regexp",
      regex: "[/](?:(?:\\[(?:\\\\]|[^\\]])+\\])|(?:\\\\/|[^\\]/]))*[/]\\w*\\s*(?=[).,;]|$)"
    }, {
      token: "script.string", // single line
      regex: "['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']"
    }, {
      token: "script.constant.numeric", // hex
      regex: "0[xX][0-9a-fA-F]+\\b"
    }, {
      token: "script.constant.numeric", // float
      regex: "[+-]?\\d+(?:(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)?\\b"
    }, {
      token: "script.constant.language.boolean",
      regex: "(?:true|false)\\b"
    }, {
      token: "script.keyword",
      regex: painlessKeywords
    }, {
      token: "script.text",
      regex: "[a-zA-Z_$][a-zA-Z0-9_$]*\\b"
    }, {
      token: "script.keyword.operator",
      regex: "\\?\\.|\\*\\.|=~|==~|!|%|&|\\*|\\-\\-|\\-|\\+\\+|\\+|~|===|==|=|!=|!==|<=|>=|<<=|>>=|>>>=|<>|<|>|->|!|&&|\\|\\||\\?\\:|\\*=|%=|\\+=|\\-=|&=|\\^=|\\b(?:in|instanceof|new|typeof|void)"
    }, {
      token: "script.lparen",
      regex: "[[({]"
    }, {
      token: "script.rparen",
      regex: "[\\])}]"
    }, {
      token: "script.text",
      regex: "\\s+"
    }]
  };
}

oop.inherits(ScriptHighlightRules, TextHighlightRules);

/***/ }),
/* 970 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addToRules = addToRules;
var _ = __webpack_require__(1);
var ScriptHighlightRules = __webpack_require__(969).ScriptHighlightRules;

var jsonRules = function jsonRules(root) {
  root = root ? root : "json";
  var rules = {};
  rules[root] = [{
    token: ["variable", "whitespace", "ace.punctuation.colon", "whitespace", "punctuation.start_triple_quote"],
    regex: '("script"|"inline")(\\s*?)(:)(\\s*?)(""")',
    next: "script-start",
    merge: false,
    push: true
  }, {
    token: "variable", // single line
    regex: '["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]\\s*(?=:)'
  }, {
    token: "punctuation.start_triple_quote",
    regex: '"""',
    next: "string_literal",
    merge: false,
    push: true
  }, {
    token: "string", // single line
    regex: '["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]'
  }, {
    token: "constant.numeric", // hex
    regex: "0[xX][0-9a-fA-F]+\\b"
  }, {
    token: "constant.numeric", // float
    regex: "[+-]?\\d+(?:(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)?\\b"
  }, {
    token: "constant.language.boolean",
    regex: "(?:true|false)\\b"
  }, {
    token: "invalid.illegal", // single quoted strings are not allowed
    regex: "['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']"
  }, {
    token: "invalid.illegal", // comments are not allowed
    regex: "\\/\\/.*$"
  }, {
    token: "paren.lparen",
    merge: false,
    regex: "{",
    next: root,
    push: true
  }, {
    token: "paren.lparen",
    merge: false,
    regex: "[[(]"
  }, {
    token: "paren.rparen",
    merge: false,
    regex: "[\\])]"
  }, {
    token: "paren.rparen",
    regex: "}",
    merge: false,
    next: "pop"
  }, {
    token: "punctuation.comma",
    regex: ","
  }, {
    token: "punctuation.colon",
    regex: ":"
  }, {
    token: "whitespace",
    regex: "\\s+"
  }, {
    token: "text",
    regex: ".+?"
  }];
  rules["string_literal"] = [{
    token: "punctuation.end_triple_quote",
    regex: '"""',
    next: "pop"
  }, {
    token: "multi_string",
    regex: "."
  }];
  return rules;
};

function addToRules(otherRules, embedUnder) {
  otherRules.$rules = _.defaultsDeep(otherRules.$rules, jsonRules(embedUnder));
  otherRules.embedRules(ScriptHighlightRules, "script-", [{
    token: "punctuation.end_triple_quote",
    regex: '"""',
    next: "pop"
  }]);
}

/***/ }),
/* 971 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (editor) {
  var resize = editor.resize;
  var throttledResize = (0, _lodash.throttle)(function () {

    resize.call(editor);

    // Keep current top line in view when resizing to avoid losing user context
    var userRow = (0, _lodash.get)(throttledResize, 'topRow', 0);
    if (userRow !== 0) {
      editor.renderer.scrollToLine(userRow, false, false, function () {});
    }
  }, 35);
  return throttledResize;
};

var _lodash = __webpack_require__(1);

module.exports = exports['default'];

/***/ }),
/* 972 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OutputJsonHighlightRules = OutputJsonHighlightRules;
var ace = __webpack_require__(51);
__webpack_require__(362);
var x_json = __webpack_require__(970);

var oop = ace.require("ace/lib/oop");
var JsonHighlightRules = ace.require("ace/mode/json_highlight_rules").JsonHighlightRules;

function OutputJsonHighlightRules() {

  this.$rules = {};

  x_json.addToRules(this, 'start');

  this.$rules.start.unshift({
    "token": "warning",
    "regex": "#!.*$"
  }, {
    "token": "comment",
    "regex": "#.*$"
  });

  if (this.constructor === OutputJsonHighlightRules) {
    this.normalizeRules();
  }
}

oop.inherits(OutputJsonHighlightRules, JsonHighlightRules);

/***/ }),
/* 973 */,
/* 974 */,
/* 975 */,
/* 976 */,
/* 977 */,
/* 978 */,
/* 979 */,
/* 980 */,
/* 981 */,
/* 982 */,
/* 983 */,
/* 984 */,
/* 985 */,
/* 986 */,
/* 987 */,
/* 988 */,
/* 989 */,
/* 990 */,
/* 991 */,
/* 992 */,
/* 993 */,
/* 994 */,
/* 995 */,
/* 996 */,
/* 997 */,
/* 998 */,
/* 999 */,
/* 1000 */,
/* 1001 */,
/* 1002 */,
/* 1003 */,
/* 1004 */,
/* 1005 */,
/* 1006 */,
/* 1007 */,
/* 1008 */,
/* 1009 */,
/* 1010 */,
/* 1011 */,
/* 1012 */,
/* 1013 */,
/* 1014 */,
/* 1015 */,
/* 1016 */,
/* 1017 */,
/* 1018 */,
/* 1019 */,
/* 1020 */,
/* 1021 */,
/* 1022 */,
/* 1023 */,
/* 1024 */,
/* 1025 */,
/* 1026 */,
/* 1027 */,
/* 1028 */,
/* 1029 */,
/* 1030 */,
/* 1031 */,
/* 1032 */,
/* 1033 */,
/* 1034 */,
/* 1035 */,
/* 1036 */,
/* 1037 */,
/* 1038 */,
/* 1039 */,
/* 1040 */,
/* 1041 */,
/* 1042 */,
/* 1043 */,
/* 1044 */,
/* 1045 */,
/* 1046 */,
/* 1047 */,
/* 1048 */,
/* 1049 */,
/* 1050 */,
/* 1051 */,
/* 1052 */,
/* 1053 */,
/* 1054 */,
/* 1055 */,
/* 1056 */,
/* 1057 */,
/* 1058 */,
/* 1059 */,
/* 1060 */,
/* 1061 */,
/* 1062 */,
/* 1063 */,
/* 1064 */,
/* 1065 */,
/* 1066 */,
/* 1067 */,
/* 1068 */,
/* 1069 */,
/* 1070 */,
/* 1071 */,
/* 1072 */,
/* 1073 */,
/* 1074 */,
/* 1075 */,
/* 1076 */,
/* 1077 */,
/* 1078 */,
/* 1079 */,
/* 1080 */,
/* 1081 */,
/* 1082 */,
/* 1083 */,
/* 1084 */,
/* 1085 */,
/* 1086 */,
/* 1087 */,
/* 1088 */,
/* 1089 */,
/* 1090 */,
/* 1091 */,
/* 1092 */,
/* 1093 */,
/* 1094 */,
/* 1095 */,
/* 1096 */,
/* 1097 */,
/* 1098 */,
/* 1099 */,
/* 1100 */,
/* 1101 */,
/* 1102 */,
/* 1103 */,
/* 1104 */,
/* 1105 */,
/* 1106 */,
/* 1107 */,
/* 1108 */,
/* 1109 */,
/* 1110 */,
/* 1111 */,
/* 1112 */,
/* 1113 */,
/* 1114 */,
/* 1115 */,
/* 1116 */,
/* 1117 */,
/* 1118 */,
/* 1119 */,
/* 1120 */,
/* 1121 */,
/* 1122 */,
/* 1123 */,
/* 1124 */,
/* 1125 */,
/* 1126 */,
/* 1127 */,
/* 1128 */,
/* 1129 */,
/* 1130 */,
/* 1131 */,
/* 1132 */,
/* 1133 */,
/* 1134 */,
/* 1135 */,
/* 1136 */,
/* 1137 */,
/* 1138 */,
/* 1139 */,
/* 1140 */,
/* 1141 */,
/* 1142 */,
/* 1143 */,
/* 1144 */,
/* 1145 */,
/* 1146 */,
/* 1147 */,
/* 1148 */,
/* 1149 */,
/* 1150 */,
/* 1151 */,
/* 1152 */,
/* 1153 */,
/* 1154 */,
/* 1155 */,
/* 1156 */,
/* 1157 */,
/* 1158 */,
/* 1159 */,
/* 1160 */,
/* 1161 */,
/* 1162 */,
/* 1163 */,
/* 1164 */,
/* 1165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.chrome = undefined;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _angular = __webpack_require__(16);

var _angular2 = _interopRequireDefault(_angular);

var _metadata = __webpack_require__(225);

__webpack_require__(1177);

__webpack_require__(1178);

__webpack_require__(1183);

__webpack_require__(1184);

__webpack_require__(1185);

__webpack_require__(1186);

__webpack_require__(1187);

__webpack_require__(1188);

__webpack_require__(1189);

__webpack_require__(1190);

__webpack_require__(1191);

__webpack_require__(1193);

__webpack_require__(1194);

__webpack_require__(1195);

__webpack_require__(1196);

__webpack_require__(1197);

__webpack_require__(1199);

__webpack_require__(1200);

__webpack_require__(1201);

__webpack_require__(1202);

__webpack_require__(1203);

__webpack_require__(1204);

__webpack_require__(1205);

__webpack_require__(1206);

__webpack_require__(1207);

__webpack_require__(1208);

__webpack_require__(1209);

__webpack_require__(1210);

__webpack_require__(1214);

__webpack_require__(1218);

__webpack_require__(1219);

__webpack_require__(1221);

__webpack_require__(1222);

__webpack_require__(1223);

__webpack_require__(1224);

__webpack_require__(1225);

__webpack_require__(1227);

__webpack_require__(1228);

__webpack_require__(1229);

__webpack_require__(1230);

__webpack_require__(1231);

__webpack_require__(1233);

__webpack_require__(1234);

__webpack_require__(1235);

__webpack_require__(1236);

__webpack_require__(1237);

__webpack_require__(1238);

__webpack_require__(1239);

__webpack_require__(1240);

__webpack_require__(1241);

__webpack_require__(1242);

__webpack_require__(422);

__webpack_require__(1243);

__webpack_require__(1244);

__webpack_require__(1245);

__webpack_require__(1246);

__webpack_require__(1247);

__webpack_require__(1248);

__webpack_require__(1249);

__webpack_require__(1250);

__webpack_require__(1251);

__webpack_require__(1252);

__webpack_require__(1253);

__webpack_require__(1254);

__webpack_require__(1255);

__webpack_require__(1256);

__webpack_require__(1257);

__webpack_require__(1259);

__webpack_require__(1260);

__webpack_require__(1261);

__webpack_require__(1262);

__webpack_require__(1263);

__webpack_require__(1264);

__webpack_require__(1265);

__webpack_require__(1266);

__webpack_require__(1267);

__webpack_require__(1268);

__webpack_require__(1269);

__webpack_require__(1270);

__webpack_require__(1271);

__webpack_require__(1272);

__webpack_require__(1273);

__webpack_require__(1274);

__webpack_require__(1275);

__webpack_require__(1276);

__webpack_require__(1277);

__webpack_require__(1278);

__webpack_require__(431);

__webpack_require__(62);

__webpack_require__(691);

__webpack_require__(236);

__webpack_require__(692);

__webpack_require__(693);

__webpack_require__(445);

__webpack_require__(1419);

var _angular3 = __webpack_require__(1421);

var _apps = __webpack_require__(1458);

var _apps2 = _interopRequireDefault(_apps);

var _controls = __webpack_require__(1459);

var _controls2 = _interopRequireDefault(_controls);

var _nav = __webpack_require__(1460);

var _template = __webpack_require__(1463);

var _template2 = _interopRequireDefault(_template);

var _theme = __webpack_require__(1464);

var _theme2 = _interopRequireDefault(_theme);

var _translations = __webpack_require__(1465);

var _translations2 = _interopRequireDefault(_translations);

var _xsrf = __webpack_require__(1466);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var chrome = exports.chrome = {};
var internals = _lodash2.default.defaults(_lodash2.default.cloneDeep(_metadata.metadata), {
  basePath: '',
  rootController: null,
  rootTemplate: null,
  showAppsLink: null,
  xsrfToken: null,
  devMode: true,
  brand: null,
  nav: [],
  applicationClasses: []
});

(0, _apps2.default)(chrome, internals);
(0, _xsrf.initChromeXsrfApi)(chrome, internals);
(0, _nav.initChromeNavApi)(chrome, internals);
(0, _angular3.initAngularApi)(chrome, internals);
(0, _controls2.default)(chrome, internals);
(0, _template2.default)(chrome, internals);
(0, _theme2.default)(chrome, internals);
(0, _translations2.default)(chrome, internals);

var waitForBootstrap = new Promise(function (resolve) {
  chrome.bootstrap = function () {
    chrome.setupAngular();
    _angular2.default.bootstrap(document.body, ['kibana']);
    resolve();
  };
});

/**
 * ---- ATTENTION: Read documentation carefully before using this! ----
 *
 * Returns a promise, that resolves with an instance of the currently used Angular
 * $injector service for usage outside of Angular.
 * You can use this injector to get access to any other injectable component (service,
 * constant, etc.) by using its get method.
 *
 * If you ever use Angular outside of an Angular context via this method, you should
 * be really sure you know what you are doing!
 *
 * When using this method inside your code, you will need to stub it while running
 * tests. Look into 'src/test_utils/public/stub_get_active_injector' for more information.
 */
chrome.dangerouslyGetActiveInjector = function () {
  return waitForBootstrap.then(function () {
    var $injector = _angular2.default.element(document.body).injector();
    if (!$injector) {
      return Promise.reject('document.body had no angular context after bootstrapping');
    }
    return $injector;
  });
};

/***/ }),
/* 1166 */,
/* 1167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lodashLangMixin = lodashLangMixin;
function lodashLangMixin(_) {
  _.mixin(_, {

    /**
     * Checks to see if an input value is number-like, this
     * includes strings that parse into valid numbers and objects
     * that don't have a type of number but still parse properly
     * via-some sort of valueOf magic
     *
     * @param  {any} v - the value to check
     * @return {Boolean}
     */
    isNumeric: function isNumeric(v) {
      return !_.isNaN(v) && (typeof v === 'number' || !Array.isArray(v) && !_.isNaN(parseFloat(v)));
    }

  });
}

/***/ }),
/* 1168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lodashObjectMixin = lodashObjectMixin;
function lodashObjectMixin(_) {
  return _.mixin(_, {

    /**
     * Flatten an object into a single-level object.
     * NOTE: The flatten behavior here works if you don't need to keep a reference to the original value
     *
     * set flattenArrays to traverse into arrays and create properties like:
     *  {
     *    'users.0.name': 'username1',
     *    'users.1.name': 'username2',
     *    'users.2.name': 'username3',
     *  }
     *
     * @param  {string} dot - the seperator for keys, '.' is generally preferred
     * @param  {object} nestedObj - the object to flatten
     * @param  {Boolean} flattenArrays - should arrays be travered or left alone?
     * @return {object}
     */
    flattenWith: function flattenWith(dot, nestedObj, flattenArrays) {
      var stack = []; // track key stack
      var flatObj = {};

      (function flattenObj(obj) {
        _.keys(obj).forEach(function (key) {
          stack.push(key);
          if (!flattenArrays && Array.isArray(obj[key])) flatObj[stack.join(dot)] = obj[key];else if (_.isObject(obj[key])) flattenObj(obj[key]);else flatObj[stack.join(dot)] = obj[key];
          stack.pop();
        });
      })(nestedObj);

      return flatObj;
    }

  });
}

/***/ }),
/* 1169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lodashCollectionMixin = lodashCollectionMixin;
function lodashCollectionMixin(_) {
  _.mixin(_, {

    /**
     * move an obj either up or down in the collection by
     * injecting it either before/after the prev/next obj that
     * satisfied the qualifier
     *
     * or, just from one index to another...
     *
     * @param  {array} objs - the list to move the object within
     * @param  {number|any} obj - the object that should be moved, or the index that the object is currently at
     * @param  {number|boolean} below - the index to move the object to, or whether it should be moved up or down
     * @param  {function} qualifier - a lodash-y callback, object = _.where, string = _.pluck
     * @return {array} - the objs argument
     */
    move: function move(objs, obj, below, qualifier) {
      var origI = _.isNumber(obj) ? obj : objs.indexOf(obj);
      if (origI === -1) return objs;

      if (_.isNumber(below)) {
        // move to a specific index
        objs.splice(below, 0, objs.splice(origI, 1)[0]);
        return objs;
      }

      below = !!below;
      qualifier = _.callback(qualifier);

      var above = !below;
      var finder = below ? _.findIndex : _.findLastIndex;

      // find the index of the next/previous obj that meets the qualifications
      var targetI = finder(objs, function (otherAgg, otherI) {
        if (below && otherI <= origI) return;
        if (above && otherI >= origI) return;
        return !!qualifier(otherAgg, otherI);
      });

      if (targetI === -1) return objs;

      // place the obj at it's new index
      objs.splice(targetI, 0, objs.splice(origI, 1)[0]);
    },

    /**
     * Like _.groupBy, but allows specifying multiple groups for a
     * single object.
     *
     * _.organizeBy([{ a: [1, 2, 3] }, { b: true, a: [1, 4] }], 'a')
     * // Object {1: Array[2], 2: Array[1], 3: Array[1], 4: Array[1]}
     *
     * _.groupBy([{ a: [1, 2, 3] }, { b: true, a: [1, 4] }], 'a')
     * // Object {'1,2,3': Array[1], '1,4': Array[1]}
     *
     * @param  {array} collection - the list of values to organize
     * @param  {Function} callback - either a property name, or a callback.
     * @return {object}
     */
    organizeBy: function organizeBy(collection, callback) {
      var buckets = {};
      var prop = typeof callback === 'function' ? false : callback;

      function add(key, obj) {
        if (!buckets[key]) buckets[key] = [];
        buckets[key].push(obj);
      }

      _.each(collection, function (obj) {
        var keys = prop === false ? callback(obj) : obj[prop];

        if (!Array.isArray(keys)) {
          add(keys, obj);
          return;
        }

        var length = keys.length;
        while (length-- > 0) {
          add(keys[length], obj);
        }
      });

      return buckets;
    },

    /**
     * Remove or add a value to an array based on it's presense in the
     * array initially.
     *
     * @param  {array} arr
     * @param  {any} value - the value to toggle
     * @return {array} arr
     */
    toggleInOut: function toggleInOut(arr, value) {
      if (_.contains(arr, value)) {
        arr.splice(arr.indexOf(value), 1);
      } else {
        arr.push(value);
      }
      return arr;
    },

    /**
     * Efficient and safe version of [].push(dest, source);
     *
     * @param  {Array} source - the array to pull values from
     * @param  {Array} dest   - the array to push values into
     * @return {Array} dest
     */
    pushAll: function pushAll(source, dest) {
      var start = dest.length;
      var adding = source.length;

      // allocate - http://goo.gl/e2i0S0
      dest.length = start + adding;

      // fill sparse positions
      var i = -1;
      while (++i < adding) {
        dest[start + i] = source[i];
      }return dest;
    }

  });
}

/***/ }),
/* 1170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lodashFunctionMixin = lodashFunctionMixin;
function lodashFunctionMixin(_) {
  _.mixin({

    /**
     * Create a method that wraps another method which expects a callback as it's last
     * argument. The wrapper method will call the wrapped function only once (the first
     * time it is called), but will always call the callbacks passed to it. This has a
     * similar effect to calling a promise-returning function that is wrapped with _.once
     * but can be used outside of angular.
     *
     * @param  {Function} fn - the function that should only be executed once and accepts
     *                       a callback as it's last arg
     * @return {Function} - the wrapper method
     */
    onceWithCb: function onceWithCb(fn) {
      var callbacks = [];

      // on initial flush, call the init function, but ensure
      // that it only happens once
      var flush = _.once(function (cntx, args) {
        args.push(function finishedOnce() {
          // override flush to simply schedule an asynchronous clear
          flush = function flush() {
            setTimeout(function () {
              _.callEach(callbacks.splice(0));
            }, 0);
          };

          flush();
        });

        fn.apply(cntx, args);
      });

      return function runOnceWithCb() {
        var args = [].slice.call(arguments, 0);
        var cb = args[args.length - 1];

        if (typeof cb === 'function') {
          callbacks.push(cb);
          // trim the arg list so the other callback can
          // be pushed if needed
          args = args.slice(0, -1);
        }

        // always call flush, it might not do anything
        flush(this, args);
      };
    },

    /**
     * Call all of the function in an array
     *
     * @param  {array[functions]} arr
     * @return {undefined}
     */
    callEach: function callEach(arr) {
      return _.map(arr, function (fn) {
        return _.isFunction(fn) ? fn() : undefined;
      });
    }

  });
}

/***/ }),
/* 1171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lodashOopMixin = lodashOopMixin;
function lodashOopMixin(_) {

  // create a property descriptor for properties
  // that won't change
  function describeConst(val) {
    return {
      writable: false,
      enumerable: false,
      configurable: false,
      value: val
    };
  }

  var props = {
    inherits: describeConst(function (SuperClass) {

      var prototype = Object.create(SuperClass.prototype, {
        constructor: describeConst(this),
        superConstructor: describeConst(SuperClass)
      });

      Object.defineProperties(this, {
        prototype: describeConst(prototype),
        Super: describeConst(SuperClass)
      });

      return this;
    })
  };

  _.mixin(_, {

    /**
     * Add class-related behavior to a function, currently this
     * only attaches an .inherits() method.
     *
     * @param  {Constructor} ClassConstructor - The function that should be extended
     * @return {Constructor} - the constructor passed in;
     */
    class: function _class(ClassConstructor) {
      return Object.defineProperties(ClassConstructor, props);
    }
  });
}

/***/ }),
/* 1172 */,
/* 1173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = bindToJquery;

var _testSubjSelector = __webpack_require__(1174);

var _testSubjSelector2 = _interopRequireDefault(_testSubjSelector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line @elastic/kibana-custom/no-default-export
function bindToJquery($) {

  /**
   * Find elements with the `data-test-subj` attribute by the terms in that attribute.
   *
   * ```js
   * // this
   * let $button = $('[data-test-subj~="saveButton"]');
   *
   * // becomes this
   * let $button = $.findTestSubject('saveButton');
   * ```
   *
   * Supports multiple subjects
   * ```js
   * // find any saveButton or cancelButton
   * let $buttons = $.findTestSubject('saveButton', 'cancelButton');
   * ```
   *
   * Supports subject "selectors"
   * ```js
   * // find any saveButton inside a savedObjectForm
   * let $button = $.findTestSubject('savedObjectForm saveButton');
   * ```
   *
   * Supports selecting compound subjects
   * ```js
   * // find any smallButton that is also a saveButton inside a savedObjectForm
   * let $input = $.findTestSubject('savedObjectForm smallButton&saveButton');
   * ```
   *
   * @return {jQueryCollection}
   */
  $.findTestSubject = function () {
    return findTestSubject.apply($(document.body), arguments);
  };

  /**
   * Just like $.findTestSubject, except only finds elements within another element.
   * @return {jQueryCollection}
   */
  $.fn.findTestSubject = findTestSubject;

  function findTestSubject() {
    var $els = $();
    var $context = this;

    for (var _len = arguments.length, subjectSelectors = Array(_len), _key = 0; _key < _len; _key++) {
      subjectSelectors[_key] = arguments[_key];
    }

    subjectSelectors.forEach(function (selector) {
      $els = $els.add($context.find((0, _testSubjSelector2.default)(selector)));
    });

    return $els;
  }
}
module.exports = exports['default'];

/***/ }),
/* 1174 */,
/* 1175 */,
/* 1176 */,
/* 1177 */,
/* 1178 */,
/* 1179 */,
/* 1180 */,
/* 1181 */,
/* 1182 */,
/* 1183 */,
/* 1184 */,
/* 1185 */,
/* 1186 */,
/* 1187 */,
/* 1188 */,
/* 1189 */,
/* 1190 */,
/* 1191 */,
/* 1192 */,
/* 1193 */,
/* 1194 */,
/* 1195 */,
/* 1196 */,
/* 1197 */,
/* 1198 */,
/* 1199 */,
/* 1200 */,
/* 1201 */,
/* 1202 */,
/* 1203 */,
/* 1204 */,
/* 1205 */,
/* 1206 */,
/* 1207 */,
/* 1208 */,
/* 1209 */,
/* 1210 */,
/* 1211 */,
/* 1212 */,
/* 1213 */,
/* 1214 */,
/* 1215 */,
/* 1216 */,
/* 1217 */,
/* 1218 */,
/* 1219 */,
/* 1220 */,
/* 1221 */,
/* 1222 */,
/* 1223 */,
/* 1224 */,
/* 1225 */,
/* 1226 */,
/* 1227 */,
/* 1228 */,
/* 1229 */,
/* 1230 */,
/* 1231 */,
/* 1232 */,
/* 1233 */,
/* 1234 */,
/* 1235 */,
/* 1236 */,
/* 1237 */,
/* 1238 */,
/* 1239 */,
/* 1240 */,
/* 1241 */,
/* 1242 */,
/* 1243 */,
/* 1244 */,
/* 1245 */,
/* 1246 */,
/* 1247 */,
/* 1248 */,
/* 1249 */,
/* 1250 */,
/* 1251 */,
/* 1252 */,
/* 1253 */,
/* 1254 */,
/* 1255 */,
/* 1256 */,
/* 1257 */,
/* 1258 */,
/* 1259 */,
/* 1260 */,
/* 1261 */,
/* 1262 */,
/* 1263 */,
/* 1264 */,
/* 1265 */,
/* 1266 */,
/* 1267 */,
/* 1268 */,
/* 1269 */,
/* 1270 */,
/* 1271 */,
/* 1272 */,
/* 1273 */,
/* 1274 */,
/* 1275 */,
/* 1276 */,
/* 1277 */,
/* 1278 */,
/* 1279 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

var _datemath = __webpack_require__(90);

var _datemath2 = _interopRequireDefault(_datemath);

__webpack_require__(663);

__webpack_require__(301);

var _events = __webpack_require__(133);

var _diff_time = __webpack_require__(1338);

var _diff_interval = __webpack_require__(1339);

var _routes = __webpack_require__(29);

var _routes2 = _interopRequireDefault(_routes);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_routes2.default.addSetupWork(function (timefilter) {
  return timefilter.init();
});

_modules.uiModules.get('kibana').service('timefilter', function (Private, globalState, $rootScope, config) {
  var Events = Private(_events.EventsProvider);

  function convertISO8601(stringTime) {
    var obj = (0, _moment2.default)(stringTime, 'YYYY-MM-DDTHH:mm:ss.SSSZ', true);
    return obj.isValid() ? obj : stringTime;
  }

  _lodash2.default.class(Timefilter).inherits(Events);
  function Timefilter() {
    Timefilter.Super.call(this);

    var self = this;
    var diffTime = Private(_diff_time.TimefilterLibDiffTimeProvider)(self);
    var diffInterval = Private(_diff_interval.TimefilterLibDiffIntervalProvider)(self);

    self.isTimeRangeSelectorEnabled = false;
    self.isAutoRefreshSelectorEnabled = false;

    self.init = _lodash2.default.once(function () {
      var timeDefaults = config.get('timepicker:timeDefaults');
      var refreshIntervalDefaults = config.get('timepicker:refreshIntervalDefaults');

      // These can be date math strings or moments.
      self.time = _lodash2.default.defaults(globalState.time || {}, timeDefaults);
      self.refreshInterval = _lodash2.default.defaults(globalState.refreshInterval || {}, refreshIntervalDefaults);

      globalState.on('fetch_with_changes', function () {
        // clone and default to {} in one
        var newTime = _lodash2.default.defaults({}, globalState.time, timeDefaults);
        var newRefreshInterval = _lodash2.default.defaults({}, globalState.refreshInterval, refreshIntervalDefaults);

        if (newTime) {
          if (newTime.to) newTime.to = convertISO8601(newTime.to);
          if (newTime.from) newTime.from = convertISO8601(newTime.from);
        }

        self.time = newTime;
        self.refreshInterval = newRefreshInterval;
      });
    });

    $rootScope.$$timefilter = self;

    $rootScope.$watchMulti(['$$timefilter.time', '$$timefilter.time.from', '$$timefilter.time.to', '$$timefilter.time.mode'], diffTime);

    $rootScope.$watchMulti(['$$timefilter.refreshInterval', '$$timefilter.refreshInterval.pause', '$$timefilter.refreshInterval.value'], diffInterval);
  }

  Timefilter.prototype.update = function () {
    $rootScope.$apply();
  };

  Timefilter.prototype.get = function (indexPattern, range) {

    if (!indexPattern) {
      //in CI, we sometimes seem to fail here.
      return;
    }

    var filter = void 0;
    var timefield = indexPattern.timeFieldName && _lodash2.default.find(indexPattern.fields, { name: indexPattern.timeFieldName });

    if (timefield) {
      var bounds = this.getBounds();
      filter = { range: {} };
      filter.range[timefield.name] = {
        gte: range ? range.min.valueOf() : bounds.min.valueOf(),
        lte: range ? range.max.valueOf() : bounds.max.valueOf(),
        format: 'epoch_millis'
      };
    }

    return filter;
  };

  Timefilter.prototype.getBounds = function () {
    return {
      min: _datemath2.default.parse(this.time.from),
      max: _datemath2.default.parse(this.time.to, true)
    };
  };

  Timefilter.prototype.getActiveBounds = function () {
    if (this.isTimeRangeSelectorEnabled) {
      return this.getBounds();
    }
  };

  /**
   * Show the time bounds selector part of the time filter
   */
  Timefilter.prototype.enableTimeRangeSelector = function () {
    this.isTimeRangeSelectorEnabled = true;
  };

  /**
   * Hide the time bounds selector part of the time filter
   */
  Timefilter.prototype.disableTimeRangeSelector = function () {
    this.isTimeRangeSelectorEnabled = false;
  };

  /**
   * Show the auto refresh part of the time filter
   */
  Timefilter.prototype.enableAutoRefreshSelector = function () {
    this.isAutoRefreshSelectorEnabled = true;
  };

  /**
   * Hide the auto refresh part of the time filter
   */
  Timefilter.prototype.disableAutoRefreshSelector = function () {
    this.isAutoRefreshSelectorEnabled = false;
  };

  return new Timefilter();
});

/***/ }),
/* 1280 */,
/* 1281 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QueryString = undefined;

var _utils = __webpack_require__(199);

var QueryString = exports.QueryString = {};

/*****
/*** orignally copied from angular, modified our purposes
/*****/

function tryDecodeURIComponent(value) {
  try {
    return decodeURIComponent(value);
  }
  // Ignore any invalid uri component
  catch (e) {} // eslint-disable-line no-empty
}

/**
 * Parses an escaped url query string into key-value pairs.
 * @returns {Object.<string,boolean|Array>}
 */
QueryString.decode = function (keyValue) {
  var obj = {};
  var keyValueParts = void 0;
  var key = void 0;

  (keyValue || '').split('&').forEach(function (keyValue) {
    if (keyValue) {
      keyValueParts = keyValue.split('=');
      key = tryDecodeURIComponent(keyValueParts[0]);
      if (key !== void 0) {
        var val = keyValueParts[1] !== void 0 ? tryDecodeURIComponent(keyValueParts[1]) : true;
        if (!obj[key]) {
          obj[key] = val;
        } else if (Array.isArray(obj[key])) {
          obj[key].push(val);
        } else {
          obj[key] = [obj[key], val];
        }
      }
    }
  });
  return obj;
};

/**
 * Creates a queryString out of an object
 * @param  {Object} obj
 * @return {String}
 */
QueryString.encode = function (obj) {
  var parts = [];
  var keys = Object.keys(obj).sort();
  keys.forEach(function (key) {
    var value = obj[key];
    if (Array.isArray(value)) {
      value.forEach(function (arrayValue) {
        parts.push(QueryString.param(key, arrayValue));
      });
    } else {
      parts.push(QueryString.param(key, value));
    }
  });
  return parts.length ? parts.join('&') : '';
};

QueryString.param = function (key, val) {
  return (0, _utils.encodeQueryComponent)(key, true) + (val === true ? '' : '=' + (0, _utils.encodeQueryComponent)(val, true));
};

/**
 * Extracts the query string from a url
 * @param  {String} url
 * @return {Object} - returns an object describing the start/end index of the url in the string. The indices will be
 *                    the same if the url does not have a query string
 */
QueryString.findInUrl = function (url) {
  var qsStart = url.indexOf('?');
  var hashStart = url.lastIndexOf('#');

  if (hashStart === -1) {
    // out of bounds
    hashStart = url.length;
  }

  if (qsStart === -1) {
    qsStart = hashStart;
  }

  return {
    start: qsStart,
    end: hashStart
  };
};

QueryString.replaceParamInUrl = function (url, param, newVal) {
  var loc = QueryString.findInUrl(url);
  var parsed = QueryString.decode(url.substring(loc.start + 1, loc.end));

  if (newVal != null) {
    parsed[param] = newVal;
  } else {
    delete parsed[param];
  }

  var chars = url.split('');
  chars.splice(loc.start, loc.end - loc.start, '?' + QueryString.encode(parsed));
  return chars.join('');
};

/***/ }),
/* 1282 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BinderFor = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _binder = __webpack_require__(432);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BinderFor = exports.BinderFor = function (_BinderBase) {
  _inherits(BinderFor, _BinderBase);

  function BinderFor(emitter) {
    _classCallCheck(this, BinderFor);

    var _this = _possibleConstructorReturn(this, (BinderFor.__proto__ || Object.getPrototypeOf(BinderFor)).call(this));

    _this.emitter = emitter;
    return _this;
  }

  _createClass(BinderFor, [{
    key: 'on',
    value: function on() {
      var _get2;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      (_get2 = _get(BinderFor.prototype.__proto__ || Object.getPrototypeOf(BinderFor.prototype), 'on', this)).call.apply(_get2, [this, this.emitter].concat(args));
    }
  }]);

  return BinderFor;
}(_binder.BinderBase);

/***/ }),
/* 1283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deepCloneWithBuffers = deepCloneWithBuffers;

var _lodash = __webpack_require__(1);

function cloneBuffersCustomizer(val) {
  if (Buffer.isBuffer(val)) {
    return new Buffer(val);
  }
}

function deepCloneWithBuffers(vals) {
  return (0, _lodash.cloneDeep)(vals, cloneBuffersCustomizer);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(114).Buffer))

/***/ }),
/* 1284 */,
/* 1285 */,
/* 1286 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fromRoot = fromRoot;

var _package_json = __webpack_require__(665);

var _path = __webpack_require__(296);

function fromRoot() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return _path.resolve.apply(undefined, [_package_json.pkg.__dirname].concat(args));
}

/***/ }),
/* 1287 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unset = unset;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _toPath = __webpack_require__(666);

var _toPath2 = _interopRequireDefault(_toPath);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function unset(object, rawPath) {
  if (!object) return;
  var path = (0, _toPath2.default)(rawPath);

  switch (path.length) {
    case 0:
      return;

    case 1:
      delete object[rawPath];
      break;

    default:
      var leaf = path.pop();
      var parentPath = path.slice();
      var parent = _lodash2.default.get(object, parentPath);
      unset(parent, leaf);
      if (!_lodash2.default.size(parent)) {
        unset(object, parentPath);
      }
      break;
  }
}

/***/ }),
/* 1288 */,
/* 1289 */,
/* 1290 */,
/* 1291 */,
/* 1292 */,
/* 1293 */,
/* 1294 */,
/* 1295 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encodeQueryComponent = encodeQueryComponent;
/**
 * This method is intended for encoding *key* or *value* parts of query component. We need a custom
 * method because encodeURIComponent is too aggressive and encodes stuff that doesn't have to be
 * encoded per http://tools.ietf.org/html/rfc3986:
 *    query         = *( pchar / "/" / "?" )
 *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
 *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
 *    pct-encoded   = "%" HEXDIG HEXDIG
 *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
 *                     / "*" / "+" / "," / ";" / "="
 */
function encodeQueryComponent(val) {
  var pctEncodeSpaces = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, pctEncodeSpaces ? '%20' : '+');
}

/***/ }),
/* 1296 */,
/* 1297 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.getFlattenedObject = getFlattenedObject;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function shouldReadKeys(value) {
  return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null && !Array.isArray(value);
}

/**
 *  Flattens a deeply nested object to a map of dot-separated
 *  paths pointing to all primative values **and arrays**
 *  from `rootValue`.
 *
 *  example:
 *    getFlattenedObject({ a: { b: 1, c: [2,3] } })
 *    // => { 'a.b': 1, 'a.c': [2,3] }
 *
 *  @param {Object} rootValue
 *  @returns {Object}
 */
function getFlattenedObject(rootValue) {
  if (!shouldReadKeys(rootValue)) {
    throw new TypeError('Root value is not flatten-able, received ' + rootValue);
  }

  return function flatten(acc, prefix, object) {
    return Object.keys(object).reduce(function (acc, key) {
      var value = object[key];
      var path = prefix ? prefix + '.' + key : key;

      if (shouldReadKeys(value)) {
        return flatten(acc, path, value);
      } else {
        return _extends({}, acc, _defineProperty({}, path, value));
      }
    }, acc);
  }({}, '', rootValue);
}

/***/ }),
/* 1298 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getKbnFieldType = getKbnFieldType;
exports.castEsToKbnFieldTypeName = castEsToKbnFieldTypeName;
exports.getKbnTypeNames = getKbnTypeNames;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var KbnFieldType = exports.KbnFieldType = function KbnFieldType() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  _classCallCheck(this, KbnFieldType);

  var name = options.name,
      _options$sortable = options.sortable,
      sortable = _options$sortable === undefined ? false : _options$sortable,
      _options$filterable = options.filterable,
      filterable = _options$filterable === undefined ? false : _options$filterable,
      _options$esTypes = options.esTypes,
      esTypes = _options$esTypes === undefined ? [] : _options$esTypes;


  Object.defineProperties(this, {
    name: { value: name },
    sortable: { value: sortable },
    filterable: { value: filterable },
    esTypes: { value: Object.freeze(esTypes.slice()) }
  });
};

var KBN_FIELD_TYPES = [new KbnFieldType({
  name: 'string',
  sortable: true,
  filterable: true,
  esTypes: ['string', 'text', 'keyword', '_type', '_id']
}), new KbnFieldType({
  name: 'number',
  sortable: true,
  filterable: true,
  esTypes: ['float', 'half_float', 'scaled_float', 'double', 'integer', 'long', 'short', 'byte', 'token_count']
}), new KbnFieldType({
  name: 'date',
  sortable: true,
  filterable: true,
  esTypes: ['date']
}), new KbnFieldType({
  name: 'ip',
  sortable: true,
  filterable: true,
  esTypes: ['ip']
}), new KbnFieldType({
  name: 'boolean',
  sortable: true,
  filterable: true,
  esTypes: ['boolean']
}), new KbnFieldType({
  name: 'geo_point',
  esTypes: ['geo_point']
}), new KbnFieldType({
  name: 'geo_shape',
  esTypes: ['geo_shape']
}), new KbnFieldType({
  name: 'attachment',
  esTypes: ['attachment']
}), new KbnFieldType({
  name: 'murmur3',
  esTypes: ['murmur3']
}), new KbnFieldType({
  name: '_source',
  esTypes: ['_source']
}), new KbnFieldType({
  name: 'unknown'
}), new KbnFieldType({
  name: 'conflict'
})];

/**
 *  Get a type object by name
 *  @param  {string} typeName
 *  @return {KbnFieldType}
 */
function getKbnFieldType(typeName) {
  return KBN_FIELD_TYPES.find(function (type) {
    return type.name === typeName;
  });
}

/**
 *  Get the KbnFieldType name for an esType string
 *  @param {string} esType
 *  @return {string}
 */
function castEsToKbnFieldTypeName(esType) {
  var type = KBN_FIELD_TYPES.find(function (type) {
    return type.esTypes.includes(esType);
  });
  return type ? type.name : 'unknown';
}

/**
 *  Get the esTypes known by all kbnFieldTypes
 *  @return {Array<string>}
 */
function getKbnTypeNames() {
  return KBN_FIELD_TYPES.map(function (type) {
    return type.name;
  });
}

/***/ }),
/* 1299 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _intersperse_stream = __webpack_require__(1300);

Object.defineProperty(exports, 'createIntersperseStream', {
  enumerable: true,
  get: function get() {
    return _intersperse_stream.createIntersperseStream;
  }
});

var _split_stream = __webpack_require__(1310);

Object.defineProperty(exports, 'createSplitStream', {
  enumerable: true,
  get: function get() {
    return _split_stream.createSplitStream;
  }
});

var _list_stream = __webpack_require__(1311);

Object.defineProperty(exports, 'createListStream', {
  enumerable: true,
  get: function get() {
    return _list_stream.createListStream;
  }
});

var _reduce_stream = __webpack_require__(675);

Object.defineProperty(exports, 'createReduceStream', {
  enumerable: true,
  get: function get() {
    return _reduce_stream.createReduceStream;
  }
});

var _json_streams = __webpack_require__(1312);

Object.defineProperty(exports, 'createJsonParseStream', {
  enumerable: true,
  get: function get() {
    return _json_streams.createJsonParseStream;
  }
});
Object.defineProperty(exports, 'createJsonStringifyStream', {
  enumerable: true,
  get: function get() {
    return _json_streams.createJsonStringifyStream;
  }
});

var _promise_from_streams = __webpack_require__(1313);

Object.defineProperty(exports, 'createPromiseFromStreams', {
  enumerable: true,
  get: function get() {
    return _promise_from_streams.createPromiseFromStreams;
  }
});

var _concat_stream = __webpack_require__(1314);

Object.defineProperty(exports, 'createConcatStream', {
  enumerable: true,
  get: function get() {
    return _concat_stream.createConcatStream;
  }
});

var _map_stream = __webpack_require__(1315);

Object.defineProperty(exports, 'createMapStream', {
  enumerable: true,
  get: function get() {
    return _map_stream.createMapStream;
  }
});

var _replace_stream = __webpack_require__(1316);

Object.defineProperty(exports, 'createReplaceStream', {
  enumerable: true,
  get: function get() {
    return _replace_stream.createReplaceStream;
  }
});

/***/ }),
/* 1300 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIntersperseStream = createIntersperseStream;

var _stream = __webpack_require__(166);

/**
 *  Create a Transform stream that receives values in object mode,
 *  and intersperses a chunk between each object received.
 *
 *  This is useful for writing lists:
 *
 *    createListStream(['foo', 'bar'])
 *      .pipe(createIntersperseStream('\n'))
 *      .pipe(process.stdout) // outputs "foo\nbar"
 *
 *  Combine with a concat stream to get "join" like functionality:
 *
 *    await createPromiseFromStreams([
 *      createListStream(['foo', 'bar']),
 *      createIntersperseStream(' '),
 *      createConcatStream()
 *    ]) // produces a single value "foo bar"
 *
 *  @param  {String|Buffer} intersperseChunk
 *  @return {Transform}
 */
function createIntersperseStream(intersperseChunk) {
  var first = true;

  return new _stream.Transform({
    writableObjectMode: true,
    readableObjectMode: true,
    transform: function transform(chunk, enc, callback) {
      try {
        if (first) {
          first = false;
        } else {
          this.push(intersperseChunk);
        }

        this.push(chunk);
        callback(null);
      } catch (err) {
        callback(err);
      }
    }
  });
}

/***/ }),
/* 1301 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 1302 */,
/* 1303 */,
/* 1304 */,
/* 1305 */,
/* 1306 */,
/* 1307 */,
/* 1308 */,
/* 1309 */,
/* 1310 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createSplitStream = createSplitStream;

var _stream = __webpack_require__(166);

/**
 *  Creates a Transform stream that consumes a stream of Buffers
 *  and produces a stream of strings (in object mode) by splitting
 *  the received bytes using the splitChunk.
 *
 *  Ways this is behaves like String#split:
 *    - instances of splitChunk are removed from the input
 *    - splitChunk can be on any size
 *    - if there are no bytes found after the last splitChunk
 *      a final empty chunk is emitted
 *
 *  Ways this deviates from String#split:
 *    - splitChunk cannot be a regexp
 *    - an empty string or Buffer will not produce a stream of individual
 *      bytes like `string.split('')` would
 *
 *  @param  {String} splitChunk
 *  @return {Transform}
 */
function createSplitStream(splitChunk) {
  var unsplitBuffer = Buffer.alloc(0);

  return new _stream.Transform({
    writableObjectMode: false,
    readableObjectMode: true,
    transform: function transform(chunk, enc, callback) {
      try {
        var i = void 0;
        var toSplit = Buffer.concat([unsplitBuffer, chunk]);
        while ((i = toSplit.indexOf(splitChunk)) !== -1) {
          var slice = toSplit.slice(0, i);
          toSplit = toSplit.slice(i + splitChunk.length);
          this.push(slice.toString('utf8'));
        }

        unsplitBuffer = toSplit;
        callback(null);
      } catch (err) {
        callback(err);
      }
    },
    flush: function flush(callback) {
      try {
        this.push(unsplitBuffer.toString('utf8'));

        callback(null);
      } catch (err) {
        callback(err);
      }
    }
  });
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(114).Buffer))

/***/ }),
/* 1311 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createListStream = createListStream;

var _stream = __webpack_require__(166);

/**
 *  Create a Readable stream that provides the items
 *  from a list as objects to subscribers
 *
 *  @param  {Array<any>} items - the list of items to provide
 *  @return {Readable}
 */
function createListStream() {
  var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  var queue = [].concat(items);

  return new _stream.Readable({
    objectMode: true,
    read: function read(size) {
      var _this = this;

      queue.splice(0, size).forEach(function (item) {
        _this.push(item);
      });

      if (!queue.length) {
        this.push(null);
      }
    }
  });
}

/***/ }),
/* 1312 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createJsonParseStream = createJsonParseStream;
exports.createJsonStringifyStream = createJsonStringifyStream;

var _stream = __webpack_require__(166);

/**
 *  Create a Transform stream that accepts strings (in
 *  object mode) and parsed those streams to provide their
 *  JavaScript value.
 *
 *  Parse errors are emitted with the "error" event, and
 *  if not caught will cause the process to crash. When caught
 *  the stream will continue to parse subsequent values.
 *
 *  @return {Transform}
 */
function createJsonParseStream() {
  return new _stream.Transform({
    writableObjectMode: true,
    readableObjectMode: true,
    transform: function transform(json, enc, callback) {
      try {
        callback(null, JSON.parse(json));
      } catch (err) {
        callback(err);
      }
    }
  });
}

/**
 *  Create a Transform stream that accepts arbitrary JavaScript
 *  values, stringifies them, and provides the output in object
 *  mode to consumers.
 *
 *  Serialization errors are emitted with the "error" event, and
 *  if not caught will cause the process to crash. When caught
 *  the stream will continue to stringify subsequent values.
 *
 *  @param  {Object} options
 *  @property {Boolean} options.pretty
 *  @return {Transform}
 */
function createJsonStringifyStream() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$pretty = _ref.pretty,
      pretty = _ref$pretty === undefined ? false : _ref$pretty;

  return new _stream.Transform({
    writableObjectMode: true,
    readableObjectMode: true,
    transform: function transform(json, enc, callback) {
      try {
        callback(null, JSON.stringify(json, null, pretty ? 2 : 0));
      } catch (err) {
        callback(err);
      }
    }
  });
}

/***/ }),
/* 1313 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 *  Take an array of streams, pipe the output
 *  from each one into the next, listening for
 *  errors from any of the streams, and then resolve
 *  the promise once the final stream has finished
 *  writing/reading.
 *
 *  If the last stream is readable, it's final value
 *  will be provided as the promise value.
 *
 *  Errors emmitted from any stream will cause
 *  the promise to be rejected with that error.
 *
 *  @param  {Array<Stream>} streams
 *  @return {Promise<any>}
 */
var createPromiseFromStreams = exports.createPromiseFromStreams = function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(streams) {
    var last, anyStreamFailure, lastFinishedWriting, lastFinishedReading;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            last = streams[streams.length - 1];

            // reject if any of the streams emits an error

            anyStreamFailure = new Promise(function (resolve, reject) {
              streams.forEach(function (stream, i) {
                if (i > 0) streams[i - 1].pipe(stream);
                stream.on('error', reject);
                return stream;
              });
            });

            // resolve when the last stream has finished writing, or
            // immediately if the last stream is not writable

            lastFinishedWriting = new Promise(function (resolve) {
              if (typeof last.write !== 'function') {
                resolve();
                return;
              }

              last.on('finish', resolve);
            });

            // resolve with the final value provided by the last stream
            // after the last stream has provided it, or immediately if the
            // stream is not readable

            lastFinishedReading = new Promise(function (resolve) {
              if (typeof last.read !== 'function') {
                resolve();
                return;
              }

              var finalChunk = void 0;
              last.on('data', function (chunk) {
                finalChunk = chunk;
              });
              last.on('end', function () {
                resolve(finalChunk);
              });
            });

            // wait (and rethrow) the first error, or for the last stream
            // to both finish writing and providing values to read

            _context.next = 6;
            return Promise.race([anyStreamFailure, Promise.all([lastFinishedWriting, lastFinishedReading])]);

          case 6:
            _context.next = 8;
            return lastFinishedReading;

          case 8:
            return _context.abrupt('return', _context.sent);

          case 9:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function createPromiseFromStreams(_x) {
    return _ref.apply(this, arguments);
  };
}();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

/***/ }),
/* 1314 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createConcatStream = createConcatStream;

var _reduce_stream = __webpack_require__(675);

/**
 *  Creates a Transform stream that consumes all provided
 *  values and concatenates them using each values `concat`
 *  method.
 *
 *  Concatenate strings:
 *    createListStream(['f', 'o', 'o'])
 *      .pipe(createConcatStream())
 *      .on('data', console.log)
 *      // logs "foo"
 *
 *  Concatenate values into an array:
 *    createListStream([1,2,3])
 *      .pipe(createConcatStream([]))
 *      .pipe(createJsonStringifyStream())
 *      .on('data', console.log)
 *      // logs "[1,2,3]"
 *
 *
 *  @param {any} initial The initial value that subsequent
 *                       items will concat with
 *  @return {Transform}
 */
function createConcatStream(initial) {
  return (0, _reduce_stream.createReduceStream)(function (acc, chunk) {
    return acc.concat(chunk);
  }, initial);
}

/***/ }),
/* 1315 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMapStream = createMapStream;

var _stream = __webpack_require__(166);

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function createMapStream(fn) {
  var i = 0;

  return new _stream.Transform({
    objectMode: true,
    transform: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(value, enc, done) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.t0 = this;
                _context.next = 4;
                return fn(value, i++);

              case 4:
                _context.t1 = _context.sent;

                _context.t0.push.call(_context.t0, _context.t1);

                done();
                _context.next = 12;
                break;

              case 9:
                _context.prev = 9;
                _context.t2 = _context['catch'](0);

                done(_context.t2);

              case 12:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this, [[0, 9]]);
      }));

      function transform(_x, _x2, _x3) {
        return _ref.apply(this, arguments);
      }

      return transform;
    }()
  });
}

/***/ }),
/* 1316 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createReplaceStream = createReplaceStream;

var _stream = __webpack_require__(166);

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function createReplaceStream(toReplace, replacement) {
  if (typeof toReplace !== 'string') {
    throw new TypeError('toReplace must be a string');
  }

  var buffer = Buffer.alloc(0);
  return new _stream.Transform({
    objectMode: false,
    transform: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(value, enc, done) {
        var index;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;

                buffer = Buffer.concat([buffer, value], buffer.length + value.length);

              case 2:
                if (false) {
                  _context.next = 11;
                  break;
                }

                // try to find the next instance of `toReplace` in buffer
                index = buffer.indexOf(toReplace);

                // if there is no next instance, break

                if (!(index === -1)) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt('break', 11);

              case 6:

                // flush everything to the left of the next instance
                // of `toReplace`
                this.push(buffer.slice(0, index));

                // then flush an instance of `replacement`
                this.push(replacement);

                // and finally update the buffer to include everything
                // to the right of `toReplace`, dropping to replace from the buffer
                buffer = buffer.slice(index + toReplace.length);
                _context.next = 2;
                break;

              case 11:

                // until now we have only flushed data that is to the left
                // of a discovered instance of `toReplace`. If `toReplace` is
                // never found this would lead to us buffering the entire stream.
                //
                // Instead, we only keep enough buffer to complete a potentially
                // patial instance of `toReplace`
                if (buffer.length > toReplace.length) {
                  // the entire buffer except the last `toReplace.length` bytes
                  // so that if all but one byte from `toReplace` is in the buffer,
                  // and the next chunk delivers the necessary byte, the buffer will then
                  // contain a complete `toReplace` token.
                  this.push(buffer.slice(0, buffer.length - toReplace.length));
                  buffer = buffer.slice(-toReplace.length);
                }

                done();
                _context.next = 18;
                break;

              case 15:
                _context.prev = 15;
                _context.t0 = _context['catch'](0);

                done(_context.t0);

              case 18:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this, [[0, 15]]);
      }));

      function transform(_x, _x2, _x3) {
        return _ref.apply(this, arguments);
      }

      return transform;
    }(),
    flush: function flush(callback) {
      if (buffer.length) {
        this.push(buffer);
      }

      buffer = null;
      callback();
    }
  });
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(114).Buffer))

/***/ }),
/* 1317 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _comma_separated_list = __webpack_require__(1318);

Object.defineProperty(exports, 'parseCommaSeparatedList', {
  enumerable: true,
  get: function get() {
    return _comma_separated_list.parseCommaSeparatedList;
  }
});

var _prose = __webpack_require__(1319);

Object.defineProperty(exports, 'formatListAsProse', {
  enumerable: true,
  get: function get() {
    return _prose.formatListAsProse;
  }
});

/***/ }),
/* 1318 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseCommaSeparatedList = parseCommaSeparatedList;
function parseCommaSeparatedList(input) {
  if (Array.isArray(input)) {
    return input;
  }

  return String(input || '').split(',').map(function (word) {
    return word.trim();
  }).filter(Boolean);
}

/***/ }),
/* 1319 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatListAsProse = formatListAsProse;
/**
 *  Converts an array of items into a sentence-ready string.
 *
 *  @param {Array<any>} list
 *  @param {Object} [options={}]
 *  @property {Boolean} [options.inclusive=true] Creates an inclusive list using "and"
 *                                               when `true` (default), otherwise uses "or"
 *  @return {String}
 */
function formatListAsProse(list) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _options$inclusive = options.inclusive,
      inclusive = _options$inclusive === undefined ? true : _options$inclusive;


  if (!Array.isArray(list)) {
    throw new TypeError('formatListAsProse() requires an array');
  }

  var count = list.length;
  var conjunction = inclusive ? 'and' : 'or';

  if (count <= 2) {
    return list.join(' ' + conjunction + ' ');
  }

  return list.slice(0, -1).concat(conjunction + ' ' + list[count - 1]).join(', ');
}

/***/ }),
/* 1320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.applyDiff = applyDiff;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _angular = __webpack_require__(16);

var _angular2 = _interopRequireDefault(_angular);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function applyDiff(target, source) {

  var diff = {};

  /**
   * Filter the private vars
   * @param {string} key The keys
   * @returns {boolean}
   */
  var filterPrivateAndMethods = function filterPrivateAndMethods(obj) {
    return function (key) {
      if (_lodash2.default.isFunction(obj[key])) return false;
      if (key.charAt(0) === '$') return false;
      return key.charAt(0) !== '_';
    };
  };

  var targetKeys = _lodash2.default.keys(target).filter(filterPrivateAndMethods(target));
  var sourceKeys = _lodash2.default.keys(source).filter(filterPrivateAndMethods(source));

  // Find the keys to be removed
  diff.removed = _lodash2.default.difference(targetKeys, sourceKeys);

  // Find the keys to be added
  diff.added = _lodash2.default.difference(sourceKeys, targetKeys);

  // Find the keys that will be changed
  diff.changed = _lodash2.default.filter(sourceKeys, function (key) {
    return !_angular2.default.equals(target[key], source[key]);
  });

  // Make a list of all the keys that are changing
  diff.keys = _lodash2.default.union(diff.changed, diff.removed, diff.added);

  // Remove all the keys
  _lodash2.default.each(diff.removed, function (key) {
    delete target[key];
  });

  // Assign the changed to the source to the target
  _lodash2.default.assign(target, _lodash2.default.pick(source, diff.changed));
  // Assign the added to the source to the target
  _lodash2.default.assign(target, _lodash2.default.pick(source, diff.added));

  return diff;
}

/***/ }),
/* 1321 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatMsg = formatMsg;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _format_es_msg = __webpack_require__(1322);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var has = _lodash2.default.has;

/**
 * Formats the error message from an error object, extended elasticsearch
 * object or simple string; prepends optional second parameter to the message
 * @param  {Error|String} err
 * @param  {String} from - Prefix for message indicating source (optional)
 * @returns {string}
 */
function formatMsg(err, from) {
  var rtn = '';
  if (from) {
    rtn += from + ': ';
  }

  var esMsg = (0, _format_es_msg.formatESMsg)(err);

  if (typeof err === 'string') {
    rtn += err;
  } else if (esMsg) {
    rtn += esMsg;
  } else if (err instanceof Error) {
    rtn += formatMsg.describeError(err);
  } else if (has(err, 'status') && has(err, 'data')) {
    // is an Angular $http "error object"
    if (err.status === -1) {
      // status = -1 indicates that the request was failed to reach the server
      rtn += 'An HTTP request has failed to connect. ' + 'Please check if the Kibana server is running and that your browser has a working connection, ' + 'or contact your system administrator.';
    } else {
      rtn += 'Error ' + err.status + ' ' + err.statusText + ': ' + err.data.message;
    }
  }

  return rtn;
}

formatMsg.describeError = function (err) {
  if (!err) return undefined;
  if (err.body && err.body.message) return err.body.message;
  if (err.message) return err.message;
  return '' + err;
};

/***/ }),
/* 1322 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatESMsg = formatESMsg;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Utilize the extended error information returned from elasticsearch
 * @param  {Error|String} err
 * @returns {string}
 */
function formatESMsg(err) {
  var rootCause = _lodash2.default.get(err, 'resp.error.root_cause');
  if (!rootCause) {
    return; //undefined
  }

  var result = _lodash2.default.pluck(rootCause, 'reason').join('\n');
  return result;
}

/***/ }),
/* 1323 */
/***/ (function(module, exports) {

module.exports = "<div\n  id=\"fatal-splash-screen-header\"\n  class=\"kuiViewContent kuiViewContent--constrainedWidth kuiViewContentItem\"\n>\n  <div style=\"text-align: center\">\n    <h1 class=\"kuiTitle kuiVerticalRhythm\">\n      Oops!\n    </h1>\n\n    <p class=\"kuiText kuiVerticalRhythm\">\n      Looks like something went wrong. Refreshing may do the trick.\n    </p>\n\n    <div\n      class=\"kuiButtonGroup kuiVerticalRhythm\"\n      style=\"text-align: center; display: inline-block;\"\n    >\n      <button\n        class=\"kuiButton kuiButton--primary\"\n        onclick=\"window.history.back();\"\n      >\n        Go back\n      </button>\n\n      <button\n        class=\"kuiButton kuiButton--hollow\"\n        onclick=\"localStorage.clear(); sessionStorage.clear(); window.location.hash = ''; window.location.reload();\"\n      >\n        Clear your session\n      </button>\n    </div>\n  </div>\n  <div id=\"fatal-splash-screen\">\n  </div>\n</div>\n"

/***/ }),
/* 1324 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _modules = __webpack_require__(2);

var _apply_scope_bindings = __webpack_require__(1325);

/**
 * The <render-directive> directive is useful for programaticaly modifying or
 * extending a view. It allows defining the majority of the directives behavior
 * using a "definition" object, which the implementer can obtain from plugins (for instance).
 *
 * The definition object supports the parts of a directive definition that are
 * easy enough to implement without having to hack angular, and does it's best to
 * make sure standard directive life-cycle timing is respected.
 *
 * @param [Object] definition - the external configuration for this directive to assume
 * @param [Function] definition.controller - a constructor used to create the controller for this directive
 * @param [String] definition.controllerAs - a name where the controller should be stored on scope
 * @param [Object] definition.scope - an object defining the binding properties for values read from
 *                                  attributes and bound to $scope. The keys of this object are the
 *                                  local names of $scope properties, and the values are a combination
 *                                  of the binding style (=, @, or &) and the external attribute name.
 *                                  See [the Angular docs]
 *                                  (https://code.angularjs.org/1.4.9/docs/api/ng/service/$compile#-scope-)
 *                                  for more info
 * @param [Object|Function] definition.link - either a post link function or an object with pre and/or
 *                                          post link functions.
 */
_modules.uiModules.get('kibana').directive('renderDirective', function (Private) {
  var applyScopeBindings = Private(_apply_scope_bindings.ApplyScopeBindingsProvider);

  return {
    restrict: 'E',
    scope: {
      'definition': '='
    },
    template: function template($el) {
      return $el.html();
    },
    controller: function controller($scope, $element, $attrs, $transclude, $injector) {
      if (!$scope.definition) throw new Error('render-directive must have a definition attribute');

      var _$scope$definition = $scope.definition,
          controller = _$scope$definition.controller,
          controllerAs = _$scope$definition.controllerAs,
          scope = _$scope$definition.scope;


      applyScopeBindings(scope, $scope, $attrs);

      if (controller) {
        if (controllerAs) {
          $scope[controllerAs] = this;
        }

        var locals = { $scope: $scope, $element: $element, $attrs: $attrs, $transclude: $transclude };
        var controllerInstance = $injector.invoke(controller, this, locals) || this;

        if (controllerAs) {
          $scope[controllerAs] = controllerInstance;
        }
      }
    },
    link: {
      pre: function pre($scope, $el, $attrs, controller) {
        var link = $scope.definition.link;

        var preLink = (0, _lodash.isPlainObject)(link) ? link.pre : null;
        if (preLink) preLink($scope, $el, $attrs, controller);
      },
      post: function post($scope, $el, $attrs, controller) {
        var link = $scope.definition.link;

        var postLink = (0, _lodash.isPlainObject)(link) ? link.post : link;
        if (postLink) postLink($scope, $el, $attrs, controller);
      }
    }
  };
});

/***/ }),
/* 1325 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.ApplyScopeBindingsProvider = ApplyScopeBindingsProvider;

var _lodash = __webpack_require__(1);

__webpack_require__(677);

var bindingRE = /^(=|=\?|&|@)([a-zA-Z0-9_$]+)?$/;

function ApplyScopeBindingsProvider($parse) {
  return function (bindings, $scope, $attrs) {
    (0, _lodash.forOwn)(bindings, function (binding, local) {
      if (!bindingRE.test(binding)) {
        throw new Error('Invalid scope binding "' + binding + '". Expected it to match ' + bindingRE);
      }

      var _binding$match = binding.match(bindingRE),
          _binding$match2 = _slicedToArray(_binding$match, 3),
          type = _binding$match2[1],
          _binding$match2$ = _binding$match2[2],
          attribute = _binding$match2$ === undefined ? local : _binding$match2$;

      var attr = $attrs[attribute];
      switch (type) {
        case '=':
          $scope.$bind(local, attr);
          break;
        case '=?':
          throw new Error('<render-directive> does not currently support optional two-way bindings.');
          break;
        case '&':
          if (attr) {
            var getter = $parse(attr);
            $scope[local] = function () {
              return getter($scope.$parent);
            };
          } else {
            $scope[local] = _lodash.noop;
          }
          break;
        case '@':
          $scope[local] = attr;
          $attrs.$observe(attribute, function (v) {
            return $scope[local] = v;
          });
          break;
      }
    });
  };
}

/***/ }),
/* 1326 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _angular = __webpack_require__(16);

var _angular2 = _interopRequireDefault(_angular);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_modules.uiModules.get('kibana').config(function ($provide) {

  function strictEquality(a, b) {
    // are the values equal? or, are they both NaN?
    return a === b || a !== a && b !== b;
  }

  function errorNotAssignable(source, target) {
    throw Error('Unable to accept change to bound $scope property "' + source + '"' + ' because source expression "' + target + '" is not assignable!');
  }

  $provide.decorator('$rootScope', function ($delegate, $parse) {
    /**
     * Two-way bind a value from scope to another property on scope. This
     * allow values on scope that work like they do in an isolate scope, but
     * without requiring one.
     *
     * @param  {expression} to - the location on scope to bind to
     * @param  {expression} from - the location on scope to bind from
     * @param  {Scope} $sourceScope - the scope to read "from" expression from
     * @return {undefined}
     */
    $delegate.constructor.prototype.$bind = function (to, from, $sourceScope) {
      var $source = $sourceScope || this.$parent;
      var $target = this;

      // parse expressions
      var $to = $parse(to);
      if (!$to.assign) errorNotAssignable(to, from);
      var $from = $parse(from);

      // bind scopes to expressions
      var getTarget = function getTarget() {
        return $to($target);
      };
      var setTarget = function setTarget(v) {
        return $to.assign($target, v);
      };
      var getSource = function getSource() {
        return $from($source);
      };
      var setSource = function setSource(v) {
        return $from.assignOrFail($source, v);
      };

      // to support writing from the child to the parent we need to know
      // which source has changed. Track the source value and anytime it
      // changes (even if the target value changed too) push from source
      // to target. If the source hasn't changed then the change is from
      // the target and push accordingly
      var lastSourceVal = getSource();

      $from.assignOrFail = $from.assign || function () {
        // revert the change and throw an error, child writes aren't supported
        $to($target, lastSourceVal = $from($source));
        errorNotAssignable(from, to);
      };

      // if we are syncing down a literal, then we use loose equality check
      var strict = !$from.literal;
      var compare = strict ? strictEquality : _angular2.default.equals;

      // push the initial value down, start off in sync
      setTarget(lastSourceVal);

      $target.$watch(function () {
        var sourceVal = getSource();
        var targetVal = getTarget();

        var outOfSync = !compare(sourceVal, targetVal);
        var sourceChanged = outOfSync && !compare(sourceVal, lastSourceVal);

        if (sourceChanged) setTarget(sourceVal);else if (outOfSync) setSource(targetVal);

        return lastSourceVal = sourceVal;
      }, null, !strict);
    };

    return $delegate;
  });
});

/***/ }),
/* 1327 */
/***/ (function(module, exports) {

module.exports = "<!--\n!!!!\n  Since fatal error could prevent angular from starting\n  this template is just a simple lodash template\n!!!!\n-->\n<h1><i class=\"fa fa-warning-triangle\"></i></h1>\n<div class=\"panel panel-danger\">\n  <div class=\"panel-heading\">\n    <h1 class=\"panel-title\">\n      <i class=\"fa fa-warning\"></i> Fatal Error\n    </h1>\n  </div>\n  <div class=\"panel-body fatal-body\"><%- msg %></div>\n  <% if (info) { %>\n    <div class=\"panel-footer\"><pre><%- info %></pre></div>\n  <% } %>\n  <% if (stack) { %>\n    <div class=\"panel-footer\"><pre><%- stack %></pre></div>\n  <% } %>\n</div>"

/***/ }),
/* 1328 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseObject = BaseObject;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _risonNode = __webpack_require__(132);

var _risonNode2 = _interopRequireDefault(_risonNode);

var _angular = __webpack_require__(16);

var _angular2 = _interopRequireDefault(_angular);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function BaseObject(attributes) {
  // Set the attributes or default to an empty object
  _lodash2.default.assign(this, attributes);
}

/**
 * Returns the attirbutes for the objct
 * @returns {object}
 */
BaseObject.prototype.toObject = function () {
  // return just the data.
  return _lodash2.default.omit(this, function (value, key) {
    return key.charAt(0) === '$' || key.charAt(0) === '_' || _lodash2.default.isFunction(value);
  });
};

/**
 * Serialize the model to RISON
 * @returns {string}
 */
BaseObject.prototype.toRISON = function () {
  // Use Angular to remove the private vars, and JSON.stringify to serialize
  return _risonNode2.default.encode(JSON.parse(_angular2.default.toJson(this)));
};

/**
 * Serialize the model to JSON
 * @returns {object}
 */
BaseObject.prototype.toJSON = function () {
  return this.toObject();
};

/***/ }),
/* 1329 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @name stateManagementConfig
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @description Allows apps to configure state management
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _modules = __webpack_require__(2);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

_modules.uiModules.get('kibana/state_management').provider('stateManagementConfig', function () {
  function StateManagementConfigProvider() {
    _classCallCheck(this, StateManagementConfigProvider);

    this._enabled = true;
  }

  _createClass(StateManagementConfigProvider, [{
    key: '$get',
    value: function $get() /* inject stuff */{
      return {
        enabled: this._enabled
      };
    }
  }, {
    key: 'disable',
    value: function disable() {
      this._enabled = false;
    }
  }, {
    key: 'enable',
    value: function enable() {
      this._enabled = true;
    }
  }]);

  return StateManagementConfigProvider;
}());

/***/ }),
/* 1330 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hashed_item_store_singleton = __webpack_require__(1331);

Object.defineProperty(exports, 'HashedItemStoreSingleton', {
  enumerable: true,
  get: function get() {
    return _hashed_item_store_singleton.HashedItemStoreSingleton;
  }
});

var _state_hash = __webpack_require__(1333);

Object.defineProperty(exports, 'createStateHash', {
  enumerable: true,
  get: function get() {
    return _state_hash.createStateHash;
  }
});
Object.defineProperty(exports, 'isStateHash', {
  enumerable: true,
  get: function get() {
    return _state_hash.isStateHash;
  }
});

/***/ }),
/* 1331 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HashedItemStoreSingleton = undefined;

var _hashed_item_store = __webpack_require__(1332);

var HashedItemStoreSingleton = exports.HashedItemStoreSingleton = new _hashed_item_store.HashedItemStore(window.sessionStorage);

/***/ }),
/* 1332 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HashedItemStore = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The HashedItemStore associates JSON objects with states in browser history and persists these
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * objects in sessionStorage. We persist them so that when a tab is closed and re-opened, we can
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * retain access to the state objects referenced by the browser history.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Because there is a limit on how much data we can put into sessionStorage, the HashedItemStore
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * will attempt to remove old items from storage once that limit is reached.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * -------------------------------------------------------------------------------------------------
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Consideration 1: We can't (easily) mirror the browser history
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * If we use letters to indicate a unique state object, and numbers to represent the same state
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * occurring again (due to action by the user), a history could look like this:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Old < - - - - - - - - > New
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * A1 | B1 | C1 | A2 | D1 | E1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * If the user navigates back to C1 and starts to create new states, persisted history states will
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * become inaccessible:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Old < - - - - - - - - - - -> New
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * A1 | B1 | C1 | F1 | G1 | H1 | I1  (new history states)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *                A2 | D1 | E1       (inaccessible persisted history states)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Theoretically, we could build a mirror of the browser history. When the onpopstate event is
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * dispatched, we could determine whether we have gone back or forward in history. Then, when
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * a new state is persisted, we could delete all of the persisted items which are no longer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * accessible. (Note that this would require reference-counting so that A isn't removed while D and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * E are, since A would still have a remaining reference from A1).
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * However, the History API doesn't allow us to read from the history beyond the current state. This
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * means that if a session is restored, we can't rebuild this browser history mirror.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Due to this imperfect implementation, HashedItemStore ignores the possibility of inaccessible
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * history states. In the future, we could implement this history mirror and persist it in
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * sessionStorage too. Then, when restoring a session, we can just retrieve it from sessionStorage.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * -------------------------------------------------------------------------------------------------
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Consideration 2: We can't tell when we've hit the browser history limit
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Because some of our persisted history states may no longer be referenced by the browser history,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * and we have no way of knowing which ones, we have no way of knowing whether we've persisted a
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * number of accessible states beyond the browser history length limit.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * More fundamentally, the browser history length limit is a browser implementation detail, so it
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * can change from browser to browser, or over time. Respecting this limit would introduce a lot of
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * (unnecessary?) complexity.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * For these reasons, HashedItemStore doesn't concern itself with this constraint.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _lodash = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var HashedItemStore = exports.HashedItemStore = function () {

  /**
   * HashedItemStore uses objects called indexed items to refer to items that have been persisted
   * in sessionStorage. An indexed item is shaped {hash, touched}. The touched date is when the item
   * was last referenced by the browser history.
   */
  function HashedItemStore(sessionStorage) {
    _classCallCheck(this, HashedItemStore);

    this._sessionStorage = sessionStorage;

    // Store indexed items in descending order by touched (oldest first, newest last). We'll use
    // this to remove older items when we run out of storage space.
    this._indexedItems = [];

    // Potentially restore a previously persisted index. This happens when
    // we re-open a closed tab.
    var persistedItemIndex = this._sessionStorage.getItem(HashedItemStore.PERSISTED_INDEX_KEY);
    if (persistedItemIndex) {
      this._indexedItems = (0, _lodash.sortBy)(JSON.parse(persistedItemIndex) || [], 'touched');
    }
  }

  _createClass(HashedItemStore, [{
    key: 'setItem',
    value: function setItem(hash, item) {
      var isItemPersisted = this._persistItem(hash, item);

      if (isItemPersisted) {
        this._touchHash(hash);
      }

      return isItemPersisted;
    }
  }, {
    key: 'getItem',
    value: function getItem(hash) {
      var item = this._sessionStorage.getItem(hash);

      if (item !== null) {
        this._touchHash(hash);
      }

      return item;
    }
  }, {
    key: '_getIndexedItem',
    value: function _getIndexedItem(hash) {
      return this._indexedItems.find(function (indexedItem) {
        return indexedItem.hash === hash;
      });
    }
  }, {
    key: '_persistItem',
    value: function _persistItem(hash, item) {
      try {
        this._sessionStorage.setItem(hash, item);
        return true;
      } catch (e) {
        // If there was an error then we need to make some space for the item.
        if (this._indexedItems.length === 0) {
          // If there's nothing left to remove, then we've run out of space and we're trying to
          // persist too large an item.
          return false;
        }

        // We need to try to make some space for the item by removing older items (i.e. items that
        // haven't been accessed recently).
        this._removeOldestItem();

        // Try to persist again.
        return this._persistItem(hash, item);
      }
    }
  }, {
    key: '_removeOldestItem',
    value: function _removeOldestItem() {
      var oldestIndexedItem = this._indexedItems.shift();
      // Remove oldest item from storage.
      this._sessionStorage.removeItem(oldestIndexedItem.hash);
    }
  }, {
    key: '_touchHash',
    value: function _touchHash(hash) {
      // Touching a hash indicates that it's been used recently, so it won't be the first in line
      // when we remove items to free up storage space.

      // either get or create an indexedItem
      var indexedItem = this._getIndexedItem(hash) || { hash: hash };

      // set/update the touched time to now so that it's the "newest" item in the index
      indexedItem.touched = Date.now();

      // ensure that the item is last in the index
      (0, _lodash.pull)(this._indexedItems, indexedItem);
      this._indexedItems.push(indexedItem);

      // Regardless of whether this is a new or updated item, we need to persist the index.
      this._sessionStorage.setItem(HashedItemStore.PERSISTED_INDEX_KEY, JSON.stringify(this._indexedItems));
    }
  }]);

  return HashedItemStore;
}();

HashedItemStore.PERSISTED_INDEX_KEY = 'kbn.hashedItemsIndex.v1';

/***/ }),
/* 1333 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createStateHash = createStateHash;
exports.isStateHash = isStateHash;

var _crypto = __webpack_require__(1334);

// This prefix is used to identify hash strings that have been encoded in the URL.
var HASH_PREFIX = 'h@';

function createStateHash(json, existingJsonProvider) {
  if (typeof json !== 'string') {
    throw new Error('createHash only accepts strings (JSON).');
  }

  var hash = new _crypto.Sha256().update(json, 'utf8').digest('hex');

  var shortenedHash = void 0;

  // Shorten the hash to at minimum 7 characters. We just need to make sure that it either:
  // a) hasn't been used yet
  // b) or has been used already, but with the JSON we're currently hashing.
  for (var i = 7; i < hash.length; i++) {
    shortenedHash = hash.slice(0, i);
    var existingJson = existingJsonProvider(shortenedHash);
    if (existingJson === null || existingJson === json) break;
  }

  return '' + HASH_PREFIX + shortenedHash;
}

function isStateHash(str) {
  return String(str).indexOf(HASH_PREFIX) === 0;
}

/***/ }),
/* 1334 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _sha = __webpack_require__(1335);

Object.defineProperty(exports, 'Sha256', {
  enumerable: true,
  get: function get() {
    return _sha.Sha256;
  }
});

/***/ }),
/* 1335 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// ported from https://github.com/spalger/sha.js/blob/6557630d508873e262e94bff70c50bdd797c1df7/sha256.js
// and https://github.com/spalger/sha.js/blob/6557630d508873e262e94bff70c50bdd797c1df7/hash.js

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 * Copyright (c) 2013-2014 sha.js contributors
 *
 * Permission is hereby granted, free of charge,
 * to any person obtaining a copy of this software and
 * associated documentation files (the "Software"), to
 * deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify,
 * merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom
 * the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice
 * shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

var K = [0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5, 0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174, 0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA, 0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967, 0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85, 0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070, 0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3, 0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2];

var W = new Array(64);

var Sha256 = exports.Sha256 = function () {
  function Sha256() {
    _classCallCheck(this, Sha256);

    this.init();

    this._w = W; // new Array(64)

    var blockSize = 64;
    var finalSize = 56;
    this._block = new Buffer(blockSize);
    this._finalSize = finalSize;
    this._blockSize = blockSize;
    this._len = 0;
    this._s = 0;
  }

  _createClass(Sha256, [{
    key: 'init',
    value: function init() {
      this._a = 0x6a09e667;
      this._b = 0xbb67ae85;
      this._c = 0x3c6ef372;
      this._d = 0xa54ff53a;
      this._e = 0x510e527f;
      this._f = 0x9b05688c;
      this._g = 0x1f83d9ab;
      this._h = 0x5be0cd19;

      return this;
    }
  }, {
    key: 'update',
    value: function update(data, enc) {
      if (typeof data === 'string') {
        enc = enc || 'utf8';
        data = new Buffer(data, enc);
      }

      var l = this._len += data.length;
      var s = this._s || 0;
      var f = 0;
      var buffer = this._block;

      while (s < l) {
        var t = Math.min(data.length, f + this._blockSize - s % this._blockSize);
        var _ch = t - f;

        for (var i = 0; i < _ch; i++) {
          buffer[s % this._blockSize + i] = data[i + f];
        }

        s += _ch;
        f += _ch;

        if (s % this._blockSize === 0) {
          this._update(buffer);
        }
      }
      this._s = s;

      return this;
    }
  }, {
    key: 'digest',
    value: function digest(enc) {
      // Suppose the length of the message M, in bits, is l
      var l = this._len * 8;

      // Append the bit 1 to the end of the message
      this._block[this._len % this._blockSize] = 0x80;

      // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
      this._block.fill(0, this._len % this._blockSize + 1);

      if (l % (this._blockSize * 8) >= this._finalSize * 8) {
        this._update(this._block);
        this._block.fill(0);
      }

      // to this append the block which is equal to the number l written in binary
      // TODO: handle case where l is > Math.pow(2, 29)
      this._block.writeInt32BE(l, this._blockSize - 4);

      var hash = this._update(this._block) || this._hash();

      return enc ? hash.toString(enc) : hash;
    }
  }, {
    key: '_update',
    value: function _update(M) {
      var W = this._w;

      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      var f = this._f | 0;
      var g = this._g | 0;
      var h = this._h | 0;

      var i = void 0;
      for (i = 0; i < 16; ++i) {
        W[i] = M.readInt32BE(i * 4);
      }for (; i < 64; ++i) {
        W[i] = gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16] | 0;
      }for (var j = 0; j < 64; ++j) {
        var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W[j] | 0;
        var T2 = sigma0(a) + maj(a, b, c) | 0;

        h = g;
        g = f;
        f = e;
        e = d + T1 | 0;
        d = c;
        c = b;
        b = a;
        a = T1 + T2 | 0;
      }

      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
      this._f = f + this._f | 0;
      this._g = g + this._g | 0;
      this._h = h + this._h | 0;
    }
  }, {
    key: '_hash',
    value: function _hash() {
      var H = new Buffer(32);

      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      H.writeInt32BE(this._h, 28);

      return H;
    }
  }]);

  return Sha256;
}();

function ch(x, y, z) {
  return z ^ x & (y ^ z);
}

function maj(x, y, z) {
  return x & y | z & (x | y);
}

function sigma0(x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
}

function sigma1(x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
}

function gamma0(x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
}

function gamma1(x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(114).Buffer))

/***/ }),
/* 1336 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _angular = __webpack_require__(16);

var _angular2 = _interopRequireDefault(_angular);

var _lodash = __webpack_require__(1);

var _modules = __webpack_require__(2);

var _notifier = __webpack_require__(43);

var _delayed_updater = __webpack_require__(1337);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana/config');

// service for delivering config variables to everywhere else
_module.service('config', function (Private, $rootScope, chrome, uiSettings) {
  var config = this;
  var notify = new _notifier.Notifier({ location: 'Config' });
  var defaults = uiSettings.defaults,
      initialUserSettings = uiSettings.user;

  var delayedUpdate = Private(_delayed_updater.ConfigDelayedUpdaterProvider);
  var settings = mergeSettings(defaults, initialUserSettings);

  config.getAll = function () {
    return (0, _lodash.cloneDeep)(settings);
  };
  config.get = function (key, defaultValue) {
    return getCurrentValue(key, defaultValue);
  };
  config.set = function (key, val) {
    return change(key, (0, _lodash.isPlainObject)(val) ? _angular2.default.toJson(val) : val);
  };
  config.remove = function (key) {
    return change(key, null);
  };
  config.isDeclared = function (key) {
    return key in settings;
  };
  config.isDefault = function (key) {
    return !config.isDeclared(key) || nullOrEmpty(settings[key].userValue);
  };
  config.isCustom = function (key) {
    return config.isDeclared(key) && !('value' in settings[key]);
  };
  config.watchAll = function (fn, scope) {
    return watchAll(scope, fn);
  };
  config.watch = function (key, fn, scope) {
    return watch(key, scope, fn);
  };

  /**
   * A little helper for binding config variables to $scopes
   *
   * @param  {Scope} $scope - an angular $scope object
   * @param  {string} key - the config key to bind to
   * @param  {string} [property] - optional property name where the value should
   *                             be stored. Defaults to the config key
   * @return {function} - an unbind function
   */
  config.bindToScope = function (scope, key) {
    var property = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : key;

    return watch(key, scope, update);
    function update(newVal) {
      scope[property] = newVal;
    }
  };

  function watch(key) {
    var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $rootScope;
    var fn = arguments[2];

    if (!config.isDeclared(key)) {
      throw new Error('Unexpected `config.watch("' + key + '", fn)` call on unrecognized configuration setting "' + key + '".\nSetting an initial value via `config.set("' + key + '", value)` before binding\nany custom setting configuration watchers for "' + key + '" may fix this issue.');
    }
    var newVal = config.get(key);
    var update = function update(e) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return fn.apply(undefined, args);
    };
    fn(newVal, null, key, config);
    return scope.$on('change:config.' + key, update);
  }

  function watchAll() {
    var scope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : $rootScope;
    var fn = arguments[1];

    var update = function update(e) {
      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return fn.apply(undefined, args);
    };
    fn(null, null, null, config);
    return scope.$on('change:config', update);
  }

  function change(key, value) {
    var declared = config.isDeclared(key);
    var oldVal = declared ? settings[key].userValue : undefined;
    var newVal = key in defaults && defaults[key].defaultValue === value ? null : value;
    var unchanged = oldVal === newVal;
    if (unchanged) {
      return Promise.resolve();
    }
    var initialVal = declared ? config.get(key) : undefined;
    localUpdate(key, newVal, initialVal);

    return delayedUpdate(key, newVal).then(function (updatedSettings) {
      settings = mergeSettings(defaults, updatedSettings);
    }).catch(function (reason) {
      localUpdate(key, initialVal, config.get(key));
      notify.error(reason);
    });
  }

  function localUpdate(key, newVal, oldVal) {
    patch(key, newVal);
    advertise(key, oldVal);
  }

  function patch(key, value) {
    if (!config.isDeclared(key)) {
      settings[key] = {};
    }
    if (value === null) {
      delete settings[key].userValue;
    } else {
      var type = settings[key].type;

      if (type === 'json' && typeof value !== 'string') {
        settings[key].userValue = _angular2.default.toJson(value);
      } else {
        settings[key].userValue = value;
      }
    }
  }

  function advertise(key, oldVal) {
    var newVal = config.get(key);
    notify.log('config change: ' + key + ': ' + oldVal + ' -> ' + newVal);
    $rootScope.$broadcast('change:config.' + key, newVal, oldVal, key, config);
    $rootScope.$broadcast('change:config', newVal, oldVal, key, config);
  }

  function nullOrEmpty(value) {
    return value === undefined || value === null;
  }

  function getCurrentValue(key, defaultValueForGetter) {
    if (!config.isDeclared(key)) {
      if (defaultValueForGetter === undefined) {
        throw new Error('Unexpected `config.get("' + key + '")` call on unrecognized configuration setting "' + key + '".\nSetting an initial value via `config.set("' + key + '", value)` before attempting to retrieve\nany custom setting value for "' + key + '" may fix this issue.\nYou can also save an step using `config.get("' + key + '", defaultValue)`, which\nwill set the initial value if one is not already set.');
      }
      config.set(key, defaultValueForGetter);
    }
    var _settings$key = settings[key],
        userValue = _settings$key.userValue,
        defaultValue = _settings$key.value,
        type = _settings$key.type;

    var currentValue = config.isDefault(key) ? defaultValue : userValue;
    if (type === 'json') {
      return JSON.parse(currentValue);
    } else if (type === 'number') {
      return parseFloat(currentValue);
    }
    return currentValue;
  }
});

function mergeSettings(extended, defaults) {
  return (0, _lodash.defaultsDeep)(extended, defaults);
}

/***/ }),
/* 1337 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.ConfigDelayedUpdaterProvider = ConfigDelayedUpdaterProvider;
function ConfigDelayedUpdaterProvider($http, chrome, Promise) {
  var unsavedChanges = {};
  var unresolvedPromises = [];
  var saveTimeout = null;

  return function delayedUpdate(key, value) {
    unsavedChanges[key] = value;

    return new Promise(saveSoon).then(function (res) {
      return res.data.settings;
    });
  };

  function saveSoon(resolve, reject) {
    if (saveTimeout) {
      clearTimeout(saveTimeout);
    }

    saveTimeout = setTimeout(fire, 200);
    unresolvedPromises.push({ resolve: resolve, reject: reject });
  }

  function fire() {
    var changes = unsavedChanges;
    var promises = unresolvedPromises;

    unresolvedPromises = [];
    unsavedChanges = {};

    persist(changes).then(function (result) {
      return settle(promises, 'resolve', result);
    }).catch(function (reason) {
      return settle(promises, 'reject', reason);
    });
  }

  function settle(listeners, decision, data) {
    listeners.forEach(function (listener) {
      return listener[decision](data);
    });
  }

  function persist(changes) {
    var keys = Object.keys(changes);
    if (keys.length === 1) {
      var _keys = _slicedToArray(keys, 1),
          key = _keys[0];

      var value = changes[key];
      var update = value === null ? remove : edit;
      return update(key, value);
    }
    return editMany(changes);
  }

  function remove(key) {
    return sync('delete', { postfix: '/' + key });
  }

  function edit(key, value) {
    return sync('post', { postfix: '/' + key, data: { value: value } });
  }

  function editMany(changes) {
    return sync('post', { data: { changes: changes } });
  }

  function sync(method) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$postfix = _ref.postfix,
        postfix = _ref$postfix === undefined ? '' : _ref$postfix,
        data = _ref.data;

    return $http({
      method: method,
      url: chrome.addBasePath('/api/kibana/settings' + postfix),
      data: data
    });
  }
}

/***/ }),
/* 1338 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TimefilterLibDiffTimeProvider = TimefilterLibDiffTimeProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _diff_time_picker_vals = __webpack_require__(678);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function TimefilterLibDiffTimeProvider(Private) {
  var diff = Private(_diff_time_picker_vals.UtilsDiffTimePickerValsProvider);

  return function (self) {
    var oldTime = _lodash2.default.clone(self.time);
    return function () {
      if (diff(self.time, oldTime)) {
        self.emit('update');
        self.emit('fetch');
      }
      oldTime = _lodash2.default.clone(self.time);
    };
  };
}

/***/ }),
/* 1339 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TimefilterLibDiffIntervalProvider = TimefilterLibDiffIntervalProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _diff_time_picker_vals = __webpack_require__(678);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function TimefilterLibDiffIntervalProvider(Private) {
  var diff = Private(_diff_time_picker_vals.UtilsDiffTimePickerValsProvider);

  return function (self) {
    var oldRefreshInterval = _lodash2.default.clone(self.refreshInterval);

    return function () {
      if (diff(self.refreshInterval, oldRefreshInterval)) {
        self.emit('update');
        if (!self.refreshInterval.pause && self.refreshInterval.value !== 0) {
          self.emit('fetch');
        }
      }

      oldRefreshInterval = _lodash2.default.clone(self.refreshInterval);
    };
  };
}

/***/ }),
/* 1340 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.uiRoutes = undefined;

var _route_manager = __webpack_require__(1341);

var _route_manager2 = _interopRequireDefault(_route_manager);

__webpack_require__(1345);

var _modules = __webpack_require__(2);

var _route_setup_manager = __webpack_require__(679);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultRouteManager = new _route_manager2.default();

var uiRoutes = exports.uiRoutes = Object.create(defaultRouteManager, {
  WAIT_FOR_URL_CHANGE_TOKEN: {
    value: _route_setup_manager.WAIT_FOR_URL_CHANGE_TOKEN
  },

  enable: {
    value: function value() {
      _modules.uiModules.get('kibana', ['ngRoute']).config(defaultRouteManager.config).run(defaultRouteManager.run);
    }
  }
});

/***/ }),
/* 1341 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = RouteManager;

var _lodash = __webpack_require__(1);

var _wrap_route_with_prep = __webpack_require__(1342);

var _route_setup_manager = __webpack_require__(679);

var _breadcrumbs = __webpack_require__(1344);

// eslint-disable-next-line @elastic/kibana-custom/no-default-export
function RouteManager() {
  var _this = this;

  var self = this;
  var setup = new _route_setup_manager.RouteSetupManager();
  var when = [];
  var defaults = [];
  var otherwise = void 0;

  self.config = function ($routeProvider) {
    when.forEach(function (args) {
      var path = args[0];
      var route = args[1] || {};

      defaults.forEach(function (def) {
        if (def.regex.test(path)) {
          (0, _lodash.defaultsDeep)(route, (0, _lodash.cloneDeep)(def.value));
        }
      });

      if (route.reloadOnSearch == null) {
        route.reloadOnSearch = false;
      }

      if (route.requireDefaultIndex == null) {
        route.requireDefaultIndex = false;
      }

      (0, _wrap_route_with_prep.wrapRouteWithPrep)(route, setup);
      $routeProvider.when(path, route);
    });

    if (otherwise) {
      (0, _wrap_route_with_prep.wrapRouteWithPrep)(otherwise, setup);
      $routeProvider.otherwise(otherwise);
    }
  };

  self.run = function ($location, $route, $injector) {
    self.getBreadcrumbs = function () {
      var breadcrumbs = (0, _breadcrumbs.parsePathToBreadcrumbs)($location.path());
      var map = $route.current.mapBreadcrumbs;
      return map ? $injector.invoke(map, null, { breadcrumbs: breadcrumbs }) : breadcrumbs;
    };
  };

  var wrapSetupAndChain = function wrapSetupAndChain(fn) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    fn.apply(setup, args);
    return _this;
  };

  this.addSetupWork = (0, _lodash.wrap)(setup.addSetupWork, wrapSetupAndChain);
  this.afterSetupWork = (0, _lodash.wrap)(setup.afterSetupWork, wrapSetupAndChain);
  this.afterWork = (0, _lodash.wrap)(setup.afterWork, wrapSetupAndChain);

  self.when = function (path, route) {
    when.push([path, route]);
    return self;
  };

  // before attaching the routes to the routeProvider, test the RE
  // against the .when() path and add/override the resolves if there is a match
  self.defaults = function (regex, value) {
    defaults.push({ regex: regex, value: value });
    return self;
  };

  self.otherwise = function (route) {
    otherwise = route;
    return self;
  };

  self.getBreadcrumbs = function () {
    // overwritten in self.run();
    return [];
  };

  self.RouteManager = RouteManager;
}
module.exports = exports['default'];

/***/ }),
/* 1342 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wrapRouteWithPrep = wrapRouteWithPrep;

var _angular = __webpack_require__(16);

var _angular2 = _interopRequireDefault(_angular);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _work_queue = __webpack_require__(1343);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function wrapRouteWithPrep(route, setup) {
  if (!route.resolve && route.redirectTo) return;

  var userWork = new _work_queue.WorkQueue();
  // the point at which we will consider the queue "full"
  userWork.limit = _lodash2.default.keys(route.resolve).length;

  var resolve = {
    __prep__: function __prep__($injector) {
      return $injector.invoke(setup.doWork, setup, { userWork: userWork });
    }
  };

  // send each user resolve to the userWork queue, which will prevent it from running before the
  // prep is complete
  _lodash2.default.forOwn(route.resolve || {}, function (expr, name) {
    resolve[name] = function ($injector, Promise) {
      var defer = Promise.defer();
      userWork.push(defer);
      return defer.promise.then(function () {
        return $injector[_angular2.default.isString(expr) ? 'get' : 'invoke'](expr);
      });
    };
  });

  // we're copied everything over so now overwrite
  route.resolve = resolve;
}

/***/ }),
/* 1343 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WorkQueue = WorkQueue;
function WorkQueue() {
  var q = this;

  var work = [];
  var fullDefers = [];

  q.limit = 0;
  Object.defineProperty(q, 'length', {
    get: function get() {
      return work.length;
    }
  });

  var resolve = function resolve(defers) {
    return defers.splice(0).map(function (defer) {
      return defer.resolve();
    });
  };

  var checkIfFull = function checkIfFull() {
    if (work.length >= q.limit && fullDefers.length) {
      resolve(fullDefers);
    }
  };

  q.resolveWhenFull = function (defer) {
    fullDefers.push(defer);
    checkIfFull();
  };

  q.doWork = function () {
    var resps = resolve(work);
    checkIfFull();
    return resps;
  };

  q.empty = function () {
    work.splice(0);
    checkIfFull();
  };

  q.push = function (defer) {
    work.push(defer);
    checkIfFull();
  };
}

/***/ }),
/* 1344 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parsePathToBreadcrumbs = parsePathToBreadcrumbs;

var _lodash = __webpack_require__(1);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 *  Take a path (from $location.path() usually) and parse
 *  it's segments into a list of breadcrumbs
 *
 *  @param  {string} path
 *  @return {Array<Breadcrumb>}
 */
function parsePathToBreadcrumbs(path) {
  return (0, _lodash.trim)(path, '/').split('/').reduce(function (acc, id, i, parts) {
    return [].concat(_toConsumableArray(acc), [{
      id: id,
      display: (0, _lodash.startCase)(id),
      href: i === 0 ? '#/' + id : acc[i - 1].href + '/' + id,
      current: i === parts.length - 1
    }]);
  }, []);
}

/***/ }),
/* 1345 */,
/* 1346 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.notify = undefined;

var _modules = __webpack_require__(2);

var _notifier = __webpack_require__(43);

__webpack_require__(438);

var _metadata = __webpack_require__(225);

var _module = _modules.uiModules.get('kibana/notify');
var notify = exports.notify = new _notifier.Notifier();

_module.factory('createNotifier', function () {
  return function (opts) {
    return new _notifier.Notifier(opts);
  };
});

_module.factory('Notifier', function () {
  return _notifier.Notifier;
});

// teach Notifier how to use angular interval services
_module.run(function (config, $interval, $compile) {
  _notifier.Notifier.applyConfig({
    setInterval: $interval,
    clearInterval: $interval.cancel
  });
  applyConfig(config);
  _notifier.Notifier.$compile = $compile;
});

// if kibana is not included then the notify service can't
// expect access to config (since it's dependent on kibana)
if (!!_metadata.metadata.kbnIndex) {
  __webpack_require__(301);
  _module.run(function (config) {
    config.watchAll(function () {
      return applyConfig(config);
    });
  });
}

function applyConfig(config) {
  _notifier.Notifier.applyConfig({
    bannerLifetime: config.get('notifications:lifetime:banner'),
    errorLifetime: config.get('notifications:lifetime:error'),
    warningLifetime: config.get('notifications:lifetime:warning'),
    infoLifetime: config.get('notifications:lifetime:info')
  });
  notify.banner(config.get('notifications:banner'));
}

window.onerror = function (err, url, line) {
  notify.fatal(new Error(err + ' (' + url + ':' + line + ')'));
  return true;
};

if (window.addEventListener) {
  var notifier = new _notifier.Notifier({
    location: 'Promise'
  });

  window.addEventListener('unhandledrejection', function (e) {
    notifier.log('Detected an unhandled Promise rejection.\n' + e.reason);
  });
}

/***/ }),
/* 1347 */
/***/ (function(module, exports) {

module.exports = "<div class=\"toaster-container\">\n  <ul class=\"toaster\">\n    <li ng-repeat=\"notif in list\" kbn-toast notif=\"notif\">\n      <div ng-class=\"notif.getAlertClass()\">\n\n        <span ng-show=\"notif.count > 1\" class=\"badge\">{{ notif.count }}</span>\n\n        <i ng-class=\"notif.getIconClass()\" tooltip=\"{{notif.title}}\"></i>\n\n        <kbn-truncated\n          ng-if=\"notif.content\"\n          source=\"{{notif.content | markdown}}\"\n          is-html=\"true\"\n          length=\"250\"\n          ng-class=\"notif.getToastMessageClass()\"\n        ></kbn-truncated>\n\n        <render-directive\n          ng-if=\"notif.directive\"\n          definition=\"notif.directive\"\n          notif=\"notif\"\n          ng-class=\"notif.getToastMessageClass()\"\n        ></render-directive>\n\n        <div class=\"kuiButtonGroup\" ng-class=\"notif.getButtonGroupClass()\">\n          <button\n            type=\"button\"\n            ng-if=\"notif.stack && !notif.showStack\"\n            class=\"kuiButton\"\n            ng-class=\"notif.getButtonClass()\"\n            ng-click=\"notif.cancelTimer(); notif.showStack = true\"\n          >\n            More Info\n          </button>\n          <button\n            type=\"button\"\n            ng-if=\"notif.stack && notif.showStack\"\n            class=\"kuiButton\"\n            ng-class=\"notif.getButtonClass()\"\n            ng-click=\"notif.showStack = false\"\n          >\n            Less Info\n          </button>\n          <button\n            data-test-subj=\"notifierDismissButton\"\n            type=\"button\"\n            ng-if=\"notif.accept\"\n            class=\"kuiButton\"\n            ng-class=\"notif.getButtonClass()\"\n            ng-click=\"notif.accept()\"\n          >\n            OK\n          </button>\n          <button\n            type=\"button\"\n            ng-if=\"notif.address\"\n            class=\"kuiButton\"\n            ng-class=\"notif.getButtonClass()\"\n            ng-click=\"notif.address()\"\n          >\n            Fix it\n          </button>\n          <button\n            type=\"button\"\n            class=\"kuiButton\"\n            ng-repeat=\"action in notif.customActions\"\n            ng-class=\"action.getButtonClass()\"\n            ng-click=\"action.callback()\"\n            ng-bind=\"action.key\"\n            data-test-subj=\"{{action.dataTestSubj}}\"\n          ></button>\n        </div>\n\n        <!-- Countdown badge -->\n        <button\n          type=\"button\"\n          ng-if=\"notif.isTimed()\"\n          class=\"toaster-countdown\"\n          ng-click=\"notif.cancelTimer()\"\n        >\n          <span\n            class=\"badge\"\n            hover-text=\"stop\"\n          >\n            {{notif.timeRemaining}}s\n          </span>\n        </button>\n      </div>\n\n      <div ng-if=\"notif.stack && notif.showStack\" ng-class=\"notif.getAlertClassStack()\">\n        <pre ng-repeat=\"stack in notif.stacks\" ng-bind=\"stack\"></pre>\n      </div>\n\n    </li>\n  </ul>\n</div>\n"

/***/ }),
/* 1348 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1349 */,
/* 1350 */,
/* 1351 */,
/* 1352 */,
/* 1353 */,
/* 1354 */,
/* 1355 */,
/* 1356 */,
/* 1357 */,
/* 1358 */,
/* 1359 */,
/* 1360 */,
/* 1361 */,
/* 1362 */,
/* 1363 */,
/* 1364 */,
/* 1365 */,
/* 1366 */,
/* 1367 */,
/* 1368 */,
/* 1369 */,
/* 1370 */,
/* 1371 */,
/* 1372 */,
/* 1373 */,
/* 1374 */,
/* 1375 */,
/* 1376 */,
/* 1377 */,
/* 1378 */,
/* 1379 */,
/* 1380 */,
/* 1381 */,
/* 1382 */,
/* 1383 */,
/* 1384 */,
/* 1385 */,
/* 1386 */,
/* 1387 */,
/* 1388 */,
/* 1389 */,
/* 1390 */,
/* 1391 */,
/* 1392 */,
/* 1393 */,
/* 1394 */,
/* 1395 */,
/* 1396 */,
/* 1397 */,
/* 1398 */,
/* 1399 */,
/* 1400 */,
/* 1401 */,
/* 1402 */,
/* 1403 */,
/* 1404 */,
/* 1405 */,
/* 1406 */,
/* 1407 */,
/* 1408 */,
/* 1409 */,
/* 1410 */,
/* 1411 */,
/* 1412 */,
/* 1413 */,
/* 1414 */
/***/ (function(module, exports) {

module.exports = "<span ng-if=\"!isHtml\">{{content}}</span>\n<span ng-if=\"isHtml\" ng-bind-html=\"content\"></span>\n<span ng-if=\"truncated\">\n  <a ng-click=\"toggle()\">{{action}}</a>\n</span>\n"

/***/ }),
/* 1415 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * # `Private()`
 * Private module loader, used to merge angular and require js dependency styles
 * by allowing a require.js module to export a single provider function that will
 * create a value used within an angular application. This provider can declare
 * angular dependencies by listing them as arguments, and can be require additional
 * Private modules.
 *
 * ## Define a private module provider:
 * ```js
 * export default function PingProvider($http) {
 *   this.ping = function () {
 *     return $http.head('/health-check');
 *   };
 * };
 * ```
 *
 * ## Require a private module:
 * ```js
 * export default function ServerHealthProvider(Private, Promise) {
 *   let ping = Private(require('ui/ping'));
 *   return {
 *     check: Promise.method(function () {
 *       let attempts = 0;
 *       return (function attempt() {
 *         attempts += 1;
 *         return ping.ping()
 *         .catch(function (err) {
 *           if (attempts < 3) return attempt();
 *         })
 *       }())
 *       .then(function () {
 *         return true;
 *       })
 *       .catch(function () {
 *         return false;
 *       });
 *     })
 *   }
 * };
 * ```
 *
 * # `Private.stub(provider, newInstance)`
 * `Private.stub()` replaces the instance of a module with another value. This is all we have needed until now.
 *
 * ```js
 * beforeEach(inject(function ($injector, Private) {
 *   Private.stub(
 *     // since this module just exports a function, we need to change
 *     // what Private returns in order to modify it's behavior
 *     require('ui/agg_response/hierarchical/_build_split'),
 *     sinon.stub().returns(fakeSplit)
 *   );
 * }));
 * ```
 *
 * # `Private.swap(oldProvider, newProvider)`
 * This new method does an 1-for-1 swap of module providers, unlike `stub()` which replaces a modules instance.
 * Pass the module you want to swap out, and the one it should be replaced with, then profit.
 *
 * Note: even though this example shows `swap()` being called in a config
 * function, it can be called from anywhere. It is particularly useful
 * in this scenario though.
 *
 * ```js
 * beforeEach(module('kibana', function (PrivateProvider) {
 *   PrivateProvider.swap(
 *     // since the courier is required automatically before the tests are loaded,
 *     // we can't stub it's internal components unless we do so before the
 *     // application starts. This is why angular has config functions
 *     require('ui/courier/_redirect_when_missing'),
 *     function StubbedRedirectProvider($decorate) {
 *       // $decorate is a function that will instantiate the original module when called
 *       return sinon.spy($decorate());
 *     }
 *   );
 * }));
 * ```
 *
 * @param {[type]} prov [description]
 */

var nextId = _lodash2.default.partial(_lodash2.default.uniqueId, 'privateProvider#');

function name(fn) {
  return fn.name || fn.toString().split('\n').shift();
}

_modules.uiModules.get('kibana/private').provider('Private', function () {
  var provider = this;

  // one cache/swaps per Provider
  var cache = {};
  var swaps = {};

  // return the uniq id for this function
  function identify(fn) {
    if (typeof fn !== 'function') {
      throw new TypeError('Expected private module "' + fn + '" to be a function');
    }

    if (fn.$$id) return fn.$$id;else return fn.$$id = nextId();
  }

  provider.stub = function (fn, instance) {
    cache[identify(fn)] = instance;
    return instance;
  };

  provider.swap = function (fn, prov) {
    var id = identify(fn);
    swaps[id] = prov;
  };

  provider.$get = ['$injector', function PrivateFactory($injector) {

    // prevent circular deps by tracking where we came from
    var privPath = [];
    var pathToString = function pathToString() {
      return privPath.map(name).join(' -> ');
    };

    // call a private provider and return the instance it creates
    function instantiate(prov, locals) {
      if (~privPath.indexOf(prov)) {
        throw new Error('Circular reference to "' + name(prov) + '"' + ' found while resolving private deps: ' + pathToString());
      }

      privPath.push(prov);

      var context = {};
      var instance = $injector.invoke(prov, context, locals);
      if (!_lodash2.default.isObject(instance)) instance = context;

      privPath.pop();
      return instance;
    }

    // retrieve an instance from cache or create and store on
    function get(id, prov, $delegateId, $delegateProv) {
      if (cache[id]) return cache[id];

      var instance = void 0;

      if ($delegateId != null && $delegateProv != null) {
        instance = instantiate(prov, {
          $decorate: _lodash2.default.partial(get, $delegateId, $delegateProv)
        });
      } else {
        instance = instantiate(prov);
      }

      return cache[id] = instance;
    }

    // main api, get the appropriate instance for a provider
    function Private(prov) {
      var id = identify(prov);
      var $delegateId = void 0;
      var $delegateProv = void 0;

      if (swaps[id]) {
        $delegateId = id;
        $delegateProv = prov;

        prov = swaps[$delegateId];
        id = identify(prov);
      }

      return get(id, prov, $delegateId, $delegateProv);
    }

    Private.stub = provider.stub;
    Private.swap = provider.swap;

    return Private;
  }];
});

/***/ }),
/* 1416 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');

// Provides a tiny subset of the excelent API from
// bluebird, reimplemented using the $q service
_module.service('Promise', function ($q, $timeout) {
  function Promise(fn) {
    if (typeof this === 'undefined') throw new Error('Promise constructor must be called with "new"');

    var defer = $q.defer();
    try {
      fn(defer.resolve, defer.reject);
    } catch (e) {
      defer.reject(e);
    }
    return defer.promise;
  }

  Promise.all = Promise.props = $q.all;
  Promise.resolve = function (val) {
    var defer = $q.defer();
    defer.resolve(val);
    return defer.promise;
  };
  Promise.reject = function (reason) {
    var defer = $q.defer();
    defer.reject(reason);
    return defer.promise;
  };
  Promise.cast = $q.when;
  Promise.defer = $q.defer;
  Promise.delay = function (ms) {
    return $timeout(_lodash2.default.noop, ms);
  };
  Promise.method = function (fn) {
    return function () {
      var args = Array.prototype.slice.call(arguments);
      return Promise.try(fn, args, this);
    };
  };
  Promise.nodeify = function (promise, cb) {
    promise.then(function (val) {
      cb(void 0, val);
    }, cb);
  };
  Promise.map = function (arr, fn) {
    return Promise.all(arr.map(function (i, el, list) {
      return Promise.try(fn, [i, el, list]);
    }));
  };
  Promise.each = function (arr, fn) {
    var queue = arr.slice(0);
    var i = 0;
    return function next() {
      if (!queue.length) return arr;
      return Promise.try(fn, [arr.shift(), i++]).then(next);
    }();
  };
  Promise.is = function (obj) {
    // $q doesn't create instances of any constructor, promises are just objects with a then function
    // https://github.com/angular/angular.js/blob/58f5da86645990ef984353418cd1ed83213b111e/src/ng/q.js#L335
    return obj && typeof obj.then === 'function';
  };
  Promise.halt = _lodash2.default.once(function () {
    var promise = new Promise(function () {});
    promise.then = _lodash2.default.constant(promise);
    promise.catch = _lodash2.default.constant(promise);
    return promise;
  });
  Promise.try = function (fn, args, ctx) {
    if (typeof fn !== 'function') {
      return Promise.reject(new TypeError('fn must be a function'));
    }

    var value = void 0;

    if (Array.isArray(args)) {
      try {
        value = fn.apply(ctx, args);
      } catch (e) {
        return Promise.reject(e);
      }
    } else {
      try {
        value = fn.call(ctx, args);
      } catch (e) {
        return Promise.reject(e);
      }
    }

    return Promise.resolve(value);
  };
  Promise.fromNode = function (takesCbFn) {
    return new Promise(function (resolve, reject) {
      takesCbFn(function (err) {
        for (var _len = arguments.length, results = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          results[_key - 1] = arguments[_key];
        }

        if (err) reject(err);else if (results.length > 1) resolve(results);else resolve(results[0]);
      });
    });
  };
  Promise.race = function (iterable) {
    return new Promise(function (resolve, reject) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var i = _step.value;

          Promise.resolve(i).then(resolve, reject);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    });
  };

  return Promise;
});

_module.factory('PromiseEmitter', function (Promise) {
  /**
   * Create a function that uses an "event" like pattern for promises.
   *
   * When a single argument is passed, this will behave just like calling `new Promise(fn)`,
   * but when a second arguemnt is passed, the fn will be used to recreate a promise eveytime
   * the previous is resolved. The following example demonstrates what this allows:
   *
   * When using `new Promise()` to create a promise, you can allow consumers to be
   * notified of a single change:
   * ```
   * obj.onUpdate= function() {
   *   // NOTE: we are NOT using `new Promise.emitter()` here
   *   return new Promise(function (resolve, reject) {
   *     // wait for the update...
   *     resolve();
   *   });
   * }
   * ```
   *
   * And the consumer can ask for continual updates be re-invoking the `.onChange()` method
   * every time a change occurs:
   * ```
   * obj.onChange().then(function useChanges(change) {
   *   // use changes...
   *   // then register to receive notifcation of the next change
   *   obj.onChange().then(useChanges);
   * });
   * ```
   *
   * But by defining obj.onChange using `new Promise.emitter`:
   * ```
   * obj.onChange = function (handler) {
   *   return new Promise.emitter(function (resolve, reject) {
   *     // wait for changes...
   *     resolve();
   *   });
   * };
   * ```
   *
   * The consumer can now simplify their code by passing the handler directly to `.onUpdate()`
   * and the boilerplate of recalling `.onUpdate()` will be handled for them.
   * ```
   * obj.onChanges(function useChanges(changes) {
   *   // use changes...
   * });
   * ```
   *
   * @param  {Function} fn - Used to init the promise, and call either
   *                       reject or resolve (passed as args)
   * @param  {Function} handler - A function that will be called every
   *                            time this promise is resolved
   *
   * @return {Promise}
   */
  function PromiseEmitter(fn, handler) {
    var prom = new Promise(fn);

    if (!handler) return prom;

    return prom.then(handler).then(function recurse() {
      return new PromiseEmitter(fn, handler);
    });
  }

  return PromiseEmitter;
});

/***/ }),
/* 1417 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Storage = Storage;

var _modules = __webpack_require__(2);

var _angular = __webpack_require__(16);

var _angular2 = _interopRequireDefault(_angular);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Storage(store) {
  var self = this;
  self.store = store;

  self.get = function (key) {
    try {
      return JSON.parse(self.store.getItem(key));
    } catch (e) {
      return null;
    }
  };

  self.set = function (key, value) {
    try {
      return self.store.setItem(key, _angular2.default.toJson(value));
    } catch (e) {
      return false;
    }
  };

  self.remove = function (key) {
    return self.store.removeItem(key);
  };

  self.clear = function () {
    return self.store.clear();
  };
}

var createService = function createService(type) {
  return function ($window) {
    return new Storage($window[type]);
  };
};

_modules.uiModules.get('kibana/storage').service('localStorage', createService('localStorage')).service('sessionStorage', createService('sessionStorage'));

/***/ }),
/* 1418 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_modules.uiModules.get('kibana').config(function ($provide) {

  $provide.decorator('$rootScope', function ($delegate) {
    /**
     * Watch multiple expressions with a single callback. Along
     * with making code simpler it also merges all of the watcher
     * handlers within a single tick.
     *
     * # expression format
     * expressions can be specified in one of the following ways:
     * 1. string that evaluates to a value on scope. Creates a regular $watch
     *    expression.
     *     'someScopeValue.prop' === $scope.$watch('someScopeValue.prop', fn);
     *
     * 2. #1 prefixed with '[]', which uses $watchCollection rather than $watch.
     *     '[]expr' === $scope.$watchCollection('expr', fn);
     *
     * 3. #1 prefixed with '=', which uses $watch with objectEquality turned on
     *     '=expr' === $scope.$watch('expr', fn, true);
     *
     * 4. a function that will be called, like a normal function water
     *
     * 5. an object with any of the properties:
     *   `get`: the getter called on each iteration
     *   `deep`: a flag to turn on objectEquality in $watch
     *   `fn`: the watch registration function ($scope.$watch or $scope.$watchCollection)
     *
     * @param  {array[string|function|obj]} expressions - the list of expressions to $watch
     * @param  {Function} fn - the callback function
     * @return {Function} - an unwatch function, just like the return value of $watch
     */
    $delegate.constructor.prototype.$watchMulti = function (expressions, fn) {
      if (!Array.isArray(expressions)) throw new TypeError('expected an array of expressions to watch');
      if (!_lodash2.default.isFunction(fn)) throw new TypeError('expected a function that is triggered on each watch');

      var $scope = this;
      var vals = new Array(expressions.length);
      var prev = new Array(expressions.length);
      var fire = false;
      var init = 0;
      var neededInits = expressions.length;

      // first, register all of the multi-watchers
      var unwatchers = expressions.map(function (expr, i) {
        expr = normalizeExpression($scope, expr);
        if (!expr) return;

        return expr.fn.call($scope, expr.get, function (newVal, oldVal) {
          if (newVal === oldVal) {
            init += 1;
          }

          vals[i] = newVal;
          prev[i] = oldVal;
          fire = true;
        }, expr.deep);
      });

      // then, the watcher that checks to see if any of
      // the other watchers triggered this cycle
      var flip = false;
      unwatchers.push($scope.$watch(function () {
        if (init < neededInits) return init;

        if (fire) {
          fire = false;
          flip = !flip;
        }
        return flip;
      }, function () {
        if (init < neededInits) return false;

        fn(vals.slice(0), prev.slice(0));
        vals.forEach(function (v, i) {
          prev[i] = v;
        });
      }));

      return _lodash2.default.partial(_lodash2.default.callEach, unwatchers);
    };

    function normalizeExpression($scope, expr) {
      if (!expr) return;
      var norm = {
        fn: $scope.$watch,
        deep: false
      };

      if (_lodash2.default.isFunction(expr)) return _lodash2.default.assign(norm, { get: expr });
      if (_lodash2.default.isObject(expr)) return _lodash2.default.assign(norm, expr);
      if (!_lodash2.default.isString(expr)) return;

      if (expr.substr(0, 2) === '[]') {
        return _lodash2.default.assign(norm, {
          fn: $scope.$watchCollection,
          get: expr.substr(2)
        });
      }

      if (expr.charAt(0) === '=') {
        return _lodash2.default.assign(norm, {
          deep: true,
          get: expr.substr(1)
        });
      }

      return _lodash2.default.assign(norm, { get: expr });
    }

    return $delegate;
  });
});

/***/ }),
/* 1419 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1420);

/***/ }),
/* 1420 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

_modules.uiModules.get('kibana').service('globalNavState', function (localStorage, $rootScope) {
  return {
    isOpen: function isOpen() {
      var isOpen = localStorage.get('kibana.isGlobalNavOpen');
      if (isOpen === null) {
        // The global nav should default to being open for the initial experience.
        return true;
      }
      return isOpen;
    },

    setOpen: function setOpen(isOpen) {
      localStorage.set('kibana.isGlobalNavOpen', isOpen);
      $rootScope.$broadcast('globalNavState:change');
      return isOpen;
    }
  };
});

/***/ }),
/* 1421 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initAngularApi = initAngularApi;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _url = __webpack_require__(71);

var _modules = __webpack_require__(2);

var _notifier = __webpack_require__(43);

var _error_url_overflow = __webpack_require__(1422);

var _directives = __webpack_require__(1429);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var URL_LIMIT_WARN_WITHIN = 1000;

function initAngularApi(chrome, internals) {
  chrome.getFirstPathSegment = _lodash2.default.noop;

  chrome.setupAngular = function () {
    var kibana = _modules.uiModules.get('kibana');

    _lodash2.default.forOwn(chrome.getInjected(), function (val, name) {
      kibana.value(name, val);
    });

    kibana.value('kbnVersion', internals.version).value('buildNum', internals.buildNum).value('buildSha', internals.buildSha).value('serverName', internals.serverName).value('uiSettings', internals.uiSettings).value('sessionId', Date.now()).value('chrome', chrome).value('esUrl', function () {
      var a = document.createElement('a');
      a.href = chrome.addBasePath('/elasticsearch');
      return a.href;
    }()).config(chrome.$setupXsrfRequestInterceptor).config(function ($compileProvider, $locationProvider) {
      if (!internals.devMode) {
        $compileProvider.debugInfoEnabled(false);
      }

      $locationProvider.hashPrefix('');
    }).run(function ($location, $rootScope, Private, config) {
      chrome.getFirstPathSegment = function () {
        return $location.path().split('/')[1];
      };

      var notify = new _notifier.Notifier();
      var urlOverflow = Private(_error_url_overflow.UrlOverflowServiceProvider);
      var check = function check() {
        // disable long url checks when storing state in session storage
        if (config.get('state:storeInSessionStorage')) return;
        if ($location.path() === '/error/url-overflow') return;

        try {
          if (urlOverflow.check($location.absUrl()) <= URL_LIMIT_WARN_WITHIN) {
            notify.directive({
              template: '\n                <p>\n                  The URL has gotten big and may cause Kibana\n                  to stop working. Please either enable the\n                  <code>state:storeInSessionStorage</code>\n                  option in the <a href="#/management/kibana/settings">advanced\n                  settings</a> or simplify the onscreen visuals.\n                </p>\n              '
            }, {
              type: 'error',
              actions: [{ text: 'close' }]
            });
          }
        } catch (e) {
          var _parseUrl = (0, _url.parse)(window.location.href),
              host = _parseUrl.host,
              path = _parseUrl.path,
              search = _parseUrl.search,
              protocol = _parseUrl.protocol;
          // rewrite the entire url to force the browser to reload and
          // discard any potentially unstable state from before


          window.location.href = (0, _url.format)({ host: host, path: path, search: search, protocol: protocol, hash: '#/error/url-overflow' });
        }
      };

      $rootScope.$on('$routeUpdate', check);
      $rootScope.$on('$routeChangeStart', check);
    });

    (0, _directives.directivesProvider)(chrome, internals);

    _modules.uiModules.link(kibana);
  };
}

/***/ }),
/* 1422 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UrlOverflowServiceProvider = undefined;

var _url_overflow_service = __webpack_require__(695);

Object.defineProperty(exports, 'UrlOverflowServiceProvider', {
  enumerable: true,
  get: function get() {
    return _url_overflow_service.UrlOverflowServiceProvider;
  }
});

__webpack_require__(1423);

/***/ }),
/* 1423 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _url_overflow_service = __webpack_require__(695);

Object.keys(_url_overflow_service).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _url_overflow_service[key];
    }
  });
});

var _routes = __webpack_require__(29);

var _routes2 = _interopRequireDefault(_routes);

var _url = __webpack_require__(170);

__webpack_require__(1427);

var _error_url_overflow = __webpack_require__(1428);

var _error_url_overflow2 = _interopRequireDefault(_error_url_overflow);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

_routes2.default.when('/error/url-overflow', {
  template: _error_url_overflow2.default,
  controllerAs: 'controller',
  controller: function OverflowController(Private, config, $scope) {
    _classCallCheck(this, OverflowController);

    var kbnUrl = Private(_url.KbnUrlProvider);
    var urlOverflow = Private(_url_overflow_service.UrlOverflowServiceProvider);

    if (!urlOverflow.get()) {
      kbnUrl.redirectPath('/');
      return;
    }

    this.url = urlOverflow.get();
    this.limit = urlOverflow.failLength();
    $scope.$on('$destroy', function () {
      return urlOverflow.clear();
    });
  }
});

/***/ }),
/* 1424 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KbnUrlProvider = KbnUrlProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

__webpack_require__(696);

__webpack_require__(697);

var _modules = __webpack_require__(2);

var _app_state = __webpack_require__(237);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_modules.uiModules.get('kibana/url').service('kbnUrl', function (Private) {
  return Private(KbnUrlProvider);
});

function KbnUrlProvider($injector, $location, $rootScope, $parse, Private) {
  /**
   *  the `kbnUrl` service was created to smooth over some of the
   *  inconsistent behavior that occurs when modifying the url via
   *  the `$location` api. In general it is recommended that you use
   *  the `kbnUrl` service any time you want to modify the url.
   *
   *  "features" that `kbnUrl` does it's best to guarantee, which
   *  are not guaranteed with the `$location` service:
   *   - calling `kbnUrl.change()` with a url that resolves to the current
   *     route will force a full transition (rather than just updating the
   *     properties of the $route object)
   *
   *  Additional features of `kbnUrl`
   *   - parameterized urls
   *   - easily include an app state with the url
   *
   *  @type {KbnUrl}
   */
  var self = this;

  /**
   * Navigate to a url
   *
   * @param  {String} url - the new url, can be a template. See #eval
   * @param  {Object} [paramObj] - optional set of parameters for the url template
   * @return {undefined}
   */
  self.change = function (url, paramObj, appState) {
    self._changeLocation('url', url, paramObj, false, appState);
  };

  /**
   * Same as #change except only changes the url's path,
   * leaving the search string and such intact
   *
   * @param  {String} path - the new path, can be a template. See #eval
   * @param  {Object} [paramObj] - optional set of parameters for the path template
   * @return {undefined}
   */
  self.changePath = function (path, paramObj) {
    self._changeLocation('path', path, paramObj);
  };

  /**
   * Same as #change except that it removes the current url from history
   *
   * @param  {String} url - the new url, can be a template. See #eval
   * @param  {Object} [paramObj] - optional set of parameters for the url template
   * @return {undefined}
   */
  self.redirect = function (url, paramObj, appState) {
    self._changeLocation('url', url, paramObj, true, appState);
  };

  /**
   * Same as #redirect except only changes the url's path,
   * leaving the search string and such intact
   *
   * @param  {String} path - the new path, can be a template. See #eval
   * @param  {Object} [paramObj] - optional set of parameters for the path template
   * @return {undefined}
   */
  self.redirectPath = function (path, paramObj) {
    self._changeLocation('path', path, paramObj, true);
  };

  /**
   * Evaluate a url template. templates can contain double-curly wrapped
   * expressions that are evaluated in the context of the paramObj
   *
   * @param  {String} template - the url template to evaluate
   * @param  {Object} [paramObj] - the variables to expose to the template
   * @return {String} - the evaluated result
   * @throws {Error} If any of the expressions can't be parsed.
   */
  self.eval = function (template, paramObj) {
    paramObj = paramObj || {};

    return template.replace(/\{\{([^\}]+)\}\}/g, function (match, expr) {
      // remove filters
      var key = expr.split('|')[0].trim();

      // verify that the expression can be evaluated
      var p = $parse(key)(paramObj);

      // if evaluation can't be made, throw
      if (_lodash2.default.isUndefined(p)) {
        throw new Error('Replacement failed, unresolved expression: ' + expr);
      }

      // append uriescape filter if not included
      if (expr.indexOf('uriescape') === -1) {
        expr += '|uriescape';
      }

      return $parse(expr)(paramObj);
    });
  };

  /**
   * convert an object's route to an href, compatible with
   * window.location.href= and <a href="">
   *
   * @param  {Object} obj - any object that list's it's routes at obj.routes{}
   * @param  {string} route - the route name
   * @return {string} - the computed href
   */
  self.getRouteHref = function (obj, route) {
    return '#' + self.getRouteUrl(obj, route);
  };

  /**
   * convert an object's route to a url, compatible with url.change() or $location.url()
   *
   * @param  {Object} obj - any object that list's it's routes at obj.routes{}
   * @param  {string} route - the route name
   * @return {string} - the computed url
   */
  self.getRouteUrl = function (obj, route) {
    var template = obj && obj.routes && obj.routes[route];
    if (template) return self.eval(template, obj);
  };

  /**
   * Similar to getRouteUrl, supports objects which list their routes,
   * and redirects to the named route. See #redirect
   *
   * @param  {Object} obj - any object that list's it's routes at obj.routes{}
   * @param  {string} route - the route name
   * @return {undefined}
   */
  self.redirectToRoute = function (obj, route) {
    self.redirect(self.getRouteUrl(obj, route));
  };

  /**
   * Similar to getRouteUrl, supports objects which list their routes,
   * and changes the url to the named route. See #change
   *
   * @param  {Object} obj - any object that list's it's routes at obj.routes{}
   * @param  {string} route - the route name
   * @return {undefined}
   */
  self.changeToRoute = function (obj, route) {
    self.change(self.getRouteUrl(obj, route));
  };

  /**
   * Removes the given parameter from the url. Does so without modifying the browser
   * history.
   * @param param
   */
  self.removeParam = function (param) {
    $location.search(param, null).replace();
  };

  /////
  // private api
  /////
  var reloading = void 0;

  self._changeLocation = function (type, url, paramObj, replace, appState) {
    var prev = {
      path: $location.path(),
      search: $location.search()
    };

    url = self.eval(url, paramObj);
    $location[type](url);
    if (replace) $location.replace();

    if (appState) {
      $location.search(appState.getQueryParamName(), appState.toQueryParam());
    }

    var next = {
      path: $location.path(),
      search: $location.search()
    };

    if ($injector.has('$route')) {
      var $route = $injector.get('$route');

      if (self._shouldForceReload(next, prev, $route)) {
        var _appState = Private(_app_state.AppStateProvider).getAppState();
        if (_appState) _appState.destroy();

        reloading = $rootScope.$on('$locationChangeSuccess', function () {
          // call the "unlisten" function returned by $on
          reloading();
          reloading = false;

          $route.reload();
        });
      }
    }
  };

  // determine if the router will automatically reload the route
  self._shouldForceReload = function (next, prev, $route) {
    if (reloading) return false;

    var route = $route.current && $route.current.$$route;
    if (!route) return false;

    // for the purposes of determining whether the router will
    // automatically be reloading, '' and '/' are equal
    var nextPath = next.path || '/';
    var prevPath = prev.path || '/';
    if (nextPath !== prevPath) return false;

    var reloadOnSearch = route.reloadOnSearch;
    var searchSame = _lodash2.default.isEqual(next.search, prev.search);
    return reloadOnSearch && searchSame || !reloadOnSearch;
  };
}

/***/ }),
/* 1425 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _events = __webpack_require__(133);

var _persisted_state = __webpack_require__(698);

var _modules = __webpack_require__(2);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @name AngularPersistedState
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Returns a PersistedState object which uses an EventEmitter instead of
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the SimpleEmitter. The EventEmitter adds digest loops every time a handler is called
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * so it's preferable to use this variation when a callback modifies angular UI.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * TODO: The handlers themselves should really be responsible for triggering digest loops
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * as opposed to having an all or nothing situation. A nice goal would be to get rid
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * of the EventEmitter entirely and require handlers that need it to trigger a digest loop
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * themselves. We can even supply a service to wrap the callbacks in a function that
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * would call the callback, and finish with a $rootScope.$apply().
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var _module = _modules.uiModules.get('kibana');

_module.factory('PersistedState', function ($injector) {
  var Private = $injector.get('Private');
  var Events = Private(_events.EventsProvider);

  // Extend PersistedState to override the EmitterClass class with
  // our Angular friendly version.
  return function (_PersistedState) {
    _inherits(AngularPersistedState, _PersistedState);

    function AngularPersistedState(value, path, parent, silent) {
      _classCallCheck(this, AngularPersistedState);

      return _possibleConstructorReturn(this, (AngularPersistedState.__proto__ || Object.getPrototypeOf(AngularPersistedState)).call(this, value, path, parent, silent, Events));
    }

    return AngularPersistedState;
  }(_persisted_state.PersistedState);
});

/***/ }),
/* 1426 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _modify_url = __webpack_require__(668);

Object.defineProperty(exports, 'modifyUrl', {
  enumerable: true,
  get: function get() {
    return _modify_url.modifyUrl;
  }
});

/***/ }),
/* 1427 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1428 */
/***/ (function(module, exports) {

module.exports = "<div class=\"app-container error-url-overflow-app\">\n  <h3>\n    <i aria-hidden=\"true\" class=\"fa fa-warning text-danger\"></i> Woah there!\n  </h3>\n  <p>\n    That's a big URL you have there. I have some unfortunate news: Your browser doesn't play nice with Kibana's bacon-double-cheese-burger-with-extra-fries sized URL. To keep you from running into problems Kibana limits URLs in your browser to {{controller.limit}} characters for your safety.\n  </p>\n\n  <h3>Ok, how do I fix this?</h3>\n  <p>This usually only happens with big, complex dashboards, so you have some options:</p>\n  <ol>\n    <li>Enable the <code>state:storeInSessionStorage</code> option in the <a href=\"#/management/kibana/settings\">advanced settings</a>. This will prevent the URLs from getting long, but makes them a bit less portable.</li>\n    <li>Remove some stuff from your dashboard. This will reduce the length of the URL and keep IE in a good place.</li>\n    <li>Don't use IE. Every other supported browser we know of doesn't have this limit.</li>\n  </ol>\n  <br>\n  <br>\n  <p><small>Foot note: Party size candy bars are tiny. Party size sub sandwiches are massive. Really makes you think.</small></p>\n</div>\n"

/***/ }),
/* 1429 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.directivesProvider = directivesProvider;

__webpack_require__(1430);

var _kbn_chrome = __webpack_require__(1442);

var _append_nav_controls = __webpack_require__(1451);

__webpack_require__(1455);

function directivesProvider(chrome, internals) {
  (0, _kbn_chrome.kbnChromeProvider)(chrome, internals);
  (0, _append_nav_controls.kbnAppendChromeNavControls)(chrome, internals);
}

/***/ }),
/* 1430 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1431);

/***/ }),
/* 1431 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1432);

__webpack_require__(1436);

var _global_nav = __webpack_require__(1440);

var _global_nav2 = _interopRequireDefault(_global_nav);

__webpack_require__(1441);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');

_module.directive('globalNav', function (globalNavState, chrome) {
  return {
    restrict: 'E',
    replace: true,
    scope: {
      chrome: '=',
      isVisible: '=',
      logoBrand: '=',
      smallLogoBrand: '=',
      appTitle: '='
    },
    template: _global_nav2.default,
    link: function link(scope) {
      // App switcher functionality.
      function updateGlobalNav() {
        var isOpen = globalNavState.isOpen();
        scope.isGlobalNavOpen = isOpen;
        scope.globalNavToggleButton = {
          classes: isOpen ? 'global-nav-link--close' : undefined,
          title: isOpen ? 'Collapse' : 'Expand',
          tooltipContent: isOpen ? 'Collapse side bar' : 'Expand side bar'
        };

        // Notify visualizations, e.g. the dashboard, that they should re-render.
        scope.$root.$broadcast('globalNav:update');
      }

      updateGlobalNav();

      scope.$root.$on('globalNavState:change', function () {
        updateGlobalNav();
      });

      scope.getHref = function (path) {
        return chrome.addBasePath(path);
      };

      scope.toggleGlobalNav = function (event) {
        event.preventDefault();
        globalNavState.setOpen(!globalNavState.isOpen());
      };
    }
  };
});

/***/ }),
/* 1432 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1433);

/***/ }),
/* 1433 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _dom_location = __webpack_require__(1434);

var _url = __webpack_require__(71);

var _modules = __webpack_require__(2);

var _app_switcher = __webpack_require__(1435);

var _app_switcher2 = _interopRequireDefault(_app_switcher);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_modules.uiModules.get('kibana').provider('appSwitcherEnsureNavigation', function () {
  var forceNavigation = false;

  this.forceNavigation = function (val) {
    forceNavigation = !!val;
  };

  this.$get = ['Private', function (Private) {
    var domLocation = Private(_dom_location.DomLocationProvider);

    return function (event, link) {
      if (link.disabled) {
        event.preventDefault();
      }

      if (!forceNavigation || event.isDefaultPrevented() || event.altKey || event.metaKey || event.ctrlKey) {
        return;
      }

      var toParsed = (0, _url.parse)(event.delegateTarget.href);
      var fromParsed = (0, _url.parse)(domLocation.href);
      var sameProto = toParsed.protocol === fromParsed.protocol;
      var sameHost = toParsed.host === fromParsed.host;
      var samePath = toParsed.path === fromParsed.path;

      if (sameProto && sameHost && samePath) {
        toParsed.hash && domLocation.reload();

        // event.preventDefault() keeps the browser from seeing the new url as an update
        // and even setting window.location does not mimic that behavior, so instead
        // we use stopPropagation() to prevent angular from seeing the click and
        // starting a digest cycle/attempting to handle it in the router.
        event.stopPropagation();
      }
    };
  }];
}).directive('appSwitcher', function () {
  return {
    restrict: 'E',
    scope: {
      chrome: '='
    },
    template: _app_switcher2.default,
    controllerAs: 'switcher',
    controller: function controller($scope, appSwitcherEnsureNavigation, globalNavState) {
      if (!$scope.chrome || !$scope.chrome.getNavLinks) {
        throw new TypeError('appSwitcher directive requires the "chrome" config-object');
      }

      this.links = $scope.chrome.getNavLinks();

      // links don't cause full-navigation events in certain scenarios
      // so we force them when needed
      this.ensureNavigation = appSwitcherEnsureNavigation;

      this.getTooltip = function (link) {
        // If the sidebar is open then we don't need to show the title because
        // it will already be visible.
        if (globalNavState.isOpen()) {
          return link.tooltip;
        }
        return link.tooltip ? link.title + ' - ' + link.tooltip : link.title;
      };
    }
  };
});

/***/ }),
/* 1434 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DomLocationProvider = DomLocationProvider;
function DomLocationProvider($window) {
  return {
    reload: function reload(forceFetch) {
      $window.location.reload(forceFetch);
    },

    get href() {
      return $window.location.href;
    },

    set href(val) {
      return $window.location.href = val;
    }
  };
}

/***/ }),
/* 1435 */
/***/ (function(module, exports) {

module.exports = "<global-nav-link\n  ng-repeat=\"link in switcher.links\"\n  ng-if=\"!link.hidden\"\n  is-active=\"link.active\"\n  is-disabled=\"link.disabled\"\n  tooltip-content=\"switcher.getTooltip(link)\"\n  on-click=\"switcher.ensureNavigation($event, link)\"\n  url=\"link.active ? link.url : (link.lastSubUrl || link.url)\"\n  icon=\"link.icon\"\n  label=\"link.title\"\n></global-nav-link>\n"

/***/ }),
/* 1436 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1437);

/***/ }),
/* 1437 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _global_nav_link = __webpack_require__(1438);

var _global_nav_link2 = _interopRequireDefault(_global_nav_link);

__webpack_require__(1439);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');

_module.directive('globalNavLink', function (chrome) {
  return {
    restrict: 'E',
    replace: true,
    scope: {
      isActive: '=',
      isDisabled: '=',
      tooltipContent: '=',
      onClick: '&',
      url: '=',
      kbnRoute: '=',
      icon: '=',
      label: '='
    },
    template: _global_nav_link2.default,
    link: function link(scope) {
      scope.getHref = function () {
        if (scope.url) {
          return scope.url;
        }

        if (scope.kbnRoute) {
          return chrome.addBasePath(scope.kbnRoute);
        }
      };
    }
  };
});

/***/ }),
/* 1438 */
/***/ (function(module, exports) {

module.exports = "<div\n  class=\"global-nav-link {{classes}}\"\n  ng-class=\"{ active: isActive, 'is-global-nav-link-disabled': isDisabled }\"\n  tooltip=\"{{ tooltipContent }}\"\n  tooltip-placement=\"right\"\n  tooltip-popup-delay=\"0\"\n  tooltip-append-to-body=\"1\"\n>\n  <a\n    class=\"global-nav-link__anchor\"\n    href=\"{{ getHref() }}\"\n    ng-click=\"onClick({ $event: $event })\"\n    data-test-subj=\"appLink\"\n    aria-label=\"{{::label}}\"\n  >\n    <div class=\"global-nav-link__icon\">\n      <img\n        ng-if=\"icon\"\n        class=\"global-nav-link__icon-image\"\n        kbn-src=\"{{ '/' + icon }}\"\n        aria-hidden=\"true\"\n      >\n\n      <span\n        ng-if=\"!icon\"\n        class=\"global-nav-link__icon-placeholder\"\n        data-test-subj=\"appLinkIconPlaceholder\"\n      >\n        {{ label[0] }}\n      </span>\n    </div>\n\n    <div class=\"global-nav-link__title\">\n      {{ label }}\n    </div>\n  </a>\n</div>\n"

/***/ }),
/* 1439 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1440 */
/***/ (function(module, exports) {

module.exports = "<nav\n  class=\"global-nav\"\n  ng-class=\"{'is-global-nav-open': isGlobalNavOpen}\"\n  ng-show=\"isVisible\"\n>\n\n  <!-- Logo -->\n  <div class=\"global-nav__logo\">\n    <a href=\"{{ getHref('/app/kibana#/home') }}\" data-test-subj=\"kibanaLogo\">\n      <li\n        ng-if=\"!logoBrand && !smallLogoBrand\"\n        aria-label=\"{{ appTitle }} Logo\"\n        class=\"logo kibana\"\n      ></li>\n\n      <li\n        ng-if=\"logoBrand\"\n        ng-style=\"{ 'background': logoBrand }\"\n        aria-label=\"{{ appTitle }} Logo\"\n        class=\"logo hidden-sm\"\n      ></li>\n\n      <li\n        ng-if=\"smallLogoBrand\"\n        ng-style=\"{ 'background': smallLogoBrand }\"\n        aria-label=\"{{ appTitle }} Logo\"\n        class=\"logo-small visible-sm hidden-xs\"\n      ></li>\n    </a>\n  </div>\n\n  <!-- Links -->\n  <div class=\"global-nav__links\">\n    <!-- Main apps -->\n    <div class=\"global-nav__links-section\">\n      <app-switcher\n        chrome=\"chrome\"\n      ></app-switcher>\n    </div>\n\n    <!-- Bottom button -->\n    <div class=\"global-nav__links-section\">\n      <div class=\"chrome-actions\" kbn-chrome-append-nav-controls></div>\n\n      <!-- Open/close sidebar -->\n      <global-nav-link\n        class=\"{{ globalNavToggleButton.classes }}\"\n        tooltip-content=\"globalNavToggleButton.tooltipContent\"\n        on-click=\"toggleGlobalNav($event)\"\n        icon=\"'plugins/kibana/assets/play-circle.svg'\"\n        label=\"globalNavToggleButton.title\"\n      ></global-nav-link>\n    </div>\n  </div>\n\n</nav>\n"

/***/ }),
/* 1441 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1442 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.kbnChromeProvider = kbnChromeProvider;

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

var _lodash = __webpack_require__(1);

__webpack_require__(1443);

var _modules = __webpack_require__(2);

var _system_api = __webpack_require__(1444);

var _state_hashing = __webpack_require__(446);

var _notify = __webpack_require__(62);

var _sub_url_route_filter = __webpack_require__(1449);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function kbnChromeProvider(chrome, internals) {

  _modules.uiModules.get('kibana').directive('kbnChrome', function () {
    return {
      template: function template() {
        var $content = (0, _jquery2.default)(__webpack_require__(1450));
        var $app = $content.find('.application');

        if (internals.rootController) {
          $app.attr('ng-controller', internals.rootController);
        }

        if (internals.rootTemplate) {
          $app.removeAttr('ng-view');
          $app.html(internals.rootTemplate);
        }

        return $content;
      },


      controllerAs: 'chrome',
      controller: function controller($scope, $rootScope, $location, $http, Private) {
        var getUnhashableStates = Private(_state_hashing.getUnhashableStatesProvider);

        // are we showing the embedded version of the chrome?
        if (Boolean($location.search().embed)) {
          internals.permanentlyHideChrome();
        }

        var subUrlRouteFilter = Private(_sub_url_route_filter.SubUrlRouteFilterProvider);

        function updateSubUrls() {
          var urlWithHashes = window.location.href;
          var urlWithStates = (0, _state_hashing.unhashUrl)(urlWithHashes, getUnhashableStates());
          internals.trackPossibleSubUrl(urlWithStates);
        }

        function onRouteChange($event) {
          if (subUrlRouteFilter($event)) {
            updateSubUrls();
          }
        }

        $rootScope.$on('$routeChangeSuccess', onRouteChange);
        $rootScope.$on('$routeUpdate', onRouteChange);
        updateSubUrls(); // initialize sub urls

        var allPendingHttpRequests = function allPendingHttpRequests() {
          return $http.pendingRequests;
        };
        var removeSystemApiRequests = function removeSystemApiRequests() {
          var pendingHttpRequests = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          return (0, _lodash.remove)(pendingHttpRequests, _system_api.isSystemApiRequest);
        };
        $scope.$watchCollection(allPendingHttpRequests, removeSystemApiRequests);

        // and some local values
        chrome.httpActive = $http.pendingRequests;
        $scope.notifList = _notify.notify._notifs;

        return chrome;
      }
    };
  });
}

/***/ }),
/* 1443 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1444 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _system_api = __webpack_require__(1445);

Object.defineProperty(exports, 'addSystemApiHeader', {
  enumerable: true,
  get: function get() {
    return _system_api.addSystemApiHeader;
  }
});
Object.defineProperty(exports, 'isSystemApiRequest', {
  enumerable: true,
  get: function get() {
    return _system_api.isSystemApiRequest;
  }
});

/***/ }),
/* 1445 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.addSystemApiHeader = addSystemApiHeader;
exports.isSystemApiRequest = isSystemApiRequest;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var SYSTEM_API_HEADER_NAME = 'kbn-system-api';

/**
 * Adds a custom header designating request as system API
 * @param originalHeaders Object representing set of headers
 * @return Object representing set of headers, with system API header added in
 */
function addSystemApiHeader(originalHeaders) {
  var systemApiHeaders = _defineProperty({}, SYSTEM_API_HEADER_NAME, true);
  return _extends({}, originalHeaders, systemApiHeaders);
}

/**
 * Returns true if request is a system API request; false otherwise
 *
 * @param request Object Request object created by $http service
 * @return true if request is a system API request; false otherwise
 */
function isSystemApiRequest(request) {
  return !!request.headers[SYSTEM_API_HEADER_NAME];
}

/***/ }),
/* 1446 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getUnhashableStatesProvider = getUnhashableStatesProvider;
function getUnhashableStatesProvider(getAppState, globalState) {
  return function getUnhashableStates() {
    return [getAppState(), globalState].filter(Boolean);
  };
}

/***/ }),
/* 1447 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hashUrl = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _encodeUriQuery = __webpack_require__(699);

var _encodeUriQuery2 = _interopRequireDefault(_encodeUriQuery);

var _risonNode = __webpack_require__(132);

var _risonNode2 = _interopRequireDefault(_risonNode);

var _url = __webpack_require__(71);

var _querystring = __webpack_require__(297);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var conservativeStringifyQuerystring = function conservativeStringifyQuerystring(query) {
  return (0, _querystring.stringify)(query, null, null, {
    encodeURIComponent: _encodeUriQuery2.default
  });
};

var hashStateInQuery = function hashStateInQuery(state, query) {
  var name = state.getQueryParamName();
  var value = query[name];
  if (!value) {
    return { name: name, value: value };
  }

  var decodedValue = _risonNode2.default.decode(value);
  var hashedValue = state.toQueryParam(decodedValue);
  return { name: name, value: hashedValue };
};

var hashStatesInQuery = function hashStatesInQuery(states, query) {
  var hashedQuery = states.reduce(function (result, state) {
    var _hashStateInQuery = hashStateInQuery(state, query),
        name = _hashStateInQuery.name,
        value = _hashStateInQuery.value;

    if (value) {
      result[name] = value;
    }
    return result;
  }, {});

  return _extends({}, query, hashedQuery);
};

var hashUrl = exports.hashUrl = function hashUrl(states, redirectUrl) {
  // we need states to proceed, throwing an error if we don't have any
  if (states === null || !states.length) {
    throw new Error('states parameter must be an Array with length greater than 0');
  }

  var parsedUrl = (0, _url.parse)(redirectUrl);
  // if we don't have a hash, we return the redirectUrl without hashing anything
  if (!parsedUrl.hash) {
    return redirectUrl;
  }

  // The URLs that we use aren't "conventional" and the hash is sometimes appearing before
  // the querystring, even though conventionally they appear after it. The parsedUrl
  // is the entire URL, and the parsedAppUrl is everything after the hash.
  //
  // EXAMPLE
  // parsedUrl: /app/kibana#/visualize/edit/somelongguid?g=()&a=()
  // parsedAppUrl: /visualize/edit/somelongguid?g=()&a=()
  var parsedAppUrl = (0, _url.parse)(parsedUrl.hash.slice(1), true);

  // the parsedAppUrl actually has the query that we care about
  var query = parsedAppUrl.query;

  var newQuery = hashStatesInQuery(states, query);

  var newHash = (0, _url.format)({
    search: conservativeStringifyQuerystring(newQuery),
    pathname: parsedAppUrl.pathname
  });

  return (0, _url.format)({
    hash: '#' + newHash,
    host: parsedUrl.host,
    search: parsedUrl.search,
    pathname: parsedUrl.pathname,
    protocol: parsedUrl.protocol
  });
};

/***/ }),
/* 1448 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.unhashUrl = unhashUrl;

var _url = __webpack_require__(71);

var _encodeUriQuery = __webpack_require__(699);

var _encodeUriQuery2 = _interopRequireDefault(_encodeUriQuery);

var _querystring = __webpack_require__(297);

var _unhash_query_string = __webpack_require__(700);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function unhashUrl(urlWithHashes, states) {
  if (!urlWithHashes) return urlWithHashes;

  var urlWithHashesParsed = (0, _url.parse)(urlWithHashes, true);
  if (!urlWithHashesParsed.hostname) {
    // passing a url like "localhost:5601" or "/app/kibana" should be prevented
    throw new TypeError('Only absolute urls should be passed to `unhashUrl()`. ' + 'Unable to detect url hostname.');
  }

  if (!urlWithHashesParsed.hash) return urlWithHashes;

  var appUrl = urlWithHashesParsed.hash.slice(1); // trim the #
  if (!appUrl) return urlWithHashes;

  var appUrlParsed = (0, _url.parse)(urlWithHashesParsed.hash.slice(1), true);
  if (!appUrlParsed.query) return urlWithHashes;

  var appQueryWithoutHashes = (0, _unhash_query_string.unhashQueryString)(appUrlParsed.query || {}, states);

  // encodeUriQuery implements the less-aggressive encoding done naturally by
  // the browser. We use it to generate the same urls the browser would
  var appQueryStringWithoutHashes = (0, _querystring.stringify)(appQueryWithoutHashes, null, null, {
    encodeURIComponent: _encodeUriQuery2.default
  });

  return (0, _url.format)(_extends({}, urlWithHashesParsed, {
    hash: (0, _url.format)({
      pathname: appUrlParsed.pathname,
      search: appQueryStringWithoutHashes
    })
  }));
}

/***/ }),
/* 1449 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SubUrlRouteFilterProvider = SubUrlRouteFilterProvider;
/**
 *  Creates a function that will be called on each route change
 *  to determine if the event should be used to update the last
 *  subUrl of chrome links/tabs
 *  @injected
 */
function SubUrlRouteFilterProvider($injector) {
  if (!$injector.has('$route')) {
    return function alwaysUpdate() {
      return true;
    };
  }

  var $route = $injector.get('$route');
  return function ignoreRedirectToRoutes() {
    return Boolean($route.current && !$route.current.redirectTo);
  };
}

/***/ }),
/* 1450 */
/***/ (function(module, exports) {

module.exports = "<div class=\"content\" chrome-context data-test-subj=\"kibanaChrome\">\n  <global-nav\n    chrome=\"chrome\"\n    data-test-subj=\"globalNav\"\n    is-visible=\"chrome.getVisible()\"\n    logo-brand=\"chrome.getBrand('logo')\"\n    small-logo-brand=\"chrome.getBrand('smallLogo')\"\n    app-title=\"chrome.getAppTitle()\"\n  ></global-nav>\n\n  <div class=\"app-wrapper\" ng-class=\"{ 'hidden-chrome': !chrome.getVisible() }\">\n    <div class=\"app-wrapper-panel\">\n      <kbn-notifications list=\"notifList\"></kbn-notifications>\n      <kbn-loading-indicator></kbn-loading-indicator>\n      <div\n        class=\"application\"\n        ng-class=\"'tab-' + chrome.getFirstPathSegment() + ' ' + chrome.getApplicationClasses()\"\n        ng-view\n      ></div>\n    </div>\n  </div>\n</div>\n"

/***/ }),
/* 1451 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.kbnAppendChromeNavControls = kbnAppendChromeNavControls;

var _chrome_nav_controls = __webpack_require__(1452);

var _modules = __webpack_require__(2);

function kbnAppendChromeNavControls() {

  _modules.uiModules.get('kibana').directive('kbnChromeAppendNavControls', function (Private) {
    return {
      template: function template($element) {
        var parts = [$element.html()];
        var controls = Private(_chrome_nav_controls.chromeNavControlsRegistry);

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = controls.inOrder[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var control = _step.value;

            parts.unshift('<!-- nav control ' + control.name + ' -->', control.template);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return parts.join('\n');
      }
    };
  });
}

/***/ }),
/* 1452 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.chromeNavControlsRegistry = undefined;

var _registry = __webpack_require__(63);

var chromeNavControlsRegistry = exports.chromeNavControlsRegistry = (0, _registry.uiRegistry)({
  name: 'chromeNavControls',
  order: ['order']
});

/***/ }),
/* 1453 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IndexedArray = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _inflector = __webpack_require__(1454);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var pathGetter = (0, _lodash2.default)(_lodash2.default.get).rearg(1, 0).ary(2);
var inflectIndex = (0, _inflector.inflector)('by');
var inflectOrder = (0, _inflector.inflector)('in', 'Order');

var CLEAR_CACHE = {};
var OPT_NAMES = ['index', 'group', 'order', 'initialSet', 'immutable'];

/**
 *  Generic extension of Array class, which will index (and reindex) the
 *  objects it contains based on their properties.
 *
 *  @param {Object} config describes the properties of this registry object
 *  @param {Array<string>} [config.index] a list of props/paths that should be used to index the docs.
 *  @param {Array<string>} [config.group] a list of keys/paths to group docs by.
 *  @param {Array<string>} [config.order] a list of keys/paths to order the keys by.
 *  @param {Array<any>} [config.initialSet] the initial dataset the IndexedArray should contain.
 *  @param {boolean} [config.immutable] a flag that hints to people reading the implementation that this IndexedArray
 *                                      should not be modified
 */

var IndexedArray = exports.IndexedArray = function () {
  function IndexedArray(config) {
    _classCallCheck(this, IndexedArray);

    config = _lodash2.default.pick(config || {}, OPT_NAMES);

    // use defineProperty so that value can't be changed
    Object.defineProperty(this, 'raw', { value: [] });

    this._indexNames = _lodash2.default.union(this._setupIndex(config.group, inflectIndex, _lodash2.default.organizeBy), this._setupIndex(config.index, inflectIndex, _lodash2.default.indexBy), this._setupIndex(config.order, inflectOrder, function (raw, pluckValue) {
      return [].concat(_toConsumableArray(raw)).sort(function (itemA, itemB) {
        var a = String(pluckValue(itemA));
        var b = String(pluckValue(itemB));
        return a.toLowerCase().localeCompare(b.toLowerCase());
      });
    }));

    if (config.initialSet) {
      this.push.apply(this, config.initialSet);
    }

    Object.defineProperty(this, 'immutable', { value: !!config.immutable });
  }

  /**
   * Remove items from this based on a predicate
   * @param {Function|Object|string} predicate - the predicate used to decide what is removed
   * @return {array} - the removed data
   */


  _createClass(IndexedArray, [{
    key: 'remove',
    value: function remove(predicate) {
      this._assertMutable('remove');
      var out = _lodash2.default.remove(this, predicate);
      _lodash2.default.remove(this.raw, predicate);
      this._clearIndices();
      return out;
    }

    /**
     * provide a hook for the JSON serializer
     * @return {array} - a plain, vanilla array with our same data
     */

  }, {
    key: 'toJSON',
    value: function toJSON() {
      return this.raw;
    }

    // wrappers for mutable Array methods

  }, {
    key: 'copyWithin',
    value: function copyWithin() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return this._mutation('copyWithin', args);
    }
  }, {
    key: 'fill',
    value: function fill() {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return this._mutation('fill', args);
    }
  }, {
    key: 'pop',
    value: function pop() {
      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return this._mutation('pop', args);
    }
  }, {
    key: 'push',
    value: function push() {
      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return this._mutation('push', args);
    }
  }, {
    key: 'reverse',
    value: function reverse() {
      for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      return this._mutation('reverse', args);
    }
  }, {
    key: 'shift',
    value: function shift() {
      for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      return this._mutation('shift', args);
    }
  }, {
    key: 'sort',
    value: function sort() {
      for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }

      return this._mutation('sort', args);
    }
  }, {
    key: 'splice',
    value: function splice() {
      for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }

      return this._mutation('splice', args);
    }
  }, {
    key: 'unshift',
    value: function unshift() {
      for (var _len9 = arguments.length, args = Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      }

      return this._mutation('unshift', args);
    }

    /**
     *  If this instance of IndexedArray is not mutable, throw an error
     *  @private
     *  @param  {String} methodName - user facing method name, for error message
     *  @return {undefined}
     */

  }, {
    key: '_assertMutable',
    value: function _assertMutable(methodName) {
      if (this.immutable) {
        throw new Error(methodName + '() is not allowed on immutable IndexedArray instances');
      }
    }

    /**
     *  Execute some mutable method from the Array prototype
     *  on the IndexedArray and this.raw
     *
     *  @private
     *  @param  {string} methodName
     *  @param  {Array<any>} args
     *  @return {any}
     */

  }, {
    key: '_mutation',
    value: function _mutation(methodName, args) {
      this._assertMutable(methodName);
      _get(IndexedArray.prototype.__proto__ || Object.getPrototypeOf(IndexedArray.prototype), methodName, this).apply(this, args);
      this._clearIndices();
      return _get(IndexedArray.prototype.__proto__ || Object.getPrototypeOf(IndexedArray.prototype), methodName, this).apply(this.raw, args);
    }

    /**
     * Create indices for a group of object properties. getters and setters are used to
     * read and control the indices.
     * @private
     * @param  {string[]} props   - the properties that should be used to index docs
     * @param  {function} inflect - a function that will be called with a property name, and
     *                            creates the public property at which the index will be exposed
     * @param  {function} op      - the function that will be used to create the indices, it is passed
     *                            the raw representaion of the registry, and a getter for reading the
     *                            right prop
     *
     * @returns {string[]}        - the public keys of all indices created
     */

  }, {
    key: '_setupIndex',
    value: function _setupIndex(props, inflect, op) {
      var _this = this;

      // shortcut for empty props
      if (!props || props.length === 0) return;

      return props.map(function (prop) {
        var indexName = inflect(prop);
        var getIndexValueFromItem = pathGetter.partial(prop).value();
        var cache = void 0;

        Object.defineProperty(_this, indexName, {
          enumerable: false,
          configurable: false,

          set: function set(val) {
            // can't set any value other than the CLEAR_CACHE constant
            if (val === CLEAR_CACHE) {
              cache = false;
            } else {
              throw new TypeError(indexName + ' can not be set, it is a computed index of values');
            }
          },
          get: function get() {
            if (!cache) {
              cache = op(_this.raw, getIndexValueFromItem);
            }

            return cache;
          }
        });

        return indexName;
      });
    }

    /**
     * Clear cached index/group/order caches so they will be recreated
     * on next access
     * @private
     * @return {undefined}
     */

  }, {
    key: '_clearIndices',
    value: function _clearIndices() {
      var _this2 = this;

      this._indexNames.forEach(function (name) {
        _this2[name] = CLEAR_CACHE;
      });
    }
  }]);

  return IndexedArray;
}();

// using traditional `extends Array` syntax doesn't work with babel
// See https://babeljs.io/docs/usage/caveats/


IndexedArray.OPT_NAMES = OPT_NAMES;
Object.setPrototypeOf(IndexedArray.prototype, Array.prototype);

/***/ }),
/* 1454 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inflector = inflector;

function upFirst(str, total) {
  return str.charAt(0).toUpperCase() + (total ? str.substr(1).toLowerCase() : str.substr(1));
}

function startsWith(str, test) {
  return str.substr(0, test.length).toLowerCase() === test.toLowerCase();
}

function endsWith(str, test) {
  var tooShort = str.length < test.length;
  if (tooShort) return;

  return str.substr(str.length - test.length).toLowerCase() === test.toLowerCase();
}

function inflector(prefix, postfix) {
  return function inflect(key) {
    var inflected = void 0;

    if (key.indexOf('.') !== -1) {
      inflected = key.split('.').map(function (step, i) {
        return i === 0 ? step : upFirst(step, true);
      }).join('');
    } else {
      inflected = key;
    }

    if (prefix && !startsWith(key, prefix)) {
      inflected = prefix + upFirst(inflected);
    }

    if (postfix && !endsWith(key, postfix)) {
      inflected = inflected + postfix;
    }

    return inflected;
  };
}

/***/ }),
/* 1455 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _loading_indicator = __webpack_require__(1456);

var _loading_indicator2 = _interopRequireDefault(_loading_indicator);

__webpack_require__(1457);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_modules.uiModules.get('ui/kibana').directive('kbnLoadingIndicator', function () {
  return {
    restrict: 'E',
    replace: true,
    template: _loading_indicator2.default
  };
});

/***/ }),
/* 1456 */
/***/ (function(module, exports) {

module.exports = "<div\n  class=\"loadingIndicator\"\n  ng-show=\"chrome.httpActive.length\"\n  data-test-subj=\"globalLoadingIndicator\"\n>\n  <div class=\"loadingIndicator__bar\"></div>\n</div>\n"

/***/ }),
/* 1457 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1458 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (chrome, internals) {

  if ((0, _lodash.get)(internals, 'app.navLink.url')) {
    internals.app.navLink.url = (0, _url.resolve)(window.location.href, internals.app.navLink.url);
  }

  internals.appUrlStore = internals.appUrlStore || window.sessionStorage;
  try {
    var verifySessionStorage = 'verify sessionStorage';
    internals.appUrlStore.setItem(verifySessionStorage, 1);
    internals.appUrlStore.removeItem(verifySessionStorage);
  } catch (error) {
    throw new Error('Kibana requires access to sessionStorage, and it looks like ' + 'your browser is restricting it. If you\'re ' + 'using Safari with private browsing enabled, you can solve this ' + 'problem by disabling private browsing, or by using another browser.');
  }

  /**
   * ui/chrome apps API
   *
   *   ui/chrome has some metadata about the current app, and enables the
   *   navbar link, a small grid to the left of the tabs, when there is more
   *   than one app installed.
   */

  chrome.setShowAppsLink = function (val) {
    internals.showAppsLink = !!val;
    return chrome;
  };

  chrome.getShowAppsLink = function () {
    return internals.showAppsLink == null ? internals.nav.length > 1 : internals.showAppsLink;
  };

  chrome.getKibanaVersion = function () {
    return internals.version;
  };

  chrome.getApp = function () {
    return (0, _lodash.clone)(internals.app);
  };

  chrome.getAppTitle = function () {
    return (0, _lodash.get)(internals, ['app', 'title']);
  };

  chrome.getAppUrl = function () {
    return (0, _lodash.get)(internals, ['app', 'navLink', 'url']);
  };

  chrome.getInjected = function (name, def) {
    if (name == null) return (0, _lodash.clone)(internals.vars) || {};
    return (0, _lodash.get)(internals.vars, name, def);
  };

  chrome.getLastUrlFor = function (appId) {
    return internals.appUrlStore.getItem('appLastUrl:' + appId);
  };

  chrome.setLastUrlFor = function (appId, url) {
    internals.appUrlStore.setItem('appLastUrl:' + appId, url);
  };
};

var _lodash = __webpack_require__(1);

var _url = __webpack_require__(71);

module.exports = exports['default'];

// eslint-disable-next-line @elastic/kibana-custom/no-default-export

/***/ }),
/* 1459 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (chrome, internals) {
  /**
   * ui/chrome Controls API
   *
   *   Exposes controls for the Kibana chrome
   *
   *   Visible
   *     determines if the Kibana chrome should be displayed
   */

  var permanentlyHideChrome = false;
  internals.permanentlyHideChrome = function () {
    permanentlyHideChrome = true;
    internals.visible = false;
  };

  chrome.getIsChromePermanentlyHidden = function () {
    return permanentlyHideChrome;
  };

  /**
   * @param {boolean} display - should the chrome be displayed
   * @return {chrome}
   */
  chrome.setVisible = function (display) {
    if (permanentlyHideChrome) {
      return chrome;
    }
    internals.visible = Boolean(display);
    return chrome;
  };

  /**
   * @return {boolean} - display state of the chrome
   */
  chrome.getVisible = function () {
    if (_lodash2.default.isUndefined(internals.visible)) return !permanentlyHideChrome;
    return internals.visible;
  };
};

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];

// eslint-disable-next-line @elastic/kibana-custom/no-default-export

/***/ }),
/* 1460 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initChromeNavApi = initChromeNavApi;

var _lodash = __webpack_require__(1);

var _prepend_path = __webpack_require__(701);

var _relative_to_absolute = __webpack_require__(1461);

var _absolute_to_parsed_url = __webpack_require__(702);

function initChromeNavApi(chrome, internals) {
  chrome.getNavLinks = function () {
    return internals.nav;
  };

  chrome.navLinkExists = function (id) {
    return !!internals.nav.find(function (link) {
      return link.id === id;
    });
  };

  chrome.getNavLinkById = function (id) {
    var navLink = internals.nav.find(function (link) {
      return link.id === id;
    });
    if (!navLink) {
      throw new Error('Nav link for id = ' + id + ' not found');
    }
    return navLink;
  };

  chrome.showOnlyById = function (id) {
    (0, _lodash.remove)(internals.nav, function (app) {
      return app.id !== id;
    });
  };

  chrome.getBasePath = function () {
    return internals.basePath || '';
  };

  /**
   *
   * @param url {string} a relative url. ex: /app/kibana#/management
   * @return {string} the relative url with the basePath prepended to it. ex: rkz/app/kibana#/management
   */
  chrome.addBasePath = function (url) {
    return (0, _prepend_path.prependPath)(url, chrome.getBasePath());
  };

  chrome.removeBasePath = function (url) {
    if (!internals.basePath) {
      return url;
    }

    var basePathRegExp = new RegExp('^' + internals.basePath);
    return url.replace(basePathRegExp, '');
  };

  function lastSubUrlKey(link) {
    return 'lastSubUrl:' + link.url;
  }

  function setLastUrl(link, url) {
    if (link.linkToLastSubUrl === false) {
      return;
    }

    link.lastSubUrl = url;
    internals.appUrlStore.setItem(lastSubUrlKey(link), url);
  }

  function refreshLastUrl(link) {
    link.lastSubUrl = internals.appUrlStore.getItem(lastSubUrlKey(link)) || link.lastSubUrl || link.url;
  }

  function injectNewGlobalState(link, fromAppId, newGlobalState) {
    var kibanaParsedUrl = (0, _absolute_to_parsed_url.absoluteToParsedUrl)(link.lastSubUrl, chrome.getBasePath());

    // don't copy global state if links are for different apps
    if (fromAppId !== kibanaParsedUrl.appId) return;

    kibanaParsedUrl.setGlobalState(newGlobalState);

    link.lastSubUrl = kibanaParsedUrl.getAbsoluteUrl();
  }

  /**
   * Clear last url for deleted saved objects to avoid loading pages with "Could not locate.."
   */
  chrome.untrackNavLinksForDeletedSavedObjects = function (deletedIds) {
    function urlContainsDeletedId(url) {
      var includedId = deletedIds.find(function (deletedId) {
        return url.includes(deletedId);
      });
      if (includedId === undefined) {
        return false;
      }
      return true;
    }

    internals.nav.forEach(function (link) {
      if (link.linkToLastSubUrl && urlContainsDeletedId(link.lastSubUrl)) {
        setLastUrl(link, link.url);
      }
    });
  };

  /**
   * Manually sets the last url for the given app. The last url for a given app is updated automatically during
   * normal page navigation, so this should only need to be called to insert a last url that was not actually
   * navigated to. For instance, when saving an object and redirecting to another page, the last url of the app
   * should be the saved instance, but because of the redirect to a different page (e.g. `Save and Add to Dashboard`
   * on visualize tab), it won't be tracked automatically and will need to be inserted manually. See
   * https://github.com/elastic/kibana/pull/11932 for more background on why this was added.
   * @param linkId {String} - an id that represents the navigation link.
   * @param kibanaParsedUrl {KibanaParsedUrl} the url to track
   */
  chrome.trackSubUrlForApp = function (linkId, kibanaParsedUrl) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = internals.nav[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var link = _step.value;

        if (link.id === linkId) {
          var absoluteUrl = kibanaParsedUrl.getAbsoluteUrl();
          setLastUrl(link, absoluteUrl);
          return;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  };

  internals.trackPossibleSubUrl = function (url) {
    var kibanaParsedUrl = (0, _absolute_to_parsed_url.absoluteToParsedUrl)(url, chrome.getBasePath());

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = internals.nav[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var link = _step2.value;

        link.active = url.startsWith(link.subUrlBase);
        if (link.active) {
          setLastUrl(link, url);
          continue;
        }

        refreshLastUrl(link);

        var newGlobalState = kibanaParsedUrl.getGlobalState();
        if (newGlobalState) {
          injectNewGlobalState(link, kibanaParsedUrl.appId, newGlobalState);
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  };

  internals.nav.forEach(function (link) {
    link.url = (0, _relative_to_absolute.relativeToAbsolute)(link.url);
    link.subUrlBase = (0, _relative_to_absolute.relativeToAbsolute)(link.subUrlBase);
  });

  // simulate a possible change in url to initialize the
  // link.active and link.lastUrl properties
  internals.trackPossibleSubUrl(document.location.href);
}

/***/ }),
/* 1461 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.relativeToAbsolute = relativeToAbsolute;
/**
 *
 * @param {string} url - a relative or root relative url.  If a relative path is given then the
 * absolute url returned will depend on the current page where this function is called from. For example
 * if you are on page "http://www.mysite.com/shopping/kids" and you pass this function "adults", you would get
 * back "http://www.mysite.com/shopping/adults".  If you passed this function a root relative path, or one that
 * starts with a "/", for example "/account/cart", you would get back "http://www.mysite.com/account/cart".
 * @return {string} the relative url transformed into an absolute url
 */
function relativeToAbsolute(url) {
  // convert all link urls to absolute urls
  var a = document.createElement('a');
  a.setAttribute('href', url);
  return a.href;
}

/***/ }),
/* 1462 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractAppPathAndId = extractAppPathAndId;

var _url = __webpack_require__(71);

/**
 * If the url is determined to contain an appId and appPath, it returns those portions. If it is not in the right
 * format and an appId and appPath can't be extracted, it returns an empty object.
 * @param {string} url - a relative or absolute url which contains an appPath, an appId, and optionally, a basePath.
 * @param {string} basePath - optional base path, if given should start with "/".
 */
function extractAppPathAndId(url) {
  var basePath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  var parsedUrl = (0, _url.parse)(url);
  if (!parsedUrl.path) {
    return {};
  }
  var pathWithoutBase = parsedUrl.path.slice(basePath.length);

  if (!pathWithoutBase.startsWith('/app/')) {
    return {};
  }

  var appPath = parsedUrl.hash && parsedUrl.hash.length > 0 ? parsedUrl.hash.slice(1) : '';
  return { appId: pathWithoutBase.slice('/app/'.length), appPath: appPath };
}

/***/ }),
/* 1463 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (chrome, internals) {

  /**
   * ui/chrome Template API
   *
   *   Root Template
   *     The root template is rendered within the primary chrome ui and should
   *     be used when building an app that is more of a page, or to override the
   *     placement of ng-view. When including a root template, the mark-up will
   *     look something like this:
   *
   *     body
   *       notifs
   *       div.content
   *         nav
   *         config
   *         div.application
   *           <-- your template here -->
   *
   *   Root Controller
   *     To attach a controller to the root of ui/chrome's content area, outside of
   *     where it attaches the ng-view directive (assuming no rootTemplate is used)
   *     which will allow cause the controller to persist across views or make for
   *     a simple place to define some quick global functionality for a very simple
   *     app (like the status page).
   */

  /**
   * @param {string} template
   * @return {chrome}
   */
  chrome.setRootTemplate = function (template) {
    internals.rootTemplate = template;
    return chrome;
  };

  /**
   * @param {string} as - the name that the controller should bind to
   * @param {Function} controller - the controller initializer function
   * @return {chrome}
   */
  chrome.setRootController = function (as, controllerName) {
    if (controllerName === undefined) {
      controllerName = as;
      as = null;
    }

    if (typeof controllerName === 'function') {
      chrome.$$rootControllerConstruct = controllerName;
      controllerName = 'chrome.$$rootControllerConstruct';
    }

    internals.rootController = controllerName + (as ? ' as ' + as : '');
    return chrome;
  };
};

module.exports = exports['default']; // eslint-disable-next-line @elastic/kibana-custom/no-default-export

/***/ }),
/* 1464 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (chrome, internals) {
  /**
   * ui/chrome Theme API
   *
   *   Logo
   *     Set the background for the logo and small logo in the navbar.
   *     When the app is in the "small" category, a modified version of the
   *     logo is displayed that is 45px wide.
   *     eg. 'url(/plugins/app/logo.png) center no-repeat'
   *
   *   Brand
   *     Similar to a logo, but is just text with styles to make it stick out.
   */

  /**
   * @param {string|object} item - brand key to set, or object to apply
   * @param {mixed} val - value to put on the brand item
   * @return {chrome}
   */
  chrome.setBrand = function (item, val) {
    internals.brand = internals.brand || {};

    // allow objects to be passed in
    if (_lodash2.default.isPlainObject(item)) {
      internals.brand = _lodash2.default.clone(item);
    } else {
      internals.brand[item] = val;
    }

    return chrome;
  };

  /**
   * @return {string} - the brand text
   */
  chrome.getBrand = function (item) {
    if (!internals.brand) return;
    return internals.brand[item];
  };

  /**
   * Adds a class to the application node
   * @param {string} - the class name to add
   * @return {chrome}
   */
  chrome.addApplicationClass = function (val) {
    var classes = internals.applicationClasses || [];
    classes.push(val);
    classes = _lodash2.default.uniq(classes);

    internals.applicationClasses = classes;
    return chrome;
  };

  /**
   * Removes a class from the application node. Note: this only
   * removes classes that were added via the addApplicationClass method
   * @param  {string|[string]} - class or classes to be removed
   * @return {chrome}
   */
  chrome.removeApplicationClass = function (val) {
    var classesToRemove = [].concat(val || []);
    var classes = internals.applicationClasses || [];
    _lodash2.default.pull.apply(_lodash2.default, [classes].concat(_toConsumableArray(classesToRemove)));

    internals.applicationClasses = classes;
    return chrome;
  };

  /**
   * @return {string} - a space delimited string of the classes added by the
   * addApplicationClass method
   */
  chrome.getApplicationClasses = function () {
    return internals.applicationClasses.join(' ');
  };
};

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

// eslint-disable-next-line @elastic/kibana-custom/no-default-export


module.exports = exports['default'];

/***/ }),
/* 1465 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (chrome, internals) {
  /**
   * ui/chrome Translations API
   *
   *   Translations
   *     Returns the translations which have been loaded by the Kibana server instance
   */

  /**
   * @return {Object} - Translations
   */
  chrome.getTranslations = function () {
    return internals.translations || [];
  };
};

module.exports = exports["default"]; // eslint-disable-next-line @elastic/kibana-custom/no-default-export

/***/ }),
/* 1466 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initChromeXsrfApi = initChromeXsrfApi;

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

var _lodash = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function initChromeXsrfApi(chrome, internals) {

  chrome.getXsrfToken = function () {
    return internals.version;
  };

  _jquery2.default.ajaxPrefilter(function (_ref, originalOptions, jqXHR) {
    var _ref$kbnXsrfToken = _ref.kbnXsrfToken,
        kbnXsrfToken = _ref$kbnXsrfToken === undefined ? true : _ref$kbnXsrfToken;

    if (kbnXsrfToken) {
      jqXHR.setRequestHeader('kbn-version', internals.version);
    }
  });

  chrome.$setupXsrfRequestInterceptor = function ($httpProvider) {
    $httpProvider.interceptors.push(function () {
      return {
        request: function request(opts) {
          var _opts$kbnXsrfToken = opts.kbnXsrfToken,
              kbnXsrfToken = _opts$kbnXsrfToken === undefined ? true : _opts$kbnXsrfToken;

          if (kbnXsrfToken) {
            (0, _lodash.set)(opts, ['headers', 'kbn-version'], internals.version);
          }
          return opts;
        }
      };
    });
  };
}

/***/ }),
/* 1467 */,
/* 1468 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerTheme = registerTheme;
exports.applyTheme = applyTheme;
exports.getCurrentTheme = getCurrentTheme;
var themes = {};
var currentTheme = undefined;

function registerTheme(theme, styles) {
  themes[theme] = styles;
}

function applyTheme(newTheme) {
  currentTheme = newTheme;

  var styleNode = document.getElementById('themeCss');

  if (styleNode) {
    var css = themes[currentTheme];

    if (styleNode.styleSheet) {
      styleNode.styleSheet.cssText = css;
    } else {
      styleNode.appendChild(document.createTextNode(css));
    }
  }
}

function getCurrentTheme() {
  return currentTheme;
}

/***/ }),
/* 1469 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1470 */,
/* 1471 */,
/* 1472 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./base.less": 1473,
	"./callout.less": 1474,
	"./config.less": 1475,
	"./control_group.less": 1476,
	"./dark-theme.less": 1477,
	"./dark-variables.less": 1478,
	"./hintbox.less": 1479,
	"./input.less": 1480,
	"./list-group-menu.less": 1481,
	"./local_search.less": 1482,
	"./navbar.less": 1483,
	"./pagination.less": 1484,
	"./pui_react.less": 1485,
	"./react-input-range.less": 1486,
	"./react-select.less": 1487,
	"./sidebar.less": 1488,
	"./spinner.less": 1489,
	"./table.less": 1490,
	"./theme.less": 1491,
	"./truncate.less": 1492,
	"./ui_select.less": 1493
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 1472;

/***/ }),
/* 1473 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1474 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1475 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1476 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1477 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1478 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1479 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1480 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1481 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1482 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1483 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1484 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1485 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1486 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1487 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1488 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1489 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1490 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1491 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1492 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1493 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1494 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _routes = __webpack_require__(29);

var _routes2 = _interopRequireDefault(_routes);

var _testbed = __webpack_require__(1495);

var _testbed2 = _interopRequireDefault(_testbed);

__webpack_require__(1496);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

_routes2.default.when('/testbed', {
  template: _testbed2.default,
  controllerAs: 'testbed',
  controller: function TestbedController() {
    _classCallCheck(this, TestbedController);
  }
});

/***/ }),
/* 1495 */
/***/ (function(module, exports) {

module.exports = "<div class=\"kuiViewContent\">\n  <div class=\"kuiViewContentItem\">\n\n  <pre ng-if=\"testbed.data\">{{ testbed.data }}</pre>\n\n    <!-- All markup within the CONTENT section below can be deleted and replaced with whatever markup you need to   demonstate your functionality. Nothing need be preserved. -->\n    <!-- CONTENT START -->\n\n    <!-- CONTENT END -->\n\n  </div>\n</div>\n"

/***/ }),
/* 1496 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1497 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Panel;
function Panel(name, config) {

  this.name = name;

  this.help = config.help || '';

  this.render = config.render;

  if (!config.render) throw new Error('Panel must have a rendering function');
}
module.exports = exports['default'];

/***/ }),
/* 1498 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = timechartFn;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

var _momentTimezone = __webpack_require__(447);

var _momentTimezone2 = _interopRequireDefault(_momentTimezone);

var _observe_resize = __webpack_require__(1501);

var _observe_resize2 = _interopRequireDefault(_observe_resize);

var _lib = __webpack_require__(1502);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

__webpack_require__(1505);
__webpack_require__(1513);


var DEBOUNCE_DELAY = 50;

function timechartFn(Private, config, $rootScope, timefilter, $compile) {
  return function () {
    return {
      help: 'Draw a timeseries chart',
      render: function render($scope, $elem) {
        var template = '<div class="chart-top-title"></div><div class="chart-canvas"></div>';
        var tickFormatters = __webpack_require__(1514)();
        var getxAxisFormatter = Private(__webpack_require__(1515));
        var generateTicks = Private(__webpack_require__(1516));

        // TODO: I wonder if we should supply our own moment that sets this every time?
        // could just use angular's injection to provide a moment service?
        _momentTimezone2.default.tz.setDefault(config.get('dateFormat:tz'));

        var render = $scope.seriesList.render || {};

        $scope.chart = $scope.seriesList.list;
        $scope.interval = $scope.interval;
        $scope.search = $scope.search || _lodash2.default.noop;

        var legendValueNumbers = void 0;
        var legendCaption = void 0;
        var debouncedSetLegendNumbers = _lodash2.default.debounce(setLegendNumbers, DEBOUNCE_DELAY, {
          maxWait: DEBOUNCE_DELAY,
          leading: true,
          trailing: false
        });
        // ensure legend is the same height with or without a caption so legend items do not move around
        var emptyCaption = '<br>';

        var defaultOptions = {
          xaxis: {
            mode: 'time',
            tickLength: 5,
            timezone: 'browser'
          },
          selection: {
            mode: 'x',
            color: '#ccc'
          },
          crosshair: {
            mode: 'x',
            color: '#C66',
            lineWidth: 2
          },
          grid: {
            show: render.grid,
            borderWidth: 0,
            borderColor: null,
            margin: 10,
            hoverable: true,
            autoHighlight: false
          },
          legend: {
            backgroundColor: null,
            position: 'nw',
            labelBoxBorderColor: 'rgb(255,255,255,0)',
            labelFormatter: function labelFormatter(label, series) {
              var wrapperSpan = document.createElement('span');
              var labelSpan = document.createElement('span');
              var numberSpan = document.createElement('span');

              wrapperSpan.setAttribute('class', 'ngLegendValue');
              wrapperSpan.setAttribute('kbn-accessible-click', '');
              wrapperSpan.setAttribute('ng-click', 'toggleSeries(' + series._id + ')');
              wrapperSpan.setAttribute('ng-focus', 'focusSeries(' + series._id + ')');
              wrapperSpan.setAttribute('ng-mouseover', 'highlightSeries(' + series._id + ')');

              labelSpan.setAttribute('ng-non-bindable', '');
              labelSpan.appendChild(document.createTextNode(label));
              numberSpan.setAttribute('class', 'ngLegendValueNumber');

              wrapperSpan.appendChild(labelSpan);
              wrapperSpan.appendChild(numberSpan);

              return wrapperSpan.outerHTML;
            }
          },
          colors: ['#01A4A4', '#C66', '#D0D102', '#616161', '#00A1CB', '#32742C', '#F18D05', '#113F8C', '#61AE24', '#D70060']
        };

        var originalColorMap = new Map();
        $scope.chart.forEach(function (series, seriesIndex) {
          if (!series.color) {
            var colorIndex = seriesIndex % defaultOptions.colors.length;
            series.color = defaultOptions.colors[colorIndex];
          }
          originalColorMap.set(series, series.color);
        });

        var hightlightedSeries = void 0;
        var focusedSeries = void 0;
        function unhighlightSeries() {
          if (hightlightedSeries === null) {
            return;
          }

          hightlightedSeries = null;
          focusedSeries = null;
          $scope.chart.forEach(function (series) {
            series.color = originalColorMap.get(series); // reset the colors
          });
          drawPlot($scope.chart);
        }
        $scope.highlightSeries = _lodash2.default.debounce(function (id) {
          if (hightlightedSeries === id) {
            return;
          }

          hightlightedSeries = id;
          $scope.chart.forEach(function (series, seriesIndex) {
            if (seriesIndex !== id) {
              series.color = 'rgba(128,128,128,0.1)'; // mark as grey
            } else {
              series.color = originalColorMap.get(series); // color it like it was
            }
          });
          drawPlot($scope.chart);
        }, DEBOUNCE_DELAY);
        $scope.focusSeries = function (id) {
          focusedSeries = id;
          $scope.highlightSeries(id);
        };

        $scope.toggleSeries = function (id) {
          var series = $scope.chart[id];
          series._hide = !series._hide;
          drawPlot($scope.chart);
        };

        var cancelResize = (0, _observe_resize2.default)($elem, function () {
          drawPlot($scope.chart);
        });

        $scope.$on('$destroy', function () {
          cancelResize();
          $elem.off('plothover');
          $elem.off('plotselected');
          $elem.off('mouseleave');
        });

        $elem.on('plothover', function (event, pos, item) {
          $rootScope.$broadcast('timelionPlotHover', event, pos, item);
        });

        $elem.on('plotselected', function (event, ranges) {
          timefilter.time.from = (0, _momentTimezone2.default)(ranges.xaxis.from);
          timefilter.time.to = (0, _momentTimezone2.default)(ranges.xaxis.to);
          timefilter.time.mode = 'absolute';
          $scope.$apply();
        });

        $elem.on('mouseleave', function () {
          $rootScope.$broadcast('timelionPlotLeave');
        });

        $scope.$on('timelionPlotHover', function (angularEvent, flotEvent, pos) {
          if (!$scope.plot) return;
          $scope.plot.setCrosshair(pos);
          debouncedSetLegendNumbers(pos);
        });

        $scope.$on('timelionPlotLeave', function () {
          if (!$scope.plot) return;
          $scope.plot.clearCrosshair();
          clearLegendNumbers();
        });

        // Shamelessly borrowed from the flotCrosshairs example
        function setLegendNumbers(pos) {
          unhighlightSeries();

          var plot = $scope.plot;

          var axes = plot.getAxes();
          if (pos.x < axes.xaxis.min || pos.x > axes.xaxis.max) {
            return;
          }

          var i = void 0;
          var j = void 0;
          var dataset = plot.getData();
          if (legendCaption) {
            legendCaption.text((0, _momentTimezone2.default)(pos.x).format(_lodash2.default.get(dataset, '[0]._global.legend.timeFormat', _lib.DEFAULT_TIME_FORMAT)));
          }
          for (i = 0; i < dataset.length; ++i) {

            var series = dataset[i];
            var precision = _lodash2.default.get(series, '_meta.precision', 2);

            if (series._hide) continue;

            // Nearest point
            for (j = 0; j < series.data.length; ++j) {
              if (series.data[j][0] > pos.x) break;
            }

            var y = void 0;
            try {
              y = series.data[j][1];
            } catch (e) {
              y = null;
            }

            if (y != null) {
              var label = y.toFixed(precision);
              if (series.yaxis.tickFormatter) {
                label = series.yaxis.tickFormatter(label, series.yaxis);
              }
              legendValueNumbers.eq(i).text('(' + label + ')');
            } else {
              legendValueNumbers.eq(i).empty();
            }
          }
        }

        function clearLegendNumbers() {
          if (legendCaption) {
            legendCaption.html(emptyCaption);
          }
          _lodash2.default.each(legendValueNumbers, function (num) {
            (0, _jquery2.default)(num).empty();
          });
        }

        var legendScope = $scope.$new();
        function drawPlot(plotConfig) {
          if (!(0, _jquery2.default)('.chart-canvas', $elem).length) $elem.html(template);
          var canvasElem = (0, _jquery2.default)('.chart-canvas', $elem);

          // we can't use `$.plot` to draw the chart when the height or width is 0
          // so, we'll need another event to trigger drawPlot to actually draw it
          if (canvasElem.height() === 0 || canvasElem.width() === 0) {
            return;
          }

          var title = (0, _lodash2.default)(plotConfig).map('_title').compact().last();
          (0, _jquery2.default)('.chart-top-title', $elem).text(title == null ? '' : title);

          var options = _lodash2.default.cloneDeep(defaultOptions);

          // Get the X-axis tick format
          var time = timefilter.getBounds();
          var interval = (0, _lib.calculateInterval)(time.min.valueOf(), time.max.valueOf(), config.get('timelion:target_buckets') || 200, $scope.interval, config.get('timelion:min_interval') || '1ms');
          var format = getxAxisFormatter(interval);

          // Use moment to format ticks so we get timezone correction
          options.xaxis.tickFormatter = function (val) {
            return (0, _momentTimezone2.default)(val).format(format);
          };

          // Calculate how many ticks can fit on the axis
          var tickLetterWidth = 7;
          var tickPadding = 45;
          options.xaxis.ticks = Math.floor($elem.width() / (format.length * tickLetterWidth + tickPadding));

          var series = _lodash2.default.map(plotConfig, function (series, index) {
            series = _lodash2.default.cloneDeep(_lodash2.default.defaults(series, {
              shadowSize: 0,
              lines: {
                lineWidth: 3
              }
            }));
            series._id = index;

            if (series.color) {
              var span = document.createElement('span');
              span.style.color = series.color;
              series.color = span.style.color;
            }

            if (series._hide) {
              series.data = [];
              series.stack = false;
              //series.color = "#ddd";
              series.label = '(hidden) ' + series.label;
            }

            if (series._global) {
              _lodash2.default.merge(options, series._global, function (objVal, srcVal) {
                // This is kind of gross, it means that you can't replace a global value with a null
                // best you can do is an empty string. Deal with it.
                if (objVal == null) return srcVal;
                if (srcVal == null) return objVal;
              });
            }

            return series;
          });

          if (options.yaxes) {
            options.yaxes.forEach(function (yaxis) {
              if (yaxis && yaxis.units) {
                yaxis.tickFormatter = tickFormatters[yaxis.units.type];
                var byteModes = ['bytes', 'bytes/s'];
                if (byteModes.includes(yaxis.units.type)) {
                  yaxis.tickGenerator = generateTicks;
                }
              }
            });
          }

          $scope.plot = _jquery2.default.plot(canvasElem, _lodash2.default.compact(series), options);

          if ($scope.plot) {
            $scope.$emit('timelionChartRendered');
          }

          legendScope.$destroy();
          legendScope = $scope.$new();
          // Used to toggle the series, and for displaying values on hover
          legendValueNumbers = canvasElem.find('.ngLegendValueNumber');
          _lodash2.default.each(canvasElem.find('.ngLegendValue'), function (elem) {
            $compile(elem)(legendScope);
          });

          if (_lodash2.default.get($scope.plot.getData(), '[0]._global.legend.showTime', true)) {
            legendCaption = (0, _jquery2.default)('<caption class="timelionLegendCaption"></caption>');
            legendCaption.html(emptyCaption);
            canvasElem.find('div.legend table').append(legendCaption);

            // legend has been re-created. Apply focus on legend element when previously set
            if (focusedSeries || focusedSeries === 0) {
              var $legendLabels = canvasElem.find('div.legend table .legendLabel>span');
              $legendLabels.get(focusedSeries).focus();
            }
          }
        }
        $scope.$watch('chart', drawPlot);
      }
    };
  };
}
module.exports = exports['default'];

/***/ }),
/* 1499 */,
/* 1500 */,
/* 1501 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function ($elem, fn, frequency) {

  frequency = frequency || 500;
  var currentHeight = $elem.height();
  var currentWidth = $elem.width();

  var timeout = void 0;

  function checkLoop() {
    timeout = setTimeout(function () {
      if (currentHeight !== $elem.height() || currentWidth !== $elem.width()) {
        currentHeight = $elem.height();
        currentWidth = $elem.width();

        if (currentWidth > 0 && currentWidth > 0) fn();
      }
      checkLoop();
    }, frequency);
  }

  checkLoop();

  return function () {
    clearTimeout(timeout);
  };
};

module.exports = exports["default"];

/***/ }),
/* 1502 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _calculate_interval = __webpack_require__(1503);

Object.defineProperty(exports, 'calculateInterval', {
  enumerable: true,
  get: function get() {
    return _calculate_interval.calculateInterval;
  }
});
var DEFAULT_TIME_FORMAT = exports.DEFAULT_TIME_FORMAT = 'MMMM Do YYYY, HH:mm:ss.SSS';

/***/ }),
/* 1503 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateInterval = calculateInterval;

var _to_milliseconds = __webpack_require__(1504);

var _to_milliseconds2 = _interopRequireDefault(_to_milliseconds);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Totally cribbed this from Kibana 3.
// I bet there's something similar in the Kibana 4 code. Somewhere. Somehow.
function roundInterval(interval) {
  switch (true) {
    case interval <= 500:
      // <= 0.5s
      return '100ms';
    case interval <= 5000:
      // <= 5s
      return '1s';
    case interval <= 7500:
      // <= 7.5s
      return '5s';
    case interval <= 15000:
      // <= 15s
      return '10s';
    case interval <= 45000:
      // <= 45s
      return '30s';
    case interval <= 180000:
      // <= 3m
      return '1m';
    case interval <= 450000:
      // <= 9m
      return '5m';
    case interval <= 1200000:
      // <= 20m
      return '10m';
    case interval <= 2700000:
      // <= 45m
      return '30m';
    case interval <= 7200000:
      // <= 2h
      return '1h';
    case interval <= 21600000:
      // <= 6h
      return '3h';
    case interval <= 86400000:
      // <= 24h
      return '12h';
    case interval <= 604800000:
      // <= 1w
      return '24h';
    case interval <= 1814400000:
      // <= 3w
      return '1w';
    case interval < 3628800000:
      // <  2y
      return '30d';
    default:
      return '1y';
  }
}

function calculateInterval(from, to, size, interval, min) {
  if (interval !== 'auto') return interval;
  var dateMathInterval = roundInterval((to - from) / size);
  if ((0, _to_milliseconds2.default)(dateMathInterval) < (0, _to_milliseconds2.default)(min)) return min;
  return dateMathInterval;
}

/***/ }),
/* 1504 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (expr) {
  var match = expr.match(parseRE);
  if (match) {
    if (match[2] === 'M' && match[1] !== '1') {
      throw new Error('Invalid interval. 1M is only valid monthly interval.');
    }

    return parseFloat(match[1] || 1) * vals[match[2]];
  }
};

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// map of moment's short/long unit ids and elasticsearch's long unit ids
// to their value in milliseconds
var vals = _lodash2.default.transform([['ms', 'milliseconds', 'millisecond'], ['s', 'seconds', 'second', 'sec'], ['m', 'minutes', 'minute', 'min'], ['h', 'hours', 'hour'], ['d', 'days', 'day'], ['w', 'weeks', 'week'], ['M', 'months', 'month'], ['quarter'], ['y', 'years', 'year']], function (vals, units) {
  var normal = _moment2.default.normalizeUnits(units[0]);
  var val = _moment2.default.duration(1, normal).asMilliseconds();
  [].concat(normal, units).forEach(function (unit) {
    vals[unit] = val;
  });
}, {});
// match any key from the vals object prececed by an optional number
var parseRE = new RegExp('^(\\d+(?:\\.\\d*)?)?\\s*(' + _lodash2.default.keys(vals).join('|') + ')$');

module.exports = exports['default'];

/***/ }),
/* 1505 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1506);
__webpack_require__(1507);
__webpack_require__(1508);
__webpack_require__(1509);
__webpack_require__(1510);
__webpack_require__(1511);
__webpack_require__(1512);

/***/ }),
/* 1506 */
/***/ (function(module, exports) {

/* Javascript plotting library for jQuery, version 0.8.3.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

*/

// first an inline dependency, jquery.colorhelpers.js, we inline it here
// for convenience

/* Plugin for jQuery for working with colors.
 *
 * Version 1.1.
 *
 * Inspiration from jQuery color animation plugin by John Resig.
 *
 * Released under the MIT license by Ole Laursen, October 2009.
 *
 * Examples:
 *
 *   $.color.parse("#fff").scale('rgb', 0.25).add('a', -0.5).toString()
 *   var c = $.color.extract($("#mydiv"), 'background-color');
 *   console.log(c.r, c.g, c.b, c.a);
 *   $.color.make(100, 50, 25, 0.4).toString() // returns "rgba(100,50,25,0.4)"
 *
 * Note that .scale() and .add() return the same modified object
 * instead of making a new one.
 *
 * V. 1.1: Fix error handling so e.g. parsing an empty string does
 * produce a color rather than just crashing.
 */
(function($){$.color={};$.color.make=function(r,g,b,a){var o={};o.r=r||0;o.g=g||0;o.b=b||0;o.a=a!=null?a:1;o.add=function(c,d){for(var i=0;i<c.length;++i)o[c.charAt(i)]+=d;return o.normalize()};o.scale=function(c,f){for(var i=0;i<c.length;++i)o[c.charAt(i)]*=f;return o.normalize()};o.toString=function(){if(o.a>=1){return"rgb("+[o.r,o.g,o.b].join(",")+")"}else{return"rgba("+[o.r,o.g,o.b,o.a].join(",")+")"}};o.normalize=function(){function clamp(min,value,max){return value<min?min:value>max?max:value}o.r=clamp(0,parseInt(o.r),255);o.g=clamp(0,parseInt(o.g),255);o.b=clamp(0,parseInt(o.b),255);o.a=clamp(0,o.a,1);return o};o.clone=function(){return $.color.make(o.r,o.b,o.g,o.a)};return o.normalize()};$.color.extract=function(elem,css){var c;do{c=elem.css(css).toLowerCase();if(c!=""&&c!="transparent")break;elem=elem.parent()}while(elem.length&&!$.nodeName(elem.get(0),"body"));if(c=="rgba(0, 0, 0, 0)")c="transparent";return $.color.parse(c)};$.color.parse=function(str){var res,m=$.color.make;if(res=/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10));if(res=/rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10),parseFloat(res[4]));if(res=/rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55);if(res=/rgba\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55,parseFloat(res[4]));if(res=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str))return m(parseInt(res[1],16),parseInt(res[2],16),parseInt(res[3],16));if(res=/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str))return m(parseInt(res[1]+res[1],16),parseInt(res[2]+res[2],16),parseInt(res[3]+res[3],16));var name=$.trim(str).toLowerCase();if(name=="transparent")return m(255,255,255,0);else{res=lookupColors[name]||[0,0,0];return m(res[0],res[1],res[2])}};var lookupColors={aqua:[0,255,255],azure:[240,255,255],beige:[245,245,220],black:[0,0,0],blue:[0,0,255],brown:[165,42,42],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgrey:[169,169,169],darkgreen:[0,100,0],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkviolet:[148,0,211],fuchsia:[255,0,255],gold:[255,215,0],green:[0,128,0],indigo:[75,0,130],khaki:[240,230,140],lightblue:[173,216,230],lightcyan:[224,255,255],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightyellow:[255,255,224],lime:[0,255,0],magenta:[255,0,255],maroon:[128,0,0],navy:[0,0,128],olive:[128,128,0],orange:[255,165,0],pink:[255,192,203],purple:[128,0,128],violet:[128,0,128],red:[255,0,0],silver:[192,192,192],white:[255,255,255],yellow:[255,255,0]}})(jQuery);

// the actual Flot code
(function($) {

	// Cache the prototype hasOwnProperty for faster access

	var hasOwnProperty = Object.prototype.hasOwnProperty;

    // A shim to provide 'detach' to jQuery versions prior to 1.4.  Using a DOM
    // operation produces the same effect as detach, i.e. removing the element
    // without touching its jQuery data.

    // Do not merge this into Flot 0.9, since it requires jQuery 1.4.4+.

    if (!$.fn.detach) {
        $.fn.detach = function() {
            return this.each(function() {
                if (this.parentNode) {
                    this.parentNode.removeChild( this );
                }
            });
        };
    }

	///////////////////////////////////////////////////////////////////////////
	// The Canvas object is a wrapper around an HTML5 <canvas> tag.
	//
	// @constructor
	// @param {string} cls List of classes to apply to the canvas.
	// @param {element} container Element onto which to append the canvas.
	//
	// Requiring a container is a little iffy, but unfortunately canvas
	// operations don't work unless the canvas is attached to the DOM.

	function Canvas(cls, container) {

		var element = container.children("." + cls)[0];

		if (element == null) {

			element = document.createElement("canvas");
			element.className = cls;

			$(element).css({ direction: "ltr", position: "absolute", left: 0, top: 0 })
				.appendTo(container);

			// If HTML5 Canvas isn't available, fall back to [Ex|Flash]canvas

			if (!element.getContext) {
				if (window.G_vmlCanvasManager) {
					element = window.G_vmlCanvasManager.initElement(element);
				} else {
					throw new Error("Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.");
				}
			}
		}

		this.element = element;

		var context = this.context = element.getContext("2d");

		// Determine the screen's ratio of physical to device-independent
		// pixels.  This is the ratio between the canvas width that the browser
		// advertises and the number of pixels actually present in that space.

		// The iPhone 4, for example, has a device-independent width of 320px,
		// but its screen is actually 640px wide.  It therefore has a pixel
		// ratio of 2, while most normal devices have a ratio of 1.

		var devicePixelRatio = window.devicePixelRatio || 1,
			backingStoreRatio =
				context.webkitBackingStorePixelRatio ||
				context.mozBackingStorePixelRatio ||
				context.msBackingStorePixelRatio ||
				context.oBackingStorePixelRatio ||
				context.backingStorePixelRatio || 1;

		this.pixelRatio = devicePixelRatio / backingStoreRatio;

		// Size the canvas to match the internal dimensions of its container

		this.resize(container.width(), container.height());

		// Collection of HTML div layers for text overlaid onto the canvas

		this.textContainer = null;
		this.text = {};

		// Cache of text fragments and metrics, so we can avoid expensively
		// re-calculating them when the plot is re-rendered in a loop.

		this._textCache = {};
	}

	// Resizes the canvas to the given dimensions.
	//
	// @param {number} width New width of the canvas, in pixels.
	// @param {number} width New height of the canvas, in pixels.

	Canvas.prototype.resize = function(width, height) {

		if (width <= 0 || height <= 0) {
			throw new Error("Invalid dimensions for plot, width = " + width + ", height = " + height);
		}

		var element = this.element,
			context = this.context,
			pixelRatio = this.pixelRatio;

		// Resize the canvas, increasing its density based on the display's
		// pixel ratio; basically giving it more pixels without increasing the
		// size of its element, to take advantage of the fact that retina
		// displays have that many more pixels in the same advertised space.

		// Resizing should reset the state (excanvas seems to be buggy though)

		if (this.width != width) {
			element.width = width * pixelRatio;
			element.style.width = width + "px";
			this.width = width;
		}

		if (this.height != height) {
			element.height = height * pixelRatio;
			element.style.height = height + "px";
			this.height = height;
		}

		// Save the context, so we can reset in case we get replotted.  The
		// restore ensure that we're really back at the initial state, and
		// should be safe even if we haven't saved the initial state yet.

		context.restore();
		context.save();

		// Scale the coordinate space to match the display density; so even though we
		// may have twice as many pixels, we still want lines and other drawing to
		// appear at the same size; the extra pixels will just make them crisper.

		context.scale(pixelRatio, pixelRatio);
	};

	// Clears the entire canvas area, not including any overlaid HTML text

	Canvas.prototype.clear = function() {
		this.context.clearRect(0, 0, this.width, this.height);
	};

	// Finishes rendering the canvas, including managing the text overlay.

	Canvas.prototype.render = function() {

		var cache = this._textCache;

		// For each text layer, add elements marked as active that haven't
		// already been rendered, and remove those that are no longer active.

		for (var layerKey in cache) {
			if (hasOwnProperty.call(cache, layerKey)) {

				var layer = this.getTextLayer(layerKey),
					layerCache = cache[layerKey];

				layer.hide();

				for (var styleKey in layerCache) {
					if (hasOwnProperty.call(layerCache, styleKey)) {
						var styleCache = layerCache[styleKey];
						for (var key in styleCache) {
							if (hasOwnProperty.call(styleCache, key)) {

								var positions = styleCache[key].positions;

								for (var i = 0, position; position = positions[i]; i++) {
									if (position.active) {
										if (!position.rendered) {
											layer.append(position.element);
											position.rendered = true;
										}
									} else {
										positions.splice(i--, 1);
										if (position.rendered) {
											position.element.detach();
										}
									}
								}

								if (positions.length == 0) {
									delete styleCache[key];
								}
							}
						}
					}
				}

				layer.show();
			}
		}
	};

	// Creates (if necessary) and returns the text overlay container.
	//
	// @param {string} classes String of space-separated CSS classes used to
	//     uniquely identify the text layer.
	// @return {object} The jQuery-wrapped text-layer div.

	Canvas.prototype.getTextLayer = function(classes) {

		var layer = this.text[classes];

		// Create the text layer if it doesn't exist

		if (layer == null) {

			// Create the text layer container, if it doesn't exist

			if (this.textContainer == null) {
				this.textContainer = $("<div class='flot-text'></div>")
					.css({
						position: "absolute",
						top: 0,
						left: 0,
						bottom: 0,
						right: 0,
						'font-size': "smaller",
						color: "#545454"
					})
					.insertAfter(this.element);
			}

			layer = this.text[classes] = $("<div></div>")
				.addClass(classes)
				.css({
					position: "absolute",
					top: 0,
					left: 0,
					bottom: 0,
					right: 0
				})
				.appendTo(this.textContainer);
		}

		return layer;
	};

	// Creates (if necessary) and returns a text info object.
	//
	// The object looks like this:
	//
	// {
	//     width: Width of the text's wrapper div.
	//     height: Height of the text's wrapper div.
	//     element: The jQuery-wrapped HTML div containing the text.
	//     positions: Array of positions at which this text is drawn.
	// }
	//
	// The positions array contains objects that look like this:
	//
	// {
	//     active: Flag indicating whether the text should be visible.
	//     rendered: Flag indicating whether the text is currently visible.
	//     element: The jQuery-wrapped HTML div containing the text.
	//     x: X coordinate at which to draw the text.
	//     y: Y coordinate at which to draw the text.
	// }
	//
	// Each position after the first receives a clone of the original element.
	//
	// The idea is that that the width, height, and general 'identity' of the
	// text is constant no matter where it is placed; the placements are a
	// secondary property.
	//
	// Canvas maintains a cache of recently-used text info objects; getTextInfo
	// either returns the cached element or creates a new entry.
	//
	// @param {string} layer A string of space-separated CSS classes uniquely
	//     identifying the layer containing this text.
	// @param {string} text Text string to retrieve info for.
	// @param {(string|object)=} font Either a string of space-separated CSS
	//     classes or a font-spec object, defining the text's font and style.
	// @param {number=} angle Angle at which to rotate the text, in degrees.
	//     Angle is currently unused, it will be implemented in the future.
	// @param {number=} width Maximum width of the text before it wraps.
	// @return {object} a text info object.

	Canvas.prototype.getTextInfo = function(layer, text, font, angle, width) {

		var textStyle, layerCache, styleCache, info;

		// Cast the value to a string, in case we were given a number or such

		text = "" + text;

		// If the font is a font-spec object, generate a CSS font definition

		if (typeof font === "object") {
			textStyle = font.style + " " + font.variant + " " + font.weight + " " + font.size + "px/" + font.lineHeight + "px " + font.family;
		} else {
			textStyle = font;
		}

		// Retrieve (or create) the cache for the text's layer and styles

		layerCache = this._textCache[layer];

		if (layerCache == null) {
			layerCache = this._textCache[layer] = {};
		}

		styleCache = layerCache[textStyle];

		if (styleCache == null) {
			styleCache = layerCache[textStyle] = {};
		}

		info = styleCache[text];

		// If we can't find a matching element in our cache, create a new one

		if (info == null) {

			var element = $("<div></div>").html(text)
				.css({
					position: "absolute",
					'max-width': width,
					top: -9999
				})
				.appendTo(this.getTextLayer(layer));

			if (typeof font === "object") {
				element.css({
					font: textStyle,
					color: font.color
				});
			} else if (typeof font === "string") {
				element.addClass(font);
			}

			info = styleCache[text] = {
				width: element.outerWidth(true),
				height: element.outerHeight(true),
				element: element,
				positions: []
			};

			element.detach();
		}

		return info;
	};

	// Adds a text string to the canvas text overlay.
	//
	// The text isn't drawn immediately; it is marked as rendering, which will
	// result in its addition to the canvas on the next render pass.
	//
	// @param {string} layer A string of space-separated CSS classes uniquely
	//     identifying the layer containing this text.
	// @param {number} x X coordinate at which to draw the text.
	// @param {number} y Y coordinate at which to draw the text.
	// @param {string} text Text string to draw.
	// @param {(string|object)=} font Either a string of space-separated CSS
	//     classes or a font-spec object, defining the text's font and style.
	// @param {number=} angle Angle at which to rotate the text, in degrees.
	//     Angle is currently unused, it will be implemented in the future.
	// @param {number=} width Maximum width of the text before it wraps.
	// @param {string=} halign Horizontal alignment of the text; either "left",
	//     "center" or "right".
	// @param {string=} valign Vertical alignment of the text; either "top",
	//     "middle" or "bottom".

	Canvas.prototype.addText = function(layer, x, y, text, font, angle, width, halign, valign) {

		var info = this.getTextInfo(layer, text, font, angle, width),
			positions = info.positions;

		// Tweak the div's position to match the text's alignment

		if (halign == "center") {
			x -= info.width / 2;
		} else if (halign == "right") {
			x -= info.width;
		}

		if (valign == "middle") {
			y -= info.height / 2;
		} else if (valign == "bottom") {
			y -= info.height;
		}

		// Determine whether this text already exists at this position.
		// If so, mark it for inclusion in the next render pass.

		for (var i = 0, position; position = positions[i]; i++) {
			if (position.x == x && position.y == y) {
				position.active = true;
				return;
			}
		}

		// If the text doesn't exist at this position, create a new entry

		// For the very first position we'll re-use the original element,
		// while for subsequent ones we'll clone it.

		position = {
			active: true,
			rendered: false,
			element: positions.length ? info.element.clone() : info.element,
			x: x,
			y: y
		};

		positions.push(position);

		// Move the element to its final position within the container

		position.element.css({
			top: Math.round(y),
			left: Math.round(x),
			'text-align': halign	// In case the text wraps
		});
	};

	// Removes one or more text strings from the canvas text overlay.
	//
	// If no parameters are given, all text within the layer is removed.
	//
	// Note that the text is not immediately removed; it is simply marked as
	// inactive, which will result in its removal on the next render pass.
	// This avoids the performance penalty for 'clear and redraw' behavior,
	// where we potentially get rid of all text on a layer, but will likely
	// add back most or all of it later, as when redrawing axes, for example.
	//
	// @param {string} layer A string of space-separated CSS classes uniquely
	//     identifying the layer containing this text.
	// @param {number=} x X coordinate of the text.
	// @param {number=} y Y coordinate of the text.
	// @param {string=} text Text string to remove.
	// @param {(string|object)=} font Either a string of space-separated CSS
	//     classes or a font-spec object, defining the text's font and style.
	// @param {number=} angle Angle at which the text is rotated, in degrees.
	//     Angle is currently unused, it will be implemented in the future.

	Canvas.prototype.removeText = function(layer, x, y, text, font, angle) {
		if (text == null) {
			var layerCache = this._textCache[layer];
			if (layerCache != null) {
				for (var styleKey in layerCache) {
					if (hasOwnProperty.call(layerCache, styleKey)) {
						var styleCache = layerCache[styleKey];
						for (var key in styleCache) {
							if (hasOwnProperty.call(styleCache, key)) {
								var positions = styleCache[key].positions;
								for (var i = 0, position; position = positions[i]; i++) {
									position.active = false;
								}
							}
						}
					}
				}
			}
		} else {
			var positions = this.getTextInfo(layer, text, font, angle).positions;
			for (var i = 0, position; position = positions[i]; i++) {
				if (position.x == x && position.y == y) {
					position.active = false;
				}
			}
		}
	};

	///////////////////////////////////////////////////////////////////////////
	// The top-level container for the entire plot.

    function Plot(placeholder, data_, options_, plugins) {
        // data is on the form:
        //   [ series1, series2 ... ]
        // where series is either just the data as [ [x1, y1], [x2, y2], ... ]
        // or { data: [ [x1, y1], [x2, y2], ... ], label: "some label", ... }

        var series = [],
            options = {
                // the color theme used for graphs
                colors: ["#edc240", "#afd8f8", "#cb4b4b", "#4da74d", "#9440ed"],
                legend: {
                    show: true,
                    noColumns: 1, // number of colums in legend table
                    labelFormatter: null, // fn: string -> string
                    labelBoxBorderColor: "#ccc", // border color for the little label boxes
                    container: null, // container (as jQuery object) to put legend in, null means default on top of graph
                    position: "ne", // position of default legend container within plot
                    margin: 5, // distance from grid edge to default legend container within plot
                    backgroundColor: null, // null means auto-detect
                    backgroundOpacity: 0.85, // set to 0 to avoid background
                    sorted: null    // default to no legend sorting
                },
                xaxis: {
                    show: null, // null = auto-detect, true = always, false = never
                    position: "bottom", // or "top"
                    mode: null, // null or "time"
                    font: null, // null (derived from CSS in placeholder) or object like { size: 11, lineHeight: 13, style: "italic", weight: "bold", family: "sans-serif", variant: "small-caps" }
                    color: null, // base color, labels, ticks
                    tickColor: null, // possibly different color of ticks, e.g. "rgba(0,0,0,0.15)"
                    transform: null, // null or f: number -> number to transform axis
                    inverseTransform: null, // if transform is set, this should be the inverse function
                    min: null, // min. value to show, null means set automatically
                    max: null, // max. value to show, null means set automatically
                    autoscaleMargin: null, // margin in % to add if auto-setting min/max
                    ticks: null, // either [1, 3] or [[1, "a"], 3] or (fn: axis info -> ticks) or app. number of ticks for auto-ticks
                    tickFormatter: null, // fn: number -> string
                    labelWidth: null, // size of tick labels in pixels
                    labelHeight: null,
                    reserveSpace: null, // whether to reserve space even if axis isn't shown
                    tickLength: null, // size in pixels of ticks, or "full" for whole line
                    alignTicksWithAxis: null, // axis number or null for no sync
                    tickDecimals: null, // no. of decimals, null means auto
                    tickSize: null, // number or [number, "unit"]
                    minTickSize: null // number or [number, "unit"]
                },
                yaxis: {
                    autoscaleMargin: 0.02,
                    position: "left" // or "right"
                },
                xaxes: [],
                yaxes: [],
                series: {
                    points: {
                        show: false,
                        radius: 3,
                        lineWidth: 2, // in pixels
                        fill: true,
                        fillColor: "#ffffff",
                        symbol: "circle" // or callback
                    },
                    lines: {
                        // we don't put in show: false so we can see
                        // whether lines were actively disabled
                        lineWidth: 2, // in pixels
                        fill: false,
                        fillColor: null,
                        steps: false
                        // Omit 'zero', so we can later default its value to
                        // match that of the 'fill' option.
                    },
                    bars: {
                        show: false,
                        lineWidth: 2, // in pixels
                        barWidth: 1, // in units of the x axis
                        fill: true,
                        fillColor: null,
                        align: "left", // "left", "right", or "center"
                        horizontal: false,
                        zero: true
                    },
                    shadowSize: 3,
                    highlightColor: null
                },
                grid: {
                    show: true,
                    aboveData: false,
                    color: "#545454", // primary color used for outline and labels
                    backgroundColor: null, // null for transparent, else color
                    borderColor: null, // set if different from the grid color
                    tickColor: null, // color for the ticks, e.g. "rgba(0,0,0,0.15)"
                    margin: 0, // distance from the canvas edge to the grid
                    labelMargin: 5, // in pixels
                    axisMargin: 8, // in pixels
                    borderWidth: 2, // in pixels
                    minBorderMargin: null, // in pixels, null means taken from points radius
                    markings: null, // array of ranges or fn: axes -> array of ranges
                    markingsColor: "#f4f4f4",
                    markingsLineWidth: 2,
                    // interactive stuff
                    clickable: false,
                    hoverable: false,
                    autoHighlight: true, // highlight in case mouse is near
                    mouseActiveRadius: 10 // how far the mouse can be away to activate an item
                },
                interaction: {
                    redrawOverlayInterval: 1000/60 // time between updates, -1 means in same flow
                },
                hooks: {}
            },
        surface = null,     // the canvas for the plot itself
        overlay = null,     // canvas for interactive stuff on top of plot
        eventHolder = null, // jQuery object that events should be bound to
        ctx = null, octx = null,
        xaxes = [], yaxes = [],
        plotOffset = { left: 0, right: 0, top: 0, bottom: 0},
        plotWidth = 0, plotHeight = 0,
        hooks = {
            processOptions: [],
            processRawData: [],
            processDatapoints: [],
            processOffset: [],
            drawBackground: [],
            drawSeries: [],
            draw: [],
            bindEvents: [],
            drawOverlay: [],
            shutdown: []
        },
        plot = this;

        // public functions
        plot.setData = setData;
        plot.setupGrid = setupGrid;
        plot.draw = draw;
        plot.getPlaceholder = function() { return placeholder; };
        plot.getCanvas = function() { return surface.element; };
        plot.getPlotOffset = function() { return plotOffset; };
        plot.width = function () { return plotWidth; };
        plot.height = function () { return plotHeight; };
        plot.offset = function () {
            var o = eventHolder.offset();
            o.left += plotOffset.left;
            o.top += plotOffset.top;
            return o;
        };
        plot.getData = function () { return series; };
        plot.getAxes = function () {
            var res = {}, i;
            $.each(xaxes.concat(yaxes), function (_, axis) {
                if (axis)
                    res[axis.direction + (axis.n != 1 ? axis.n : "") + "axis"] = axis;
            });
            return res;
        };
        plot.getXAxes = function () { return xaxes; };
        plot.getYAxes = function () { return yaxes; };
        plot.c2p = canvasToAxisCoords;
        plot.p2c = axisToCanvasCoords;
        plot.getOptions = function () { return options; };
        plot.highlight = highlight;
        plot.unhighlight = unhighlight;
        plot.triggerRedrawOverlay = triggerRedrawOverlay;
        plot.pointOffset = function(point) {
            return {
                left: parseInt(xaxes[axisNumber(point, "x") - 1].p2c(+point.x) + plotOffset.left, 10),
                top: parseInt(yaxes[axisNumber(point, "y") - 1].p2c(+point.y) + plotOffset.top, 10)
            };
        };
        plot.shutdown = shutdown;
        plot.destroy = function () {
            shutdown();
            placeholder.removeData("plot").empty();

            series = [];
            options = null;
            surface = null;
            overlay = null;
            eventHolder = null;
            ctx = null;
            octx = null;
            xaxes = [];
            yaxes = [];
            hooks = null;
            highlights = [];
            plot = null;
        };
        plot.resize = function () {
        	var width = placeholder.width(),
        		height = placeholder.height();
            surface.resize(width, height);
            overlay.resize(width, height);
        };

        // public attributes
        plot.hooks = hooks;

        // initialize
        initPlugins(plot);
        parseOptions(options_);
        setupCanvases();
        setData(data_);
        setupGrid();
        draw();
        bindEvents();


        function executeHooks(hook, args) {
            args = [plot].concat(args);
            for (var i = 0; i < hook.length; ++i)
                hook[i].apply(this, args);
        }

        function initPlugins() {

            // References to key classes, allowing plugins to modify them

            var classes = {
                Canvas: Canvas
            };

            for (var i = 0; i < plugins.length; ++i) {
                var p = plugins[i];
                p.init(plot, classes);
                if (p.options)
                    $.extend(true, options, p.options);
            }
        }

        function parseOptions(opts) {

            $.extend(true, options, opts);

            // $.extend merges arrays, rather than replacing them.  When less
            // colors are provided than the size of the default palette, we
            // end up with those colors plus the remaining defaults, which is
            // not expected behavior; avoid it by replacing them here.

            if (opts && opts.colors) {
            	options.colors = opts.colors;
            }

            if (options.xaxis.color == null)
                options.xaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();
            if (options.yaxis.color == null)
                options.yaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();

            if (options.xaxis.tickColor == null) // grid.tickColor for back-compatibility
                options.xaxis.tickColor = options.grid.tickColor || options.xaxis.color;
            if (options.yaxis.tickColor == null) // grid.tickColor for back-compatibility
                options.yaxis.tickColor = options.grid.tickColor || options.yaxis.color;

            if (options.grid.borderColor == null)
                options.grid.borderColor = options.grid.color;
            if (options.grid.tickColor == null)
                options.grid.tickColor = $.color.parse(options.grid.color).scale('a', 0.22).toString();

            // Fill in defaults for axis options, including any unspecified
            // font-spec fields, if a font-spec was provided.

            // If no x/y axis options were provided, create one of each anyway,
            // since the rest of the code assumes that they exist.

            var i, axisOptions, axisCount,
                fontSize = placeholder.css("font-size"),
                fontSizeDefault = fontSize ? +fontSize.replace("px", "") : 13,
                fontDefaults = {
                    style: placeholder.css("font-style"),
                    size: Math.round(0.8 * fontSizeDefault),
                    variant: placeholder.css("font-variant"),
                    weight: placeholder.css("font-weight"),
                    family: placeholder.css("font-family")
                };

            axisCount = options.xaxes.length || 1;
            for (i = 0; i < axisCount; ++i) {

                axisOptions = options.xaxes[i];
                if (axisOptions && !axisOptions.tickColor) {
                    axisOptions.tickColor = axisOptions.color;
                }

                axisOptions = $.extend(true, {}, options.xaxis, axisOptions);
                options.xaxes[i] = axisOptions;

                if (axisOptions.font) {
                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);
                    if (!axisOptions.font.color) {
                        axisOptions.font.color = axisOptions.color;
                    }
                    if (!axisOptions.font.lineHeight) {
                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);
                    }
                }
            }

            axisCount = options.yaxes.length || 1;
            for (i = 0; i < axisCount; ++i) {

                axisOptions = options.yaxes[i];
                if (axisOptions && !axisOptions.tickColor) {
                    axisOptions.tickColor = axisOptions.color;
                }

                axisOptions = $.extend(true, {}, options.yaxis, axisOptions);
                options.yaxes[i] = axisOptions;

                if (axisOptions.font) {
                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);
                    if (!axisOptions.font.color) {
                        axisOptions.font.color = axisOptions.color;
                    }
                    if (!axisOptions.font.lineHeight) {
                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);
                    }
                }
            }

            // backwards compatibility, to be removed in future
            if (options.xaxis.noTicks && options.xaxis.ticks == null)
                options.xaxis.ticks = options.xaxis.noTicks;
            if (options.yaxis.noTicks && options.yaxis.ticks == null)
                options.yaxis.ticks = options.yaxis.noTicks;
            if (options.x2axis) {
                options.xaxes[1] = $.extend(true, {}, options.xaxis, options.x2axis);
                options.xaxes[1].position = "top";
                // Override the inherit to allow the axis to auto-scale
                if (options.x2axis.min == null) {
                    options.xaxes[1].min = null;
                }
                if (options.x2axis.max == null) {
                    options.xaxes[1].max = null;
                }
            }
            if (options.y2axis) {
                options.yaxes[1] = $.extend(true, {}, options.yaxis, options.y2axis);
                options.yaxes[1].position = "right";
                // Override the inherit to allow the axis to auto-scale
                if (options.y2axis.min == null) {
                    options.yaxes[1].min = null;
                }
                if (options.y2axis.max == null) {
                    options.yaxes[1].max = null;
                }
            }
            if (options.grid.coloredAreas)
                options.grid.markings = options.grid.coloredAreas;
            if (options.grid.coloredAreasColor)
                options.grid.markingsColor = options.grid.coloredAreasColor;
            if (options.lines)
                $.extend(true, options.series.lines, options.lines);
            if (options.points)
                $.extend(true, options.series.points, options.points);
            if (options.bars)
                $.extend(true, options.series.bars, options.bars);
            if (options.shadowSize != null)
                options.series.shadowSize = options.shadowSize;
            if (options.highlightColor != null)
                options.series.highlightColor = options.highlightColor;

            // save options on axes for future reference
            for (i = 0; i < options.xaxes.length; ++i)
                getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i];
            for (i = 0; i < options.yaxes.length; ++i)
                getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i];

            // add hooks from options
            for (var n in hooks)
                if (options.hooks[n] && options.hooks[n].length)
                    hooks[n] = hooks[n].concat(options.hooks[n]);

            executeHooks(hooks.processOptions, [options]);
        }

        function setData(d) {
            series = parseData(d);
            fillInSeriesOptions();
            processData();
        }

        function parseData(d) {
            var res = [];
            for (var i = 0; i < d.length; ++i) {
                var s = $.extend(true, {}, options.series);

                if (d[i].data != null) {
                    s.data = d[i].data; // move the data instead of deep-copy
                    delete d[i].data;

                    $.extend(true, s, d[i]);

                    d[i].data = s.data;
                }
                else
                    s.data = d[i];
                res.push(s);
            }

            return res;
        }

        function axisNumber(obj, coord) {
            var a = obj[coord + "axis"];
            if (typeof a == "object") // if we got a real axis, extract number
                a = a.n;
            if (typeof a != "number")
                a = 1; // default to first axis
            return a;
        }

        function allAxes() {
            // return flat array without annoying null entries
            return $.grep(xaxes.concat(yaxes), function (a) { return a; });
        }

        function canvasToAxisCoords(pos) {
            // return an object with x/y corresponding to all used axes
            var res = {}, i, axis;
            for (i = 0; i < xaxes.length; ++i) {
                axis = xaxes[i];
                if (axis && axis.used)
                    res["x" + axis.n] = axis.c2p(pos.left);
            }

            for (i = 0; i < yaxes.length; ++i) {
                axis = yaxes[i];
                if (axis && axis.used)
                    res["y" + axis.n] = axis.c2p(pos.top);
            }

            if (res.x1 !== undefined)
                res.x = res.x1;
            if (res.y1 !== undefined)
                res.y = res.y1;

            return res;
        }

        function axisToCanvasCoords(pos) {
            // get canvas coords from the first pair of x/y found in pos
            var res = {}, i, axis, key;

            for (i = 0; i < xaxes.length; ++i) {
                axis = xaxes[i];
                if (axis && axis.used) {
                    key = "x" + axis.n;
                    if (pos[key] == null && axis.n == 1)
                        key = "x";

                    if (pos[key] != null) {
                        res.left = axis.p2c(pos[key]);
                        break;
                    }
                }
            }

            for (i = 0; i < yaxes.length; ++i) {
                axis = yaxes[i];
                if (axis && axis.used) {
                    key = "y" + axis.n;
                    if (pos[key] == null && axis.n == 1)
                        key = "y";

                    if (pos[key] != null) {
                        res.top = axis.p2c(pos[key]);
                        break;
                    }
                }
            }

            return res;
        }

        function getOrCreateAxis(axes, number) {
            if (!axes[number - 1])
                axes[number - 1] = {
                    n: number, // save the number for future reference
                    direction: axes == xaxes ? "x" : "y",
                    options: $.extend(true, {}, axes == xaxes ? options.xaxis : options.yaxis)
                };

            return axes[number - 1];
        }

        function fillInSeriesOptions() {

            var neededColors = series.length, maxIndex = -1, i;

            // Subtract the number of series that already have fixed colors or
            // color indexes from the number that we still need to generate.

            for (i = 0; i < series.length; ++i) {
                var sc = series[i].color;
                if (sc != null) {
                    neededColors--;
                    if (typeof sc == "number" && sc > maxIndex) {
                        maxIndex = sc;
                    }
                }
            }

            // If any of the series have fixed color indexes, then we need to
            // generate at least as many colors as the highest index.

            if (neededColors <= maxIndex) {
                neededColors = maxIndex + 1;
            }

            // Generate all the colors, using first the option colors and then
            // variations on those colors once they're exhausted.

            var c, colors = [], colorPool = options.colors,
                colorPoolSize = colorPool.length, variation = 0;

            for (i = 0; i < neededColors; i++) {

                c = $.color.parse(colorPool[i % colorPoolSize] || "#666");

                // Each time we exhaust the colors in the pool we adjust
                // a scaling factor used to produce more variations on
                // those colors. The factor alternates negative/positive
                // to produce lighter/darker colors.

                // Reset the variation after every few cycles, or else
                // it will end up producing only white or black colors.

                if (i % colorPoolSize == 0 && i) {
                    if (variation >= 0) {
                        if (variation < 0.5) {
                            variation = -variation - 0.2;
                        } else variation = 0;
                    } else variation = -variation;
                }

                colors[i] = c.scale('rgb', 1 + variation);
            }

            // Finalize the series options, filling in their colors

            var colori = 0, s;
            for (i = 0; i < series.length; ++i) {
                s = series[i];

                // assign colors
                if (s.color == null) {
                    s.color = colors[colori].toString();
                    ++colori;
                }
                else if (typeof s.color == "number")
                    s.color = colors[s.color].toString();

                // turn on lines automatically in case nothing is set
                if (s.lines.show == null) {
                    var v, show = true;
                    for (v in s)
                        if (s[v] && s[v].show) {
                            show = false;
                            break;
                        }
                    if (show)
                        s.lines.show = true;
                }

                // If nothing was provided for lines.zero, default it to match
                // lines.fill, since areas by default should extend to zero.

                if (s.lines.zero == null) {
                    s.lines.zero = !!s.lines.fill;
                }

                // setup axes
                s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, "x"));
                s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, "y"));
            }
        }

        function processData() {
            var topSentry = Number.POSITIVE_INFINITY,
                bottomSentry = Number.NEGATIVE_INFINITY,
                fakeInfinity = Number.MAX_VALUE,
                i, j, k, m, length,
                s, points, ps, x, y, axis, val, f, p,
                data, format;

            function updateAxis(axis, min, max) {
                if (min < axis.datamin && min != -fakeInfinity)
                    axis.datamin = min;
                if (max > axis.datamax && max != fakeInfinity)
                    axis.datamax = max;
            }

            $.each(allAxes(), function (_, axis) {
                // init axis
                axis.datamin = topSentry;
                axis.datamax = bottomSentry;
                axis.used = false;
            });

            for (i = 0; i < series.length; ++i) {
                s = series[i];
                s.datapoints = { points: [] };

                executeHooks(hooks.processRawData, [ s, s.data, s.datapoints ]);
            }

            // first pass: clean and copy data
            for (i = 0; i < series.length; ++i) {
                s = series[i];

                data = s.data;
                format = s.datapoints.format;

                if (!format) {
                    format = [];
                    // find out how to copy
                    format.push({ x: true, number: true, required: true });
                    format.push({ y: true, number: true, required: true });

                    if (s.bars.show || (s.lines.show && s.lines.fill)) {
                        var autoscale = !!((s.bars.show && s.bars.zero) || (s.lines.show && s.lines.zero));
                        format.push({ y: true, number: true, required: false, defaultValue: 0, autoscale: autoscale });
                        if (s.bars.horizontal) {
                            delete format[format.length - 1].y;
                            format[format.length - 1].x = true;
                        }
                    }

                    s.datapoints.format = format;
                }

                if (s.datapoints.pointsize != null)
                    continue; // already filled in

                s.datapoints.pointsize = format.length;

                ps = s.datapoints.pointsize;
                points = s.datapoints.points;

                var insertSteps = s.lines.show && s.lines.steps;
                s.xaxis.used = s.yaxis.used = true;

                for (j = k = 0; j < data.length; ++j, k += ps) {
                    p = data[j];

                    var nullify = p == null;
                    if (!nullify) {
                        for (m = 0; m < ps; ++m) {
                            val = p[m];
                            f = format[m];

                            if (f) {
                                if (f.number && val != null) {
                                    val = +val; // convert to number
                                    if (isNaN(val))
                                        val = null;
                                    else if (val == Infinity)
                                        val = fakeInfinity;
                                    else if (val == -Infinity)
                                        val = -fakeInfinity;
                                }

                                if (val == null) {
                                    if (f.required)
                                        nullify = true;

                                    if (f.defaultValue != null)
                                        val = f.defaultValue;
                                }
                            }

                            points[k + m] = val;
                        }
                    }

                    if (nullify) {
                        for (m = 0; m < ps; ++m) {
                            val = points[k + m];
                            if (val != null) {
                                f = format[m];
                                // extract min/max info
                                if (f.autoscale !== false) {
                                    if (f.x) {
                                        updateAxis(s.xaxis, val, val);
                                    }
                                    if (f.y) {
                                        updateAxis(s.yaxis, val, val);
                                    }
                                }
                            }
                            points[k + m] = null;
                        }
                    }
                    else {
                        // a little bit of line specific stuff that
                        // perhaps shouldn't be here, but lacking
                        // better means...
                        if (insertSteps && k > 0
                            && points[k - ps] != null
                            && points[k - ps] != points[k]
                            && points[k - ps + 1] != points[k + 1]) {
                            // copy the point to make room for a middle point
                            for (m = 0; m < ps; ++m)
                                points[k + ps + m] = points[k + m];

                            // middle point has same y
                            points[k + 1] = points[k - ps + 1];

                            // we've added a point, better reflect that
                            k += ps;
                        }
                    }
                }
            }

            // give the hooks a chance to run
            for (i = 0; i < series.length; ++i) {
                s = series[i];

                executeHooks(hooks.processDatapoints, [ s, s.datapoints]);
            }

            // second pass: find datamax/datamin for auto-scaling
            for (i = 0; i < series.length; ++i) {
                s = series[i];
                points = s.datapoints.points;
                ps = s.datapoints.pointsize;
                format = s.datapoints.format;

                var xmin = topSentry, ymin = topSentry,
                    xmax = bottomSentry, ymax = bottomSentry;

                for (j = 0; j < points.length; j += ps) {
                    if (points[j] == null)
                        continue;

                    for (m = 0; m < ps; ++m) {
                        val = points[j + m];
                        f = format[m];
                        if (!f || f.autoscale === false || val == fakeInfinity || val == -fakeInfinity)
                            continue;

                        if (f.x) {
                            if (val < xmin)
                                xmin = val;
                            if (val > xmax)
                                xmax = val;
                        }
                        if (f.y) {
                            if (val < ymin)
                                ymin = val;
                            if (val > ymax)
                                ymax = val;
                        }
                    }
                }

                if (s.bars.show) {
                    // make sure we got room for the bar on the dancing floor
                    var delta;

                    switch (s.bars.align) {
                        case "left":
                            delta = 0;
                            break;
                        case "right":
                            delta = -s.bars.barWidth;
                            break;
                        default:
                            delta = -s.bars.barWidth / 2;
                    }

                    if (s.bars.horizontal) {
                        ymin += delta;
                        ymax += delta + s.bars.barWidth;
                    }
                    else {
                        xmin += delta;
                        xmax += delta + s.bars.barWidth;
                    }
                }

                updateAxis(s.xaxis, xmin, xmax);
                updateAxis(s.yaxis, ymin, ymax);
            }

            $.each(allAxes(), function (_, axis) {
                if (axis.datamin == topSentry)
                    axis.datamin = null;
                if (axis.datamax == bottomSentry)
                    axis.datamax = null;
            });
        }

        function setupCanvases() {

            // Make sure the placeholder is clear of everything except canvases
            // from a previous plot in this container that we'll try to re-use.

            placeholder.css("padding", 0) // padding messes up the positioning
                .children().filter(function(){
                    return !$(this).hasClass("flot-overlay") && !$(this).hasClass('flot-base');
                }).remove();

            if (placeholder.css("position") == 'static')
                placeholder.css("position", "relative"); // for positioning labels and overlay

            surface = new Canvas("flot-base", placeholder);
            overlay = new Canvas("flot-overlay", placeholder); // overlay canvas for interactive features

            ctx = surface.context;
            octx = overlay.context;

            // define which element we're listening for events on
            eventHolder = $(overlay.element).unbind();

            // If we're re-using a plot object, shut down the old one

            var existing = placeholder.data("plot");

            if (existing) {
                existing.shutdown();
                overlay.clear();
            }

            // save in case we get replotted
            placeholder.data("plot", plot);
        }

        function bindEvents() {
            // bind events
            if (options.grid.hoverable) {
                eventHolder.mousemove(onMouseMove);

                // Use bind, rather than .mouseleave, because we officially
                // still support jQuery 1.2.6, which doesn't define a shortcut
                // for mouseenter or mouseleave.  This was a bug/oversight that
                // was fixed somewhere around 1.3.x.  We can return to using
                // .mouseleave when we drop support for 1.2.6.

                eventHolder.bind("mouseleave", onMouseLeave);
            }

            if (options.grid.clickable)
                eventHolder.click(onClick);

            executeHooks(hooks.bindEvents, [eventHolder]);
        }

        function shutdown() {
            if (redrawTimeout)
                clearTimeout(redrawTimeout);

            eventHolder.unbind("mousemove", onMouseMove);
            eventHolder.unbind("mouseleave", onMouseLeave);
            eventHolder.unbind("click", onClick);

            executeHooks(hooks.shutdown, [eventHolder]);
        }

        function setTransformationHelpers(axis) {
            // set helper functions on the axis, assumes plot area
            // has been computed already

            function identity(x) { return x; }

            var s, m, t = axis.options.transform || identity,
                it = axis.options.inverseTransform;

            // precompute how much the axis is scaling a point
            // in canvas space
            if (axis.direction == "x") {
                s = axis.scale = plotWidth / Math.abs(t(axis.max) - t(axis.min));
                m = Math.min(t(axis.max), t(axis.min));
            }
            else {
                s = axis.scale = plotHeight / Math.abs(t(axis.max) - t(axis.min));
                s = -s;
                m = Math.max(t(axis.max), t(axis.min));
            }

            // data point to canvas coordinate
            if (t == identity) // slight optimization
                axis.p2c = function (p) { return (p - m) * s; };
            else
                axis.p2c = function (p) { return (t(p) - m) * s; };
            // canvas coordinate to data point
            if (!it)
                axis.c2p = function (c) { return m + c / s; };
            else
                axis.c2p = function (c) { return it(m + c / s); };
        }

        function measureTickLabels(axis) {

            var opts = axis.options,
                ticks = axis.ticks || [],
                labelWidth = opts.labelWidth || 0,
                labelHeight = opts.labelHeight || 0,
                maxWidth = labelWidth || (axis.direction == "x" ? Math.floor(surface.width / (ticks.length || 1)) : null),
                legacyStyles = axis.direction + "Axis " + axis.direction + axis.n + "Axis",
                layer = "flot-" + axis.direction + "-axis flot-" + axis.direction + axis.n + "-axis " + legacyStyles,
                font = opts.font || "flot-tick-label tickLabel";

            for (var i = 0; i < ticks.length; ++i) {

                var t = ticks[i];

                if (!t.label)
                    continue;

                var info = surface.getTextInfo(layer, t.label, font, null, maxWidth);

                labelWidth = Math.max(labelWidth, info.width);
                labelHeight = Math.max(labelHeight, info.height);
            }

            axis.labelWidth = opts.labelWidth || labelWidth;
            axis.labelHeight = opts.labelHeight || labelHeight;
        }

        function allocateAxisBoxFirstPhase(axis) {
            // find the bounding box of the axis by looking at label
            // widths/heights and ticks, make room by diminishing the
            // plotOffset; this first phase only looks at one
            // dimension per axis, the other dimension depends on the
            // other axes so will have to wait

            var lw = axis.labelWidth,
                lh = axis.labelHeight,
                pos = axis.options.position,
                isXAxis = axis.direction === "x",
                tickLength = axis.options.tickLength,
                axisMargin = options.grid.axisMargin,
                padding = options.grid.labelMargin,
                innermost = true,
                outermost = true,
                first = true,
                found = false;

            // Determine the axis's position in its direction and on its side

            $.each(isXAxis ? xaxes : yaxes, function(i, a) {
                if (a && (a.show || a.reserveSpace)) {
                    if (a === axis) {
                        found = true;
                    } else if (a.options.position === pos) {
                        if (found) {
                            outermost = false;
                        } else {
                            innermost = false;
                        }
                    }
                    if (!found) {
                        first = false;
                    }
                }
            });

            // The outermost axis on each side has no margin

            if (outermost) {
                axisMargin = 0;
            }

            // The ticks for the first axis in each direction stretch across

            if (tickLength == null) {
                tickLength = first ? "full" : 5;
            }

            if (!isNaN(+tickLength))
                padding += +tickLength;

            if (isXAxis) {
                lh += padding;

                if (pos == "bottom") {
                    plotOffset.bottom += lh + axisMargin;
                    axis.box = { top: surface.height - plotOffset.bottom, height: lh };
                }
                else {
                    axis.box = { top: plotOffset.top + axisMargin, height: lh };
                    plotOffset.top += lh + axisMargin;
                }
            }
            else {
                lw += padding;

                if (pos == "left") {
                    axis.box = { left: plotOffset.left + axisMargin, width: lw };
                    plotOffset.left += lw + axisMargin;
                }
                else {
                    plotOffset.right += lw + axisMargin;
                    axis.box = { left: surface.width - plotOffset.right, width: lw };
                }
            }

             // save for future reference
            axis.position = pos;
            axis.tickLength = tickLength;
            axis.box.padding = padding;
            axis.innermost = innermost;
        }

        function allocateAxisBoxSecondPhase(axis) {
            // now that all axis boxes have been placed in one
            // dimension, we can set the remaining dimension coordinates
            if (axis.direction == "x") {
                axis.box.left = plotOffset.left - axis.labelWidth / 2;
                axis.box.width = surface.width - plotOffset.left - plotOffset.right + axis.labelWidth;
            }
            else {
                axis.box.top = plotOffset.top - axis.labelHeight / 2;
                axis.box.height = surface.height - plotOffset.bottom - plotOffset.top + axis.labelHeight;
            }
        }

        function adjustLayoutForThingsStickingOut() {
            // possibly adjust plot offset to ensure everything stays
            // inside the canvas and isn't clipped off

            var minMargin = options.grid.minBorderMargin,
                axis, i;

            // check stuff from the plot (FIXME: this should just read
            // a value from the series, otherwise it's impossible to
            // customize)
            if (minMargin == null) {
                minMargin = 0;
                for (i = 0; i < series.length; ++i)
                    minMargin = Math.max(minMargin, 2 * (series[i].points.radius + series[i].points.lineWidth/2));
            }

            var margins = {
                left: minMargin,
                right: minMargin,
                top: minMargin,
                bottom: minMargin
            };

            // check axis labels, note we don't check the actual
            // labels but instead use the overall width/height to not
            // jump as much around with replots
            $.each(allAxes(), function (_, axis) {
                if (axis.reserveSpace && axis.ticks && axis.ticks.length) {
                    if (axis.direction === "x") {
                        margins.left = Math.max(margins.left, axis.labelWidth / 2);
                        margins.right = Math.max(margins.right, axis.labelWidth / 2);
                    } else {
                        margins.bottom = Math.max(margins.bottom, axis.labelHeight / 2);
                        margins.top = Math.max(margins.top, axis.labelHeight / 2);
                    }
                }
            });

            plotOffset.left = Math.ceil(Math.max(margins.left, plotOffset.left));
            plotOffset.right = Math.ceil(Math.max(margins.right, plotOffset.right));
            plotOffset.top = Math.ceil(Math.max(margins.top, plotOffset.top));
            plotOffset.bottom = Math.ceil(Math.max(margins.bottom, plotOffset.bottom));
        }

        function setupGrid() {
            var i, axes = allAxes(), showGrid = options.grid.show;

            // Initialize the plot's offset from the edge of the canvas

            for (var a in plotOffset) {
                var margin = options.grid.margin || 0;
                plotOffset[a] = typeof margin == "number" ? margin : margin[a] || 0;
            }

            executeHooks(hooks.processOffset, [plotOffset]);

            // If the grid is visible, add its border width to the offset

            for (var a in plotOffset) {
                if(typeof(options.grid.borderWidth) == "object") {
                    plotOffset[a] += showGrid ? options.grid.borderWidth[a] : 0;
                }
                else {
                    plotOffset[a] += showGrid ? options.grid.borderWidth : 0;
                }
            }

            $.each(axes, function (_, axis) {
                var axisOpts = axis.options;
                axis.show = axisOpts.show == null ? axis.used : axisOpts.show;
                axis.reserveSpace = axisOpts.reserveSpace == null ? axis.show : axisOpts.reserveSpace;
                setRange(axis);
            });

            if (showGrid) {

                var allocatedAxes = $.grep(axes, function (axis) {
                    return axis.show || axis.reserveSpace;
                });

                $.each(allocatedAxes, function (_, axis) {
                    // make the ticks
                    setupTickGeneration(axis);
                    setTicks(axis);
                    snapRangeToTicks(axis, axis.ticks);
                    // find labelWidth/Height for axis
                    measureTickLabels(axis);
                });

                // with all dimensions calculated, we can compute the
                // axis bounding boxes, start from the outside
                // (reverse order)
                for (i = allocatedAxes.length - 1; i >= 0; --i)
                    allocateAxisBoxFirstPhase(allocatedAxes[i]);

                // make sure we've got enough space for things that
                // might stick out
                adjustLayoutForThingsStickingOut();

                $.each(allocatedAxes, function (_, axis) {
                    allocateAxisBoxSecondPhase(axis);
                });
            }

            plotWidth = surface.width - plotOffset.left - plotOffset.right;
            plotHeight = surface.height - plotOffset.bottom - plotOffset.top;

            // now we got the proper plot dimensions, we can compute the scaling
            $.each(axes, function (_, axis) {
                setTransformationHelpers(axis);
            });

            if (showGrid) {
                drawAxisLabels();
            }

            insertLegend();
        }

        function setRange(axis) {
            var opts = axis.options,
                min = +(opts.min != null ? opts.min : axis.datamin),
                max = +(opts.max != null ? opts.max : axis.datamax),
                delta = max - min;

            if (delta == 0.0) {
                // degenerate case
                var widen = max == 0 ? 1 : 0.01;

                if (opts.min == null)
                    min -= widen;
                // always widen max if we couldn't widen min to ensure we
                // don't fall into min == max which doesn't work
                if (opts.max == null || opts.min != null)
                    max += widen;
            }
            else {
                // consider autoscaling
                var margin = opts.autoscaleMargin;
                if (margin != null) {
                    if (opts.min == null) {
                        min -= delta * margin;
                        // make sure we don't go below zero if all values
                        // are positive
                        if (min < 0 && axis.datamin != null && axis.datamin >= 0)
                            min = 0;
                    }
                    if (opts.max == null) {
                        max += delta * margin;
                        if (max > 0 && axis.datamax != null && axis.datamax <= 0)
                            max = 0;
                    }
                }
            }
            axis.min = min;
            axis.max = max;
        }

        function setupTickGeneration(axis) {
            var opts = axis.options;

            // estimate number of ticks
            var noTicks;
            if (typeof opts.ticks == "number" && opts.ticks > 0)
                noTicks = opts.ticks;
            else
                // heuristic based on the model a*sqrt(x) fitted to
                // some data points that seemed reasonable
                noTicks = 0.3 * Math.sqrt(axis.direction == "x" ? surface.width : surface.height);

            var delta = (axis.max - axis.min) / noTicks,
                dec = -Math.floor(Math.log(delta) / Math.LN10),
                maxDec = opts.tickDecimals;

            if (maxDec != null && dec > maxDec) {
                dec = maxDec;
            }

            var magn = Math.pow(10, -dec),
                norm = delta / magn, // norm is between 1.0 and 10.0
                size;

            if (norm < 1.5) {
                size = 1;
            } else if (norm < 3) {
                size = 2;
                // special case for 2.5, requires an extra decimal
                if (norm > 2.25 && (maxDec == null || dec + 1 <= maxDec)) {
                    size = 2.5;
                    ++dec;
                }
            } else if (norm < 7.5) {
                size = 5;
            } else {
                size = 10;
            }

            size *= magn;

            if (opts.minTickSize != null && size < opts.minTickSize) {
                size = opts.minTickSize;
            }

            axis.delta = delta;
            axis.tickDecimals = Math.max(0, maxDec != null ? maxDec : dec);
            axis.tickSize = opts.tickSize || size;

            // Time mode was moved to a plug-in in 0.8, and since so many people use it
            // we'll add an especially friendly reminder to make sure they included it.

            if (opts.mode == "time" && !axis.tickGenerator) {
                throw new Error("Time mode requires the flot.time plugin.");
            }

            // Flot supports base-10 axes; any other mode else is handled by a plug-in,
            // like flot.time.js.

            if (!axis.tickGenerator) {

                axis.tickGenerator = function (axis) {

                    var ticks = [],
                        start = floorInBase(axis.min, axis.tickSize),
                        i = 0,
                        v = Number.NaN,
                        prev;

                    do {
                        prev = v;
                        v = start + i * axis.tickSize;
                        ticks.push(v);
                        ++i;
                    } while (v < axis.max && v != prev);
                    return ticks;
                };

				axis.tickFormatter = function (value, axis) {

					var factor = axis.tickDecimals ? Math.pow(10, axis.tickDecimals) : 1;
					var formatted = "" + Math.round(value * factor) / factor;

					// If tickDecimals was specified, ensure that we have exactly that
					// much precision; otherwise default to the value's own precision.

					if (axis.tickDecimals != null) {
						var decimal = formatted.indexOf(".");
						var precision = decimal == -1 ? 0 : formatted.length - decimal - 1;
						if (precision < axis.tickDecimals) {
							return (precision ? formatted : formatted + ".") + ("" + factor).substr(1, axis.tickDecimals - precision);
						}
					}

                    return formatted;
                };
            }

            if ($.isFunction(opts.tickFormatter))
                axis.tickFormatter = function (v, axis) { return "" + opts.tickFormatter(v, axis); };

            if (opts.alignTicksWithAxis != null) {
                var otherAxis = (axis.direction == "x" ? xaxes : yaxes)[opts.alignTicksWithAxis - 1];
                if (otherAxis && otherAxis.used && otherAxis != axis) {
                    // consider snapping min/max to outermost nice ticks
                    var niceTicks = axis.tickGenerator(axis);
                    if (niceTicks.length > 0) {
                        if (opts.min == null)
                            axis.min = Math.min(axis.min, niceTicks[0]);
                        if (opts.max == null && niceTicks.length > 1)
                            axis.max = Math.max(axis.max, niceTicks[niceTicks.length - 1]);
                    }

                    axis.tickGenerator = function (axis) {
                        // copy ticks, scaled to this axis
                        var ticks = [], v, i;
                        for (i = 0; i < otherAxis.ticks.length; ++i) {
                            v = (otherAxis.ticks[i].v - otherAxis.min) / (otherAxis.max - otherAxis.min);
                            v = axis.min + v * (axis.max - axis.min);
                            ticks.push(v);
                        }
                        return ticks;
                    };

                    // we might need an extra decimal since forced
                    // ticks don't necessarily fit naturally
                    if (!axis.mode && opts.tickDecimals == null) {
                        var extraDec = Math.max(0, -Math.floor(Math.log(axis.delta) / Math.LN10) + 1),
                            ts = axis.tickGenerator(axis);

                        // only proceed if the tick interval rounded
                        // with an extra decimal doesn't give us a
                        // zero at end
                        if (!(ts.length > 1 && /\..*0$/.test((ts[1] - ts[0]).toFixed(extraDec))))
                            axis.tickDecimals = extraDec;
                    }
                }
            }
        }

        function setTicks(axis) {
            var oticks = axis.options.ticks, ticks = [];
            if (oticks == null || (typeof oticks == "number" && oticks > 0))
                ticks = axis.tickGenerator(axis);
            else if (oticks) {
                if ($.isFunction(oticks))
                    // generate the ticks
                    ticks = oticks(axis);
                else
                    ticks = oticks;
            }

            // clean up/labelify the supplied ticks, copy them over
            var i, v;
            axis.ticks = [];
            for (i = 0; i < ticks.length; ++i) {
                var label = null;
                var t = ticks[i];
                if (typeof t == "object") {
                    v = +t[0];
                    if (t.length > 1)
                        label = t[1];
                }
                else
                    v = +t;
                if (label == null)
                    label = axis.tickFormatter(v, axis);
                if (!isNaN(v))
                    axis.ticks.push({ v: v, label: label });
            }
        }

        function snapRangeToTicks(axis, ticks) {
            if (axis.options.autoscaleMargin && ticks.length > 0) {
                // snap to ticks
                if (axis.options.min == null)
                    axis.min = Math.min(axis.min, ticks[0].v);
                if (axis.options.max == null && ticks.length > 1)
                    axis.max = Math.max(axis.max, ticks[ticks.length - 1].v);
            }
        }

        function draw() {

            surface.clear();

            executeHooks(hooks.drawBackground, [ctx]);

            var grid = options.grid;

            // draw background, if any
            if (grid.show && grid.backgroundColor)
                drawBackground();

            if (grid.show && !grid.aboveData) {
                drawGrid();
            }

            for (var i = 0; i < series.length; ++i) {
                executeHooks(hooks.drawSeries, [ctx, series[i]]);
                drawSeries(series[i]);
            }

            executeHooks(hooks.draw, [ctx]);

            if (grid.show && grid.aboveData) {
                drawGrid();
            }

            surface.render();

            // A draw implies that either the axes or data have changed, so we
            // should probably update the overlay highlights as well.

            triggerRedrawOverlay();
        }

        function extractRange(ranges, coord) {
            var axis, from, to, key, axes = allAxes();

            for (var i = 0; i < axes.length; ++i) {
                axis = axes[i];
                if (axis.direction == coord) {
                    key = coord + axis.n + "axis";
                    if (!ranges[key] && axis.n == 1)
                        key = coord + "axis"; // support x1axis as xaxis
                    if (ranges[key]) {
                        from = ranges[key].from;
                        to = ranges[key].to;
                        break;
                    }
                }
            }

            // backwards-compat stuff - to be removed in future
            if (!ranges[key]) {
                axis = coord == "x" ? xaxes[0] : yaxes[0];
                from = ranges[coord + "1"];
                to = ranges[coord + "2"];
            }

            // auto-reverse as an added bonus
            if (from != null && to != null && from > to) {
                var tmp = from;
                from = to;
                to = tmp;
            }

            return { from: from, to: to, axis: axis };
        }

        function drawBackground() {
            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);

            ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor, plotHeight, 0, "rgba(255, 255, 255, 0)");
            ctx.fillRect(0, 0, plotWidth, plotHeight);
            ctx.restore();
        }

        function drawGrid() {
            var i, axes, bw, bc;

            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);

            // draw markings
            var markings = options.grid.markings;
            if (markings) {
                if ($.isFunction(markings)) {
                    axes = plot.getAxes();
                    // xmin etc. is backwards compatibility, to be
                    // removed in the future
                    axes.xmin = axes.xaxis.min;
                    axes.xmax = axes.xaxis.max;
                    axes.ymin = axes.yaxis.min;
                    axes.ymax = axes.yaxis.max;

                    markings = markings(axes);
                }

                for (i = 0; i < markings.length; ++i) {
                    var m = markings[i],
                        xrange = extractRange(m, "x"),
                        yrange = extractRange(m, "y");

                    // fill in missing
                    if (xrange.from == null)
                        xrange.from = xrange.axis.min;
                    if (xrange.to == null)
                        xrange.to = xrange.axis.max;
                    if (yrange.from == null)
                        yrange.from = yrange.axis.min;
                    if (yrange.to == null)
                        yrange.to = yrange.axis.max;

                    // clip
                    if (xrange.to < xrange.axis.min || xrange.from > xrange.axis.max ||
                        yrange.to < yrange.axis.min || yrange.from > yrange.axis.max)
                        continue;

                    xrange.from = Math.max(xrange.from, xrange.axis.min);
                    xrange.to = Math.min(xrange.to, xrange.axis.max);
                    yrange.from = Math.max(yrange.from, yrange.axis.min);
                    yrange.to = Math.min(yrange.to, yrange.axis.max);

                    var xequal = xrange.from === xrange.to,
                        yequal = yrange.from === yrange.to;

                    if (xequal && yequal) {
                        continue;
                    }

                    // then draw
                    xrange.from = Math.floor(xrange.axis.p2c(xrange.from));
                    xrange.to = Math.floor(xrange.axis.p2c(xrange.to));
                    yrange.from = Math.floor(yrange.axis.p2c(yrange.from));
                    yrange.to = Math.floor(yrange.axis.p2c(yrange.to));

                    if (xequal || yequal) {
                        var lineWidth = m.lineWidth || options.grid.markingsLineWidth,
                            subPixel = lineWidth % 2 ? 0.5 : 0;
                        ctx.beginPath();
                        ctx.strokeStyle = m.color || options.grid.markingsColor;
                        ctx.lineWidth = lineWidth;
                        if (xequal) {
                            ctx.moveTo(xrange.to + subPixel, yrange.from);
                            ctx.lineTo(xrange.to + subPixel, yrange.to);
                        } else {
                            ctx.moveTo(xrange.from, yrange.to + subPixel);
                            ctx.lineTo(xrange.to, yrange.to + subPixel);                            
                        }
                        ctx.stroke();
                    } else {
                        ctx.fillStyle = m.color || options.grid.markingsColor;
                        ctx.fillRect(xrange.from, yrange.to,
                                     xrange.to - xrange.from,
                                     yrange.from - yrange.to);
                    }
                }
            }

            // draw the ticks
            axes = allAxes();
            bw = options.grid.borderWidth;

            for (var j = 0; j < axes.length; ++j) {
                var axis = axes[j], box = axis.box,
                    t = axis.tickLength, x, y, xoff, yoff;
                if (!axis.show || axis.ticks.length == 0)
                    continue;

                ctx.lineWidth = 1;

                // find the edges
                if (axis.direction == "x") {
                    x = 0;
                    if (t == "full")
                        y = (axis.position == "top" ? 0 : plotHeight);
                    else
                        y = box.top - plotOffset.top + (axis.position == "top" ? box.height : 0);
                }
                else {
                    y = 0;
                    if (t == "full")
                        x = (axis.position == "left" ? 0 : plotWidth);
                    else
                        x = box.left - plotOffset.left + (axis.position == "left" ? box.width : 0);
                }

                // draw tick bar
                if (!axis.innermost) {
                    ctx.strokeStyle = axis.options.color;
                    ctx.beginPath();
                    xoff = yoff = 0;
                    if (axis.direction == "x")
                        xoff = plotWidth + 1;
                    else
                        yoff = plotHeight + 1;

                    if (ctx.lineWidth == 1) {
                        if (axis.direction == "x") {
                            y = Math.floor(y) + 0.5;
                        } else {
                            x = Math.floor(x) + 0.5;
                        }
                    }

                    ctx.moveTo(x, y);
                    ctx.lineTo(x + xoff, y + yoff);
                    ctx.stroke();
                }

                // draw ticks

                ctx.strokeStyle = axis.options.tickColor;

                ctx.beginPath();
                for (i = 0; i < axis.ticks.length; ++i) {
                    var v = axis.ticks[i].v;

                    xoff = yoff = 0;

                    if (isNaN(v) || v < axis.min || v > axis.max
                        // skip those lying on the axes if we got a border
                        || (t == "full"
                            && ((typeof bw == "object" && bw[axis.position] > 0) || bw > 0)
                            && (v == axis.min || v == axis.max)))
                        continue;

                    if (axis.direction == "x") {
                        x = axis.p2c(v);
                        yoff = t == "full" ? -plotHeight : t;

                        if (axis.position == "top")
                            yoff = -yoff;
                    }
                    else {
                        y = axis.p2c(v);
                        xoff = t == "full" ? -plotWidth : t;

                        if (axis.position == "left")
                            xoff = -xoff;
                    }

                    if (ctx.lineWidth == 1) {
                        if (axis.direction == "x")
                            x = Math.floor(x) + 0.5;
                        else
                            y = Math.floor(y) + 0.5;
                    }

                    ctx.moveTo(x, y);
                    ctx.lineTo(x + xoff, y + yoff);
                }

                ctx.stroke();
            }


            // draw border
            if (bw) {
                // If either borderWidth or borderColor is an object, then draw the border
                // line by line instead of as one rectangle
                bc = options.grid.borderColor;
                if(typeof bw == "object" || typeof bc == "object") {
                    if (typeof bw !== "object") {
                        bw = {top: bw, right: bw, bottom: bw, left: bw};
                    }
                    if (typeof bc !== "object") {
                        bc = {top: bc, right: bc, bottom: bc, left: bc};
                    }

                    if (bw.top > 0) {
                        ctx.strokeStyle = bc.top;
                        ctx.lineWidth = bw.top;
                        ctx.beginPath();
                        ctx.moveTo(0 - bw.left, 0 - bw.top/2);
                        ctx.lineTo(plotWidth, 0 - bw.top/2);
                        ctx.stroke();
                    }

                    if (bw.right > 0) {
                        ctx.strokeStyle = bc.right;
                        ctx.lineWidth = bw.right;
                        ctx.beginPath();
                        ctx.moveTo(plotWidth + bw.right / 2, 0 - bw.top);
                        ctx.lineTo(plotWidth + bw.right / 2, plotHeight);
                        ctx.stroke();
                    }

                    if (bw.bottom > 0) {
                        ctx.strokeStyle = bc.bottom;
                        ctx.lineWidth = bw.bottom;
                        ctx.beginPath();
                        ctx.moveTo(plotWidth + bw.right, plotHeight + bw.bottom / 2);
                        ctx.lineTo(0, plotHeight + bw.bottom / 2);
                        ctx.stroke();
                    }

                    if (bw.left > 0) {
                        ctx.strokeStyle = bc.left;
                        ctx.lineWidth = bw.left;
                        ctx.beginPath();
                        ctx.moveTo(0 - bw.left/2, plotHeight + bw.bottom);
                        ctx.lineTo(0- bw.left/2, 0);
                        ctx.stroke();
                    }
                }
                else {
                    ctx.lineWidth = bw;
                    ctx.strokeStyle = options.grid.borderColor;
                    ctx.strokeRect(-bw/2, -bw/2, plotWidth + bw, plotHeight + bw);
                }
            }

            ctx.restore();
        }

        function drawAxisLabels() {

            $.each(allAxes(), function (_, axis) {
                var box = axis.box,
                    legacyStyles = axis.direction + "Axis " + axis.direction + axis.n + "Axis",
                    layer = "flot-" + axis.direction + "-axis flot-" + axis.direction + axis.n + "-axis " + legacyStyles,
                    font = axis.options.font || "flot-tick-label tickLabel",
                    tick, x, y, halign, valign;

                // Remove text before checking for axis.show and ticks.length;
                // otherwise plugins, like flot-tickrotor, that draw their own
                // tick labels will end up with both theirs and the defaults.

                surface.removeText(layer);

                if (!axis.show || axis.ticks.length == 0)
                    return;

                for (var i = 0; i < axis.ticks.length; ++i) {

                    tick = axis.ticks[i];
                    if (!tick.label || tick.v < axis.min || tick.v > axis.max)
                        continue;

                    if (axis.direction == "x") {
                        halign = "center";
                        x = plotOffset.left + axis.p2c(tick.v);
                        if (axis.position == "bottom") {
                            y = box.top + box.padding;
                        } else {
                            y = box.top + box.height - box.padding;
                            valign = "bottom";
                        }
                    } else {
                        valign = "middle";
                        y = plotOffset.top + axis.p2c(tick.v);
                        if (axis.position == "left") {
                            x = box.left + box.width - box.padding;
                            halign = "right";
                        } else {
                            x = box.left + box.padding;
                        }
                    }

                    surface.addText(layer, x, y, tick.label, font, null, null, halign, valign);
                }
            });
        }

        function drawSeries(series) {
            if (series.lines.show)
                drawSeriesLines(series);
            if (series.bars.show)
                drawSeriesBars(series);
            if (series.points.show)
                drawSeriesPoints(series);
        }

        function drawSeriesLines(series) {
            function plotLine(datapoints, xoffset, yoffset, axisx, axisy) {
                var points = datapoints.points,
                    ps = datapoints.pointsize,
                    prevx = null, prevy = null;

                ctx.beginPath();
                for (var i = ps; i < points.length; i += ps) {
                    var x1 = points[i - ps], y1 = points[i - ps + 1],
                        x2 = points[i], y2 = points[i + 1];

                    if (x1 == null || x2 == null)
                        continue;

                    // clip with ymin
                    if (y1 <= y2 && y1 < axisy.min) {
                        if (y2 < axisy.min)
                            continue;   // line segment is outside
                        // compute new intersection point
                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y1 = axisy.min;
                    }
                    else if (y2 <= y1 && y2 < axisy.min) {
                        if (y1 < axisy.min)
                            continue;
                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y2 = axisy.min;
                    }

                    // clip with ymax
                    if (y1 >= y2 && y1 > axisy.max) {
                        if (y2 > axisy.max)
                            continue;
                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y1 = axisy.max;
                    }
                    else if (y2 >= y1 && y2 > axisy.max) {
                        if (y1 > axisy.max)
                            continue;
                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y2 = axisy.max;
                    }

                    // clip with xmin
                    if (x1 <= x2 && x1 < axisx.min) {
                        if (x2 < axisx.min)
                            continue;
                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x1 = axisx.min;
                    }
                    else if (x2 <= x1 && x2 < axisx.min) {
                        if (x1 < axisx.min)
                            continue;
                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x2 = axisx.min;
                    }

                    // clip with xmax
                    if (x1 >= x2 && x1 > axisx.max) {
                        if (x2 > axisx.max)
                            continue;
                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x1 = axisx.max;
                    }
                    else if (x2 >= x1 && x2 > axisx.max) {
                        if (x1 > axisx.max)
                            continue;
                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x2 = axisx.max;
                    }

                    if (x1 != prevx || y1 != prevy)
                        ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);

                    prevx = x2;
                    prevy = y2;
                    ctx.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2) + yoffset);
                }
                ctx.stroke();
            }

            function plotLineArea(datapoints, axisx, axisy) {
                var points = datapoints.points,
                    ps = datapoints.pointsize,
                    bottom = Math.min(Math.max(0, axisy.min), axisy.max),
                    i = 0, top, areaOpen = false,
                    ypos = 1, segmentStart = 0, segmentEnd = 0;

                // we process each segment in two turns, first forward
                // direction to sketch out top, then once we hit the
                // end we go backwards to sketch the bottom
                while (true) {
                    if (ps > 0 && i > points.length + ps)
                        break;

                    i += ps; // ps is negative if going backwards

                    var x1 = points[i - ps],
                        y1 = points[i - ps + ypos],
                        x2 = points[i], y2 = points[i + ypos];

                    if (areaOpen) {
                        if (ps > 0 && x1 != null && x2 == null) {
                            // at turning point
                            segmentEnd = i;
                            ps = -ps;
                            ypos = 2;
                            continue;
                        }

                        if (ps < 0 && i == segmentStart + ps) {
                            // done with the reverse sweep
                            ctx.fill();
                            areaOpen = false;
                            ps = -ps;
                            ypos = 1;
                            i = segmentStart = segmentEnd + ps;
                            continue;
                        }
                    }

                    if (x1 == null || x2 == null)
                        continue;

                    // clip x values

                    // clip with xmin
                    if (x1 <= x2 && x1 < axisx.min) {
                        if (x2 < axisx.min)
                            continue;
                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x1 = axisx.min;
                    }
                    else if (x2 <= x1 && x2 < axisx.min) {
                        if (x1 < axisx.min)
                            continue;
                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x2 = axisx.min;
                    }

                    // clip with xmax
                    if (x1 >= x2 && x1 > axisx.max) {
                        if (x2 > axisx.max)
                            continue;
                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x1 = axisx.max;
                    }
                    else if (x2 >= x1 && x2 > axisx.max) {
                        if (x1 > axisx.max)
                            continue;
                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x2 = axisx.max;
                    }

                    if (!areaOpen) {
                        // open area
                        ctx.beginPath();
                        ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));
                        areaOpen = true;
                    }

                    // now first check the case where both is outside
                    if (y1 >= axisy.max && y2 >= axisy.max) {
                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));
                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));
                        continue;
                    }
                    else if (y1 <= axisy.min && y2 <= axisy.min) {
                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));
                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));
                        continue;
                    }

                    // else it's a bit more complicated, there might
                    // be a flat maxed out rectangle first, then a
                    // triangular cutout or reverse; to find these
                    // keep track of the current x values
                    var x1old = x1, x2old = x2;

                    // clip the y values, without shortcutting, we
                    // go through all cases in turn

                    // clip with ymin
                    if (y1 <= y2 && y1 < axisy.min && y2 >= axisy.min) {
                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y1 = axisy.min;
                    }
                    else if (y2 <= y1 && y2 < axisy.min && y1 >= axisy.min) {
                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y2 = axisy.min;
                    }

                    // clip with ymax
                    if (y1 >= y2 && y1 > axisy.max && y2 <= axisy.max) {
                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y1 = axisy.max;
                    }
                    else if (y2 >= y1 && y2 > axisy.max && y1 <= axisy.max) {
                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y2 = axisy.max;
                    }

                    // if the x value was changed we got a rectangle
                    // to fill
                    if (x1 != x1old) {
                        ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1));
                        // it goes to (x1, y1), but we fill that below
                    }

                    // fill triangular section, this sometimes result
                    // in redundant points if (x1, y1) hasn't changed
                    // from previous line to, but we just ignore that
                    ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));
                    ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));

                    // fill the other rectangle if it's there
                    if (x2 != x2old) {
                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));
                        ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2));
                    }
                }
            }

            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);
            ctx.lineJoin = "round";

            var lw = series.lines.lineWidth,
                sw = series.shadowSize;
            // FIXME: consider another form of shadow when filling is turned on
            if (lw > 0 && sw > 0) {
                // draw shadow as a thick and thin line with transparency
                ctx.lineWidth = sw;
                ctx.strokeStyle = "rgba(0,0,0,0.1)";
                // position shadow at angle from the mid of line
                var angle = Math.PI/18;
                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/2), Math.cos(angle) * (lw/2 + sw/2), series.xaxis, series.yaxis);
                ctx.lineWidth = sw/2;
                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/4), Math.cos(angle) * (lw/2 + sw/4), series.xaxis, series.yaxis);
            }

            ctx.lineWidth = lw;
            ctx.strokeStyle = series.color;
            var fillStyle = getFillStyle(series.lines, series.color, 0, plotHeight);
            if (fillStyle) {
                ctx.fillStyle = fillStyle;
                plotLineArea(series.datapoints, series.xaxis, series.yaxis);
            }

            if (lw > 0)
                plotLine(series.datapoints, 0, 0, series.xaxis, series.yaxis);
            ctx.restore();
        }

        function drawSeriesPoints(series) {
            function plotPoints(datapoints, radius, fillStyle, offset, shadow, axisx, axisy, symbol) {
                var points = datapoints.points, ps = datapoints.pointsize;

                for (var i = 0; i < points.length; i += ps) {
                    var x = points[i], y = points[i + 1];
                    if (x == null || x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)
                        continue;

                    ctx.beginPath();
                    x = axisx.p2c(x);
                    y = axisy.p2c(y) + offset;
                    if (symbol == "circle")
                        ctx.arc(x, y, radius, 0, shadow ? Math.PI : Math.PI * 2, false);
                    else
                        symbol(ctx, x, y, radius, shadow);
                    ctx.closePath();

                    if (fillStyle) {
                        ctx.fillStyle = fillStyle;
                        ctx.fill();
                    }
                    ctx.stroke();
                }
            }

            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);

            var lw = series.points.lineWidth,
                sw = series.shadowSize,
                radius = series.points.radius,
                symbol = series.points.symbol;

            // If the user sets the line width to 0, we change it to a very 
            // small value. A line width of 0 seems to force the default of 1.
            // Doing the conditional here allows the shadow setting to still be 
            // optional even with a lineWidth of 0.

            if( lw == 0 )
                lw = 0.0001;

            if (lw > 0 && sw > 0) {
                // draw shadow in two steps
                var w = sw / 2;
                ctx.lineWidth = w;
                ctx.strokeStyle = "rgba(0,0,0,0.1)";
                plotPoints(series.datapoints, radius, null, w + w/2, true,
                           series.xaxis, series.yaxis, symbol);

                ctx.strokeStyle = "rgba(0,0,0,0.2)";
                plotPoints(series.datapoints, radius, null, w/2, true,
                           series.xaxis, series.yaxis, symbol);
            }

            ctx.lineWidth = lw;
            ctx.strokeStyle = series.color;
            plotPoints(series.datapoints, radius,
                       getFillStyle(series.points, series.color), 0, false,
                       series.xaxis, series.yaxis, symbol);
            ctx.restore();
        }

        function drawBar(x, y, b, barLeft, barRight, fillStyleCallback, axisx, axisy, c, horizontal, lineWidth) {
            var left, right, bottom, top,
                drawLeft, drawRight, drawTop, drawBottom,
                tmp;

            // in horizontal mode, we start the bar from the left
            // instead of from the bottom so it appears to be
            // horizontal rather than vertical
            if (horizontal) {
                drawBottom = drawRight = drawTop = true;
                drawLeft = false;
                left = b;
                right = x;
                top = y + barLeft;
                bottom = y + barRight;

                // account for negative bars
                if (right < left) {
                    tmp = right;
                    right = left;
                    left = tmp;
                    drawLeft = true;
                    drawRight = false;
                }
            }
            else {
                drawLeft = drawRight = drawTop = true;
                drawBottom = false;
                left = x + barLeft;
                right = x + barRight;
                bottom = b;
                top = y;

                // account for negative bars
                if (top < bottom) {
                    tmp = top;
                    top = bottom;
                    bottom = tmp;
                    drawBottom = true;
                    drawTop = false;
                }
            }

            // clip
            if (right < axisx.min || left > axisx.max ||
                top < axisy.min || bottom > axisy.max)
                return;

            if (left < axisx.min) {
                left = axisx.min;
                drawLeft = false;
            }

            if (right > axisx.max) {
                right = axisx.max;
                drawRight = false;
            }

            if (bottom < axisy.min) {
                bottom = axisy.min;
                drawBottom = false;
            }

            if (top > axisy.max) {
                top = axisy.max;
                drawTop = false;
            }

            left = axisx.p2c(left);
            bottom = axisy.p2c(bottom);
            right = axisx.p2c(right);
            top = axisy.p2c(top);

            // fill the bar
            if (fillStyleCallback) {
                c.fillStyle = fillStyleCallback(bottom, top);
                c.fillRect(left, top, right - left, bottom - top)
            }

            // draw outline
            if (lineWidth > 0 && (drawLeft || drawRight || drawTop || drawBottom)) {
                c.beginPath();

                // FIXME: inline moveTo is buggy with excanvas
                c.moveTo(left, bottom);
                if (drawLeft)
                    c.lineTo(left, top);
                else
                    c.moveTo(left, top);
                if (drawTop)
                    c.lineTo(right, top);
                else
                    c.moveTo(right, top);
                if (drawRight)
                    c.lineTo(right, bottom);
                else
                    c.moveTo(right, bottom);
                if (drawBottom)
                    c.lineTo(left, bottom);
                else
                    c.moveTo(left, bottom);
                c.stroke();
            }
        }

        function drawSeriesBars(series) {
            function plotBars(datapoints, barLeft, barRight, fillStyleCallback, axisx, axisy) {
                var points = datapoints.points, ps = datapoints.pointsize;

                for (var i = 0; i < points.length; i += ps) {
                    if (points[i] == null)
                        continue;
                    drawBar(points[i], points[i + 1], points[i + 2], barLeft, barRight, fillStyleCallback, axisx, axisy, ctx, series.bars.horizontal, series.bars.lineWidth);
                }
            }

            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);

            // FIXME: figure out a way to add shadows (for instance along the right edge)
            ctx.lineWidth = series.bars.lineWidth;
            ctx.strokeStyle = series.color;

            var barLeft;

            switch (series.bars.align) {
                case "left":
                    barLeft = 0;
                    break;
                case "right":
                    barLeft = -series.bars.barWidth;
                    break;
                default:
                    barLeft = -series.bars.barWidth / 2;
            }

            var fillStyleCallback = series.bars.fill ? function (bottom, top) { return getFillStyle(series.bars, series.color, bottom, top); } : null;
            plotBars(series.datapoints, barLeft, barLeft + series.bars.barWidth, fillStyleCallback, series.xaxis, series.yaxis);
            ctx.restore();
        }

        function getFillStyle(filloptions, seriesColor, bottom, top) {
            var fill = filloptions.fill;
            if (!fill)
                return null;

            if (filloptions.fillColor)
                return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);

            var c = $.color.parse(seriesColor);
            c.a = typeof fill == "number" ? fill : 0.4;
            c.normalize();
            return c.toString();
        }

        function insertLegend() {

            if (options.legend.container != null) {
                $(options.legend.container).html("");
            } else {
                placeholder.find(".legend").remove();
            }

            if (!options.legend.show) {
                return;
            }

            var fragments = [], entries = [], rowStarted = false,
                lf = options.legend.labelFormatter, s, label;

            // Build a list of legend entries, with each having a label and a color

            for (var i = 0; i < series.length; ++i) {
                s = series[i];
                if (s.label) {
                    label = lf ? lf(s.label, s) : s.label;
                    if (label) {
                        entries.push({
                            label: label,
                            color: s.color
                        });
                    }
                }
            }

            // Sort the legend using either the default or a custom comparator

            if (options.legend.sorted) {
                if ($.isFunction(options.legend.sorted)) {
                    entries.sort(options.legend.sorted);
                } else if (options.legend.sorted == "reverse") {
                	entries.reverse();
                } else {
                    var ascending = options.legend.sorted != "descending";
                    entries.sort(function(a, b) {
                        return a.label == b.label ? 0 : (
                            (a.label < b.label) != ascending ? 1 : -1   // Logical XOR
                        );
                    });
                }
            }

            // Generate markup for the list of entries, in their final order

            for (var i = 0; i < entries.length; ++i) {

                var entry = entries[i];

                if (i % options.legend.noColumns == 0) {
                    if (rowStarted)
                        fragments.push('</tr>');
                    fragments.push('<tr>');
                    rowStarted = true;
                }

                fragments.push(
                    '<td class="legendColorBox"><div style="border:1px solid ' + options.legend.labelBoxBorderColor + ';padding:1px"><div style="width:4px;height:0;border:5px solid ' + entry.color + ';overflow:hidden"></div></div></td>' +
                    '<td class="legendLabel">' + entry.label + '</td>'
                );
            }

            if (rowStarted)
                fragments.push('</tr>');

            if (fragments.length == 0)
                return;

            var table = '<table style="font-size:smaller;color:' + options.grid.color + '">' + fragments.join("") + '</table>';
            if (options.legend.container != null)
                $(options.legend.container).html(table);
            else {
                var pos = "",
                    p = options.legend.position,
                    m = options.legend.margin;
                if (m[0] == null)
                    m = [m, m];
                if (p.charAt(0) == "n")
                    pos += 'top:' + (m[1] + plotOffset.top) + 'px;';
                else if (p.charAt(0) == "s")
                    pos += 'bottom:' + (m[1] + plotOffset.bottom) + 'px;';
                if (p.charAt(1) == "e")
                    pos += 'right:' + (m[0] + plotOffset.right) + 'px;';
                else if (p.charAt(1) == "w")
                    pos += 'left:' + (m[0] + plotOffset.left) + 'px;';
                var legend = $('<div class="legend">' + table.replace('style="', 'style="position:absolute;' + pos +';') + '</div>').appendTo(placeholder);
                if (options.legend.backgroundOpacity != 0.0) {
                    // put in the transparent background
                    // separately to avoid blended labels and
                    // label boxes
                    var c = options.legend.backgroundColor;
                    if (c == null) {
                        c = options.grid.backgroundColor;
                        if (c && typeof c == "string")
                            c = $.color.parse(c);
                        else
                            c = $.color.extract(legend, 'background-color');
                        c.a = 1;
                        c = c.toString();
                    }
                    var div = legend.children();
                    $('<div style="position:absolute;width:' + div.width() + 'px;height:' + div.height() + 'px;' + pos +'background-color:' + c + ';"> </div>').prependTo(legend).css('opacity', options.legend.backgroundOpacity);
                }
            }
        }


        // interactive features

        var highlights = [],
            redrawTimeout = null;

        // returns the data item the mouse is over, or null if none is found
        function findNearbyItem(mouseX, mouseY, seriesFilter) {
            var maxDistance = options.grid.mouseActiveRadius,
                smallestDistance = maxDistance * maxDistance + 1,
                item = null, foundPoint = false, i, j, ps;

            for (i = series.length - 1; i >= 0; --i) {
                if (!seriesFilter(series[i]))
                    continue;

                var s = series[i],
                    axisx = s.xaxis,
                    axisy = s.yaxis,
                    points = s.datapoints.points,
                    mx = axisx.c2p(mouseX), // precompute some stuff to make the loop faster
                    my = axisy.c2p(mouseY),
                    maxx = maxDistance / axisx.scale,
                    maxy = maxDistance / axisy.scale;

                ps = s.datapoints.pointsize;
                // with inverse transforms, we can't use the maxx/maxy
                // optimization, sadly
                if (axisx.options.inverseTransform)
                    maxx = Number.MAX_VALUE;
                if (axisy.options.inverseTransform)
                    maxy = Number.MAX_VALUE;

                if (s.lines.show || s.points.show) {
                    for (j = 0; j < points.length; j += ps) {
                        var x = points[j], y = points[j + 1];
                        if (x == null)
                            continue;

                        // For points and lines, the cursor must be within a
                        // certain distance to the data point
                        if (x - mx > maxx || x - mx < -maxx ||
                            y - my > maxy || y - my < -maxy)
                            continue;

                        // We have to calculate distances in pixels, not in
                        // data units, because the scales of the axes may be different
                        var dx = Math.abs(axisx.p2c(x) - mouseX),
                            dy = Math.abs(axisy.p2c(y) - mouseY),
                            dist = dx * dx + dy * dy; // we save the sqrt

                        // use <= to ensure last point takes precedence
                        // (last generally means on top of)
                        if (dist < smallestDistance) {
                            smallestDistance = dist;
                            item = [i, j / ps];
                        }
                    }
                }

                if (s.bars.show && !item) { // no other point can be nearby

                    var barLeft, barRight;

                    switch (s.bars.align) {
                        case "left":
                            barLeft = 0;
                            break;
                        case "right":
                            barLeft = -s.bars.barWidth;
                            break;
                        default:
                            barLeft = -s.bars.barWidth / 2;
                    }

                    barRight = barLeft + s.bars.barWidth;

                    for (j = 0; j < points.length; j += ps) {
                        var x = points[j], y = points[j + 1], b = points[j + 2];
                        if (x == null)
                            continue;

                        // for a bar graph, the cursor must be inside the bar
                        if (series[i].bars.horizontal ?
                            (mx <= Math.max(b, x) && mx >= Math.min(b, x) &&
                             my >= y + barLeft && my <= y + barRight) :
                            (mx >= x + barLeft && mx <= x + barRight &&
                             my >= Math.min(b, y) && my <= Math.max(b, y)))
                                item = [i, j / ps];
                    }
                }
            }

            if (item) {
                i = item[0];
                j = item[1];
                ps = series[i].datapoints.pointsize;

                return { datapoint: series[i].datapoints.points.slice(j * ps, (j + 1) * ps),
                         dataIndex: j,
                         series: series[i],
                         seriesIndex: i };
            }

            return null;
        }

        function onMouseMove(e) {
            if (options.grid.hoverable)
                triggerClickHoverEvent("plothover", e,
                                       function (s) { return s["hoverable"] != false; });
        }

        function onMouseLeave(e) {
            if (options.grid.hoverable)
                triggerClickHoverEvent("plothover", e,
                                       function (s) { return false; });
        }

        function onClick(e) {
            triggerClickHoverEvent("plotclick", e,
                                   function (s) { return s["clickable"] != false; });
        }

        // trigger click or hover event (they send the same parameters
        // so we share their code)
        function triggerClickHoverEvent(eventname, event, seriesFilter) {
            var offset = eventHolder.offset(),
                canvasX = event.pageX - offset.left - plotOffset.left,
                canvasY = event.pageY - offset.top - plotOffset.top,
            pos = canvasToAxisCoords({ left: canvasX, top: canvasY });

            pos.pageX = event.pageX;
            pos.pageY = event.pageY;

            var item = findNearbyItem(canvasX, canvasY, seriesFilter);

            if (item) {
                // fill in mouse pos for any listeners out there
                item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0]) + offset.left + plotOffset.left, 10);
                item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1]) + offset.top + plotOffset.top, 10);
            }

            if (options.grid.autoHighlight) {
                // clear auto-highlights
                for (var i = 0; i < highlights.length; ++i) {
                    var h = highlights[i];
                    if (h.auto == eventname &&
                        !(item && h.series == item.series &&
                          h.point[0] == item.datapoint[0] &&
                          h.point[1] == item.datapoint[1]))
                        unhighlight(h.series, h.point);
                }

                if (item)
                    highlight(item.series, item.datapoint, eventname);
            }

            placeholder.trigger(eventname, [ pos, item ]);
        }

        function triggerRedrawOverlay() {
            var t = options.interaction.redrawOverlayInterval;
            if (t == -1) {      // skip event queue
                drawOverlay();
                return;
            }

            if (!redrawTimeout)
                redrawTimeout = setTimeout(drawOverlay, t);
        }

        function drawOverlay() {
            redrawTimeout = null;

            // draw highlights
            octx.save();
            overlay.clear();
            octx.translate(plotOffset.left, plotOffset.top);

            var i, hi;
            for (i = 0; i < highlights.length; ++i) {
                hi = highlights[i];

                if (hi.series.bars.show)
                    drawBarHighlight(hi.series, hi.point);
                else
                    drawPointHighlight(hi.series, hi.point);
            }
            octx.restore();

            executeHooks(hooks.drawOverlay, [octx]);
        }

        function highlight(s, point, auto) {
            if (typeof s == "number")
                s = series[s];

            if (typeof point == "number") {
                var ps = s.datapoints.pointsize;
                point = s.datapoints.points.slice(ps * point, ps * (point + 1));
            }

            var i = indexOfHighlight(s, point);
            if (i == -1) {
                highlights.push({ series: s, point: point, auto: auto });

                triggerRedrawOverlay();
            }
            else if (!auto)
                highlights[i].auto = false;
        }

        function unhighlight(s, point) {
            if (s == null && point == null) {
                highlights = [];
                triggerRedrawOverlay();
                return;
            }

            if (typeof s == "number")
                s = series[s];

            if (typeof point == "number") {
                var ps = s.datapoints.pointsize;
                point = s.datapoints.points.slice(ps * point, ps * (point + 1));
            }

            var i = indexOfHighlight(s, point);
            if (i != -1) {
                highlights.splice(i, 1);

                triggerRedrawOverlay();
            }
        }

        function indexOfHighlight(s, p) {
            for (var i = 0; i < highlights.length; ++i) {
                var h = highlights[i];
                if (h.series == s && h.point[0] == p[0]
                    && h.point[1] == p[1])
                    return i;
            }
            return -1;
        }

        function drawPointHighlight(series, point) {
            var x = point[0], y = point[1],
                axisx = series.xaxis, axisy = series.yaxis,
                highlightColor = (typeof series.highlightColor === "string") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString();

            if (x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)
                return;

            var pointRadius = series.points.radius + series.points.lineWidth / 2;
            octx.lineWidth = pointRadius;
            octx.strokeStyle = highlightColor;
            var radius = 1.5 * pointRadius;
            x = axisx.p2c(x);
            y = axisy.p2c(y);

            octx.beginPath();
            if (series.points.symbol == "circle")
                octx.arc(x, y, radius, 0, 2 * Math.PI, false);
            else
                series.points.symbol(octx, x, y, radius, false);
            octx.closePath();
            octx.stroke();
        }

        function drawBarHighlight(series, point) {
            var highlightColor = (typeof series.highlightColor === "string") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString(),
                fillStyle = highlightColor,
                barLeft;

            switch (series.bars.align) {
                case "left":
                    barLeft = 0;
                    break;
                case "right":
                    barLeft = -series.bars.barWidth;
                    break;
                default:
                    barLeft = -series.bars.barWidth / 2;
            }

            octx.lineWidth = series.bars.lineWidth;
            octx.strokeStyle = highlightColor;

            drawBar(point[0], point[1], point[2] || 0, barLeft, barLeft + series.bars.barWidth,
                    function () { return fillStyle; }, series.xaxis, series.yaxis, octx, series.bars.horizontal, series.bars.lineWidth);
        }

        function getColorOrGradient(spec, bottom, top, defaultColor) {
            if (typeof spec == "string")
                return spec;
            else {
                // assume this is a gradient spec; IE currently only
                // supports a simple vertical gradient properly, so that's
                // what we support too
                var gradient = ctx.createLinearGradient(0, top, 0, bottom);

                for (var i = 0, l = spec.colors.length; i < l; ++i) {
                    var c = spec.colors[i];
                    if (typeof c != "string") {
                        var co = $.color.parse(defaultColor);
                        if (c.brightness != null)
                            co = co.scale('rgb', c.brightness);
                        if (c.opacity != null)
                            co.a *= c.opacity;
                        c = co.toString();
                    }
                    gradient.addColorStop(i / (l - 1), c);
                }

                return gradient;
            }
        }
    }

    // Add the plot function to the top level of the jQuery object

    $.plot = function(placeholder, data, options) {
        //var t0 = new Date();
        var plot = new Plot($(placeholder), data, options, $.plot.plugins);
        //(window.console ? console.log : alert)("time used (msecs): " + ((new Date()).getTime() - t0.getTime()));
        return plot;
    };

    $.plot.version = "0.8.3";

    $.plot.plugins = [];

    // Also add the plot function as a chainable property

    $.fn.plot = function(data, options) {
        return this.each(function() {
            $.plot(this, data, options);
        });
    };

    // round to nearby lower multiple of base
    function floorInBase(n, base) {
        return base * Math.floor(n / base);
    }

})(jQuery);


/***/ }),
/* 1507 */
/***/ (function(module, exports) {

/* Pretty handling of time axes.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

Set axis.mode to "time" to enable. See the section "Time series data" in
API.txt for details.

*/

(function($) {

	var options = {
		xaxis: {
			timezone: null,		// "browser" for local to the client or timezone for timezone-js
			timeformat: null,	// format string to use
			twelveHourClock: false,	// 12 or 24 time in time mode
			monthNames: null	// list of names of months
		}
	};

	// round to nearby lower multiple of base

	function floorInBase(n, base) {
		return base * Math.floor(n / base);
	}

	// Returns a string with the date d formatted according to fmt.
	// A subset of the Open Group's strftime format is supported.

	function formatDate(d, fmt, monthNames, dayNames) {

		if (typeof d.strftime == "function") {
			return d.strftime(fmt);
		}

		var leftPad = function(n, pad) {
			n = "" + n;
			pad = "" + (pad == null ? "0" : pad);
			return n.length == 1 ? pad + n : n;
		};

		var r = [];
		var escape = false;
		var hours = d.getHours();
		var isAM = hours < 12;

		if (monthNames == null) {
			monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
		}

		if (dayNames == null) {
			dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
		}

		var hours12;

		if (hours > 12) {
			hours12 = hours - 12;
		} else if (hours == 0) {
			hours12 = 12;
		} else {
			hours12 = hours;
		}

		for (var i = 0; i < fmt.length; ++i) {

			var c = fmt.charAt(i);

			if (escape) {
				switch (c) {
					case 'a': c = "" + dayNames[d.getDay()]; break;
					case 'b': c = "" + monthNames[d.getMonth()]; break;
					case 'd': c = leftPad(d.getDate()); break;
					case 'e': c = leftPad(d.getDate(), " "); break;
					case 'h':	// For back-compat with 0.7; remove in 1.0
					case 'H': c = leftPad(hours); break;
					case 'I': c = leftPad(hours12); break;
					case 'l': c = leftPad(hours12, " "); break;
					case 'm': c = leftPad(d.getMonth() + 1); break;
					case 'M': c = leftPad(d.getMinutes()); break;
					// quarters not in Open Group's strftime specification
					case 'q':
						c = "" + (Math.floor(d.getMonth() / 3) + 1); break;
					case 'S': c = leftPad(d.getSeconds()); break;
					case 'y': c = leftPad(d.getFullYear() % 100); break;
					case 'Y': c = "" + d.getFullYear(); break;
					case 'p': c = (isAM) ? ("" + "am") : ("" + "pm"); break;
					case 'P': c = (isAM) ? ("" + "AM") : ("" + "PM"); break;
					case 'w': c = "" + d.getDay(); break;
				}
				r.push(c);
				escape = false;
			} else {
				if (c == "%") {
					escape = true;
				} else {
					r.push(c);
				}
			}
		}

		return r.join("");
	}

	// To have a consistent view of time-based data independent of which time
	// zone the client happens to be in we need a date-like object independent
	// of time zones.  This is done through a wrapper that only calls the UTC
	// versions of the accessor methods.

	function makeUtcWrapper(d) {

		function addProxyMethod(sourceObj, sourceMethod, targetObj, targetMethod) {
			sourceObj[sourceMethod] = function() {
				return targetObj[targetMethod].apply(targetObj, arguments);
			};
		};

		var utc = {
			date: d
		};

		// support strftime, if found

		if (d.strftime != undefined) {
			addProxyMethod(utc, "strftime", d, "strftime");
		}

		addProxyMethod(utc, "getTime", d, "getTime");
		addProxyMethod(utc, "setTime", d, "setTime");

		var props = ["Date", "Day", "FullYear", "Hours", "Milliseconds", "Minutes", "Month", "Seconds"];

		for (var p = 0; p < props.length; p++) {
			addProxyMethod(utc, "get" + props[p], d, "getUTC" + props[p]);
			addProxyMethod(utc, "set" + props[p], d, "setUTC" + props[p]);
		}

		return utc;
	};

	// select time zone strategy.  This returns a date-like object tied to the
	// desired timezone

	function dateGenerator(ts, opts) {
		if (opts.timezone == "browser") {
			return new Date(ts);
		} else if (!opts.timezone || opts.timezone == "utc") {
			return makeUtcWrapper(new Date(ts));
		} else if (typeof timezoneJS != "undefined" && typeof timezoneJS.Date != "undefined") {
			var d = new timezoneJS.Date();
			// timezone-js is fickle, so be sure to set the time zone before
			// setting the time.
			d.setTimezone(opts.timezone);
			d.setTime(ts);
			return d;
		} else {
			return makeUtcWrapper(new Date(ts));
		}
	}
	
	// map of app. size of time units in milliseconds

	var timeUnitSize = {
		"second": 1000,
		"minute": 60 * 1000,
		"hour": 60 * 60 * 1000,
		"day": 24 * 60 * 60 * 1000,
		"month": 30 * 24 * 60 * 60 * 1000,
		"quarter": 3 * 30 * 24 * 60 * 60 * 1000,
		"year": 365.2425 * 24 * 60 * 60 * 1000
	};

	// the allowed tick sizes, after 1 year we use
	// an integer algorithm

	var baseSpec = [
		[1, "second"], [2, "second"], [5, "second"], [10, "second"],
		[30, "second"], 
		[1, "minute"], [2, "minute"], [5, "minute"], [10, "minute"],
		[30, "minute"], 
		[1, "hour"], [2, "hour"], [4, "hour"],
		[8, "hour"], [12, "hour"],
		[1, "day"], [2, "day"], [3, "day"],
		[0.25, "month"], [0.5, "month"], [1, "month"],
		[2, "month"]
	];

	// we don't know which variant(s) we'll need yet, but generating both is
	// cheap

	var specMonths = baseSpec.concat([[3, "month"], [6, "month"],
		[1, "year"]]);
	var specQuarters = baseSpec.concat([[1, "quarter"], [2, "quarter"],
		[1, "year"]]);

	function init(plot) {
		plot.hooks.processOptions.push(function (plot, options) {
			$.each(plot.getAxes(), function(axisName, axis) {

				var opts = axis.options;

				if (opts.mode == "time") {
					axis.tickGenerator = function(axis) {

						var ticks = [];
						var d = dateGenerator(axis.min, opts);
						var minSize = 0;

						// make quarter use a possibility if quarters are
						// mentioned in either of these options

						var spec = (opts.tickSize && opts.tickSize[1] ===
							"quarter") ||
							(opts.minTickSize && opts.minTickSize[1] ===
							"quarter") ? specQuarters : specMonths;

						if (opts.minTickSize != null) {
							if (typeof opts.tickSize == "number") {
								minSize = opts.tickSize;
							} else {
								minSize = opts.minTickSize[0] * timeUnitSize[opts.minTickSize[1]];
							}
						}

						for (var i = 0; i < spec.length - 1; ++i) {
							if (axis.delta < (spec[i][0] * timeUnitSize[spec[i][1]]
											  + spec[i + 1][0] * timeUnitSize[spec[i + 1][1]]) / 2
								&& spec[i][0] * timeUnitSize[spec[i][1]] >= minSize) {
								break;
							}
						}

						var size = spec[i][0];
						var unit = spec[i][1];

						// special-case the possibility of several years

						if (unit == "year") {

							// if given a minTickSize in years, just use it,
							// ensuring that it's an integer

							if (opts.minTickSize != null && opts.minTickSize[1] == "year") {
								size = Math.floor(opts.minTickSize[0]);
							} else {

								var magn = Math.pow(10, Math.floor(Math.log(axis.delta / timeUnitSize.year) / Math.LN10));
								var norm = (axis.delta / timeUnitSize.year) / magn;

								if (norm < 1.5) {
									size = 1;
								} else if (norm < 3) {
									size = 2;
								} else if (norm < 7.5) {
									size = 5;
								} else {
									size = 10;
								}

								size *= magn;
							}

							// minimum size for years is 1

							if (size < 1) {
								size = 1;
							}
						}

						axis.tickSize = opts.tickSize || [size, unit];
						var tickSize = axis.tickSize[0];
						unit = axis.tickSize[1];

						var step = tickSize * timeUnitSize[unit];

						if (unit == "second") {
							d.setSeconds(floorInBase(d.getSeconds(), tickSize));
						} else if (unit == "minute") {
							d.setMinutes(floorInBase(d.getMinutes(), tickSize));
						} else if (unit == "hour") {
							d.setHours(floorInBase(d.getHours(), tickSize));
						} else if (unit == "month") {
							d.setMonth(floorInBase(d.getMonth(), tickSize));
						} else if (unit == "quarter") {
							d.setMonth(3 * floorInBase(d.getMonth() / 3,
								tickSize));
						} else if (unit == "year") {
							d.setFullYear(floorInBase(d.getFullYear(), tickSize));
						}

						// reset smaller components

						d.setMilliseconds(0);

						if (step >= timeUnitSize.minute) {
							d.setSeconds(0);
						}
						if (step >= timeUnitSize.hour) {
							d.setMinutes(0);
						}
						if (step >= timeUnitSize.day) {
							d.setHours(0);
						}
						if (step >= timeUnitSize.day * 4) {
							d.setDate(1);
						}
						if (step >= timeUnitSize.month * 2) {
							d.setMonth(floorInBase(d.getMonth(), 3));
						}
						if (step >= timeUnitSize.quarter * 2) {
							d.setMonth(floorInBase(d.getMonth(), 6));
						}
						if (step >= timeUnitSize.year) {
							d.setMonth(0);
						}

						var carry = 0;
						var v = Number.NaN;
						var prev;

						do {

							prev = v;
							v = d.getTime();
							ticks.push(v);

							if (unit == "month" || unit == "quarter") {
								if (tickSize < 1) {

									// a bit complicated - we'll divide the
									// month/quarter up but we need to take
									// care of fractions so we don't end up in
									// the middle of a day

									d.setDate(1);
									var start = d.getTime();
									d.setMonth(d.getMonth() +
										(unit == "quarter" ? 3 : 1));
									var end = d.getTime();
									d.setTime(v + carry * timeUnitSize.hour + (end - start) * tickSize);
									carry = d.getHours();
									d.setHours(0);
								} else {
									d.setMonth(d.getMonth() +
										tickSize * (unit == "quarter" ? 3 : 1));
								}
							} else if (unit == "year") {
								d.setFullYear(d.getFullYear() + tickSize);
							} else {
								d.setTime(v + step);
							}
						} while (v < axis.max && v != prev);

						return ticks;
					};

					axis.tickFormatter = function (v, axis) {

						var d = dateGenerator(v, axis.options);

						// first check global format

						if (opts.timeformat != null) {
							return formatDate(d, opts.timeformat, opts.monthNames, opts.dayNames);
						}

						// possibly use quarters if quarters are mentioned in
						// any of these places

						var useQuarters = (axis.options.tickSize &&
								axis.options.tickSize[1] == "quarter") ||
							(axis.options.minTickSize &&
								axis.options.minTickSize[1] == "quarter");

						var t = axis.tickSize[0] * timeUnitSize[axis.tickSize[1]];
						var span = axis.max - axis.min;
						var suffix = (opts.twelveHourClock) ? " %p" : "";
						var hourCode = (opts.twelveHourClock) ? "%I" : "%H";
						var fmt;

						if (t < timeUnitSize.minute) {
							fmt = hourCode + ":%M:%S" + suffix;
						} else if (t < timeUnitSize.day) {
							if (span < 2 * timeUnitSize.day) {
								fmt = hourCode + ":%M" + suffix;
							} else {
								fmt = "%b %d " + hourCode + ":%M" + suffix;
							}
						} else if (t < timeUnitSize.month) {
							fmt = "%b %d";
						} else if ((useQuarters && t < timeUnitSize.quarter) ||
							(!useQuarters && t < timeUnitSize.year)) {
							if (span < timeUnitSize.year) {
								fmt = "%b";
							} else {
								fmt = "%b %Y";
							}
						} else if (useQuarters && t < timeUnitSize.year) {
							if (span < timeUnitSize.year) {
								fmt = "Q%q";
							} else {
								fmt = "Q%q %Y";
							}
						} else {
							fmt = "%Y";
						}

						var rt = formatDate(d, fmt, opts.monthNames, opts.dayNames);

						return rt;
					};
				}
			});
		});
	}

	$.plot.plugins.push({
		init: init,
		options: options,
		name: 'time',
		version: '1.0'
	});

	// Time-axis support used to be in Flot core, which exposed the
	// formatDate function on the plot object.  Various plugins depend
	// on the function, so we need to re-expose it here.

	$.plot.formatDate = formatDate;
	$.plot.dateGenerator = dateGenerator;

})(jQuery);


/***/ }),
/* 1508 */
/***/ (function(module, exports) {

/* Flot plugin that adds some extra symbols for plotting points.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

The symbols are accessed as strings through the standard symbol options:

	series: {
		points: {
			symbol: "square" // or "diamond", "triangle", "cross"
		}
	}

*/

(function ($) {
    function processRawData(plot, series, datapoints) {
        // we normalize the area of each symbol so it is approximately the
        // same as a circle of the given radius

        var handlers = {
            square: function (ctx, x, y, radius, shadow) {
                // pi * r^2 = (2s)^2  =>  s = r * sqrt(pi)/2
                var size = radius * Math.sqrt(Math.PI) / 2;
                ctx.rect(x - size, y - size, size + size, size + size);
            },
            diamond: function (ctx, x, y, radius, shadow) {
                // pi * r^2 = 2s^2  =>  s = r * sqrt(pi/2)
                var size = radius * Math.sqrt(Math.PI / 2);
                ctx.moveTo(x - size, y);
                ctx.lineTo(x, y - size);
                ctx.lineTo(x + size, y);
                ctx.lineTo(x, y + size);
                ctx.lineTo(x - size, y);
            },
            triangle: function (ctx, x, y, radius, shadow) {
                // pi * r^2 = 1/2 * s^2 * sin (pi / 3)  =>  s = r * sqrt(2 * pi / sin(pi / 3))
                var size = radius * Math.sqrt(2 * Math.PI / Math.sin(Math.PI / 3));
                var height = size * Math.sin(Math.PI / 3);
                ctx.moveTo(x - size/2, y + height/2);
                ctx.lineTo(x + size/2, y + height/2);
                if (!shadow) {
                    ctx.lineTo(x, y - height/2);
                    ctx.lineTo(x - size/2, y + height/2);
                }
            },
            cross: function (ctx, x, y, radius, shadow) {
                // pi * r^2 = (2s)^2  =>  s = r * sqrt(pi)/2
                var size = radius * Math.sqrt(Math.PI) / 2;
                ctx.moveTo(x - size, y - size);
                ctx.lineTo(x + size, y + size);
                ctx.moveTo(x - size, y + size);
                ctx.lineTo(x + size, y - size);
            }
        };

        var s = series.points.symbol;
        if (handlers[s])
            series.points.symbol = handlers[s];
    }
    
    function init(plot) {
        plot.hooks.processDatapoints.push(processRawData);
    }
    
    $.plot.plugins.push({
        init: init,
        name: 'symbols',
        version: '1.0'
    });
})(jQuery);


/***/ }),
/* 1509 */
/***/ (function(module, exports) {

/* Flot plugin for showing crosshairs when the mouse hovers over the plot.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

The plugin supports these options:

	crosshair: {
		mode: null or "x" or "y" or "xy"
		color: color
		lineWidth: number
	}

Set the mode to one of "x", "y" or "xy". The "x" mode enables a vertical
crosshair that lets you trace the values on the x axis, "y" enables a
horizontal crosshair and "xy" enables them both. "color" is the color of the
crosshair (default is "rgba(170, 0, 0, 0.80)"), "lineWidth" is the width of
the drawn lines (default is 1).

The plugin also adds four public methods:

  - setCrosshair( pos )

    Set the position of the crosshair. Note that this is cleared if the user
    moves the mouse. "pos" is in coordinates of the plot and should be on the
    form { x: xpos, y: ypos } (you can use x2/x3/... if you're using multiple
    axes), which is coincidentally the same format as what you get from a
    "plothover" event. If "pos" is null, the crosshair is cleared.

  - clearCrosshair()

    Clear the crosshair.

  - lockCrosshair(pos)

    Cause the crosshair to lock to the current location, no longer updating if
    the user moves the mouse. Optionally supply a position (passed on to
    setCrosshair()) to move it to.

    Example usage:

	var myFlot = $.plot( $("#graph"), ..., { crosshair: { mode: "x" } } };
	$("#graph").bind( "plothover", function ( evt, position, item ) {
		if ( item ) {
			// Lock the crosshair to the data point being hovered
			myFlot.lockCrosshair({
				x: item.datapoint[ 0 ],
				y: item.datapoint[ 1 ]
			});
		} else {
			// Return normal crosshair operation
			myFlot.unlockCrosshair();
		}
	});

  - unlockCrosshair()

    Free the crosshair to move again after locking it.
*/

(function ($) {
    var options = {
        crosshair: {
            mode: null, // one of null, "x", "y" or "xy",
            color: "rgba(170, 0, 0, 0.80)",
            lineWidth: 1
        }
    };
    
    function init(plot) {
        // position of crosshair in pixels
        var crosshair = { x: -1, y: -1, locked: false };

        plot.setCrosshair = function setCrosshair(pos) {
            if (!pos)
                crosshair.x = -1;
            else {
                var o = plot.p2c(pos);
                crosshair.x = Math.max(0, Math.min(o.left, plot.width()));
                crosshair.y = Math.max(0, Math.min(o.top, plot.height()));
            }
            
            plot.triggerRedrawOverlay();
        };
        
        plot.clearCrosshair = plot.setCrosshair; // passes null for pos
        
        plot.lockCrosshair = function lockCrosshair(pos) {
            if (pos)
                plot.setCrosshair(pos);
            crosshair.locked = true;
        };

        plot.unlockCrosshair = function unlockCrosshair() {
            crosshair.locked = false;
        };

        function onMouseOut(e) {
            if (crosshair.locked)
                return;

            if (crosshair.x != -1) {
                crosshair.x = -1;
                plot.triggerRedrawOverlay();
            }
        }

        function onMouseMove(e) {
            if (crosshair.locked)
                return;
                
            if (plot.getSelection && plot.getSelection()) {
                crosshair.x = -1; // hide the crosshair while selecting
                return;
            }
                
            var offset = plot.offset();
            crosshair.x = Math.max(0, Math.min(e.pageX - offset.left, plot.width()));
            crosshair.y = Math.max(0, Math.min(e.pageY - offset.top, plot.height()));
            plot.triggerRedrawOverlay();
        }
        
        plot.hooks.bindEvents.push(function (plot, eventHolder) {
            if (!plot.getOptions().crosshair.mode)
                return;

            eventHolder.mouseout(onMouseOut);
            eventHolder.mousemove(onMouseMove);
        });

        plot.hooks.drawOverlay.push(function (plot, ctx) {
            var c = plot.getOptions().crosshair;
            if (!c.mode)
                return;

            var plotOffset = plot.getPlotOffset();
            
            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);

            if (crosshair.x != -1) {
                var adj = plot.getOptions().crosshair.lineWidth % 2 ? 0.5 : 0;

                ctx.strokeStyle = c.color;
                ctx.lineWidth = c.lineWidth;
                ctx.lineJoin = "round";

                ctx.beginPath();
                if (c.mode.indexOf("x") != -1) {
                    var drawX = Math.floor(crosshair.x) + adj;
                    ctx.moveTo(drawX, 0);
                    ctx.lineTo(drawX, plot.height());
                }
                if (c.mode.indexOf("y") != -1) {
                    var drawY = Math.floor(crosshair.y) + adj;
                    ctx.moveTo(0, drawY);
                    ctx.lineTo(plot.width(), drawY);
                }
                ctx.stroke();
            }
            ctx.restore();
        });

        plot.hooks.shutdown.push(function (plot, eventHolder) {
            eventHolder.unbind("mouseout", onMouseOut);
            eventHolder.unbind("mousemove", onMouseMove);
        });
    }
    
    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'crosshair',
        version: '1.0'
    });
})(jQuery);


/***/ }),
/* 1510 */
/***/ (function(module, exports) {

/* Flot plugin for selecting regions of a plot.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

The plugin supports these options:

selection: {
	mode: null or "x" or "y" or "xy",
	color: color,
	shape: "round" or "miter" or "bevel",
	minSize: number of pixels
}

Selection support is enabled by setting the mode to one of "x", "y" or "xy".
In "x" mode, the user will only be able to specify the x range, similarly for
"y" mode. For "xy", the selection becomes a rectangle where both ranges can be
specified. "color" is color of the selection (if you need to change the color
later on, you can get to it with plot.getOptions().selection.color). "shape"
is the shape of the corners of the selection.

"minSize" is the minimum size a selection can be in pixels. This value can
be customized to determine the smallest size a selection can be and still
have the selection rectangle be displayed. When customizing this value, the
fact that it refers to pixels, not axis units must be taken into account.
Thus, for example, if there is a bar graph in time mode with BarWidth set to 1
minute, setting "minSize" to 1 will not make the minimum selection size 1
minute, but rather 1 pixel. Note also that setting "minSize" to 0 will prevent
"plotunselected" events from being fired when the user clicks the mouse without
dragging.

When selection support is enabled, a "plotselected" event will be emitted on
the DOM element you passed into the plot function. The event handler gets a
parameter with the ranges selected on the axes, like this:

	placeholder.bind( "plotselected", function( event, ranges ) {
		alert("You selected " + ranges.xaxis.from + " to " + ranges.xaxis.to)
		// similar for yaxis - with multiple axes, the extra ones are in
		// x2axis, x3axis, ...
	});

The "plotselected" event is only fired when the user has finished making the
selection. A "plotselecting" event is fired during the process with the same
parameters as the "plotselected" event, in case you want to know what's
happening while it's happening,

A "plotunselected" event with no arguments is emitted when the user clicks the
mouse to remove the selection. As stated above, setting "minSize" to 0 will
destroy this behavior.

The plugin allso adds the following methods to the plot object:

- setSelection( ranges, preventEvent )

  Set the selection rectangle. The passed in ranges is on the same form as
  returned in the "plotselected" event. If the selection mode is "x", you
  should put in either an xaxis range, if the mode is "y" you need to put in
  an yaxis range and both xaxis and yaxis if the selection mode is "xy", like
  this:

	setSelection({ xaxis: { from: 0, to: 10 }, yaxis: { from: 40, to: 60 } });

  setSelection will trigger the "plotselected" event when called. If you don't
  want that to happen, e.g. if you're inside a "plotselected" handler, pass
  true as the second parameter. If you are using multiple axes, you can
  specify the ranges on any of those, e.g. as x2axis/x3axis/... instead of
  xaxis, the plugin picks the first one it sees.

- clearSelection( preventEvent )

  Clear the selection rectangle. Pass in true to avoid getting a
  "plotunselected" event.

- getSelection()

  Returns the current selection in the same format as the "plotselected"
  event. If there's currently no selection, the function returns null.

*/

(function ($) {
    function init(plot) {
        var selection = {
                first: { x: -1, y: -1}, second: { x: -1, y: -1},
                show: false,
                active: false
            };

        // FIXME: The drag handling implemented here should be
        // abstracted out, there's some similar code from a library in
        // the navigation plugin, this should be massaged a bit to fit
        // the Flot cases here better and reused. Doing this would
        // make this plugin much slimmer.
        var savedhandlers = {};

        var mouseUpHandler = null;
        
        function onMouseMove(e) {
            if (selection.active) {
                updateSelection(e);
                
                plot.getPlaceholder().trigger("plotselecting", [ getSelection() ]);
            }
        }

        function onMouseDown(e) {
            if (e.which != 1)  // only accept left-click
                return;
            
            // cancel out any text selections
            document.body.focus();

            // prevent text selection and drag in old-school browsers
            if (document.onselectstart !== undefined && savedhandlers.onselectstart == null) {
                savedhandlers.onselectstart = document.onselectstart;
                document.onselectstart = function () { return false; };
            }
            if (document.ondrag !== undefined && savedhandlers.ondrag == null) {
                savedhandlers.ondrag = document.ondrag;
                document.ondrag = function () { return false; };
            }

            setSelectionPos(selection.first, e);

            selection.active = true;

            // this is a bit silly, but we have to use a closure to be
            // able to whack the same handler again
            mouseUpHandler = function (e) { onMouseUp(e); };
            
            $(document).one("mouseup", mouseUpHandler);
        }

        function onMouseUp(e) {
            mouseUpHandler = null;
            
            // revert drag stuff for old-school browsers
            if (document.onselectstart !== undefined)
                document.onselectstart = savedhandlers.onselectstart;
            if (document.ondrag !== undefined)
                document.ondrag = savedhandlers.ondrag;

            // no more dragging
            selection.active = false;
            updateSelection(e);

            if (selectionIsSane())
                triggerSelectedEvent();
            else {
                // this counts as a clear
                plot.getPlaceholder().trigger("plotunselected", [ ]);
                plot.getPlaceholder().trigger("plotselecting", [ null ]);
            }

            return false;
        }

        function getSelection() {
            if (!selectionIsSane())
                return null;
            
            if (!selection.show) return null;

            var r = {}, c1 = selection.first, c2 = selection.second;
            $.each(plot.getAxes(), function (name, axis) {
                if (axis.used) {
                    var p1 = axis.c2p(c1[axis.direction]), p2 = axis.c2p(c2[axis.direction]); 
                    r[name] = { from: Math.min(p1, p2), to: Math.max(p1, p2) };
                }
            });
            return r;
        }

        function triggerSelectedEvent() {
            var r = getSelection();

            plot.getPlaceholder().trigger("plotselected", [ r ]);

            // backwards-compat stuff, to be removed in future
            if (r.xaxis && r.yaxis)
                plot.getPlaceholder().trigger("selected", [ { x1: r.xaxis.from, y1: r.yaxis.from, x2: r.xaxis.to, y2: r.yaxis.to } ]);
        }

        function clamp(min, value, max) {
            return value < min ? min: (value > max ? max: value);
        }

        function setSelectionPos(pos, e) {
            var o = plot.getOptions();
            var offset = plot.getPlaceholder().offset();
            var plotOffset = plot.getPlotOffset();
            pos.x = clamp(0, e.pageX - offset.left - plotOffset.left, plot.width());
            pos.y = clamp(0, e.pageY - offset.top - plotOffset.top, plot.height());

            if (o.selection.mode == "y")
                pos.x = pos == selection.first ? 0 : plot.width();

            if (o.selection.mode == "x")
                pos.y = pos == selection.first ? 0 : plot.height();
        }

        function updateSelection(pos) {
            if (pos.pageX == null)
                return;

            setSelectionPos(selection.second, pos);
            if (selectionIsSane()) {
                selection.show = true;
                plot.triggerRedrawOverlay();
            }
            else
                clearSelection(true);
        }

        function clearSelection(preventEvent) {
            if (selection.show) {
                selection.show = false;
                plot.triggerRedrawOverlay();
                if (!preventEvent)
                    plot.getPlaceholder().trigger("plotunselected", [ ]);
            }
        }

        // function taken from markings support in Flot
        function extractRange(ranges, coord) {
            var axis, from, to, key, axes = plot.getAxes();

            for (var k in axes) {
                axis = axes[k];
                if (axis.direction == coord) {
                    key = coord + axis.n + "axis";
                    if (!ranges[key] && axis.n == 1)
                        key = coord + "axis"; // support x1axis as xaxis
                    if (ranges[key]) {
                        from = ranges[key].from;
                        to = ranges[key].to;
                        break;
                    }
                }
            }

            // backwards-compat stuff - to be removed in future
            if (!ranges[key]) {
                axis = coord == "x" ? plot.getXAxes()[0] : plot.getYAxes()[0];
                from = ranges[coord + "1"];
                to = ranges[coord + "2"];
            }

            // auto-reverse as an added bonus
            if (from != null && to != null && from > to) {
                var tmp = from;
                from = to;
                to = tmp;
            }
            
            return { from: from, to: to, axis: axis };
        }
        
        function setSelection(ranges, preventEvent) {
            var axis, range, o = plot.getOptions();

            if (o.selection.mode == "y") {
                selection.first.x = 0;
                selection.second.x = plot.width();
            }
            else {
                range = extractRange(ranges, "x");

                selection.first.x = range.axis.p2c(range.from);
                selection.second.x = range.axis.p2c(range.to);
            }

            if (o.selection.mode == "x") {
                selection.first.y = 0;
                selection.second.y = plot.height();
            }
            else {
                range = extractRange(ranges, "y");

                selection.first.y = range.axis.p2c(range.from);
                selection.second.y = range.axis.p2c(range.to);
            }

            selection.show = true;
            plot.triggerRedrawOverlay();
            if (!preventEvent && selectionIsSane())
                triggerSelectedEvent();
        }

        function selectionIsSane() {
            var minSize = plot.getOptions().selection.minSize;
            return Math.abs(selection.second.x - selection.first.x) >= minSize &&
                Math.abs(selection.second.y - selection.first.y) >= minSize;
        }

        plot.clearSelection = clearSelection;
        plot.setSelection = setSelection;
        plot.getSelection = getSelection;

        plot.hooks.bindEvents.push(function(plot, eventHolder) {
            var o = plot.getOptions();
            if (o.selection.mode != null) {
                eventHolder.mousemove(onMouseMove);
                eventHolder.mousedown(onMouseDown);
            }
        });


        plot.hooks.drawOverlay.push(function (plot, ctx) {
            // draw selection
            if (selection.show && selectionIsSane()) {
                var plotOffset = plot.getPlotOffset();
                var o = plot.getOptions();

                ctx.save();
                ctx.translate(plotOffset.left, plotOffset.top);

                var c = $.color.parse(o.selection.color);

                ctx.strokeStyle = c.scale('a', 0.8).toString();
                ctx.lineWidth = 1;
                ctx.lineJoin = o.selection.shape;
                ctx.fillStyle = c.scale('a', 0.4).toString();

                var x = Math.min(selection.first.x, selection.second.x) + 0.5,
                    y = Math.min(selection.first.y, selection.second.y) + 0.5,
                    w = Math.abs(selection.second.x - selection.first.x) - 1,
                    h = Math.abs(selection.second.y - selection.first.y) - 1;

                ctx.fillRect(x, y, w, h);
                ctx.strokeRect(x, y, w, h);

                ctx.restore();
            }
        });
        
        plot.hooks.shutdown.push(function (plot, eventHolder) {
            eventHolder.unbind("mousemove", onMouseMove);
            eventHolder.unbind("mousedown", onMouseDown);
            
            if (mouseUpHandler)
                $(document).unbind("mouseup", mouseUpHandler);
        });

    }

    $.plot.plugins.push({
        init: init,
        options: {
            selection: {
                mode: null, // one of null, "x", "y" or "xy"
                color: "#e8cfac",
                shape: "round", // one of "round", "miter", or "bevel"
                minSize: 5 // minimum number of pixels
            }
        },
        name: 'selection',
        version: '1.1'
    });
})(jQuery);


/***/ }),
/* 1511 */
/***/ (function(module, exports) {

/* Flot plugin for stacking data sets rather than overlyaing them.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

The plugin assumes the data is sorted on x (or y if stacking horizontally).
For line charts, it is assumed that if a line has an undefined gap (from a
null point), then the line above it should have the same gap - insert zeros
instead of "null" if you want another behaviour. This also holds for the start
and end of the chart. Note that stacking a mix of positive and negative values
in most instances doesn't make sense (so it looks weird).

Two or more series are stacked when their "stack" attribute is set to the same
key (which can be any number or string or just "true"). To specify the default
stack, you can set the stack option like this:

	series: {
		stack: null/false, true, or a key (number/string)
	}

You can also specify it for a single series, like this:

	$.plot( $("#placeholder"), [{
		data: [ ... ],
		stack: true
	}])

The stacking order is determined by the order of the data series in the array
(later series end up on top of the previous).

Internally, the plugin modifies the datapoints in each series, adding an
offset to the y value. For line series, extra data points are inserted through
interpolation. If there's a second y value, it's also adjusted (e.g for bar
charts or filled areas).

*/

(function ($) {
    var options = {
        series: { stack: null } // or number/string
    };
    
    function init(plot) {
        function findMatchingSeries(s, allseries) {
            var res = null;
            for (var i = 0; i < allseries.length; ++i) {
                if (s == allseries[i])
                    break;
                
                if (allseries[i].stack == s.stack)
                    res = allseries[i];
            }
            
            return res;
        }
        
        function stackData(plot, s, datapoints) {
            if (s.stack == null || s.stack === false)
                return;

            var other = findMatchingSeries(s, plot.getData());
            if (!other)
                return;

            var ps = datapoints.pointsize,
                points = datapoints.points,
                otherps = other.datapoints.pointsize,
                otherpoints = other.datapoints.points,
                newpoints = [],
                px, py, intery, qx, qy, bottom,
                withlines = s.lines.show,
                horizontal = s.bars.horizontal,
                withbottom = ps > 2 && (horizontal ? datapoints.format[2].x : datapoints.format[2].y),
                withsteps = withlines && s.lines.steps,
                fromgap = true,
                keyOffset = horizontal ? 1 : 0,
                accumulateOffset = horizontal ? 0 : 1,
                i = 0, j = 0, l, m;

            while (true) {
                if (i >= points.length)
                    break;

                l = newpoints.length;

                if (points[i] == null) {
                    // copy gaps
                    for (m = 0; m < ps; ++m)
                        newpoints.push(points[i + m]);
                    i += ps;
                }
                else if (j >= otherpoints.length) {
                    // for lines, we can't use the rest of the points
                    if (!withlines) {
                        for (m = 0; m < ps; ++m)
                            newpoints.push(points[i + m]);
                    }
                    i += ps;
                }
                else if (otherpoints[j] == null) {
                    // oops, got a gap
                    for (m = 0; m < ps; ++m)
                        newpoints.push(null);
                    fromgap = true;
                    j += otherps;
                }
                else {
                    // cases where we actually got two points
                    px = points[i + keyOffset];
                    py = points[i + accumulateOffset];
                    qx = otherpoints[j + keyOffset];
                    qy = otherpoints[j + accumulateOffset];
                    bottom = 0;

                    if (px == qx) {
                        for (m = 0; m < ps; ++m)
                            newpoints.push(points[i + m]);

                        newpoints[l + accumulateOffset] += qy;
                        bottom = qy;
                        
                        i += ps;
                        j += otherps;
                    }
                    else if (px > qx) {
                        // we got past point below, might need to
                        // insert interpolated extra point
                        if (withlines && i > 0 && points[i - ps] != null) {
                            intery = py + (points[i - ps + accumulateOffset] - py) * (qx - px) / (points[i - ps + keyOffset] - px);
                            newpoints.push(qx);
                            newpoints.push(intery + qy);
                            for (m = 2; m < ps; ++m)
                                newpoints.push(points[i + m]);
                            bottom = qy; 
                        }

                        j += otherps;
                    }
                    else { // px < qx
                        if (fromgap && withlines) {
                            // if we come from a gap, we just skip this point
                            i += ps;
                            continue;
                        }
                            
                        for (m = 0; m < ps; ++m)
                            newpoints.push(points[i + m]);
                        
                        // we might be able to interpolate a point below,
                        // this can give us a better y
                        if (withlines && j > 0 && otherpoints[j - otherps] != null)
                            bottom = qy + (otherpoints[j - otherps + accumulateOffset] - qy) * (px - qx) / (otherpoints[j - otherps + keyOffset] - qx);

                        newpoints[l + accumulateOffset] += bottom;
                        
                        i += ps;
                    }

                    fromgap = false;
                    
                    if (l != newpoints.length && withbottom)
                        newpoints[l + 2] += bottom;
                }

                // maintain the line steps invariant
                if (withsteps && l != newpoints.length && l > 0
                    && newpoints[l] != null
                    && newpoints[l] != newpoints[l - ps]
                    && newpoints[l + 1] != newpoints[l - ps + 1]) {
                    for (m = 0; m < ps; ++m)
                        newpoints[l + ps + m] = newpoints[l + m];
                    newpoints[l + 1] = newpoints[l - ps + 1];
                }
            }

            datapoints.points = newpoints;
        }
        
        plot.hooks.processDatapoints.push(stackData);
    }
    
    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'stack',
        version: '1.2'
    });
})(jQuery);


/***/ }),
/* 1512 */
/***/ (function(module, exports) {

/*
Axis Labels Plugin for flot.
http://github.com/markrcote/flot-axislabels
Original code is Copyright (c) 2010 Xuan Luo.
Original code was released under the GPLv3 license by Xuan Luo, September 2010.
Original code was rereleased under the MIT license by Xuan Luo, April 2012.
Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

(function ($) {
    var options = {
      axisLabels: {
        show: true
      }
    };

    function canvasSupported() {
        return !!document.createElement('canvas').getContext;
    }

    function canvasTextSupported() {
        if (!canvasSupported()) {
            return false;
        }
        var dummy_canvas = document.createElement('canvas');
        var context = dummy_canvas.getContext('2d');
        return typeof context.fillText == 'function';
    }

    function css3TransitionSupported() {
        var div = document.createElement('div');
        return typeof div.style.MozTransition != 'undefined'    // Gecko
            || typeof div.style.OTransition != 'undefined'      // Opera
            || typeof div.style.webkitTransition != 'undefined' // WebKit
            || typeof div.style.transition != 'undefined';
    }


    function AxisLabel(axisName, position, padding, plot, opts) {
        this.axisName = axisName;
        this.position = position;
        this.padding = padding;
        this.plot = plot;
        this.opts = opts;
        this.width = 0;
        this.height = 0;
    }

    AxisLabel.prototype.cleanup = function() {
    };


    CanvasAxisLabel.prototype = new AxisLabel();
    CanvasAxisLabel.prototype.constructor = CanvasAxisLabel;
    function CanvasAxisLabel(axisName, position, padding, plot, opts) {
        AxisLabel.prototype.constructor.call(this, axisName, position, padding,
                                             plot, opts);
    }

    CanvasAxisLabel.prototype.calculateSize = function() {
        if (!this.opts.axisLabelFontSizePixels)
            this.opts.axisLabelFontSizePixels = 14;
        if (!this.opts.axisLabelFontFamily)
            this.opts.axisLabelFontFamily = 'sans-serif';

        var textWidth = this.opts.axisLabelFontSizePixels + this.padding;
        var textHeight = this.opts.axisLabelFontSizePixels + this.padding;
        if (this.position == 'left' || this.position == 'right') {
            this.width = this.opts.axisLabelFontSizePixels + this.padding;
            this.height = 0;
        } else {
            this.width = 0;
            this.height = this.opts.axisLabelFontSizePixels + this.padding;
        }
    };

    CanvasAxisLabel.prototype.draw = function(box) {
        if (!this.opts.axisLabelColour)
            this.opts.axisLabelColour = 'black';
        var ctx = this.plot.getCanvas().getContext('2d');
        ctx.save();
        ctx.font = this.opts.axisLabelFontSizePixels + 'px ' +
            this.opts.axisLabelFontFamily;
        ctx.fillStyle = this.opts.axisLabelColour;
        var width = ctx.measureText(this.opts.axisLabel).width;
        var height = this.opts.axisLabelFontSizePixels;
        var x, y, angle = 0;
        if (this.position == 'top') {
            x = box.left + box.width/2 - width/2;
            y = box.top + height*0.72;
        } else if (this.position == 'bottom') {
            x = box.left + box.width/2 - width/2;
            y = box.top + box.height - height*0.72;
        } else if (this.position == 'left') {
            x = box.left + height*0.72;
            y = box.height/2 + box.top + width/2;
            angle = -Math.PI/2;
        } else if (this.position == 'right') {
            x = box.left + box.width - height*0.72;
            y = box.height/2 + box.top - width/2;
            angle = Math.PI/2;
        }
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.fillText(this.opts.axisLabel, 0, 0);
        ctx.restore();
    };


    HtmlAxisLabel.prototype = new AxisLabel();
    HtmlAxisLabel.prototype.constructor = HtmlAxisLabel;
    function HtmlAxisLabel(axisName, position, padding, plot, opts) {
        AxisLabel.prototype.constructor.call(this, axisName, position,
                                             padding, plot, opts);
        this.elem = null;
    }

    HtmlAxisLabel.prototype.calculateSize = function() {
        var elem = $('<div class="axisLabels" style="position:absolute;">' +
                     this.opts.axisLabel + '</div>');
        this.plot.getPlaceholder().append(elem);
        // store height and width of label itself, for use in draw()
        this.labelWidth = elem.outerWidth(true);
        this.labelHeight = elem.outerHeight(true);
        elem.remove();

        this.width = this.height = 0;
        if (this.position == 'left' || this.position == 'right') {
            this.width = this.labelWidth + this.padding;
        } else {
            this.height = this.labelHeight + this.padding;
        }
    };

    HtmlAxisLabel.prototype.cleanup = function() {
        if (this.elem) {
            this.elem.remove();
        }
    };

    HtmlAxisLabel.prototype.draw = function(box) {
        this.plot.getPlaceholder().find('#' + this.axisName + 'Label').remove();
        this.elem = $('<div id="' + this.axisName +
                      'Label" " class="axisLabels" style="position:absolute;">'
                      + this.opts.axisLabel + '</div>');
        this.plot.getPlaceholder().append(this.elem);
        if (this.position == 'top') {
            this.elem.css('left', box.left + box.width/2 - this.labelWidth/2 +
                          'px');
            this.elem.css('top', box.top + 'px');
        } else if (this.position == 'bottom') {
            this.elem.css('left', box.left + box.width/2 - this.labelWidth/2 +
                          'px');
            this.elem.css('top', box.top + box.height - this.labelHeight +
                          'px');
        } else if (this.position == 'left') {
            this.elem.css('top', box.top + box.height/2 - this.labelHeight/2 +
                          'px');
            this.elem.css('left', box.left + 'px');
        } else if (this.position == 'right') {
            this.elem.css('top', box.top + box.height/2 - this.labelHeight/2 +
                          'px');
            this.elem.css('left', box.left + box.width - this.labelWidth +
                          'px');
        }
    };


    CssTransformAxisLabel.prototype = new HtmlAxisLabel();
    CssTransformAxisLabel.prototype.constructor = CssTransformAxisLabel;
    function CssTransformAxisLabel(axisName, position, padding, plot, opts) {
        HtmlAxisLabel.prototype.constructor.call(this, axisName, position,
                                                 padding, plot, opts);
    }

    CssTransformAxisLabel.prototype.calculateSize = function() {
        HtmlAxisLabel.prototype.calculateSize.call(this);
        this.width = this.height = 0;
        if (this.position == 'left' || this.position == 'right') {
            this.width = this.labelHeight + this.padding;
        } else {
            this.height = this.labelHeight + this.padding;
        }
    };

    CssTransformAxisLabel.prototype.transforms = function(degrees, x, y) {
        var stransforms = {
            '-moz-transform': '',
            '-webkit-transform': '',
            '-o-transform': '',
            '-ms-transform': ''
        };
        if (x != 0 || y != 0) {
            var stdTranslate = ' translate(' + x + 'px, ' + y + 'px)';
            stransforms['-moz-transform'] += stdTranslate;
            stransforms['-webkit-transform'] += stdTranslate;
            stransforms['-o-transform'] += stdTranslate;
            stransforms['-ms-transform'] += stdTranslate;
        }
        if (degrees != 0) {
            var rotation = degrees / 90;
            var stdRotate = ' rotate(' + degrees + 'deg)';
            stransforms['-moz-transform'] += stdRotate;
            stransforms['-webkit-transform'] += stdRotate;
            stransforms['-o-transform'] += stdRotate;
            stransforms['-ms-transform'] += stdRotate;
        }
        var s = 'top: 0; left: 0; ';
        for (var prop in stransforms) {
            if (stransforms[prop]) {
                s += prop + ':' + stransforms[prop] + ';';
            }
        }
        s += ';';
        return s;
    };

    CssTransformAxisLabel.prototype.calculateOffsets = function(box) {
        var offsets = { x: 0, y: 0, degrees: 0 };
        if (this.position == 'bottom') {
            offsets.x = box.left + box.width/2 - this.labelWidth/2;
            offsets.y = box.top + box.height - this.labelHeight;
        } else if (this.position == 'top') {
            offsets.x = box.left + box.width/2 - this.labelWidth/2;
            offsets.y = box.top;
        } else if (this.position == 'left') {
            offsets.degrees = -90;
            offsets.x = box.left - this.labelWidth/2 + this.labelHeight/2;
            offsets.y = box.height/2 + box.top;
        } else if (this.position == 'right') {
            offsets.degrees = 90;
            offsets.x = box.left + box.width - this.labelWidth/2
                        - this.labelHeight/2;
            offsets.y = box.height/2 + box.top;
        }
        offsets.x = Math.round(offsets.x);
        offsets.y = Math.round(offsets.y);

        return offsets;
    };

    CssTransformAxisLabel.prototype.draw = function(box) {
        this.plot.getPlaceholder().find("." + this.axisName + "Label").remove();
        var offsets = this.calculateOffsets(box);
        this.elem = $('<div class="axisLabels ' + this.axisName +
                      'Label" style="position:absolute; ' +
                      this.transforms(offsets.degrees, offsets.x, offsets.y) +
                      '">' + this.opts.axisLabel + '</div>');
        this.plot.getPlaceholder().append(this.elem);
    };


    IeTransformAxisLabel.prototype = new CssTransformAxisLabel();
    IeTransformAxisLabel.prototype.constructor = IeTransformAxisLabel;
    function IeTransformAxisLabel(axisName, position, padding, plot, opts) {
        CssTransformAxisLabel.prototype.constructor.call(this, axisName,
                                                         position, padding,
                                                         plot, opts);
        this.requiresResize = false;
    }

    IeTransformAxisLabel.prototype.transforms = function(degrees, x, y) {
        // I didn't feel like learning the crazy Matrix stuff, so this uses
        // a combination of the rotation transform and CSS positioning.
        var s = '';
        if (degrees != 0) {
            var rotation = degrees/90;
            while (rotation < 0) {
                rotation += 4;
            }
            s += ' filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=' + rotation + '); ';
            // see below
            this.requiresResize = (this.position == 'right');
        }
        if (x != 0) {
            s += 'left: ' + x + 'px; ';
        }
        if (y != 0) {
            s += 'top: ' + y + 'px; ';
        }
        return s;
    };

    IeTransformAxisLabel.prototype.calculateOffsets = function(box) {
        var offsets = CssTransformAxisLabel.prototype.calculateOffsets.call(
                          this, box);
        // adjust some values to take into account differences between
        // CSS and IE rotations.
        if (this.position == 'top') {
            // FIXME: not sure why, but placing this exactly at the top causes
            // the top axis label to flip to the bottom...
            offsets.y = box.top + 1;
        } else if (this.position == 'left') {
            offsets.x = box.left;
            offsets.y = box.height/2 + box.top - this.labelWidth/2;
        } else if (this.position == 'right') {
            offsets.x = box.left + box.width - this.labelHeight;
            offsets.y = box.height/2 + box.top - this.labelWidth/2;
        }
        return offsets;
    };

    IeTransformAxisLabel.prototype.draw = function(box) {
        CssTransformAxisLabel.prototype.draw.call(this, box);
        if (this.requiresResize) {
            this.elem = this.plot.getPlaceholder().find("." + this.axisName +
                                                        "Label");
            // Since we used CSS positioning instead of transforms for
            // translating the element, and since the positioning is done
            // before any rotations, we have to reset the width and height
            // in case the browser wrapped the text (specifically for the
            // y2axis).
            this.elem.css('width', this.labelWidth);
            this.elem.css('height', this.labelHeight);
        }
    };


    function init(plot) {
        plot.hooks.processOptions.push(function (plot, options) {

            if (!options.axisLabels.show)
                return;

            // This is kind of a hack. There are no hooks in Flot between
            // the creation and measuring of the ticks (setTicks, measureTickLabels
            // in setupGrid() ) and the drawing of the ticks and plot box
            // (insertAxisLabels in setupGrid() ).
            //
            // Therefore, we use a trick where we run the draw routine twice:
            // the first time to get the tick measurements, so that we can change
            // them, and then have it draw it again.
            var secondPass = false;

            var axisLabels = {};
            var axisOffsetCounts = { left: 0, right: 0, top: 0, bottom: 0 };

            var defaultPadding = 2;  // padding between axis and tick labels
            plot.hooks.draw.push(function (plot, ctx) {
                var hasAxisLabels = false;
                if (!secondPass) {
                    // MEASURE AND SET OPTIONS
                    $.each(plot.getAxes(), function(axisName, axis) {
                        var opts = axis.options // Flot 0.7
                            || plot.getOptions()[axisName]; // Flot 0.6

                        // Handle redraws initiated outside of this plug-in.
                        if (axisName in axisLabels) {
                            axis.labelHeight = axis.labelHeight -
                                axisLabels[axisName].height;
                            axis.labelWidth = axis.labelWidth -
                                axisLabels[axisName].width;
                            opts.labelHeight = axis.labelHeight;
                            opts.labelWidth = axis.labelWidth;
                            axisLabels[axisName].cleanup();
                            delete axisLabels[axisName];
                        }

                        if (!opts || !opts.axisLabel || !axis.show)
                            return;

                        hasAxisLabels = true;
                        var renderer = null;

                        if (!opts.axisLabelUseHtml &&
                            navigator.appName == 'Microsoft Internet Explorer') {
                            var ua = navigator.userAgent;
                            var re  = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
                            if (re.exec(ua) != null) {
                                rv = parseFloat(RegExp.$1);
                            }
                            if (rv >= 9 && !opts.axisLabelUseCanvas && !opts.axisLabelUseHtml) {
                                renderer = CssTransformAxisLabel;
                            } else if (!opts.axisLabelUseCanvas && !opts.axisLabelUseHtml) {
                                renderer = IeTransformAxisLabel;
                            } else if (opts.axisLabelUseCanvas) {
                                renderer = CanvasAxisLabel;
                            } else {
                                renderer = HtmlAxisLabel;
                            }
                        } else {
                            if (opts.axisLabelUseHtml || (!css3TransitionSupported() && !canvasTextSupported()) && !opts.axisLabelUseCanvas) {
                                renderer = HtmlAxisLabel;
                            } else if (opts.axisLabelUseCanvas || !css3TransitionSupported()) {
                                renderer = CanvasAxisLabel;
                            } else {
                                renderer = CssTransformAxisLabel;
                            }
                        }

                        var padding = opts.axisLabelPadding === undefined ?
                                      defaultPadding : opts.axisLabelPadding;

                        axisLabels[axisName] = new renderer(axisName,
                                                            axis.position, padding,
                                                            plot, opts);

                        // flot interprets axis.labelHeight and .labelWidth as
                        // the height and width of the tick labels. We increase
                        // these values to make room for the axis label and
                        // padding.

                        axisLabels[axisName].calculateSize();

                        // AxisLabel.height and .width are the size of the
                        // axis label and padding.
                        // Just set opts here because axis will be sorted out on
                        // the redraw.

                        opts.labelHeight = axis.labelHeight +
                            axisLabels[axisName].height;
                        opts.labelWidth = axis.labelWidth +
                            axisLabels[axisName].width;
                    });

                    // If there are axis labels, re-draw with new label widths and
                    // heights.

                    if (hasAxisLabels) {
                        secondPass = true;
                        plot.setupGrid();
                        plot.draw();
                    }
                } else {
                    secondPass = false;
                    // DRAW
                    $.each(plot.getAxes(), function(axisName, axis) {
                        var opts = axis.options // Flot 0.7
                            || plot.getOptions()[axisName]; // Flot 0.6
                        if (!opts || !opts.axisLabel || !axis.show)
                            return;

                        axisLabels[axisName].draw(axis.box);
                    });
                }
            });
        });
    }


    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'axisLabels',
        version: '2.0'
    });
})(jQuery);


/***/ }),
/* 1513 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 1514 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = tickFormatters;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function baseTickFormatter(value, axis) {
  var factor = axis.tickDecimals ? Math.pow(10, axis.tickDecimals) : 1;
  var formatted = '' + Math.round(value * factor) / factor;

  // If tickDecimals was specified, ensure that we have exactly that
  // much precision; otherwise default to the value's own precision.

  if (axis.tickDecimals != null) {
    var decimal = formatted.indexOf('.');
    var precision = decimal === -1 ? 0 : formatted.length - decimal - 1;
    if (precision < axis.tickDecimals) {
      return (precision ? formatted : formatted + '.') + ('' + factor).substr(1, axis.tickDecimals - precision);
    }
  }

  return formatted;
}

function tickFormatters() {
  var formatters = {
    'bits': function bits(val) {
      var labels = ['b', 'kb', 'mb', 'gb', 'tb', 'pb'];
      var index = 0;
      while (val >= 1000 && index < labels.length) {
        val /= 1000;
        index++;
      }
      return Math.round(val * 100) / 100 + labels[index];
    },
    'bits/s': function bitsS(val) {
      var labels = ['b/s', 'kb/s', 'mb/s', 'gb/s', 'tb/s', 'pb/s'];
      var index = 0;
      while (val >= 1000 && index < labels.length) {
        val /= 1000;
        index++;
      }
      return Math.round(val * 100) / 100 + labels[index];
    },
    'bytes': function bytes(val) {
      var labels = ['B', 'KB', 'MB', 'GB', 'TB', 'PB'];
      var index = 0;
      while (val >= 1024 && index < labels.length) {
        val /= 1024;
        index++;
      }
      return Math.round(val * 100) / 100 + labels[index];
    },
    'bytes/s': function bytesS(val) {
      var labels = ['B/s', 'KB/s', 'MB/s', 'GB/s', 'TB/s', 'PB/s'];
      var index = 0;
      while (val >= 1024 && index < labels.length) {
        val /= 1024;
        index++;
      }
      return Math.round(val * 100) / 100 + labels[index];
    },
    'currency': function currency(val, axis) {
      return val.toLocaleString('en', { style: 'currency', currency: axis.options.units.prefix || 'USD' });
    },
    'percent': function percent(val, axis) {
      var precision = _lodash2.default.get(axis, 'tickDecimals', 0) - _lodash2.default.get(axis, 'options.units.tickDecimalsShift', 0);
      // toFixed only accepts values between 0 and 20
      if (precision < 0) {
        precision = 0;
      } else if (precision > 20) {
        precision = 20;
      }

      return (val * 100).toFixed(precision) + '%';
    },
    'custom': function custom(val, axis) {
      var formattedVal = baseTickFormatter(val, axis);
      var prefix = axis.options.units.prefix;
      var suffix = axis.options.units.suffix;
      return prefix + formattedVal + suffix;
    }
  };

  return formatters;
}
module.exports = exports['default'];

/***/ }),
/* 1515 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = xaxisFormatterProvider;

var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function xaxisFormatterProvider(config) {

  function getFormat(esInterval) {
    var parts = esInterval.match(/(\d+)(ms|s|m|h|d|w|M|y|)/);
    if (parts == null || parts[1] == null || parts[2] == null) throw new Error('Unknown interval');

    var interval = _moment2.default.duration(Number(parts[1]), parts[2]);

    // Cribbed from Kibana's TimeBuckets class
    var rules = config.get('dateFormat:scaled');

    for (var i = rules.length - 1; i >= 0; i--) {
      var rule = rules[i];
      if (!rule[0] || interval >= _moment2.default.duration(rule[0])) {
        return rule[1];
      }
    }

    return config.get('dateFormat');
  }

  return function (esInterval) {
    return getFormat(esInterval);
  };
}
module.exports = exports['default'];

/***/ }),
/* 1516 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = generateTicksProvider;
function generateTicksProvider() {

  function floorInBase(n, base) {
    return base * Math.floor(n / base);
  }

  function generateTicks(axis) {
    var returnTicks = [];
    var tickSize = 2;
    var delta = axis.delta;
    var steps = 0;
    var tickVal = void 0;
    var tickCount = 0;

    //Count the steps
    while (Math.abs(delta) >= 1024) {
      steps++;
      delta /= 1024;
    }

    //Set the tick size relative to the remaining delta
    while (tickSize <= 1024) {
      if (delta <= tickSize) {
        break;
      }
      tickSize *= 2;
    }
    axis.tickSize = tickSize * Math.pow(1024, steps);

    //Calculate the new ticks
    var tickMin = floorInBase(axis.min, axis.tickSize);
    do {
      tickVal = tickMin + tickCount++ * axis.tickSize;
      returnTicks.push(tickVal);
    } while (tickVal < axis.max);

    return returnTicks;
  }

  return function (axis) {
    return generateTicks(axis);
  };
}
module.exports = exports["default"];

/***/ }),
/* 1517 */,
/* 1518 */,
/* 1519 */,
/* 1520 */,
/* 1521 */,
/* 1522 */,
/* 1523 */,
/* 1524 */,
/* 1525 */,
/* 1526 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1527);

/***/ }),
/* 1527 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1528);

__webpack_require__(1531);

__webpack_require__(2014);

/***/ }),
/* 1528 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1529);

var _modules = __webpack_require__(2);

/**
 * This module will take care of attaching appropriate aria tags related to some angular stuff,
 * e.g. it will attach aria-invalid if the model state is set to invalid.
 *
 * You can find more infos in the official documentation: https://docs.angularjs.org/api/ngAria.
 *
 * Three settings are disabled: it won't automatically attach `tabindex`, `role=button` or
 * handling keyboad events for `ngClick` directives. Kibana uses `kbnAccessibleClick` to handle
 * those cases where you need an `ngClick` non button element to have keyboard access.
 */
_modules.uiModules.get('kibana', ['ngAria']).config(function ($ariaProvider) {
  $ariaProvider.config({
    bindKeydown: false,
    bindRoleForClick: false,
    tabindex: false
  });
});

/***/ }),
/* 1529 */,
/* 1530 */,
/* 1531 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _eui = __webpack_require__(11);

var _modules = __webpack_require__(2);

/**
 * Interactive elements must be able to receive focus.
 *
 * Ideally, this means using elements that are natively keyboard accessible (<a href="">,
 * <input type="button">, or <button>). Note that links should be used when navigating and buttons
 * should be used when performing an action on the page.
 *
 * If you need to use a <div>, <p>, or <a> without the href attribute, then you need to allow
 * them to receive focus and to respond to keyboard input. The workaround is to:
 *
 *   - Give the element tabindex="0" so that it can receive keyboard focus.
 *   - Add a JavaScript onkeyup event handler that triggers element functionality if the Enter key
 *     is pressed while the element is focused. This is necessary because some browsers do not trigger
 *    onclick events for such elements when activated via the keyboard.
 *   - If the item is meant to function as a button, the onkeyup event handler should also detect the
 *     Spacebar in addition to the Enter key, and the element should be given role="button".
 *
 * Apply this directive to any of these elements to automatically do the above.
 */

_modules.uiModules.get('kibana').directive('kbnAccessibleClick', function () {
  return {
    restrict: 'A',
    controller: function controller($element) {
      $element.on('keydown', function (e) {
        // Prevent a scroll from occurring if the user has hit space.
        if (e.keyCode === _eui.keyCodes.SPACE) {
          e.preventDefault();
        }
      });
    },
    link: function link(scope, element, attrs) {
      // The whole point of this directive is to hack in functionality that native buttons provide
      // by default.
      var elementType = element.prop('tagName');

      if (elementType === 'BUTTON') {
        throw new Error('kbnAccessibleClick doesn\'t need to be used on a button.');
      }

      if (elementType === 'A' && attrs.href !== undefined) {
        throw new Error('kbnAccessibleClick doesn\'t need to be used on a link if it has a href attribute.');
      }

      // We're emulating a click action, so we should already have a regular click handler defined.
      if (!attrs.ngClick) {
        throw new Error('kbnAccessibleClick requires ng-click to be defined on its element.');
      }

      // If the developer hasn't already specified attributes required for accessibility, add them.
      if (attrs.tabindex === undefined) {
        element.attr('tabindex', '0');
      }

      if (attrs.role === undefined) {
        element.attr('role', 'button');
      }

      element.on('keyup', function (e) {
        // Support keyboard accessibility by emulating mouse click on ENTER or SPACE keypress.
        if (_eui.accessibleClickKeys[e.keyCode]) {
          // Delegate to the click handler on the element (assumed to be ng-click).
          element.click();
        }
      });
    }
  };
});

/***/ }),
/* 1532 */,
/* 1533 */,
/* 1534 */,
/* 1535 */,
/* 1536 */,
/* 1537 */,
/* 1538 */,
/* 1539 */,
/* 1540 */,
/* 1541 */,
/* 1542 */,
/* 1543 */,
/* 1544 */,
/* 1545 */,
/* 1546 */,
/* 1547 */,
/* 1548 */,
/* 1549 */,
/* 1550 */,
/* 1551 */,
/* 1552 */,
/* 1553 */,
/* 1554 */,
/* 1555 */,
/* 1556 */,
/* 1557 */,
/* 1558 */,
/* 1559 */,
/* 1560 */,
/* 1561 */,
/* 1562 */,
/* 1563 */,
/* 1564 */,
/* 1565 */,
/* 1566 */,
/* 1567 */,
/* 1568 */,
/* 1569 */,
/* 1570 */,
/* 1571 */,
/* 1572 */,
/* 1573 */,
/* 1574 */,
/* 1575 */,
/* 1576 */,
/* 1577 */,
/* 1578 */,
/* 1579 */,
/* 1580 */,
/* 1581 */,
/* 1582 */,
/* 1583 */,
/* 1584 */,
/* 1585 */,
/* 1586 */,
/* 1587 */,
/* 1588 */,
/* 1589 */,
/* 1590 */,
/* 1591 */,
/* 1592 */,
/* 1593 */,
/* 1594 */,
/* 1595 */,
/* 1596 */,
/* 1597 */,
/* 1598 */,
/* 1599 */,
/* 1600 */,
/* 1601 */,
/* 1602 */,
/* 1603 */,
/* 1604 */,
/* 1605 */,
/* 1606 */,
/* 1607 */,
/* 1608 */,
/* 1609 */,
/* 1610 */,
/* 1611 */,
/* 1612 */,
/* 1613 */,
/* 1614 */,
/* 1615 */,
/* 1616 */,
/* 1617 */,
/* 1618 */,
/* 1619 */,
/* 1620 */,
/* 1621 */,
/* 1622 */,
/* 1623 */,
/* 1624 */,
/* 1625 */,
/* 1626 */,
/* 1627 */,
/* 1628 */,
/* 1629 */,
/* 1630 */,
/* 1631 */,
/* 1632 */,
/* 1633 */,
/* 1634 */,
/* 1635 */,
/* 1636 */,
/* 1637 */,
/* 1638 */,
/* 1639 */,
/* 1640 */,
/* 1641 */,
/* 1642 */,
/* 1643 */,
/* 1644 */,
/* 1645 */,
/* 1646 */,
/* 1647 */,
/* 1648 */,
/* 1649 */,
/* 1650 */,
/* 1651 */,
/* 1652 */,
/* 1653 */,
/* 1654 */,
/* 1655 */,
/* 1656 */,
/* 1657 */,
/* 1658 */,
/* 1659 */,
/* 1660 */,
/* 1661 */,
/* 1662 */,
/* 1663 */,
/* 1664 */,
/* 1665 */,
/* 1666 */,
/* 1667 */,
/* 1668 */,
/* 1669 */,
/* 1670 */,
/* 1671 */,
/* 1672 */,
/* 1673 */,
/* 1674 */,
/* 1675 */,
/* 1676 */,
/* 1677 */,
/* 1678 */,
/* 1679 */,
/* 1680 */,
/* 1681 */,
/* 1682 */,
/* 1683 */,
/* 1684 */,
/* 1685 */,
/* 1686 */,
/* 1687 */,
/* 1688 */,
/* 1689 */,
/* 1690 */,
/* 1691 */,
/* 1692 */,
/* 1693 */,
/* 1694 */,
/* 1695 */,
/* 1696 */,
/* 1697 */,
/* 1698 */,
/* 1699 */,
/* 1700 */,
/* 1701 */,
/* 1702 */,
/* 1703 */,
/* 1704 */,
/* 1705 */,
/* 1706 */,
/* 1707 */,
/* 1708 */,
/* 1709 */,
/* 1710 */,
/* 1711 */,
/* 1712 */,
/* 1713 */,
/* 1714 */,
/* 1715 */,
/* 1716 */,
/* 1717 */,
/* 1718 */,
/* 1719 */,
/* 1720 */,
/* 1721 */,
/* 1722 */,
/* 1723 */,
/* 1724 */,
/* 1725 */,
/* 1726 */,
/* 1727 */,
/* 1728 */,
/* 1729 */,
/* 1730 */,
/* 1731 */,
/* 1732 */,
/* 1733 */,
/* 1734 */,
/* 1735 */,
/* 1736 */,
/* 1737 */,
/* 1738 */,
/* 1739 */,
/* 1740 */,
/* 1741 */,
/* 1742 */,
/* 1743 */,
/* 1744 */,
/* 1745 */,
/* 1746 */,
/* 1747 */,
/* 1748 */,
/* 1749 */,
/* 1750 */,
/* 1751 */,
/* 1752 */,
/* 1753 */,
/* 1754 */,
/* 1755 */,
/* 1756 */,
/* 1757 */,
/* 1758 */,
/* 1759 */,
/* 1760 */,
/* 1761 */,
/* 1762 */,
/* 1763 */,
/* 1764 */,
/* 1765 */,
/* 1766 */,
/* 1767 */,
/* 1768 */,
/* 1769 */,
/* 1770 */,
/* 1771 */,
/* 1772 */,
/* 1773 */,
/* 1774 */,
/* 1775 */,
/* 1776 */,
/* 1777 */,
/* 1778 */,
/* 1779 */,
/* 1780 */,
/* 1781 */,
/* 1782 */,
/* 1783 */,
/* 1784 */,
/* 1785 */,
/* 1786 */,
/* 1787 */,
/* 1788 */,
/* 1789 */,
/* 1790 */,
/* 1791 */,
/* 1792 */,
/* 1793 */,
/* 1794 */,
/* 1795 */,
/* 1796 */,
/* 1797 */,
/* 1798 */,
/* 1799 */,
/* 1800 */,
/* 1801 */,
/* 1802 */,
/* 1803 */,
/* 1804 */,
/* 1805 */,
/* 1806 */,
/* 1807 */,
/* 1808 */,
/* 1809 */,
/* 1810 */,
/* 1811 */,
/* 1812 */,
/* 1813 */,
/* 1814 */,
/* 1815 */,
/* 1816 */,
/* 1817 */,
/* 1818 */,
/* 1819 */,
/* 1820 */,
/* 1821 */,
/* 1822 */,
/* 1823 */,
/* 1824 */,
/* 1825 */,
/* 1826 */,
/* 1827 */,
/* 1828 */,
/* 1829 */,
/* 1830 */,
/* 1831 */,
/* 1832 */,
/* 1833 */,
/* 1834 */,
/* 1835 */,
/* 1836 */,
/* 1837 */,
/* 1838 */,
/* 1839 */,
/* 1840 */,
/* 1841 */,
/* 1842 */,
/* 1843 */,
/* 1844 */,
/* 1845 */,
/* 1846 */,
/* 1847 */,
/* 1848 */,
/* 1849 */,
/* 1850 */,
/* 1851 */,
/* 1852 */,
/* 1853 */,
/* 1854 */,
/* 1855 */,
/* 1856 */,
/* 1857 */,
/* 1858 */,
/* 1859 */,
/* 1860 */,
/* 1861 */,
/* 1862 */,
/* 1863 */,
/* 1864 */,
/* 1865 */,
/* 1866 */,
/* 1867 */,
/* 1868 */,
/* 1869 */,
/* 1870 */,
/* 1871 */,
/* 1872 */,
/* 1873 */,
/* 1874 */,
/* 1875 */,
/* 1876 */,
/* 1877 */,
/* 1878 */,
/* 1879 */,
/* 1880 */,
/* 1881 */,
/* 1882 */,
/* 1883 */,
/* 1884 */,
/* 1885 */,
/* 1886 */,
/* 1887 */,
/* 1888 */,
/* 1889 */,
/* 1890 */,
/* 1891 */,
/* 1892 */,
/* 1893 */,
/* 1894 */,
/* 1895 */,
/* 1896 */,
/* 1897 */,
/* 1898 */,
/* 1899 */,
/* 1900 */,
/* 1901 */,
/* 1902 */,
/* 1903 */,
/* 1904 */,
/* 1905 */,
/* 1906 */,
/* 1907 */,
/* 1908 */,
/* 1909 */,
/* 1910 */,
/* 1911 */,
/* 1912 */,
/* 1913 */,
/* 1914 */,
/* 1915 */,
/* 1916 */,
/* 1917 */,
/* 1918 */,
/* 1919 */,
/* 1920 */,
/* 1921 */,
/* 1922 */,
/* 1923 */,
/* 1924 */,
/* 1925 */,
/* 1926 */,
/* 1927 */,
/* 1928 */,
/* 1929 */,
/* 1930 */,
/* 1931 */,
/* 1932 */,
/* 1933 */,
/* 1934 */,
/* 1935 */,
/* 1936 */,
/* 1937 */,
/* 1938 */,
/* 1939 */,
/* 1940 */,
/* 1941 */,
/* 1942 */,
/* 1943 */,
/* 1944 */,
/* 1945 */,
/* 1946 */,
/* 1947 */,
/* 1948 */,
/* 1949 */,
/* 1950 */,
/* 1951 */,
/* 1952 */,
/* 1953 */,
/* 1954 */,
/* 1955 */,
/* 1956 */,
/* 1957 */,
/* 1958 */,
/* 1959 */,
/* 1960 */,
/* 1961 */,
/* 1962 */,
/* 1963 */,
/* 1964 */,
/* 1965 */,
/* 1966 */,
/* 1967 */,
/* 1968 */,
/* 1969 */,
/* 1970 */,
/* 1971 */,
/* 1972 */,
/* 1973 */,
/* 1974 */,
/* 1975 */,
/* 1976 */,
/* 1977 */,
/* 1978 */,
/* 1979 */,
/* 1980 */,
/* 1981 */,
/* 1982 */,
/* 1983 */,
/* 1984 */,
/* 1985 */,
/* 1986 */,
/* 1987 */,
/* 1988 */,
/* 1989 */,
/* 1990 */,
/* 1991 */,
/* 1992 */,
/* 1993 */,
/* 1994 */,
/* 1995 */,
/* 1996 */,
/* 1997 */,
/* 1998 */,
/* 1999 */,
/* 2000 */,
/* 2001 */,
/* 2002 */,
/* 2003 */,
/* 2004 */,
/* 2005 */,
/* 2006 */,
/* 2007 */,
/* 2008 */,
/* 2009 */,
/* 2010 */,
/* 2011 */,
/* 2012 */,
/* 2013 */,
/* 2014 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

_modules.uiModules.get('kibana').directive('scrolltoActivedescendant', function () {
  return {
    link: function link(scope, element, attrs) {
      scope.$watch(function () {
        return attrs.ariaActivedescendant;
      }, function (val) {
        if (val) {
          var activeDescendant = element.find('#' + val);
          if (activeDescendant.length) {
            activeDescendant[0].scrollIntoView();
          }
        }
      });
    }
  };
}); /**
     * This directive can be applied to an element, that has also aria-activedescendant applied.
     * It will make sure, that whenever aria-activedescendant changes, the new element
     * referenced by it, will be scrolled into visible view, by calling its `scrollIntoView`
     * method.
     */

/***/ }),
/* 2015 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(16);

__webpack_require__(17);

__webpack_require__(677);

__webpack_require__(464);

__webpack_require__(752);

__webpack_require__(301);

__webpack_require__(466);

__webpack_require__(2102);

__webpack_require__(200);

__webpack_require__(776);

__webpack_require__(753);

__webpack_require__(133);

__webpack_require__(2103);

__webpack_require__(777);

__webpack_require__(256);

__webpack_require__(320);

__webpack_require__(2157);

__webpack_require__(62);

__webpack_require__(2159);

__webpack_require__(2163);

__webpack_require__(691);

__webpack_require__(236);

__webpack_require__(484);

__webpack_require__(237);

__webpack_require__(663);

__webpack_require__(692);

__webpack_require__(2168);

__webpack_require__(431);

__webpack_require__(793);

__webpack_require__(796);

__webpack_require__(2233);

__webpack_require__(170);

__webpack_require__(488);

__webpack_require__(445);

__webpack_require__(2239);

__webpack_require__(2241);

/***/ }),
/* 2016 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _angular = __webpack_require__(16);

var _angular2 = _interopRequireDefault(_angular);

__webpack_require__(445);

__webpack_require__(465);

var _modules = __webpack_require__(2);

var _kbn_top_nav = __webpack_require__(2017);

var _kbn_top_nav2 = _interopRequireDefault(_kbn_top_nav);

var _kbn_top_nav_controller = __webpack_require__(751);

var _navbar_extensions = __webpack_require__(2020);

__webpack_require__(2021);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana'); /**
                                                 * A configuration object for a top nav component.
                                                 * @typedef {Object} KbnTopNavConfig
                                                 * @type Object
                                                 * @property {string} key - A display string which will be shown in the top nav for this option.
                                                 * @property {string} [description] - optional, used for the screen-reader description of this
                                                 *  menu. Defaults to "Toggle ${key} view" for templated menu items and just "${key}" for
                                                 *  programmatic menu items
                                                 * @property {string} testId - for testing purposes, can be used to retrieve this item.
                                                 * @property {Object} [template] - an html template that will be shown when this item is clicked.
                                                 *  If template is not given then run should be supplied.
                                                 * @property {function} [run] - an optional function that will be run when the nav item is clicked.
                                                 *  Either this or template parameter should be specified.
                                                 * @param {boolean} [hideButton] - optional, set to true to prevent a menu item from being created.
                                                 *  This allow injecting templates into the navbar that don't have an associated template
                                                 */

/**
 * kbnTopNav directive
 *
 * The top section that shows the timepicker, load, share and save dialogues.
 *
 * ```
 * <kbn-top-nav name="current-app-for-extensions" config="path.to.menuItems"></kbn-top-nav>
 * ```
 *
 * Menu items/templates are passed to the kbnTopNav via the config attribute
 * and should be defined as an array of objects. Each object represents a menu
 * item and should be of type kbnTopNavConfig.
 *
 * @param {Array<kbnTopNavConfig>|KbnTopNavController} config
 *
 * Programmatic control of the navbar can be achieved one of two ways
 */

_module.directive('kbnTopNav', function (Private) {
  var KbnTopNavController = Private(_kbn_top_nav_controller.KbnTopNavControllerProvider);
  var navbarExtensions = Private(_navbar_extensions.NavBarExtensionsRegistryProvider);
  var getNavbarExtensions = _lodash2.default.memoize(function (name) {
    if (!name) throw new Error('navbar directive requires a name attribute');
    return _lodash2.default.sortBy(navbarExtensions.byAppName[name], 'order');
  });

  return {
    restrict: 'E',
    transclude: true,
    template: _kbn_top_nav2.default,

    // TODO: The kbnTopNav currently requires that it share a scope with
    // its parent directive. This allows it to export the kbnTopNav controller
    // and allows the config templates to use values from the parent scope.
    //
    // Moving this to an isolate scope will require modifying the config
    // directive to support child directives, instead of templates, so that
    // parent controllers can be imported/required rather than simply referenced
    // directly in the template.
    //
    // TODO: Our fake multi-slot transclusion solution also depends on an inherited
    // scope. Moving this to an isolate scope will cause this to break.
    //
    // scope: {}

    controller: function controller($scope, $attrs, $element, $transclude) {
      // This is a semi-hacky solution to missing slot-transclusion support in Angular 1.4.7
      // (it was added as a core feature in 1.5). Borrowed from http://stackoverflow.com/a/22080765.
      $scope.transcludes = {};

      // Extract transcluded elements for use in the link function.
      $transclude(function (clone) {
        // We expect the transcluded elements to be wrapped in a single div.
        var transcludedContentContainer = _lodash2.default.find(clone, function (item) {
          if (item.attributes) {
            return _lodash2.default.find(item.attributes, function (attr) {
              return attr.name.indexOf('data-transclude-slots') !== -1;
            });
          }
        });

        if (!transcludedContentContainer) {
          return;
        }

        var transcludedContent = transcludedContentContainer.children;
        _lodash2.default.forEach(transcludedContent, function (transcludedItem) {
          var transclusionSlot = transcludedItem.getAttribute('data-transclude-slot');
          $scope.transcludes[transclusionSlot] = transcludedItem;
        });
      });
      var extensions = getNavbarExtensions($attrs.name);

      function initTopNav(newConfig, oldConfig) {
        if (_lodash2.default.isEqual(oldConfig, newConfig)) return;

        if (newConfig instanceof KbnTopNavController) {
          newConfig.addItems(extensions);
          $scope.kbnTopNav = new KbnTopNavController(newConfig);
        } else {
          newConfig = newConfig.concat(extensions);
          $scope.kbnTopNav = new KbnTopNavController(newConfig);
        }
        $scope.kbnTopNav._link($scope, $element);
      }

      var getTopNavConfig = function getTopNavConfig() {
        return _lodash2.default.get($scope, $attrs.config, []);
      };

      var topNavConfig = getTopNavConfig();

      // Because we store $scope and $element on the kbnTopNavController, if this was passed an instance
      // instead of a configuration, it will enter an infinite digest loop. Only watch for updates if a config
      // was passed instead. This is ugly, but without diving into a larger refactor, the smallest temporary solution
      // to get dynamic nav updates working for dashboard. Console is currently the only place that passes a
      // KbnTopNavController (and a slew of tests).
      if (!(topNavConfig instanceof KbnTopNavController)) {
        $scope.$watch(getTopNavConfig, initTopNav, true);
      }

      initTopNav(topNavConfig, null);

      return $scope.kbnTopNav;
    },
    link: function link(scope) {
      // These are the slots where transcluded elements can go.
      var transclusionSlotNames = ['topLeftCorner', 'bottomRow'];

      // Transclude elements into specified "slots" in the top nav.
      transclusionSlotNames.forEach(function (name) {
        var transcludedItem = scope.transcludes[name];
        if (transcludedItem) {
          var transclusionSlot = document.querySelector('[data-transclude-slot="' + name + '"]');
          _angular2.default.element(transclusionSlot).replaceWith(transcludedItem);
        }
      });
    }
  };
});

/***/ }),
/* 2017 */
/***/ (function(module, exports) {

module.exports = "<div\n  class=\"kuiLocalNav\"\n  ng-show=\"kbnTopNav.isVisible()\"\n  data-test-subj=\"top-nav\"\n>\n  <!-- Top row -->\n  <div class=\"kuiLocalNavRow\">\n    <!-- Top left corner slot, e.g. breadcrumbs, title. -->\n    <div\n      class=\"kuiLocalNavRow__section\"\n      data-transclude-slot=\"topLeftCorner\"\n    ></div>\n\n    <!-- Right-side: menu -->\n    <div class=\"kuiLocalNavRow__section\">\n      <div class=\"kuiLocalMenu\">\n        <button\n          class=\"kuiLocalMenuItem\"\n          ng-repeat=\"menuItem in kbnTopNav.menuItems\"\n          aria-label=\"{{::menuItem.description}}\"\n          aria-haspopup=\"{{!menuItem.hasFunction}}\"\n          aria-expanded=\"{{kbnTopNav.isCurrent(menuItem.key)}}\"\n          ng-class=\"{'kuiLocalMenuItem-isSelected': kbnTopNav.isCurrent(menuItem.key), 'kuiLocalMenuItem-isDisabled': menuItem.disableButton()}\"\n          ng-click=\"kbnTopNav.handleClick(menuItem)\"\n          ng-bind=\"menuItem.label\"\n          tooltip=\"{{menuItem.tooltip()}}\"\n          tooltip-placement=\"bottom\"\n          tooltip-popup-delay=\"400\"\n          tooltip-append-to-body=\"1\"\n          data-test-subj=\"{{menuItem.testId}}\"\n        ></button>\n\n        <!-- Time-picker \"menu item\" -->\n        <kbn-global-timepicker></kbn-global-timepicker>\n      </div>\n    </div>\n  </div>\n\n  <!-- Dropdown content, e.g. time-picker. -->\n  <div\n    class=\"kuiLocalDropdown\"\n    ng-show=\"kbnTopNav.rendered\"\n  >\n    <button class=\"kuiLocalDropdownCloseButton\" ng-click=\"kbnTopNav.close()\" aria-label=\"Close\">\n      <span class=\"kuiIcon fa-chevron-circle-up\"></span>\n    </button>\n    <div id=\"template_wrapper\">\n      <!-- Content gets dynamically inserted here. -->\n    </div>\n  </div>\n\n  <div class=\"kuiLocalNavRow kuiLocalNavRow--secondary\">\n    <!-- Bottom row slot, e.g. tabs. -->\n    <div data-transclude-slot=\"bottomRow\"></div>\n  </div>\n</div>\n"

/***/ }),
/* 2018 */
/***/ (function(module, exports) {

module.exports = "<kbn-timepicker\n  from=\"timefilter.time.from\"\n  to=\"timefilter.time.to\"\n  mode=\"timefilter.time.mode\"\n  active-tab=\"'filter'\"\n  interval=\"timefilter.refreshInterval\"\n  on-filter-select=\"updateFilter(from, to)\"\n  on-interval-select=\"updateInterval(interval)\">\n</kbn-timepicker>\n"

/***/ }),
/* 2019 */
/***/ (function(module, exports) {

module.exports = "<kbn-timepicker\n  from=\"timefilter.time.from\"\n  to=\"timefilter.time.to\"\n  mode=\"timefilter.time.mode\"\n  active-tab=\"'interval'\"\n  interval=\"timefilter.refreshInterval\"\n  on-filter-select=\"updateFilter(from, to)\"\n  on-interval-select=\"updateInterval(interval)\">\n</kbn-timepicker>\n"

/***/ }),
/* 2020 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NavBarExtensionsRegistryProvider = undefined;

var _registry = __webpack_require__(63);

var NavBarExtensionsRegistryProvider = exports.NavBarExtensionsRegistryProvider = (0, _registry.uiRegistry)({
  name: 'navbarExtensions',
  index: ['name'],
  group: ['appName'],
  order: ['order']
});

/***/ }),
/* 2021 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _bread_crumbs = __webpack_require__(2022);

var _bread_crumbs2 = _interopRequireDefault(_bread_crumbs);

var _modules = __webpack_require__(2);

var _routes = __webpack_require__(29);

var _routes2 = _interopRequireDefault(_routes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');

_module.directive('breadCrumbs', function () {
  return {
    restrict: 'E',
    replace: true,
    scope: {
      omitCurrentPage: '=',
      /**
       * Pages to omit from the breadcrumbs. Should be lower-case.
       * @type {Array}
       */
      omitPages: '=',
      /**
       * Optional title to append at the end of the breadcrumbs. Note that this can't just be
       * 'title', because that will be interpreted by browsers as an actual 'title' HTML attribute.
       * @type {String}
       */
      pageTitle: '=',
      /**
       * If true, makes each breadcrumb a clickable link.
       * @type {String}
       */
      useLinks: '='
    },
    template: _bread_crumbs2.default,
    controller: function controller($scope) {

      function omitPagesFilter(crumb) {
        return !$scope.omitPages || !$scope.omitPages.includes(crumb.id);
      }

      function omitCurrentPageFilter(crumb) {
        return !($scope.omitCurrentPage && crumb.current);
      }

      $scope.$watchMulti(['[]omitPages', 'omitCurrentPage'], function getBreadcrumbs() {
        $scope.breadcrumbs = _routes2.default.getBreadcrumbs().filter(omitPagesFilter).filter(omitCurrentPageFilter);
      });
    }
  };
});

/***/ }),
/* 2022 */
/***/ (function(module, exports) {

module.exports = "<div\n  class=\"kuiLocalBreadcrumbs\"\n  data-test-subj=\"breadcrumbs\"\n  role=\"heading\"\n  aria-level=\"1\"\n>\n  <div\n    class=\"kuiLocalBreadcrumb\"\n    ng-if=\"useLinks\"\n    ng-repeat=\"breadcrumb in breadcrumbs\"\n  >\n    <a\n      class=\"kuiLocalBreadcrumb__link\"\n      href=\"{{ breadcrumb.href }}\"\n    >\n      {{ breadcrumb.display}}\n    </a>\n  </div>\n\n  <div\n    class=\"kuiLocalBreadcrumb\"\n    ng-if=\"!useLinks\"\n    ng-repeat=\"breadcrumb in breadcrumbs\"\n  >\n    {{ breadcrumb.display }}\n  </div>\n\n  <div\n    class=\"kuiLocalBreadcrumb\"\n    ng-if=\"pageTitle\"\n  >\n    {{ pageTitle }}\n  </div>\n</div>\n"

/***/ }),
/* 2023 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

__webpack_require__(753);

__webpack_require__(236);

__webpack_require__(320);

var _modules = __webpack_require__(2);

var _notifier = __webpack_require__(43);

var _search_source = __webpack_require__(135);

var _request_queue = __webpack_require__(250);

var _fetch = __webpack_require__(471);

var _search = __webpack_require__(2097);

var _root_search_source = __webpack_require__(763);

var _saved_object = __webpack_require__(2099);

var _redirect_when_missing = __webpack_require__(2101);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_modules.uiModules.get('kibana/courier').service('courier', function ($rootScope, Private, indexPatterns) {
  function Courier() {
    var self = this;
    var SearchSource = Private(_search_source.SearchSourceProvider);
    var fetchSoon = Private(_fetch.FetchSoonProvider);
    var searchLooper = self.searchLooper = Private(_search.SearchLooperProvider);

    // expose some internal modules
    self.setRootSearchSource = Private(_root_search_source.RootSearchSourceProvider).set;

    self.SavedObject = Private(_saved_object.SavedObjectProvider);
    self.indexPatterns = indexPatterns;
    self.redirectWhenMissing = Private(_redirect_when_missing.RedirectWhenMissingProvider);

    self.SearchSource = SearchSource;

    /**
    * update the time between automatic search requests
    *
    * @chainable
    */
    self.fetchInterval = function (ms) {
      searchLooper.ms(ms);
      return this;
    };

    /**
    * Start fetching search requests on an interval
    * @chainable
    */
    self.start = function () {
      searchLooper.start();
      return this;
    };

    /**
    * Process the pending request queue right now, returns
    * a promise that resembles the success of the fetch completing,
    * individual errors are routed to their respective requests.
    */
    self.fetch = function () {
      fetchSoon.fetchQueued().then(function () {
        searchLooper.restart();
      });
    };

    /**
    * is the currior currently fetching search
    * results automatically?
    *
    * @return {boolean}
    */
    self.started = function () {
      return searchLooper.started();
    };

    /**
    * stop the courier from fetching more search
    * results, does not stop vaidating docs.
    *
    * @chainable
    */
    self.stop = function () {
      searchLooper.stop();
      return this;
    };

    /**
    * Abort all pending requests
    * @return {[type]} [description]
    */
    self.close = function () {
      searchLooper.stop();

      _lodash2.default.invoke(_request_queue.requestQueue, 'abort');

      if (_request_queue.requestQueue.length) {
        throw new Error('Aborting all pending requests failed.');
      }
    };

    // Listen for refreshInterval changes
    $rootScope.$watchCollection('timefilter.refreshInterval', function () {
      var refreshValue = _lodash2.default.get($rootScope, 'timefilter.refreshInterval.value');
      var refreshPause = _lodash2.default.get($rootScope, 'timefilter.refreshInterval.pause');
      if (_lodash2.default.isNumber(refreshValue) && !refreshPause) {
        self.fetchInterval(refreshValue);
      } else {
        self.fetchInterval(0);
      }
    });

    var closeOnFatal = _lodash2.default.once(self.close);
    _notifier.Notifier.fatalCallbacks.push(closeOnFatal);
  }

  return new Courier();
});

/***/ }),
/* 2024 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(16);
module.exports = __webpack_require__(2025);
__webpack_require__(2).get('kibana', ['elasticsearch']);


/***/ }),
/* 2025 */,
/* 2026 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IndexPatternsProvider = IndexPatternsProvider;

__webpack_require__(249);

var _errors = __webpack_require__(37);

var _index_pattern = __webpack_require__(2027);

var _pattern_cache = __webpack_require__(760);

var _get = __webpack_require__(469);

var _intervals = __webpack_require__(758);

var _fields_fetcher_provider = __webpack_require__(761);

var _field_formats = __webpack_require__(64);

var _modules = __webpack_require__(2);

var _module = _modules.uiModules.get('kibana/index_patterns');

function IndexPatternsProvider(Notifier, Private) {
  var self = this;

  var IndexPattern = Private(_index_pattern.IndexPatternProvider);
  var patternCache = Private(_pattern_cache.IndexPatternsPatternCacheProvider);
  var getProvider = Private(_get.IndexPatternsGetProvider);

  self.get = function (id) {
    if (!id) return self.make();

    var cache = patternCache.get(id);
    return cache || patternCache.set(id, self.make(id));
  };

  self.make = function (id) {
    return new IndexPattern(id).init();
  };

  self.delete = function (pattern) {
    self.getIds.clearCache();
    return pattern.destroy();
  };

  self.errors = {
    MissingIndices: _errors.IndexPatternMissingIndices
  };

  self.cache = patternCache;
  self.getIds = getProvider('id');
  self.getTitles = getProvider('attributes.title');
  self.intervals = Private(_intervals.IndexPatternsIntervalsProvider);
  self.fieldsFetcher = Private(_fields_fetcher_provider.FieldsFetcherProvider);
  self.fieldFormats = Private(_field_formats.RegistryFieldFormatsProvider);
  self.IndexPattern = IndexPattern;
}

_module.service('indexPatterns', function (Private) {
  return Private(IndexPatternsProvider);
});

/***/ }),
/* 2027 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.getRoutes = getRoutes;
exports.IndexPatternProvider = IndexPatternProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _errors = __webpack_require__(37);

var _angular = __webpack_require__(16);

var _angular2 = _interopRequireDefault(_angular);

var _field_formats = __webpack_require__(64);

var _mapping_setup = __webpack_require__(755);

var _mapping_setup2 = _interopRequireDefault(_mapping_setup);

var _notify = __webpack_require__(62);

var _get_computed_fields = __webpack_require__(2030);

var _format_hit = __webpack_require__(2031);

var _get = __webpack_require__(469);

var _intervals = __webpack_require__(758);

var _field_list = __webpack_require__(759);

var _flatten_hit = __webpack_require__(2040);

var _pattern_cache = __webpack_require__(760);

var _fields_fetcher_provider = __webpack_require__(761);

var _unsupported_time_patterns = __webpack_require__(2043);

var _saved_objects = __webpack_require__(76);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function getRoutes() {
  return {
    edit: '/management/kibana/indices/{{id}}',
    addField: '/management/kibana/indices/{{id}}/create-field',
    indexedFields: '/management/kibana/indices/{{id}}?_a=(tab:indexedFields)',
    scriptedFields: '/management/kibana/indices/{{id}}?_a=(tab:scriptedFields)',
    sourceFilters: '/management/kibana/indices/{{id}}?_a=(tab:sourceFilters)'
  };
}

function IndexPatternProvider(Private, config, Promise, confirmModalPromise, kbnUrl) {
  var fieldformats = Private(_field_formats.RegistryFieldFormatsProvider);
  var getConfig = function getConfig() {
    return config.get.apply(config, arguments);
  };
  var getIds = Private(_get.IndexPatternsGetProvider)('id');
  var fieldsFetcher = Private(_fields_fetcher_provider.FieldsFetcherProvider);
  var intervals = Private(_intervals.IndexPatternsIntervalsProvider);
  var mappingSetup = Private(_mapping_setup2.default);
  var FieldList = Private(_field_list.IndexPatternsFieldListProvider);
  var flattenHit = Private(_flatten_hit.IndexPatternsFlattenHitProvider);
  var patternCache = Private(_pattern_cache.IndexPatternsPatternCacheProvider);
  var isUserAwareOfUnsupportedTimePattern = Private(_unsupported_time_patterns.IsUserAwareOfUnsupportedTimePatternProvider);
  var savedObjectsClient = Private(_saved_objects.SavedObjectsClientProvider);

  var type = 'index-pattern';
  var notify = new _notify.Notifier();
  var configWatchers = new WeakMap();

  var mapping = mappingSetup.expandShorthand({
    title: 'text',
    timeFieldName: 'keyword',
    intervalName: 'keyword',
    fields: 'json',
    sourceFilters: 'json',
    fieldFormatMap: {
      type: 'text',
      _serialize: function _serialize() {
        var map = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var serialized = _lodash2.default.transform(map, serializeFieldFormatMap);
        return _lodash2.default.isEmpty(serialized) ? undefined : _angular2.default.toJson(serialized);
      },
      _deserialize: function _deserialize() {
        var map = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '{}';

        return _lodash2.default.mapValues(_angular2.default.fromJson(map), deserializeFieldFormatMap);
      }
    }
  });

  function serializeFieldFormatMap(flat, format, field) {
    if (format) {
      flat[field] = format;
    }
  }

  function deserializeFieldFormatMap(mapping) {
    var FieldFormat = fieldformats.byId[mapping.id];
    return FieldFormat && new FieldFormat(mapping.params, getConfig);
  }

  function updateFromElasticSearch(indexPattern, response) {
    if (!response.found) {
      var markdownSaveId = indexPattern.id.replace('*', '%2A');

      throw new _errors.SavedObjectNotFound(type, indexPattern.id, kbnUrl.eval('#/management/kibana/index?id={{id}}&name=', { id: markdownSaveId }));
    }

    _lodash2.default.forOwn(mapping, function (fieldMapping, name) {
      if (!fieldMapping._deserialize) {
        return;
      }
      response._source[name] = fieldMapping._deserialize(response._source[name]);
    });

    // give index pattern all of the values in _source
    _lodash2.default.assign(indexPattern, response._source);

    if (!indexPattern.title) {
      indexPattern.title = indexPattern.id;
    }

    if (indexPattern.isUnsupportedTimePattern()) {
      if (!isUserAwareOfUnsupportedTimePattern(indexPattern)) {
        var warning = 'Support for time-intervals has been removed. ' + ('View the ["' + indexPattern.title + '" index pattern in management](') + kbnUrl.getRouteHref(indexPattern, 'edit') + ') for more information.';
        notify.warning(warning, { lifetime: Infinity });
      }
    }

    return indexFields(indexPattern);
  }

  function isFieldRefreshRequired(indexPattern) {
    if (!indexPattern.fields) {
      return true;
    }

    return indexPattern.fields.every(function (field) {
      // See https://github.com/elastic/kibana/pull/8421
      var hasFieldCaps = 'aggregatable' in field && 'searchable' in field;

      // See https://github.com/elastic/kibana/pull/11969
      var hasDocValuesFlag = 'readFromDocValues' in field;

      return !hasFieldCaps || !hasDocValuesFlag;
    });
  }

  function indexFields(indexPattern) {
    var promise = Promise.resolve();

    if (!indexPattern.id) {
      return promise;
    }

    if (isFieldRefreshRequired(indexPattern)) {
      promise = indexPattern.refreshFields();
    }

    return promise.then(function () {
      initFields(indexPattern);
    });
  }

  function setId(indexPattern, id) {
    indexPattern.id = id;
    return id;
  }

  function watch(indexPattern) {
    if (configWatchers.has(indexPattern)) {
      return;
    }
    var unwatch = config.watchAll(function () {
      if (indexPattern.fields) {
        initFields(indexPattern); // re-init fields when config changes, but only if we already had fields
      }
    });
    configWatchers.set(indexPattern, { unwatch: unwatch });
  }

  function unwatch(indexPattern) {
    if (!configWatchers.has(indexPattern)) {
      return;
    }
    configWatchers.get(indexPattern).unwatch();
    configWatchers.delete(indexPattern);
  }

  function initFields(indexPattern, input) {
    var oldValue = indexPattern.fields;
    var newValue = input || oldValue || [];
    indexPattern.fields = new FieldList(indexPattern, newValue);
  }

  function fetchFields(indexPattern) {
    return Promise.resolve().then(function () {
      return fieldsFetcher.fetch(indexPattern);
    }).then(function (fields) {
      var scripted = indexPattern.getScriptedFields();
      var all = fields.concat(scripted);
      initFields(indexPattern, all);
    });
  }

  var IndexPattern = function () {
    function IndexPattern(id) {
      _classCallCheck(this, IndexPattern);

      setId(this, id);
      this.metaFields = config.get('metaFields');
      this.getComputedFields = _get_computed_fields.getComputedFields.bind(this);

      this.flattenHit = flattenHit(this);
      this.formatHit = (0, _format_hit.formatHit)(this, fieldformats.getDefaultInstance('string'));
      this.formatField = this.formatHit.formatField;
    }

    _createClass(IndexPattern, [{
      key: 'init',
      value: function init() {
        var _this = this;

        watch(this);

        if (!this.id) {
          return Promise.resolve(this); // no id === no elasticsearch document
        }

        return savedObjectsClient.get(type, this.id).then(function (resp) {
          // temporary compatability for savedObjectsClient

          return {
            _id: resp.id,
            _type: resp.type,
            _source: _lodash2.default.cloneDeep(resp.attributes),
            found: resp._version ? true : false
          };
        }).then(function (response) {
          return updateFromElasticSearch(_this, response);
        }).then(function () {
          return _this;
        });
      }

      // Get the source filtering configuration for that index.

    }, {
      key: 'getSourceFiltering',
      value: function getSourceFiltering() {
        return {
          excludes: this.sourceFilters && this.sourceFilters.map(function (filter) {
            return filter.value;
          }) || []
        };
      }
    }, {
      key: 'addScriptedField',
      value: function addScriptedField(name, script) {
        var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'string';
        var lang = arguments[3];

        var scriptedFields = this.getScriptedFields();
        var names = _lodash2.default.pluck(scriptedFields, 'name');

        if (_lodash2.default.contains(names, name)) {
          throw new _errors.DuplicateField(name);
        }

        this.fields.push({
          name: name,
          script: script,
          type: type,
          scripted: true,
          lang: lang
        });

        this.save();
      }
    }, {
      key: 'removeScriptedField',
      value: function removeScriptedField(name) {
        var fieldIndex = _lodash2.default.findIndex(this.fields, {
          name: name,
          scripted: true
        });
        this.fields.splice(fieldIndex, 1);
        this.save();
      }
    }, {
      key: 'popularizeField',
      value: function popularizeField(fieldName) {
        var unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

        var field = _lodash2.default.get(this, ['fields', 'byName', fieldName]);
        if (!field) {
          return;
        }
        var count = Math.max((field.count || 0) + unit, 0);
        if (field.count === count) {
          return;
        }
        field.count = count;
        this.save();
      }
    }, {
      key: 'getNonScriptedFields',
      value: function getNonScriptedFields() {
        return _lodash2.default.where(this.fields, { scripted: false });
      }
    }, {
      key: 'getScriptedFields',
      value: function getScriptedFields() {
        return _lodash2.default.where(this.fields, { scripted: true });
      }
    }, {
      key: 'getInterval',
      value: function getInterval() {
        return this.intervalName && _lodash2.default.find(intervals, { name: this.intervalName });
      }
    }, {
      key: 'toIndexList',
      value: function toIndexList(start, stop, sortDirection) {
        return this.toDetailedIndexList(start, stop, sortDirection).then(function (detailedIndices) {
          if (!Array.isArray(detailedIndices)) {
            return detailedIndices.index;
          }
          return _lodash2.default.pluck(detailedIndices, 'index');
        });
      }
    }, {
      key: 'toDetailedIndexList',
      value: function toDetailedIndexList(start, stop, sortDirection) {
        var _this2 = this;

        return Promise.resolve().then(function () {
          if (_this2.isTimeBasedInterval()) {
            return intervals.toIndexList(_this2.title, _this2.getInterval(), start, stop, sortDirection);
          }

          return [{
            index: _this2.title,
            min: -Infinity,
            max: Infinity
          }];
        });
      }
    }, {
      key: 'isTimeBased',
      value: function isTimeBased() {
        return !!this.timeFieldName && (!this.fields || !!this.getTimeField());
      }
    }, {
      key: 'isTimeBasedInterval',
      value: function isTimeBasedInterval() {
        return this.isTimeBased() && !!this.getInterval();
      }
    }, {
      key: 'isUnsupportedTimePattern',
      value: function isUnsupportedTimePattern() {
        return !!this.intervalName;
      }
    }, {
      key: 'isTimeBasedWildcard',
      value: function isTimeBasedWildcard() {
        return this.isTimeBased() && this.isWildcard();
      }
    }, {
      key: 'getTimeField',
      value: function getTimeField() {
        if (!this.timeFieldName || !this.fields || !this.fields.byName) return;
        return this.fields.byName[this.timeFieldName];
      }
    }, {
      key: 'isWildcard',
      value: function isWildcard() {
        return _lodash2.default.includes(this.title, '*');
      }
    }, {
      key: 'prepBody',
      value: function prepBody() {
        var _this3 = this;

        var body = {};

        // serialize json fields
        _lodash2.default.forOwn(mapping, function (fieldMapping, fieldName) {
          if (_this3[fieldName] != null) {
            body[fieldName] = fieldMapping._serialize ? fieldMapping._serialize(_this3[fieldName]) : _this3[fieldName];
          }
        });

        // clear the indexPattern list cache
        getIds.clearCache();
        return body;
      }

      /**
       * Returns a promise that resolves to true if either the title is unique, or if the user confirmed they
       * wished to save the duplicate title.  Promise is rejected if the user rejects the confirmation.
       */

    }, {
      key: 'warnIfDuplicateTitle',
      value: function warnIfDuplicateTitle() {
        var _this4 = this;

        return (0, _saved_objects.findObjectByTitle)(savedObjectsClient, type, this.title).then(function (duplicate) {
          if (!duplicate) return false;
          if (duplicate.id === _this4.id) return false;

          var confirmMessage = 'An index pattern with the title \'' + _this4.title + '\' already exists.';

          return confirmModalPromise(confirmMessage, { confirmButtonText: 'Go to existing pattern' }).then(function () {
            kbnUrl.redirect('/management/kibana/indices/{{id}}', { id: duplicate.id });
            return true;
          }).catch(function () {
            return true;
          });
        });
      }
    }, {
      key: 'create',
      value: function create() {
        var _this5 = this;

        return this.warnIfDuplicateTitle().then(function (isDuplicate) {
          if (isDuplicate) return;

          var body = _this5.prepBody();

          return savedObjectsClient.create(type, body, { id: _this5.id }).then(function (response) {
            return setId(_this5, response.id);
          }).catch(function (err) {
            if (err.statusCode !== 409) {
              return Promise.resolve(false);
            }
            var confirmMessage = 'Are you sure you want to overwrite this?';

            return confirmModalPromise(confirmMessage, { confirmButtonText: 'Overwrite' }).then(function () {
              return Promise.try(function () {
                var cached = patternCache.get(_this5.id);
                if (cached) {
                  return cached.then(function (pattern) {
                    return pattern.destroy();
                  });
                }
              }).then(function () {
                return savedObjectsClient.create(type, body, { id: _this5.id, overwrite: true });
              }).then(function (response) {
                return setId(_this5, response.id);
              });
            }, _lodash2.default.constant(false) // if the user doesn't overwrite, resolve with false
            );
          });
        });
      }
    }, {
      key: 'save',
      value: function save() {
        var _this6 = this;

        return savedObjectsClient.update(type, this.id, this.prepBody()).then(function (_ref) {
          var id = _ref.id;
          return setId(_this6, id);
        });
      }
    }, {
      key: 'refreshFields',
      value: function refreshFields() {
        var _this7 = this;

        return fetchFields(this).then(function () {
          return _this7.save();
        }).catch(function (err) {
          notify.error(err);
          // https://github.com/elastic/kibana/issues/9224
          // This call will attempt to remap fields from the matching
          // ES index which may not actually exist. In that scenario,
          // we still want to notify the user that there is a problem
          // but we do not want to potentially make any pages unusable
          // so do not rethrow the error here
          if (err instanceof _errors.IndexPatternMissingIndices) {
            return [];
          }

          throw err;
        });
      }
    }, {
      key: 'toJSON',
      value: function toJSON() {
        return this.id;
      }
    }, {
      key: 'toString',
      value: function toString() {
        return '' + this.toJSON();
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        unwatch(this);
        patternCache.clear(this.id);
        return savedObjectsClient.delete(type, this.id);
      }
    }, {
      key: 'routes',
      get: function get() {
        return getRoutes();
      }
    }]);

    return IndexPattern;
  }();

  return IndexPattern;
}

/***/ }),
/* 2028 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.contentTypesSetup = contentTypesSetup;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _as_pretty_string = __webpack_require__(322);

var _highlight_html = __webpack_require__(468);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var types = {
  html: function html(format, convert) {
    function recurse(value, field, hit, meta) {
      if (value == null) {
        return (0, _as_pretty_string.asPrettyString)(value);
      }

      if (!value || typeof value.map !== 'function') {
        return convert.call(format, value, field, hit, meta);
      }

      var subVals = value.map(function (v) {
        return recurse(v, field, hit, meta);
      });
      var useMultiLine = subVals.some(function (sub) {
        return sub.indexOf('\n') > -1;
      });

      return subVals.join(',' + (useMultiLine ? '\n' : ' '));
    }

    return function () {
      return '<span ng-non-bindable>' + recurse.apply(undefined, arguments) + '</span>';
    };
  },

  text: function text(format, convert) {
    return function recurse(value) {
      if (!value || typeof value.map !== 'function') {
        return convert.call(format, value);
      }

      // format a list of values. In text contexts we just use JSON encoding
      return JSON.stringify(value.map(recurse));
    };
  }
};

function fallbackText(value) {
  return (0, _as_pretty_string.asPrettyString)(value);
}

function fallbackHtml(value, field, hit) {
  var formatted = _lodash2.default.escape(this.convert(value, 'text'));

  if (!hit || !hit.highlight || !hit.highlight[field.name]) {
    return formatted;
  } else {
    return (0, _highlight_html.getHighlightHtml)(formatted, hit.highlight[field.name]);
  }
}

function contentTypesSetup(format) {
  var src = format._convert || {};
  var converters = format._convert = {};

  converters.text = types.text(format, src.text || fallbackText);
  converters.html = types.html(format, src.html || fallbackHtml);

  return format._convert;
}

/***/ }),
/* 2029 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
// These are the html tags that will replace the highlight tags.
var htmlTags = exports.htmlTags = {
  pre: '<mark>',
  post: '</mark>'
};

/***/ }),
/* 2030 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getComputedFields = getComputedFields;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Takes a hit, merges it with any stored/scripted fields, and with the metaFields
// returns a flattened version
function getComputedFields() {
  var self = this;
  var scriptFields = {};
  var docvalueFields = [];

  docvalueFields = _lodash2.default.map(_lodash2.default.reject(self.fields.byType.date, 'scripted'), 'name');

  _lodash2.default.each(self.getScriptedFields(), function (field) {
    scriptFields[field.name] = {
      script: {
        inline: field.script,
        lang: field.lang
      }
    };
  });

  return {
    storedFields: ['*'],
    scriptFields: scriptFields,
    docvalueFields: docvalueFields
  };
}

/***/ }),
/* 2031 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatHit = formatHit;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _chrome = __webpack_require__(17);

var _chrome2 = _interopRequireDefault(_chrome);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Takes a hit, merges it with any stored/scripted fields, and with the metaFields
// returns a formatted version

function formatHit(indexPattern, defaultFormat) {

  function convert(hit, val, fieldName) {
    var field = indexPattern.fields.byName[fieldName];
    if (!field) return defaultFormat.convert(val, 'html');
    var parsedUrl = {
      origin: window.location.origin,
      pathname: window.location.pathname,
      basePath: _chrome2.default.getBasePath()
    };
    return field.format.getConverterFor('html')(val, field, hit, parsedUrl);
  }

  function formatHit(hit) {
    if (hit.$$_formatted) return hit.$$_formatted;

    // use and update the partial cache, but don't rewrite it. _source is stored in partials
    // but not $$_formatted
    var partials = hit.$$_partialFormatted || (hit.$$_partialFormatted = {});
    var cache = hit.$$_formatted = {};

    _lodash2.default.forOwn(indexPattern.flattenHit(hit), function (val, fieldName) {
      // sync the formatted and partial cache
      var formatted = partials[fieldName] == null ? convert(hit, val, fieldName) : partials[fieldName];
      cache[fieldName] = partials[fieldName] = formatted;
    });

    return cache;
  }

  formatHit.formatField = function (hit, fieldName) {
    var partials = hit.$$_partialFormatted;
    if (partials && partials[fieldName] != null) {
      return partials[fieldName];
    }

    if (!partials) {
      partials = hit.$$_partialFormatted = {};
    }

    var val = fieldName === '_source' ? hit._source : indexPattern.flattenHit(hit)[fieldName];
    return partials[fieldName] = convert(hit, val, fieldName);
  };

  return formatHit;
}

/***/ }),
/* 2032 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.keysToSnakeCaseShallow = keysToSnakeCaseShallow;
exports.keysToCamelCaseShallow = keysToCamelCaseShallow;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function keysToSnakeCaseShallow(object) {
  return _lodash2.default.mapKeys(object, function (value, key) {
    return _lodash2.default.snakeCase(key);
  });
}

function keysToCamelCaseShallow(object) {
  return _lodash2.default.mapKeys(object, function (value, key) {
    return _lodash2.default.camelCase(key);
  });
}

/***/ }),
/* 2033 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SavedObjectsClientProvider = SavedObjectsClientProvider;

var _error_auto_create_index = __webpack_require__(2034);

var _saved_objects_client = __webpack_require__(756);

function SavedObjectsClientProvider($http, $q, Private) {
  var errorAutoCreateIndex = Private(_error_auto_create_index.ErrorAutoCreateIndexProvider);

  return new _saved_objects_client.SavedObjectsClient({
    $http: $http,
    PromiseConstructor: $q,
    onCreateFailure: function onCreateFailure(error) {
      if (errorAutoCreateIndex.test(error)) {
        return errorAutoCreateIndex.takeover();
      }

      throw error;
    }
  });
}

/***/ }),
/* 2034 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _error_auto_create_index = __webpack_require__(2035);

Object.defineProperty(exports, 'ErrorAutoCreateIndexProvider', {
  enumerable: true,
  get: function get() {
    return _error_auto_create_index.ErrorAutoCreateIndexProvider;
  }
});

/***/ }),
/* 2035 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.ErrorAutoCreateIndexProvider = ErrorAutoCreateIndexProvider;

var _lodash = __webpack_require__(1);

var _routes = __webpack_require__(29);

var _routes2 = _interopRequireDefault(_routes);

var _url = __webpack_require__(170);

__webpack_require__(2036);

var _error_auto_create_index = __webpack_require__(2037);

var _error_auto_create_index2 = _interopRequireDefault(_error_auto_create_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

_routes2.default.when('/error/action.auto_create_index', { template: _error_auto_create_index2.default });

function ErrorAutoCreateIndexProvider(Private, Promise) {
  var kbnUrl = Private(_url.KbnUrlProvider);

  return new (function () {
    function ErrorAutoCreateIndex() {
      _classCallCheck(this, ErrorAutoCreateIndex);
    }

    _createClass(ErrorAutoCreateIndex, [{
      key: 'test',
      value: function test(error) {
        return error.statusCode === 503 && (0, _lodash.get)(error, 'body.code') === 'ES_AUTO_CREATE_INDEX_ERROR';
      }
    }, {
      key: 'takeover',
      value: function takeover() {
        kbnUrl.change('/error/action.auto_create_index');
        return Promise.halt();
      }
    }]);

    return ErrorAutoCreateIndex;
  }())();
}

/***/ }),
/* 2036 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 2037 */
/***/ (function(module, exports) {

module.exports = "<div class=\"app-container error-auto-create-index\">\n  <h3 class=\"kuiVerticalRhythm\">\n    <i aria-hidden=\"true\" class=\"fa fa-warning text-danger\"></i> Oh no!\n  </h3>\n\n  <p class=\"kuiVerticalRhythm\">\n    It looks like your Elasticsearch cluster's <code>action.auto_create_index</code> setting is preventing Kibana from automatically creating an index to store saved objects. Kibana uses this Elasticsearch feature because it is the best way to make sure that the saved object index uses the correct mappings/schema, and it allows Kibana to poll Elasticsearch less often.\n  </p>\n\n  <p class=\"kuiVerticalRhythm\">\n    Unfortunately, until this issue is fixed you won't be able to save anything in Kibana.\n  </p>\n\n  <h3 class=\"kuiVerticalRhythm\">\n    Ok, how do I fix this?\n  </h3>\n\n  <ol class=\"kuiVerticalRhythm\">\n    <li>Remove <code>action.auto_create_index: false</code> from your Elasticsearch configuration file</li>\n    <li>Restart elasticsearch.</li>\n    <li>Use the browser's back button to return to what you were doing.</li>\n  </ol>\n\n  <div class=\"kuiInfoPanel kuiInfoPanel--info kuiVerticalRhythm\">\n    <div class=\"kuiInfoPanelHeader\">\n      <span\n        class=\"kuiInfoPanelHeader__icon kuiIcon kuiIcon--info fa-info\"\n        aria-label=\"Info\"\n        role=\"img\"\n      ></span>\n      <span class=\"kuiInfoPanelHeader__title\">\n        Note:\n      </span>\n    </div>\n\n    <div class=\"kuiInfoPanelBody\">\n      <div class=\"kuiInfoPanelBody__message\">\n        The <code>action.auto_create_index</code> can also define a whitelist of patterns where this feature should be enabled. We don't discuss how to use the setting that way here because it requires knowing all of the other plugins/interations that rely on the feature for the same reasons that Kibana does.\n      </div>\n    </div>\n  </div>\n</div>\n"

/***/ }),
/* 2038 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findObjectByTitle = findObjectByTitle;

var _lodash = __webpack_require__(1);

/**
 * Returns an object matching a given title
 *
 * @param savedObjectsClient {SavedObjectsClient}
 * @param type {string}
 * @param title {string}
 * @returns {Promise<SavedObject|undefined>}
 */
function findObjectByTitle(savedObjectsClient, type, title) {
  if (!title) return Promise.resolve();

  // Elastic search will return the most relevant results first, which means exact matches should come
  // first, and so we shouldn't need to request everything. Using 10 just to be on the safe side.
  return savedObjectsClient.find({
    type: type,
    perPage: 10,
    search: '"' + title + '"',
    searchFields: ['title'],
    fields: ['title']
  }).then(function (response) {
    var match = (0, _lodash.find)(response.savedObjects, function (obj) {
      return obj.get('title').toLowerCase() === title.toLowerCase();
    });

    return match;
  });
}

/***/ }),
/* 2039 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ObjDefine = ObjDefine;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ObjDefine(defaults, prototype) {
  this.obj; // created by this.create()

  this.descs = {};
  this.defaults = defaults || {};
  this.prototype = prototype || Object.prototype;
}

ObjDefine.REDEFINE_SUPPORTED = function () {
  var a = Object.create(Object.prototype, {
    prop: {
      configurable: true,
      value: 1
    }
  });

  Object.defineProperty(a, 'prop', {
    configurable: true,
    value: 2
  });

  return a.prop === 2;
}();

/**
 * normal value, writable and exported in JSON
 *
 * @param  {any} v - value
 * @return {object} - property descriptor
 */
ObjDefine.prototype.writ = function (name, val) {
  this._define(name, val, true, true);
};

/**
 * known value, exported in JSON, not changeable
 *
 * @param  {any} v - value
 * @return {object} - property descriptor
 */
ObjDefine.prototype.fact = function (name, val) {
  this._define(name, val, true);
};

/**
 * computed fact, not exported or changeable
 *
 * @param  {any} v - value
 * @return {object} - property descriptor
 */
ObjDefine.prototype.comp = function (name, val) {
  this._define(name, val);
};

/**
 * Creates an object, decorated by the property descriptors
 * created by other ObjDefine methods and inheritting form the
 * prototype
 *
 * # note:
 * If a value is writable, but the value is undefined, the property will
 * be created by not exported to JSON unless the property is written to
 *
 * @return {object} - created object
 */
ObjDefine.prototype.create = function () {
  var self = this;
  self.obj = Object.create(this.prototype, self.descs);

  if (!ObjDefine.REDEFINE_SUPPORTED && !self.prototype.toJSON) {
    // since we can't redefine properties as enumerable we will
    // clone the object on serialization and choose which properties
    // to include or trim manually. This is currently only in use in PhantomJS
    // due to https://github.com/ariya/phantomjs/issues/11856
    self.obj.toJSON = function () {
      return _lodash2.default.transform(self.obj, function (json, val, key) {
        var desc = self.descs[key];
        if (desc && desc.enumerable && val == null) return;
        json[key] = val;
      }, {});
    };
  }

  return self.obj;
};

/**
 * Private APIS
 */

ObjDefine.prototype._define = function (name, val, exported, changeable) {
  val = val != null ? val : this.defaults[name];
  this.descs[name] = this._describe(name, val, !!exported, !!changeable);
};

ObjDefine.prototype._describe = function (name, val, exported, changeable) {
  var self = this;
  var exists = val != null;

  if (exported && ObjDefine.REDEFINE_SUPPORTED) {
    return {
      enumerable: exists,
      configurable: true,
      get: _lodash2.default.constant(val),
      set: function set(update) {
        if (!changeable) return false;

        // change the descriptor, since the value now exists.
        self.descs[name] = self._describe(name, update, exported, changeable);

        // apply the updated descriptor
        Object.defineProperty(self.obj, name, self.descs[name]);
      }
    };
  }

  if (exported && !ObjDefine.REDEFINE_SUPPORTED) {
    return {
      enumerable: true,
      configurable: true,
      writable: changeable,
      value: val
    };
  }

  return {
    enumerable: false,
    writable: changeable,
    configurable: true,
    value: val
  };
};

/***/ }),
/* 2040 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IndexPatternsFlattenHitProvider = IndexPatternsFlattenHitProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Takes a hit, merges it with any stored/scripted fields, and with the metaFields
// returns a flattened version
function IndexPatternsFlattenHitProvider(config) {
  var metaFields = config.get('metaFields');

  config.watch('metaFields', function (value) {
    metaFields = value;
  });

  function flattenHit(indexPattern, hit, deep) {
    var flat = {};

    // recursively merge _source
    var fields = indexPattern.fields.byName;
    (function flatten(obj, keyPrefix) {
      keyPrefix = keyPrefix ? keyPrefix + '.' : '';
      _lodash2.default.forOwn(obj, function (val, key) {
        key = keyPrefix + key;

        if (deep) {
          var isNestedField = fields[key] && fields[key].type === 'nested';
          var isArrayOfObjects = Array.isArray(val) && _lodash2.default.isPlainObject(_lodash2.default.first(val));
          if (isArrayOfObjects && !isNestedField) {
            _lodash2.default.each(val, function (v) {
              return flatten(v, key);
            });
            return;
          }
        } else if (flat[key] !== void 0) {
          return;
        }

        var hasValidMapping = fields[key] && fields[key].type !== 'conflict';
        var isValue = !_lodash2.default.isPlainObject(val);

        if (hasValidMapping || isValue) {
          if (!flat[key]) {
            flat[key] = val;
          } else if (Array.isArray(flat[key])) {
            flat[key].push(val);
          } else {
            flat[key] = [flat[key], val];
          }
          return;
        }

        flatten(val, key);
      });
    })(hit._source);

    // assign the meta fields
    _lodash2.default.each(metaFields, function (meta) {
      if (meta === '_source') return;
      flat[meta] = hit[meta];
    });

    // unwrap computed fields
    _lodash2.default.forOwn(hit.fields, function (val, key) {
      if (key[0] === '_' && !_lodash2.default.contains(metaFields, key)) return;
      flat[key] = Array.isArray(val) && val.length === 1 ? val[0] : val;
    });

    return flat;
  }

  return function flattenHitWrapper(indexPattern) {
    return function cachedFlatten(hit) {
      var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      return hit.$$_flattened || (hit.$$_flattened = flattenHit(indexPattern, hit, deep));
    };
  };
}

/***/ }),
/* 2041 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.createFieldsFetcher = createFieldsFetcher;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function createFieldsFetcher(apiClient, config) {
  var FieldsFetcher = function () {
    function FieldsFetcher() {
      _classCallCheck(this, FieldsFetcher);
    }

    _createClass(FieldsFetcher, [{
      key: 'fetch',
      value: function fetch(indexPattern) {
        if (indexPattern.isTimeBasedInterval()) {
          var interval = indexPattern.getInterval().name;
          return this.fetchForTimePattern(indexPattern.title, interval);
        }

        return this.fetchForWildcard(indexPattern.title);
      }
    }, {
      key: 'fetchForTimePattern',
      value: function fetchForTimePattern(indexPatternId) {
        return apiClient.getFieldsForTimePattern({
          pattern: indexPatternId,
          lookBack: config.get('indexPattern:fieldMapping:lookBack'),
          metaFields: config.get('metaFields')
        });
      }
    }, {
      key: 'fetchForWildcard',
      value: function fetchForWildcard(indexPatternId) {
        return apiClient.getFieldsForWildcard({
          pattern: indexPatternId,
          metaFields: config.get('metaFields')
        });
      }
    }]);

    return FieldsFetcher;
  }();

  return new FieldsFetcher();
}

/***/ }),
/* 2042 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.createIndexPatternsApiClient = createIndexPatternsApiClient;

var _url = __webpack_require__(71);

var _lodash = __webpack_require__(1);

var _errors = __webpack_require__(37);

var _notify = __webpack_require__(62);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function createIndexPatternsApiClient($http, basePath) {
  var apiBaseUrl = basePath + '/api/index_patterns/';
  var notify = new _notify.Notifier({ location: 'Index Patterns API' });

  function join() {
    for (var _len = arguments.length, uriComponents = Array(_len), _key = 0; _key < _len; _key++) {
      uriComponents[_key] = arguments[_key];
    }

    return uriComponents.filter(Boolean).map(encodeURIComponent).join('/');
  }

  function getUrl(path, query) {
    var noNullsQuery = (0, _lodash.pick)(query, function (value) {
      return value != null;
    });
    var noArraysQuery = (0, _lodash.mapValues)(noNullsQuery, function (value) {
      return Array.isArray(value) ? JSON.stringify(value) : value;
    });

    return (0, _url.resolve)(apiBaseUrl, (0, _url.format)({
      pathname: join.apply(undefined, _toConsumableArray(path)),
      query: noArraysQuery
    }));
  }

  function request(method, url, body) {
    return $http({
      method: method,
      url: url,
      data: body
    }).then(function (resp) {
      return resp.data;
    }).catch(function (resp) {
      // convert $http errors into actual error objects
      var respBody = resp.data;

      if (resp.status === 404 && respBody.code === 'no_matching_indices') {
        throw new _errors.IndexPatternMissingIndices(respBody.message);
      }

      var err = new Error(respBody.message || respBody.error || resp.status + ' Response');
      err.status = resp.status;
      err.body = respBody;
      throw err;
    });
  }

  var IndexPatternsApiClient = function () {
    function IndexPatternsApiClient() {
      _classCallCheck(this, IndexPatternsApiClient);
    }

    _createClass(IndexPatternsApiClient, [{
      key: 'getFieldsForTimePattern',
      value: function getFieldsForTimePattern() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var pattern = options.pattern,
            lookBack = options.lookBack,
            metaFields = options.metaFields;


        var url = getUrl(['_fields_for_time_pattern'], {
          pattern: pattern,
          look_back: lookBack,
          meta_fields: metaFields
        });

        return notify.event('getFieldsForTimePattern(' + pattern + ')', function () {
          return request('GET', url).then(function (resp) {
            return resp.fields;
          });
        });
      }
    }, {
      key: 'getFieldsForWildcard',
      value: function getFieldsForWildcard() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var pattern = options.pattern,
            metaFields = options.metaFields;


        var url = getUrl(['_fields_for_wildcard'], {
          pattern: pattern,
          meta_fields: metaFields
        });

        return notify.event('getFieldsForWildcard(' + pattern + ')', function () {
          return request('GET', url).then(function (resp) {
            return resp.fields;
          });
        });
      }
    }]);

    return IndexPatternsApiClient;
  }();

  return new IndexPatternsApiClient();
}

/***/ }),
/* 2043 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IsUserAwareOfUnsupportedTimePatternProvider = IsUserAwareOfUnsupportedTimePatternProvider;

var _bound_to_config_obj = __webpack_require__(752);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function IsUserAwareOfUnsupportedTimePatternProvider(Private, $injector) {
  var BoundToConfigObj = Private(_bound_to_config_obj.BoundToConfigObjProvider);
  var sessionStorage = $injector.get('sessionStorage');

  var HISTORY_STORAGE_KEY = 'indexPatterns:warnAboutUnsupportedTimePatterns:history';
  var FLAGS = new BoundToConfigObj({
    enabled: '=indexPatterns:warnAboutUnsupportedTimePatterns'
  });

  return function isUserAwareOfUnsupportedTimePattern(indexPattern) {
    // The user's disabled the notification. They know about it.
    if (!FLAGS.enabled) {
      return true;
    }

    // We've already told the user.
    var previousIds = sessionStorage.get(HISTORY_STORAGE_KEY) || [];
    if (previousIds.includes(indexPattern.id)) {
      return true;
    }

    // Let's store this for later, so we don't tell the user multiple times.
    sessionStorage.set(HISTORY_STORAGE_KEY, [].concat(_toConsumableArray(previousIds), [indexPattern.id]));
    return false;
  };
}

/***/ }),
/* 2044 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NormalizeSortRequestProvider = NormalizeSortRequestProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function NormalizeSortRequestProvider(config) {
  var defaultSortOptions = config.get('sort:options');

  /**
   * Decorate queries with default parameters
   * @param {query} query object
   * @returns {object}
   */
  return function (sortObject, indexPattern) {
    // [].concat({}) -> [{}], [].concat([{}]) -> [{}]
    return [].concat(sortObject).map(function (sortable) {
      return normalize(sortable, indexPattern);
    });
  };

  /*
    Normalize the sort description to the more verbose format:
    { someField: "desc" } into { someField: { "order": "desc"}}
  */
  function normalize(sortable, indexPattern) {
    var normalized = {};
    var sortField = _lodash2.default.keys(sortable)[0];
    var sortValue = sortable[sortField];
    var indexField = indexPattern.fields.byName[sortField];

    if (indexField && indexField.scripted && indexField.sortable) {
      var direction = void 0;
      if (_lodash2.default.isString(sortValue)) direction = sortValue;
      if (_lodash2.default.isObject(sortValue) && sortValue.order) direction = sortValue.order;

      sortField = '_script';
      sortValue = {
        script: {
          inline: indexField.script,
          lang: indexField.lang
        },
        type: castSortType(indexField.type),
        order: direction
      };
    } else {
      if (_lodash2.default.isString(sortValue)) {
        sortValue = { order: sortValue };
      }
      sortValue = _lodash2.default.defaults({}, sortValue, defaultSortOptions);

      if (sortField === '_score') {
        delete sortValue.unmapped_type;
      }
    }

    normalized[sortField] = sortValue;
    return normalized;
  }
}

// The ES API only supports sort scripts of type 'number' and 'string'
function castSortType(type) {
  var typeCastings = {
    number: 'number',
    string: 'string',
    date: 'number',
    boolean: 'string'
  };

  var castedType = typeCastings[type];
  if (!castedType) {
    throw new Error('Unsupported script sort type: ' + type);
  }

  return castedType;
}

/***/ }),
/* 2045 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AbstractDataSourceProvider = AbstractDataSourceProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _angular = __webpack_require__(16);

var _angular2 = _interopRequireDefault(_angular);

__webpack_require__(236);

var _request_queue = __webpack_require__(250);

var _fetch = __webpack_require__(471);

var _field_wildcard = __webpack_require__(472);

var _highlight = __webpack_require__(2059);

var _build_query = __webpack_require__(2061);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function AbstractDataSourceProvider(Private, Promise, PromiseEmitter, config) {
  var fetchSoon = Private(_fetch.FetchSoonProvider);
  var buildESQuery = Private(_build_query.BuildESQueryProvider);

  var _Private = Private(_field_wildcard.FieldWildcardProvider),
      fieldWildcardFilter = _Private.fieldWildcardFilter;

  var getConfig = function getConfig() {
    return config.get.apply(config, arguments);
  };

  function SourceAbstract(initialState) {
    var self = this;
    self._instanceid = _lodash2.default.uniqueId('data_source');

    self._state = function () {
      // state can be serialized as JSON, and passed back in to restore
      if (initialState) {
        if (typeof initialState === 'string') {
          return JSON.parse(initialState);
        } else {
          return _lodash2.default.cloneDeep(initialState);
        }
      } else {
        return {};
      }
    }();

    // set internal state values
    self._methods.forEach(function (name) {
      self[name] = function (val) {
        if (val == null) {
          delete self._state[name];
        } else {
          self._state[name] = val;
        }

        return self;
      };
    });

    self.history = [];
    self._requestStartHandlers = [];
  }

  /*****
   * PUBLIC API
   *****/

  /**
   * Get values from the state
   * @param {string} name - The name of the property desired
   * @return {any} - the value found
   */
  SourceAbstract.prototype.get = function (name) {
    var self = this;
    while (self) {
      if (self._state[name] !== void 0) return self._state[name];
      self = self.getParent();
    }
  };

  /**
   * Get the value from our own state, don't traverse up the chain
   * @param {string} name - The name of the property desired
   * @return {any} - the value found
   */
  SourceAbstract.prototype.getOwn = function (name) {
    if (this._state[name] !== void 0) return this._state[name];
  };

  /**
   * Change the entire state of a SourceAbstract
   * @param {object|string} state - The SourceAbstract's new state, or a
   *   string of the state value to set
   */
  SourceAbstract.prototype.set = function (state, val) {
    var self = this;

    if (typeof state === 'string') {
      // the getter and setter methods check for undefined explicitly
      // to identify getters and null to identify deletion
      if (val === undefined) {
        val = null;
      }
      self[state](val);
    } else {
      self._state = state;
    }
    return self;
  };

  /**
   * Create a new dataSource object of the same type
   * as this, which inherits this dataSource's properties
   * @return {SourceAbstract}
   */
  SourceAbstract.prototype.extend = function () {
    return new this.Class().inherits(this);
  };

  /**
   * return a simple, encodable object representing the state of the SourceAbstract
   * @return {[type]} [description]
   */
  SourceAbstract.prototype.toJSON = function () {
    return _lodash2.default.clone(this._state);
  };

  /**
   * Create a string representation of the object
   * @return {[type]} [description]
   */
  SourceAbstract.prototype.toString = function () {
    return _angular2.default.toJson(this.toJSON());
  };

  /**
   * Put a request in to the courier that this Source should
   * be fetched on the next run of the courier
   * @return {Promise}
   */
  SourceAbstract.prototype.onResults = function (handler) {
    var self = this;

    return new PromiseEmitter(function (resolve, reject) {
      var defer = Promise.defer();
      defer.promise.then(resolve, reject);

      var request = self._createRequest(defer);

      request.setErrorHandler(function (request, error) {
        reject(error);
        request.abort();
      });
    }, handler);
  };

  /**
   * Noop
   */
  SourceAbstract.prototype.getParent = function () {
    return this._parent;
  };

  /**
   * Fetch just this source ASAP
   *
   * ONLY USE IF YOU WILL BE USING THE RESULTS
   * provided by the returned promise, otherwise
   * call #fetchQueued()
   *
   * @async
   */
  SourceAbstract.prototype.fetch = function () {
    var self = this;
    var req = _lodash2.default.first(self._myStartableQueued());

    if (!req) {
      req = self._createRequest();
    }

    fetchSoon.these([req]);

    return req.getCompletePromise();
  };

  /**
   * Fetch this source and reject the returned Promise on error
   *
   * Otherwise behaves like #fetch()
   *
   * @async
   */
  SourceAbstract.prototype.fetchAsRejectablePromise = function () {
    var self = this;
    var req = _lodash2.default.first(self._myStartableQueued());

    if (!req) {
      req = self._createRequest();
    }

    req.setErrorHandler(function (request, error) {
      request.defer.reject(error);
      request.abort();
    });

    fetchSoon.these([req]);

    return req.getCompletePromise();
  };

  /**
   * Fetch all pending requests for this source ASAP
   * @async
   */
  SourceAbstract.prototype.fetchQueued = function () {
    return fetchSoon.these(this._myStartableQueued());
  };

  /**
   * Cancel all pending requests for this dataSource
   * @return {undefined}
   */
  SourceAbstract.prototype.cancelQueued = function () {
    var _this = this;

    _request_queue.requestQueue.filter(function (req) {
      return req.source === _this;
    }).forEach(function (req) {
      return req.abort();
    });
  };

  /**
   * Completely destroy the SearchSource.
   * @return {undefined}
   */
  SourceAbstract.prototype.destroy = function () {
    this.cancelQueued();
    this._requestStartHandlers.length = 0;
  };

  /**
   *  Add a handler that will be notified whenever requests start
   *  @param  {Function} handler
   *  @return {undefined}
   */
  SourceAbstract.prototype.onRequestStart = function (handler) {
    this._requestStartHandlers.push(handler);
  };

  /**
   *  Called by requests of this search source when they are started
   *  @param  {Courier.Request} request
   *  @return {Promise<undefined>}
   */
  SourceAbstract.prototype.requestIsStarting = function (request) {
    var _this2 = this;

    this.activeFetchCount = (this.activeFetchCount || 0) + 1;
    this.history = [request];

    return Promise.map(this._requestStartHandlers, function (fn) {
      return fn(_this2, request);
    }).then(_lodash2.default.noop);
  };

  /**
   *  Called by requests of this search source when they are done
   *  @param  {Courier.Request} request
   *  @return {undefined}
   */
  SourceAbstract.prototype.requestIsStopped = function () /* request */{
    this.activeFetchCount -= 1;
  };

  /*****
   * PRIVATE API
   *****/

  SourceAbstract.prototype._myStartableQueued = function () {
    var _this3 = this;

    return _request_queue.requestQueue.getStartable().filter(function (req) {
      return req.source === _this3;
    });
  };

  SourceAbstract.prototype._createRequest = function () {
    throw new Error('_createRequest must be implemented by subclass');
  };

  /**
   * Walk the inheritance chain of a source and return it's
   * flat representaion (taking into account merging rules)
   * @returns {Promise}
   * @resolved {Object|null} - the flat state of the SourceAbstract
   */
  SourceAbstract.prototype._flatten = function () {
    var type = this._getType();

    // the merged state of this dataSource and it's ancestors
    var flatState = {};

    // function used to write each property from each state object in the chain to flat state
    var root = this;

    // start the chain at this source
    var current = this;

    // call the ittr and return it's promise
    return function ittr() {
      // itterate the _state object (not array) and
      // pass each key:value pair to source._mergeProp. if _mergeProp
      // returns a promise, then wait for it to complete and call _mergeProp again
      return Promise.all(_lodash2.default.map(current._state, function ittr(value, key) {
        if (Promise.is(value)) {
          return value.then(function (value) {
            return ittr(value, key);
          });
        }

        var prom = root._mergeProp(flatState, value, key);
        return Promise.is(prom) ? prom : null;
      })).then(function () {
        // move to this sources parent
        var parent = current.getParent();
        // keep calling until we reach the top parent
        if (parent) {
          current = parent;
          return ittr();
        }
      });
    }().then(function () {
      if (type === 'search') {
        // This is down here to prevent the circular dependency
        flatState.body = flatState.body || {};

        var computedFields = flatState.index.getComputedFields();
        flatState.body.stored_fields = computedFields.storedFields;
        flatState.body.script_fields = flatState.body.script_fields || {};
        flatState.body.docvalue_fields = flatState.body.docvalue_fields || [];

        _lodash2.default.extend(flatState.body.script_fields, computedFields.scriptFields);
        flatState.body.docvalue_fields = _lodash2.default.union(flatState.body.docvalue_fields, computedFields.docvalueFields);

        if (flatState.body._source) {
          // exclude source fields for this index pattern specified by the user
          var filter = fieldWildcardFilter(flatState.body._source.excludes);
          flatState.body.docvalue_fields = flatState.body.docvalue_fields.filter(filter);
        }

        // if we only want to search for certain fields
        var fields = flatState.fields;
        if (fields) {
          // filter out the docvalue_fields, and script_fields to only include those that we are concerned with
          flatState.body.docvalue_fields = _lodash2.default.intersection(flatState.body.docvalue_fields, fields);
          flatState.body.script_fields = _lodash2.default.pick(flatState.body.script_fields, fields);

          // request the remaining fields from both stored_fields and _source
          var remainingFields = _lodash2.default.difference(fields, _lodash2.default.keys(flatState.body.script_fields));
          flatState.body.stored_fields = remainingFields;
          _lodash2.default.set(flatState.body, '_source.includes', remainingFields);
        }

        flatState.body.query = buildESQuery(flatState.index, flatState.query, flatState.filters);

        if (flatState.highlightAll != null) {
          if (flatState.highlightAll && flatState.body.query) {
            flatState.body.highlight = (0, _highlight.getHighlightRequest)(flatState.body.query, getConfig);
          }
          delete flatState.highlightAll;
        }

        /**
        * Translate a filter into a query to support es 3+
        * @param  {Object} filter - The filter to translate
        * @return {Object} the query version of that filter
        */
        var translateToQuery = function translateToQuery(filter) {
          if (!filter) return;

          if (filter.query) {
            return filter.query;
          }

          return filter;
        };

        // re-write filters within filter aggregations
        (function recurse(aggBranch) {
          if (!aggBranch) return;
          Object.keys(aggBranch).forEach(function (id) {
            var agg = aggBranch[id];

            if (agg.filters) {
              // translate filters aggregations
              var filters = agg.filters.filters;

              Object.keys(filters).forEach(function (filterId) {
                filters[filterId] = translateToQuery(filters[filterId]);
              });
            }

            recurse(agg.aggs || agg.aggregations);
          });
        })(flatState.body.aggs || flatState.body.aggregations);
      }

      return flatState;
    });
  };

  return SourceAbstract;
}

/***/ }),
/* 2046 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FetchSoonProvider = FetchSoonProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _request_queue = __webpack_require__(250);

var _fetch_now = __webpack_require__(2047);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This is usually the right fetch provider to use, rather than FetchNowProvider, as this class introduces
 * a slight delay in the request process to allow multiple requests to queue up (e.g. when a dashboard
 * is loading).
 *
 * @param Private
 * @param Promise
 * @constructor
 */
function FetchSoonProvider(Private, Promise) {
  var _this = this;

  var fetchNow = Private(_fetch_now.FetchNowProvider);

  var debouncedFetchNow = _lodash2.default.debounce(function () {
    var requests = _request_queue.requestQueue.filter(function (req) {
      return req.isFetchRequestedAndPending();
    });
    fetchNow(requests);
  }, {
    wait: 10,
    maxWait: 50
  });

  /**
   * Fetch a list of requests
   * @param {array} requests - the requests to fetch
   * @async
   */
  this.these = function (requests) {
    requests.forEach(function (req) {
      return req._setFetchRequested();
    });
    debouncedFetchNow();
    return Promise.all(requests.map(function (req) {
      return req.getCompletePromise();
    }));
  };

  this.fetchQueued = function () {
    return _this.these(_request_queue.requestQueue.getStartable());
  };
}

/***/ }),
/* 2047 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FetchNowProvider = FetchNowProvider;

var _notifier = __webpack_require__(764);

var _call_client = __webpack_require__(2048);

var _call_response_handlers = __webpack_require__(2056);

var _continue_incomplete = __webpack_require__(2057);

var _req_status = __webpack_require__(251);

/**
 * Fetch now provider should be used if you want the results searched and returned immediately.
 * This can be slightly inefficient if a large number of requests are queued up, we can batch these
 * by using fetchSoon. This introduces a slight delay which allows other requests to queue up before
 * sending out requests in a batch.
 *
 * @param Private
 * @param Promise
 * @return {fetchNow}
 * @constructor
 */
function FetchNowProvider(Private, Promise) {
  // core tasks
  var callClient = Private(_call_client.CallClientProvider);
  var callResponseHandlers = Private(_call_response_handlers.CallResponseHandlersProvider);
  var continueIncomplete = Private(_continue_incomplete.ContinueIncompleteProvider);

  var ABORTED = _req_status.RequestStatus.ABORTED;
  var DUPLICATE = _req_status.RequestStatus.DUPLICATE;
  var INCOMPLETE = _req_status.RequestStatus.INCOMPLETE;

  function fetchNow(requests) {
    return fetchSearchResults(requests.map(function (req) {
      if (!req.started) return req;
      return req.retry();
    })).catch(_notifier.courierNotifier.fatal);
  }

  function fetchSearchResults(requests) {
    function replaceAbortedRequests() {
      requests = requests.map(function (r) {
        return r.aborted ? ABORTED : r;
      });
    }

    replaceAbortedRequests();
    return startRequests(requests).then(function () {
      replaceAbortedRequests();
      return callClient(requests);
    }).then(function (responses) {
      replaceAbortedRequests();
      return callResponseHandlers(requests, responses);
    }).then(function (responses) {
      replaceAbortedRequests();
      return continueIncomplete(requests, responses, fetchSearchResults);
    }).then(function (responses) {
      replaceAbortedRequests();
      return responses.map(function (resp) {
        switch (resp) {
          case ABORTED:
            return null;
          case DUPLICATE:
          case INCOMPLETE:
            throw new Error('Failed to clear incomplete or duplicate request from responses.');
          default:
            return resp;
        }
      });
    });
  }

  function startRequests(requests) {
    return Promise.map(requests, function (req) {
      if (req === ABORTED) {
        return req;
      }

      return new Promise(function (resolve) {
        var action = req.started ? req.continue : req.start;
        resolve(action.call(req));
      }).catch(function (err) {
        return req.handleFailure(err);
      });
    });
  }

  return fetchNow;
}

/***/ }),
/* 2048 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CallClientProvider = CallClientProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _error_allow_explicit_index = __webpack_require__(2049);

var _is_request = __webpack_require__(765);

var _merge_duplicate_requests = __webpack_require__(2053);

var _req_status = __webpack_require__(251);

var _request_fetch_params_to_body_provider = __webpack_require__(2054);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function CallClientProvider(Private, Promise, es) {
  var errorAllowExplicitIndex = Private(_error_allow_explicit_index.ErrorAllowExplicitIndexProvider);
  var isRequest = Private(_is_request.IsRequestProvider);
  var mergeDuplicateRequests = Private(_merge_duplicate_requests.MergeDuplicatesRequestProvider);
  var requestFetchParamsToBody = Private(_request_fetch_params_to_body_provider.RequestFetchParamsToBodyProvider);

  var ABORTED = _req_status.RequestStatus.ABORTED;
  var DUPLICATE = _req_status.RequestStatus.DUPLICATE;

  function callClient(requests) {
    // merging docs can change status to DUPLICATE, capture new statuses
    var statuses = mergeDuplicateRequests(requests);

    // get the actual list of requests that we will be fetching
    var requestsToFetch = statuses.filter(isRequest);
    var execCount = requestsToFetch.length;

    if (!execCount) return Promise.resolve([]);

    // resolved by respond()
    var esPromise = void 0;
    var defer = Promise.defer();

    // for each respond with either the response or ABORTED
    var respond = function respond(responses) {
      responses = responses || [];
      return Promise.map(requests, function (request, i) {
        switch (statuses[i]) {
          case ABORTED:
            return ABORTED;
          case DUPLICATE:
            return request._uniq.resp;
          default:
            var index = _lodash2.default.findIndex(requestsToFetch, request);
            if (index < 0) {
              // This means the request failed.
              return ABORTED;
            }
            return responses[index];
        }
      }).then(function (res) {
        return defer.resolve(res);
      }, function (err) {
        return defer.reject(err);
      });
    };

    // handle a request being aborted while being fetched
    var requestWasAborted = Promise.method(function (req, i) {
      if (statuses[i] === ABORTED) {
        defer.reject(new Error('Request was aborted twice?'));
      }

      execCount -= 1;
      if (execCount > 0) {
        // the multi-request still contains other requests
        return;
      }

      if (esPromise && _lodash2.default.isFunction(esPromise.abort)) {
        esPromise.abort();
      }

      esPromise = ABORTED;

      return respond();
    });

    // attach abort handlers, close over request index
    statuses.forEach(function (req, i) {
      if (!isRequest(req)) return;
      req.whenAborted(function () {
        requestWasAborted(req, i).catch(defer.reject);
      });
    });

    // Now that all of THAT^^^ is out of the way, lets actually
    // call out to elasticsearch
    Promise.map(requestsToFetch, function (request) {
      return Promise.try(request.getFetchParams, void 0, request).then(function (fetchParams) {
        return request.fetchParams = fetchParams;
      }).then(function (value) {
        return { resolved: value };
      }).catch(function (error) {
        return { rejected: error };
      });
    }).then(function (results) {
      var requestsWithFetchParams = [];
      // Gather the fetch param responses from all the successful requests.
      results.forEach(function (result, index) {
        if (result.resolved) {
          requestsWithFetchParams.push(result.resolved);
        } else {
          var request = requestsToFetch[index];
          request.handleFailure(result.rejected);
          requestsToFetch[index] = undefined;
        }
      });
      // The index of the request inside requestsToFetch determines which response is mapped to it. If a request
      // won't generate a response, since it already failed, we need to remove the request
      // from the requestsToFetch array so the indexes will continue to match up to the responses correctly.
      requestsToFetch = requestsToFetch.filter(function (request) {
        return request !== undefined;
      });
      return requestFetchParamsToBody(requestsWithFetchParams);
    }).then(function (body) {
      // while the strategy was converting, our request was aborted
      if (esPromise === ABORTED) {
        throw ABORTED;
      }

      return esPromise = es.msearch({ body: body });
    }).then(function (clientResponse) {
      return respond(clientResponse.responses);
    }).catch(function (error) {
      if (errorAllowExplicitIndex.test(error)) {
        return errorAllowExplicitIndex.takeover();
      }

      if (error === ABORTED) respond();else defer.reject(error);
    });

    // return our promise, but catch any errors we create and
    // send them to the requests
    return defer.promise.catch(function (err) {
      requests.forEach(function (req, i) {
        if (statuses[i] !== ABORTED) {
          req.handleFailure(err);
        }
      });
    });
  }

  return callClient;
}

/***/ }),
/* 2049 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _error_allow_explicit_index = __webpack_require__(2050);

Object.defineProperty(exports, 'ErrorAllowExplicitIndexProvider', {
  enumerable: true,
  get: function get() {
    return _error_allow_explicit_index.ErrorAllowExplicitIndexProvider;
  }
});

/***/ }),
/* 2050 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.ErrorAllowExplicitIndexProvider = ErrorAllowExplicitIndexProvider;

var _lodash = __webpack_require__(1);

var _routes = __webpack_require__(29);

var _routes2 = _interopRequireDefault(_routes);

var _url = __webpack_require__(170);

__webpack_require__(2051);

var _error_allow_explicit_index = __webpack_require__(2052);

var _error_allow_explicit_index2 = _interopRequireDefault(_error_allow_explicit_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

_routes2.default.when('/error/multi.allow_explicit_index', { template: _error_allow_explicit_index2.default });

function ErrorAllowExplicitIndexProvider(Private, Promise) {
  var kbnUrl = Private(_url.KbnUrlProvider);

  return new (function () {
    function ErrorAllowExplicitIndex() {
      _classCallCheck(this, ErrorAllowExplicitIndex);
    }

    _createClass(ErrorAllowExplicitIndex, [{
      key: 'test',
      value: function test(error) {
        if (!error || error.status !== 400) {
          return false;
        }

        var type = (0, _lodash.get)(error, 'body.error.type');
        var reason = (0, _lodash.get)(error, 'body.error.reason');

        return type === 'illegal_argument_exception' && String(reason).includes('explicit index');
      }
    }, {
      key: 'takeover',
      value: function takeover() {
        kbnUrl.change('/error/multi.allow_explicit_index');
        return Promise.halt();
      }
    }]);

    return ErrorAllowExplicitIndex;
  }())();
}

/***/ }),
/* 2051 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 2052 */
/***/ (function(module, exports) {

module.exports = "<div class=\"app-container error-multi-allow-explicit-index\">\n  <h3>\n    <i aria-hidden=\"true\" class=\"fa fa-warning text-danger\"></i> Oh no!\n  </h3>\n  <p>\n    It looks like your Elasticsearch cluster has the <code>rest.action.multi.allow_explicit_index</code> setting set to <code>false</code>, which prevents Kibana from making search requests. We use this ability to send a single request to Elasticsearch that searches multiple indexes so that when there are many panels on a dashboard they will load quickly and uniformly.\n  </p>\n\n  <p>\n    Unfortunately, until this issue is fixed you won't be able to use certain apps in Kibana, like Discover, Visualize and Dashboard.\n  </p>\n\n  <h3>Ok, how do I fix this?</h3>\n  <ol>\n    <li>Remove <code>rest.action.multi.allow_explicit_index: false</code> from your Elasticsearch config file.</li>\n    <li>Restart Elasticsearch.</li>\n    <li>Use the browser's back button to return to what you were doing.</li>\n  </ol>\n</div>\n"

/***/ }),
/* 2053 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MergeDuplicatesRequestProvider = MergeDuplicatesRequestProvider;

var _is_request = __webpack_require__(765);

var _req_status = __webpack_require__(251);

function MergeDuplicatesRequestProvider(Private) {
  var isRequest = Private(_is_request.IsRequestProvider);
  var DUPLICATE = _req_status.RequestStatus.DUPLICATE;

  function mergeDuplicateRequests(requests) {
    // dedupe requests
    var index = {};
    return requests.map(function (req) {
      if (!isRequest(req)) return req;

      var iid = req.source._instanceid;
      if (!index[iid]) {
        // this request is unique so far
        index[iid] = req;
        // keep the request
        return req;
      }

      // the source was requested at least twice
      req._uniq = index[iid];
      return DUPLICATE;
    });
  }

  return mergeDuplicateRequests;
}

/***/ }),
/* 2054 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RequestFetchParamsToBodyProvider = RequestFetchParamsToBodyProvider;

var _request_fetch_params_to_body = __webpack_require__(2055);

function RequestFetchParamsToBodyProvider(Promise, timefilter, kbnIndex, sessionId) {
  return function (requestsFetchParams) {
    return (0, _request_fetch_params_to_body.requestFetchParamsToBody)(requestsFetchParams, Promise, timefilter, kbnIndex, sessionId);
  };
}

/***/ }),
/* 2055 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.requestFetchParamsToBody = requestFetchParamsToBody;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _aggressive_parse = __webpack_require__(768);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function emptySearch() {
  return {
    query: {
      bool: {
        must_not: [{ match_all: {} }]
      }
    }
  };
}

/**
 *
 * @param requestsFetchParams {Array.<Object>}
 * @param Promise
 * @param timeFilter - Only needed for time based interval indexes, which support has been removed from in 6.0. Come
 * 7.0 we can completely rip this code out and break them completely. See
 *   https://github.com/elastic/kibana/issues/12242 and
 *   https://github.com/elastic/kibana/pull/12158 for more background
 * @param kbnIndex
 * @param sessionId
 * @return {Promise.<string>}
 */
function requestFetchParamsToBody(requestsFetchParams, Promise, timeFilter, kbnIndex, sessionId) {
  var indexToListMapping = {};
  var timeBounds = timeFilter.getActiveBounds();
  var promises = requestsFetchParams.map(function (fetchParams) {
    return Promise.resolve(fetchParams.index).then(function (indexList) {
      if (!_lodash2.default.isFunction(_lodash2.default.get(indexList, 'toIndexList'))) {
        return indexList;
      }

      if (!indexToListMapping[indexList.id]) {
        indexToListMapping[indexList.id] = timeBounds ? indexList.toIndexList(timeBounds.min, timeBounds.max) : indexList.toIndexList();
      }
      return indexToListMapping[indexList.id].then(function (indexList) {
        // Make sure the index list in the cache can't be subsequently updated.
        return _lodash2.default.clone(indexList);
      });
    }).then(function (indexList) {
      var body = fetchParams.body || {};
      var index = [];
      // If we've reached this point and there are no indexes in the
      // index list at all, it means that we shouldn't expect any indexes
      // to contain the documents we're looking for, so we instead
      // perform a request for an index pattern that we know will always
      // return an empty result (ie. -*). If instead we had gone ahead
      // with an msearch without any index patterns, elasticsearch would
      // handle that request by querying *all* indexes, which is the
      // opposite of what we want in this case.
      if (Array.isArray(indexList) && indexList.length === 0) {
        index.push(kbnIndex);
        body = emptySearch();
      } else {
        index = indexList;
      }

      return JSON.stringify({
        index: index,
        type: fetchParams.type,
        search_type: fetchParams.search_type,
        ignore_unavailable: true,
        preference: sessionId
      }) + '\n' + (0, _aggressive_parse.toJson)(body, JSON.stringify);
    });
  });

  return Promise.all(promises).then(function (requests) {
    return requests.join('\n') + '\n';
  });
}

/***/ }),
/* 2056 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CallResponseHandlersProvider = CallResponseHandlersProvider;

var _errors = __webpack_require__(37);

var _req_status = __webpack_require__(251);

var _notifier = __webpack_require__(764);

function CallResponseHandlersProvider(Private, Promise) {
  var ABORTED = _req_status.RequestStatus.ABORTED;
  var INCOMPLETE = _req_status.RequestStatus.INCOMPLETE;

  function callResponseHandlers(requests, responses) {
    return Promise.map(requests, function (req, i) {
      if (req === ABORTED || req.aborted) {
        return ABORTED;
      }

      var resp = responses[i];

      if (resp.timed_out) {
        _notifier.courierNotifier.warning(new _errors.SearchTimeout());
      }

      if (resp._shards && resp._shards.failed) {
        _notifier.courierNotifier.warning(new _errors.ShardFailure(resp));
      }

      function progress() {
        if (req.isIncomplete()) {
          return INCOMPLETE;
        }

        req.complete();
        return resp;
      }

      if (resp.error) {
        if (req.filterError(resp)) {
          return progress();
        } else {
          return req.handleFailure(new _errors.RequestFailure(null, resp));
        }
      }

      return Promise.try(function () {
        return req.handleResponse(resp);
      }).then(progress);
    });
  }

  return callResponseHandlers;
}

/***/ }),
/* 2057 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ContinueIncompleteProvider = ContinueIncompleteProvider;

var _req_status = __webpack_require__(251);

function ContinueIncompleteProvider() {
  var INCOMPLETE = _req_status.RequestStatus.INCOMPLETE;

  function continueIncompleteRequests(requests, responses, fetchSearchResults) {
    var incomplete = [];

    responses.forEach(function (resp, i) {
      if (resp === INCOMPLETE) {
        incomplete.push(requests[i]);
      }
    });

    if (!incomplete.length) return responses;

    return fetchSearchResults(incomplete).then(function (completedResponses) {
      return responses.map(function (prevResponse) {
        if (prevResponse !== INCOMPLETE) return prevResponse;
        return completedResponses.shift();
      });
    });
  }

  return continueIncompleteRequests;
}

/***/ }),
/* 2058 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FieldWildcardProvider = FieldWildcardProvider;

var _lodash = __webpack_require__(1);

function FieldWildcardProvider(config) {
  var metaFields = config.get('metaFields');

  var makeRegEx = (0, _lodash.memoize)(function makeRegEx(glob) {
    return new RegExp('^' + glob.split('*').map(_lodash.escapeRegExp).join('.*') + '$');
  });

  function fieldWildcardMatcher(globs) {
    return function matcher(val) {
      // do not test metaFields or keyword
      if (metaFields.indexOf(val) !== -1) {
        return false;
      }
      return globs.some(function (p) {
        return makeRegEx(p).test(val);
      });
    };
  }

  function fieldWildcardFilter(globs) {
    var matcher = fieldWildcardMatcher(globs);
    return function filter(val) {
      return !matcher(val);
    };
  }

  return { makeRegEx: makeRegEx, fieldWildcardMatcher: fieldWildcardMatcher, fieldWildcardFilter: fieldWildcardFilter };
}

/***/ }),
/* 2059 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _highlight_html = __webpack_require__(468);

Object.defineProperty(exports, 'getHighlightHtml', {
  enumerable: true,
  get: function get() {
    return _highlight_html.getHighlightHtml;
  }
});

var _highlight_request = __webpack_require__(2060);

Object.defineProperty(exports, 'getHighlightRequest', {
  enumerable: true,
  get: function get() {
    return _highlight_request.getHighlightRequest;
  }
});

/***/ }),
/* 2060 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getHighlightRequest = getHighlightRequest;

var _highlight_tags = __webpack_require__(754);

var FRAGMENT_SIZE = Math.pow(2, 31) - 1; // Max allowed value for fragment_size (limit of a java int)

function getHighlightRequest(query, getConfig) {
  if (!getConfig('doc_table:highlight')) return;

  return {
    pre_tags: [_highlight_tags.highlightTags.pre],
    post_tags: [_highlight_tags.highlightTags.post],
    fields: {
      '*': {}
    },
    fragment_size: FRAGMENT_SIZE
  };
}

/***/ }),
/* 2061 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _build_es_query = __webpack_require__(2062);

Object.defineProperty(exports, 'BuildESQueryProvider', {
  enumerable: true,
  get: function get() {
    return _build_es_query.BuildESQueryProvider;
  }
});

/***/ }),
/* 2062 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BuildESQueryProvider = BuildESQueryProvider;

var _lodash = __webpack_require__(1);

var _decorate_query = __webpack_require__(769);

var _from_kuery = __webpack_require__(2063);

var _from_filters = __webpack_require__(773);

var _from_lucene = __webpack_require__(2094);

function BuildESQueryProvider(Private) {
  var decorateQuery = Private(_decorate_query.DecorateQueryProvider);

  /**
   *
   * @param queries - an array of query objects. Each query has a language property and a query property.
   * @param filters - an array of filter objects
   */
  function buildESQuery(indexPattern) {
    var queries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var filters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    var validQueries = queries.filter(function (query) {
      return (0, _lodash.has)(query, 'query');
    });
    var queriesByLanguage = (0, _lodash.groupBy)(validQueries, 'language');

    var kueryQuery = (0, _from_kuery.buildQueryFromKuery)(indexPattern, queriesByLanguage.kuery);
    var kqlQuery = (0, _from_kuery.buildQueryFromKql)(indexPattern, queriesByLanguage.kql);
    var luceneQuery = (0, _from_lucene.buildQueryFromLucene)(queriesByLanguage.lucene, decorateQuery);
    var filterQuery = (0, _from_filters.buildQueryFromFilters)(filters, decorateQuery, indexPattern);

    return {
      bool: {
        must: [].concat(kueryQuery.must, kqlQuery.must, luceneQuery.must, filterQuery.must),
        filter: [].concat(kueryQuery.filter, kqlQuery.filter, luceneQuery.filter, filterQuery.filter),
        should: [].concat(kueryQuery.should, kqlQuery.should, luceneQuery.should, filterQuery.should),
        must_not: [].concat(kueryQuery.must_not, kqlQuery.must_not, luceneQuery.must_not, filterQuery.must_not)
      }
    };
  }

  return buildESQuery;
}

/***/ }),
/* 2063 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.buildQueryFromKuery = buildQueryFromKuery;
exports.buildQueryFromKql = buildQueryFromKql;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _kuery = __webpack_require__(323);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function buildQueryFromKuery(indexPattern, queries) {
  var queryASTs = _lodash2.default.map(queries, function (query) {
    return (0, _kuery.fromKueryExpression)(query.query);
  });
  return buildQuery(indexPattern, queryASTs);
}

function buildQueryFromKql(indexPattern, queries) {
  var queryASTs = _lodash2.default.map(queries, function (query) {
    return (0, _kuery.fromKqlExpression)(query.query);
  });
  return buildQuery(indexPattern, queryASTs);
}

function buildQuery(indexPattern, queryASTs) {
  var compoundQueryAST = _kuery.nodeTypes.function.buildNode('and', queryASTs);
  var kueryQuery = (0, _kuery.toElasticsearchQuery)(compoundQueryAST, indexPattern);
  return _extends({
    must: [],
    filter: [],
    should: [],
    must_not: []
  }, kueryQuery.bool);
}

/***/ }),
/* 2064 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.fromKueryExpression = fromKueryExpression;
exports.fromKqlExpression = fromKqlExpression;
exports.toKueryExpression = toKueryExpression;
exports.toElasticsearchQuery = toElasticsearchQuery;

var _kuery = __webpack_require__(2065);

var _kuery2 = _interopRequireDefault(_kuery);

var _kql = __webpack_require__(2066);

var _kql2 = _interopRequireDefault(_kql);

var _pegjs = __webpack_require__(770);

var _pegjs2 = _interopRequireDefault(_pegjs);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _index = __webpack_require__(52);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var kueryParser = _pegjs2.default.buildParser(_kuery2.default);
var kqlParser = _pegjs2.default.buildParser(_kql2.default);

function fromKueryExpression(expression, parseOptions) {
  return fromExpression(expression, parseOptions, kueryParser);
}

function fromKqlExpression(expression, parseOptions) {
  return fromExpression(expression, parseOptions, kqlParser);
}

function fromExpression(expression) {
  var parseOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var parser = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : kqlParser;

  if (_lodash2.default.isUndefined(expression)) {
    throw new Error('expression must be a string, got undefined instead');
  }

  parseOptions = _extends({}, parseOptions, {
    helpers: { nodeTypes: _index.nodeTypes }
  });

  return parser.parse(expression, parseOptions);
}

function toKueryExpression(node) {
  if (!node || !node.type || !_index.nodeTypes[node.type]) {
    return '';
  }

  return _index.nodeTypes[node.type].toKueryExpression(node);
}

function toElasticsearchQuery(node, indexPattern) {
  if (!node || !node.type || !_index.nodeTypes[node.type]) {
    return toElasticsearchQuery(_index.nodeTypes.function.buildNode('and', []));
  }

  return _index.nodeTypes[node.type].toElasticsearchQuery(node, indexPattern);
}

/***/ }),
/* 2065 */
/***/ (function(module, exports) {

module.exports = "/*\n * Kuery parser\n */\n\n/*\n * Initialization block\n */\n{\n  var nodeTypes = options.helpers.nodeTypes;\n\n  if (options.includeMetadata === undefined) {\n    options.includeMetadata = true;\n  }\n\n  function addMeta(source, text, location) {\n    if (options.includeMetadata) {\n      return Object.assign(\n        {},\n        source,\n        {\n          text: text,\n          location: simpleLocation(location),\n        }\n      );\n    }\n\n    return source;\n  }\n\n  function simpleLocation(location) {\n    // Returns an object representing the position of the function within the expression,\n    // demarcated by the position of its first character and last character. We calculate these values\n    // using the offset because the expression could span multiple lines, and we don't want to deal\n    // with column and line values.\n    return {\n      min: location.start.offset,\n      max: location.end.offset\n    }\n  }\n}\n\nstart\n  = space? query:OrQuery space? {\n    if (query.type === 'literal') {\n      return addMeta(nodeTypes.function.buildNode('and', [query], 'implicit'), text(), location());\n    }\n    return query;\n  }\n  / whitespace:[\\ \\t\\r\\n]* {\n    return addMeta(nodeTypes.function.buildNode('is', '*', '*'), text(), location());\n  }\n\nOrQuery\n  = left:AndQuery space 'or'i space right:OrQuery {\n    return addMeta(nodeTypes.function.buildNode('or', [left, right], 'operator'), text(), location());\n  }\n  / AndQuery\n\nAndQuery\n  = left:NegatedClause space 'and'i space right:AndQuery {\n    return addMeta(nodeTypes.function.buildNode('and', [left, right], 'operator'), text(), location());\n  }\n  / left:NegatedClause space !'or'i right:AndQuery {\n    return addMeta(nodeTypes.function.buildNode('and', [left, right], 'implicit'), text(), location());\n  }\n  / NegatedClause\n\nNegatedClause\n  = [!] clause:Clause {\n    return addMeta(nodeTypes.function.buildNode('not', clause, 'operator'), text(), location());\n  }\n  / Clause\n\nClause\n  = '(' subQuery:start ')' {\n    return subQuery;\n  }\n  / Term\n\nTerm\n  = field:literal_arg_type ':' value:literal_arg_type {\n    return addMeta(nodeTypes.function.buildNodeWithArgumentNodes('is', [field, value], 'operator'), text(), location());\n  }\n  / field:literal_arg_type ':[' space? gt:literal_arg_type space 'to'i space lt:literal_arg_type space? ']' {\n    return addMeta(nodeTypes.function.buildNodeWithArgumentNodes('range', [field, gt, lt], 'operator'), text(), location());\n  }\n  / function\n  / !Keywords literal:literal_arg_type { return literal; }\n\nfunction_name\n = first:[a-zA-Z]+ rest:[.a-zA-Z0-9_-]* { return first.join('') + rest.join('') }\n\nfunction \"function\"\n = name:function_name space? '(' space? arg_list:arg_list? space? ')' {\n  return addMeta(nodeTypes.function.buildNodeWithArgumentNodes(name, arg_list || [], 'function'), text(), location());\n }\n\narg_list\n = first:argument rest:(space? ',' space? arg:argument {return arg})* space? ','? {\n  return [first].concat(rest);\n }\n\nargument\n = name:function_name space? '=' space? value:arg_type {\n  return addMeta(nodeTypes.namedArg.buildNode(name, value), text(), location());\n }\n / element:arg_type {return element}\n\narg_type\n = OrQuery\n / literal_arg_type\n\nliteral_arg_type\n = literal:literal {\n  var result = addMeta(nodeTypes.literal.buildNode(literal), text(), location());\n  return result;\n }\n\nKeywords\n  = 'and'i / 'or'i\n\n /* ----- Core types ----- */\n\nliteral \"literal\"\n  =  '\"' chars:dq_char* '\"' { return chars.join(''); } // double quoted string\n  / \"'\" chars:sq_char* \"'\" { return chars.join(''); } // single quoted string\n  / 'true'  { return true; } // unquoted literals from here down\n  / 'false' { return false; }\n  / 'null'  { return null; }\n  / string:[^\\[\\]()\"',:=\\ \\t]+ { // this also matches numbers via Number()\n   var result = string.join('');\n   // Sort of hacky, but PEG doesn't have backtracking so\n   // a number rule is hard to read, and performs worse\n   if (isNaN(Number(result))) return result;\n   return Number(result)\n  }\n\nspace\n = [\\ \\t\\r\\n]+\n\ndq_char\n  = \"\\\\\" sequence:('\"' / \"\\\\\") { return sequence; }\n  / [^\"] // everything except \"\n\nsq_char\n  = \"\\\\\" sequence:(\"'\" / \"\\\\\") { return sequence; }\n  / [^'] // everything except '\n\ninteger\n = digits:[0-9]+ {return parseInt(digits.join(''))}\n"

/***/ }),
/* 2066 */
/***/ (function(module, exports) {

module.exports = "/*\n * Kuery parser\n */\n\n/*\n * Initialization block\n */\n{\n  var nodeTypes = options.helpers.nodeTypes;\n\n  if (options.includeMetadata === undefined) {\n    options.includeMetadata = true;\n  }\n\n  function addMeta(source, text, location) {\n    if (options.includeMetadata) {\n      return Object.assign(\n        {},\n        source,\n        {\n          text: text,\n          location: simpleLocation(location),\n        }\n      );\n    }\n\n    return source;\n  }\n\n  function simpleLocation(location) {\n    // Returns an object representing the position of the function within the expression,\n    // demarcated by the position of its first character and last character. We calculate these values\n    // using the offset because the expression could span multiple lines, and we don't want to deal\n    // with column and line values.\n    return {\n      min: location.start.offset,\n      max: location.end.offset\n    }\n  }\n}\n\nstart\n  = Query\n  / space* {\n    return addMeta(nodeTypes.function.buildNode('and', []), text(), location());\n  }\n\nQuery\n  = space? query:OrQuery space? {\n    if (query.type === 'literal') {\n      return addMeta(nodeTypes.function.buildNode('and', [query]), text(), location());\n    }\n    return query;\n  }\n\nOrQuery\n  = left:AndQuery space 'or'i space right:OrQuery {\n    return addMeta(nodeTypes.function.buildNode('or', [left, right]), text(), location());\n  }\n  / AndQuery\n\nAndQuery\n  = left:NotQuery space 'and'i space right:AndQuery {\n    return addMeta(nodeTypes.function.buildNode('and', [left, right]), text(), location());\n  }\n  / NotQuery\n\nNotQuery\n  = 'not'i space clause:Clause {\n    return addMeta(nodeTypes.function.buildNode('not', clause), text(), location());\n  }\n  / Clause\n\nClause\n  = '(' subQuery:Query ')' {\n    return subQuery;\n  }\n  / Term\n\nTerm\n  = field:literal_arg_type space? ':' space? value:literal_arg_type {\n    return addMeta(nodeTypes.function.buildNodeWithArgumentNodes('is', [field, value]), text(), location());\n  }\n  / field:literal_arg_type space? ':' space? '[' space? gt:literal_arg_type space 'to'i space lt:literal_arg_type space? ']' {\n    return addMeta(nodeTypes.function.buildNodeWithArgumentNodes('range', [field, gt, lt]), text(), location());\n  }\n  / !Keywords literal:literal_arg_type { return literal; }\n\nliteral_arg_type\n = literal:literal {\n   var result = addMeta(nodeTypes.literal.buildNode(literal), text(), location());\n   return result;\n }\n\nKeywords\n  = 'or'i / 'and'i / 'not'i\n\n /* ----- Core types ----- */\n\nliteral \"literal\"\n  =  '\"' chars:dq_char* '\"' { return chars.join(''); } // double quoted string\n  / \"'\" chars:sq_char* \"'\" { return chars.join(''); } // single quoted string\n  / 'true'  { return true; } // unquoted literals from here down\n  / 'false' { return false; }\n  / 'null'  { return null; }\n  / string:[^\\[\\]()\"',:=\\ \\t]+ { // this also matches numbers via Number()\n   var result = string.join('');\n   // Sort of hacky, but PEG doesn't have backtracking so\n   // a number rule is hard to read, and performs worse\n   if (isNaN(Number(result))) return result;\n   return Number(result)\n  }\n\nspace\n = [\\ \\t\\r\\n]+\n\ndq_char\n  = \"\\\\\" sequence:('\"' / \"\\\\\") { return sequence; }\n  / [^\"] // everything except \"\n\nsq_char\n  = \"\\\\\" sequence:(\"'\" / \"\\\\\") { return sequence; }\n  / [^'] // everything except '\n"

/***/ }),
/* 2067 */,
/* 2068 */,
/* 2069 */,
/* 2070 */,
/* 2071 */,
/* 2072 */,
/* 2073 */,
/* 2074 */,
/* 2075 */,
/* 2076 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.buildNode = buildNode;
exports.buildNodeWithArgumentNodes = buildNodeWithArgumentNodes;
exports.toElasticsearchQuery = toElasticsearchQuery;
exports.toKueryExpression = toKueryExpression;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _functions = __webpack_require__(2077);

var _node_types = __webpack_require__(52);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function buildNode(functionName) {
  var kueryFunction = _functions.functions[functionName];

  if (_lodash2.default.isUndefined(kueryFunction)) {
    throw new Error('Unknown function "' + functionName + '"');
  }

  for (var _len = arguments.length, functionArgs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    functionArgs[_key - 1] = arguments[_key];
  }

  return _extends({
    type: 'function',
    function: functionName
  }, kueryFunction.buildNodeParams.apply(kueryFunction, functionArgs));
}

// Mainly only useful in the grammar where we'll already have real argument nodes in hand
function buildNodeWithArgumentNodes(functionName, argumentNodes) {
  var serializeStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'function';

  if (_lodash2.default.isUndefined(_functions.functions[functionName])) {
    throw new Error('Unknown function "' + functionName + '"');
  }

  return {
    type: 'function',
    function: functionName,
    arguments: argumentNodes,
    serializeStyle: serializeStyle
  };
}

function toElasticsearchQuery(node, indexPattern) {
  var kueryFunction = _functions.functions[node.function];
  return kueryFunction.toElasticsearchQuery(node, indexPattern);
}

function toKueryExpression(node) {
  var kueryFunction = _functions.functions[node.function];

  if (!_lodash2.default.isUndefined(node.text)) {
    return node.text;
  }

  if (node.serializeStyle && node.serializeStyle !== 'function') {
    return kueryFunction.toKueryExpression(node);
  }

  var functionArguments = (node.arguments || []).map(function (argument) {
    return _node_types.nodeTypes[argument.type].toKueryExpression(argument);
  });

  return node.function + '(' + functionArguments.join(', ') + ')';
}

/***/ }),
/* 2077 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.functions = undefined;

var _is = __webpack_require__(2078);

var is = _interopRequireWildcard(_is);

var _and = __webpack_require__(2079);

var and = _interopRequireWildcard(_and);

var _or = __webpack_require__(2080);

var or = _interopRequireWildcard(_or);

var _not = __webpack_require__(2081);

var not = _interopRequireWildcard(_not);

var _range = __webpack_require__(2082);

var range = _interopRequireWildcard(_range);

var _exists = __webpack_require__(2083);

var exists = _interopRequireWildcard(_exists);

var _geo_bounding_box = __webpack_require__(2084);

var geoBoundingBox = _interopRequireWildcard(_geo_bounding_box);

var _geo_polygon = __webpack_require__(2085);

var geoPolygon = _interopRequireWildcard(_geo_polygon);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var functions = exports.functions = {
  is: is,
  and: and,
  or: or,
  not: not,
  range: range,
  exists: exists,
  geoBoundingBox: geoBoundingBox,
  geoPolygon: geoPolygon
};

/***/ }),
/* 2078 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.buildNodeParams = buildNodeParams;
exports.toElasticsearchQuery = toElasticsearchQuery;
exports.toKueryExpression = toKueryExpression;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _literal = __webpack_require__(473);

var literal = _interopRequireWildcard(_literal);

var _phrase = __webpack_require__(175);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function buildNodeParams(fieldName, value) {
  var serializeStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'operator';

  if (_lodash2.default.isUndefined(fieldName)) {
    throw new Error('fieldName is a required argument');
  }
  if (_lodash2.default.isUndefined(value)) {
    throw new Error('value is a required argument');
  }

  return {
    arguments: [literal.buildNode(fieldName), literal.buildNode(value)],
    serializeStyle: serializeStyle
  };
}

function toElasticsearchQuery(node, indexPattern) {
  var _node$arguments = _slicedToArray(node.arguments, 2),
      fieldNameArg = _node$arguments[0],
      valueArg = _node$arguments[1];

  var fieldName = literal.toElasticsearchQuery(fieldNameArg);
  var field = indexPattern.fields.byName[fieldName];
  var value = !_lodash2.default.isUndefined(valueArg) ? literal.toElasticsearchQuery(valueArg) : valueArg;

  if (field && field.scripted) {
    return {
      script: _extends({}, (0, _phrase.getPhraseScript)(field, value))
    };
  } else if (fieldName === null) {
    return {
      multi_match: {
        query: value,
        type: 'phrase',
        lenient: true
      }
    };
  } else if (fieldName === '*' && value === '*') {
    return { match_all: {} };
  } else if (fieldName === '*' && value !== '*') {
    return {
      multi_match: {
        query: value,
        fields: ['*'],
        type: 'phrase',
        lenient: true
      }
    };
  } else if (fieldName !== '*' && value === '*') {
    return {
      exists: { field: fieldName }
    };
  } else {
    return {
      match_phrase: _defineProperty({}, fieldName, value)
    };
  }
}

function toKueryExpression(node) {
  if (node.serializeStyle !== 'operator') {
    throw new Error('Cannot serialize "is" function as "' + node.serializeStyle + '"');
  }

  var _node$arguments2 = _slicedToArray(node.arguments, 2),
      fieldNameArg = _node$arguments2[0],
      valueArg = _node$arguments2[1];

  var fieldName = literal.toKueryExpression(fieldNameArg);
  var value = !_lodash2.default.isUndefined(valueArg) ? literal.toKueryExpression(valueArg) : valueArg;

  return fieldName + ':' + value;
}

/***/ }),
/* 2079 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildNodeParams = buildNodeParams;
exports.toElasticsearchQuery = toElasticsearchQuery;
exports.toKueryExpression = toKueryExpression;

var _ast = __webpack_require__(136);

var ast = _interopRequireWildcard(_ast);

var _node_types = __webpack_require__(52);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function buildNodeParams(children) {
  var serializeStyle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'operator';

  return {
    arguments: children,
    serializeStyle: serializeStyle
  };
}

function toElasticsearchQuery(node, indexPattern) {
  var children = node.arguments || [];

  return {
    bool: {
      filter: children.map(function (child) {
        if (child.type === 'literal') {
          child = _node_types.nodeTypes.function.buildNode('is', null, child.value);
        }

        return ast.toElasticsearchQuery(child, indexPattern);
      })
    }
  };
}

function toKueryExpression(node) {
  if (!['operator', 'implicit'].includes(node.serializeStyle)) {
    throw new Error('Cannot serialize "and" function as "' + node.serializeStyle + '"');
  }

  var queryStrings = (node.arguments || []).map(function (arg) {
    var query = ast.toKueryExpression(arg);
    if (arg.type === 'function' && arg.function === 'or') {
      return '(' + query + ')';
    }
    return query;
  });

  if (node.serializeStyle === 'implicit') {
    return queryStrings.join(' ');
  }
  if (node.serializeStyle === 'operator') {
    return queryStrings.join(' and ');
  }
}

/***/ }),
/* 2080 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildNodeParams = buildNodeParams;
exports.toElasticsearchQuery = toElasticsearchQuery;
exports.toKueryExpression = toKueryExpression;

var _ast = __webpack_require__(136);

var ast = _interopRequireWildcard(_ast);

var _node_types = __webpack_require__(52);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function buildNodeParams(children) {
  var serializeStyle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'operator';

  return {
    arguments: children,
    serializeStyle: serializeStyle
  };
}

function toElasticsearchQuery(node, indexPattern) {
  var children = node.arguments || [];

  return {
    bool: {
      should: children.map(function (child) {
        if (child.type === 'literal') {
          child = _node_types.nodeTypes.function.buildNode('is', null, child.value);
        }

        return ast.toElasticsearchQuery(child, indexPattern);
      }),
      minimum_should_match: 1
    }
  };
}

function toKueryExpression(node) {
  if (node.serializeStyle !== 'operator') {
    throw new Error('Cannot serialize "or" function as "' + node.serializeStyle + '"');
  }

  var queryStrings = (node.arguments || []).map(function (arg) {
    return ast.toKueryExpression(arg);
  });

  return queryStrings.join(' or ');
}

/***/ }),
/* 2081 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.buildNodeParams = buildNodeParams;
exports.toElasticsearchQuery = toElasticsearchQuery;
exports.toKueryExpression = toKueryExpression;

var _ast = __webpack_require__(136);

var ast = _interopRequireWildcard(_ast);

var _node_types = __webpack_require__(52);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function buildNodeParams(child) {
  var serializeStyle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'operator';

  return {
    arguments: [child],
    serializeStyle: serializeStyle
  };
}

function toElasticsearchQuery(node, indexPattern) {
  var _node$arguments = _slicedToArray(node.arguments, 1),
      argument = _node$arguments[0];

  if (argument.type === 'literal') {
    argument = _node_types.nodeTypes.function.buildNode('is', null, argument.value);
  }

  return {
    bool: {
      must_not: ast.toElasticsearchQuery(argument, indexPattern)
    }
  };
}

function toKueryExpression(node) {
  if (node.serializeStyle !== 'operator') {
    throw new Error('Cannot serialize "not" function as "' + node.serializeStyle + '"');
  }

  var _node$arguments2 = _slicedToArray(node.arguments, 1),
      argument = _node$arguments2[0];

  var queryString = ast.toKueryExpression(argument);

  if (argument.function && (argument.function === 'and' || argument.function === 'or') && argument.serializeStyle !== 'function') {
    return '!(' + queryString + ')';
  } else {
    return '!' + queryString;
  }
}

/***/ }),
/* 2082 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.buildNodeParams = buildNodeParams;
exports.toElasticsearchQuery = toElasticsearchQuery;
exports.toKueryExpression = toKueryExpression;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _node_types = __webpack_require__(52);

var _ast = __webpack_require__(136);

var ast = _interopRequireWildcard(_ast);

var _range2 = __webpack_require__(117);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function buildNodeParams(fieldName, params) {
  var serializeStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'operator';

  params = _lodash2.default.pick(params, 'gt', 'lt', 'gte', 'lte', 'format');
  var fieldNameArg = _node_types.nodeTypes.literal.buildNode(fieldName);
  var args = _lodash2.default.map(params, function (value, key) {
    return _node_types.nodeTypes.namedArg.buildNode(key, value);
  });

  // we only support inclusive ranges in the operator syntax currently
  if (_lodash2.default.has(params, 'gt') || _lodash2.default.has(params, 'lt')) {
    serializeStyle = 'function';
  }

  return {
    arguments: [fieldNameArg].concat(_toConsumableArray(args)),
    serializeStyle: serializeStyle
  };
}

function toElasticsearchQuery(node, indexPattern) {
  var _node$arguments = _toArray(node.arguments),
      fieldNameArg = _node$arguments[0],
      args = _node$arguments.slice(1);

  var fieldName = _node_types.nodeTypes.literal.toElasticsearchQuery(fieldNameArg);
  var field = indexPattern.fields.byName[fieldName];
  var namedArgs = extractArguments(args);
  var queryParams = _lodash2.default.mapValues(namedArgs, ast.toElasticsearchQuery);

  if (field && field.scripted) {
    return {
      script: _extends({}, (0, _range2.getRangeScript)(field, queryParams))
    };
  }

  return {
    range: _defineProperty({}, fieldName, queryParams)
  };
}

function toKueryExpression(node) {
  if (node.serializeStyle !== 'operator') {
    throw new Error('Cannot serialize "range" function as "' + node.serializeStyle + '"');
  }

  var _node$arguments2 = _toArray(node.arguments),
      fieldNameArg = _node$arguments2[0],
      args = _node$arguments2.slice(1);

  var fieldName = ast.toKueryExpression(fieldNameArg);

  var _extractArguments = extractArguments(args),
      gte = _extractArguments.gte,
      lte = _extractArguments.lte;

  if (_lodash2.default.isUndefined(gte) || _lodash2.default.isUndefined(lte)) {
    throw new Error('Operator syntax only supports inclusive ranges');
  }

  return fieldName + ':[' + ast.toKueryExpression(gte) + ' to ' + ast.toKueryExpression(lte) + ']';
}

function extractArguments(args) {
  if (args.gt && args.gte || args.lt && args.lte) {
    throw new Error('range ends cannot be both inclusive and exclusive');
  }

  var unnamedArgOrder = ['gte', 'lte', 'format'];

  return args.reduce(function (acc, arg, index) {
    if (arg.type === 'namedArg') {
      acc[arg.name] = arg.value;
    } else {
      acc[unnamedArgOrder[index]] = arg;
    }

    return acc;
  }, {});
}

/***/ }),
/* 2083 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.buildNodeParams = buildNodeParams;
exports.toElasticsearchQuery = toElasticsearchQuery;

var _literal = __webpack_require__(473);

var literal = _interopRequireWildcard(_literal);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function buildNodeParams(fieldName) {
  return {
    arguments: [literal.buildNode(fieldName)]
  };
}

function toElasticsearchQuery(node, indexPattern) {
  var _node$arguments = _slicedToArray(node.arguments, 1),
      fieldNameArg = _node$arguments[0];

  var fieldName = literal.toElasticsearchQuery(fieldNameArg);
  var field = indexPattern.fields.byName[fieldName];

  if (field && field.scripted) {
    throw new Error('Exists query does not support scripted fields');
  }
  return {
    exists: { field: fieldName }
  };
}

/***/ }),
/* 2084 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.buildNodeParams = buildNodeParams;
exports.toElasticsearchQuery = toElasticsearchQuery;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _node_types = __webpack_require__(52);

var _ast = __webpack_require__(136);

var ast = _interopRequireWildcard(_ast);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function buildNodeParams(fieldName, params) {
  params = _lodash2.default.pick(params, 'topLeft', 'bottomRight');
  var fieldNameArg = _node_types.nodeTypes.literal.buildNode(fieldName);
  var args = _lodash2.default.map(params, function (value, key) {
    var latLon = value.lat + ', ' + value.lon;
    return _node_types.nodeTypes.namedArg.buildNode(key, latLon);
  });

  return {
    arguments: [fieldNameArg].concat(_toConsumableArray(args))
  };
}

function toElasticsearchQuery(node, indexPattern) {
  var _geo_bounding_box;

  var _node$arguments = _toArray(node.arguments),
      fieldNameArg = _node$arguments[0],
      args = _node$arguments.slice(1);

  var fieldName = _node_types.nodeTypes.literal.toElasticsearchQuery(fieldNameArg);
  var field = indexPattern.fields.byName[fieldName];
  var queryParams = args.reduce(function (acc, arg) {
    var snakeArgName = _lodash2.default.snakeCase(arg.name);
    return _extends({}, acc, _defineProperty({}, snakeArgName, ast.toElasticsearchQuery(arg)));
  }, {});

  if (field && field.scripted) {
    throw new Error('Geo bounding box query does not support scripted fields');
  }

  return {
    geo_bounding_box: (_geo_bounding_box = {}, _defineProperty(_geo_bounding_box, fieldName, queryParams), _defineProperty(_geo_bounding_box, 'ignore_unmapped', true), _geo_bounding_box)
  };
}

/***/ }),
/* 2085 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildNodeParams = buildNodeParams;
exports.toElasticsearchQuery = toElasticsearchQuery;

var _node_types = __webpack_require__(52);

var _ast = __webpack_require__(136);

var ast = _interopRequireWildcard(_ast);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function buildNodeParams(fieldName, points) {
  var fieldNameArg = _node_types.nodeTypes.literal.buildNode(fieldName);
  var args = points.map(function (point) {
    var latLon = point.lat + ', ' + point.lon;
    return _node_types.nodeTypes.literal.buildNode(latLon);
  });

  return {
    arguments: [fieldNameArg].concat(_toConsumableArray(args))
  };
}

function toElasticsearchQuery(node, indexPattern) {
  var _geo_polygon;

  var _node$arguments = _toArray(node.arguments),
      fieldNameArg = _node$arguments[0],
      points = _node$arguments.slice(1);

  var fieldName = _node_types.nodeTypes.literal.toElasticsearchQuery(fieldNameArg);
  var field = indexPattern.fields.byName[fieldName];
  var queryParams = {
    points: points.map(ast.toElasticsearchQuery)
  };

  if (field && field.scripted) {
    throw new Error('Geo polygon query does not support scripted fields');
  }

  return {
    geo_polygon: (_geo_polygon = {}, _defineProperty(_geo_polygon, fieldName, queryParams), _defineProperty(_geo_polygon, 'ignore_unmapped', true), _geo_polygon)
  };
}

/***/ }),
/* 2086 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildNode = buildNode;
exports.toElasticsearchQuery = toElasticsearchQuery;
exports.toKueryExpression = toKueryExpression;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _ast = __webpack_require__(136);

var ast = _interopRequireWildcard(_ast);

var _node_types = __webpack_require__(52);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function buildNode(name, value) {
  var argumentNode = _lodash2.default.get(value, 'type') === 'literal' ? value : _node_types.nodeTypes.literal.buildNode(value);
  return {
    type: 'namedArg',
    name: name,
    value: argumentNode
  };
}

function toElasticsearchQuery(node) {
  return ast.toElasticsearchQuery(node.value);
}

function toKueryExpression(node) {
  return node.name + '=' + ast.toKueryExpression(node.value);
}

/***/ }),
/* 2087 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _filter_to_kuery = __webpack_require__(2088);

Object.defineProperty(exports, 'filterToKueryAST', {
  enumerable: true,
  get: function get() {
    return _filter_to_kuery.filterToKueryAST;
  }
});

/***/ }),
/* 2088 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.filterToKueryAST = filterToKueryAST;

var _node_types = __webpack_require__(52);

var _phrase = __webpack_require__(2089);

var _range = __webpack_require__(2090);

var _exists = __webpack_require__(2091);

var _geo_bounding_box = __webpack_require__(2092);

var _geo_polygon = __webpack_require__(2093);

var conversionChain = [_phrase.convertPhraseFilter, _range.convertRangeFilter, _exists.convertExistsFilter, _geo_bounding_box.convertGeoBoundingBox, _geo_polygon.convertGeoPolygon];

function filterToKueryAST(filter) {
  var negate = filter.meta.negate;


  var node = conversionChain.reduce(function (acc, converter) {
    if (acc !== null) return acc;

    try {
      return converter(filter);
    } catch (ex) {
      return null;
    }
  }, null);

  if (!node) {
    throw new Error('Couldn\'t convert that filter to a kuery');
  }

  return negate ? _node_types.nodeTypes.function.buildNode('not', node) : node;
}

/***/ }),
/* 2089 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertPhraseFilter = convertPhraseFilter;

var _node_types = __webpack_require__(52);

function convertPhraseFilter(filter) {
  if (filter.meta.type !== 'phrase') {
    throw new Error('Expected filter of type "phrase", got "' + filter.meta.type + '"');
  }

  var _filter$meta = filter.meta,
      key = _filter$meta.key,
      params = _filter$meta.params;

  return _node_types.nodeTypes.function.buildNode('is', key, params.query);
}

/***/ }),
/* 2090 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertRangeFilter = convertRangeFilter;

var _node_types = __webpack_require__(52);

function convertRangeFilter(filter) {
  if (filter.meta.type !== 'range') {
    throw new Error('Expected filter of type "range", got "' + filter.meta.type + '"');
  }

  var _filter$meta = filter.meta,
      key = _filter$meta.key,
      params = _filter$meta.params;

  return _node_types.nodeTypes.function.buildNode('range', key, params);
}

/***/ }),
/* 2091 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertExistsFilter = convertExistsFilter;

var _node_types = __webpack_require__(52);

function convertExistsFilter(filter) {
  if (filter.meta.type !== 'exists') {
    throw new Error('Expected filter of type "exists", got "' + filter.meta.type + '"');
  }

  var key = filter.meta.key;

  return _node_types.nodeTypes.function.buildNode('exists', key);
}

/***/ }),
/* 2092 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertGeoBoundingBox = convertGeoBoundingBox;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _node_types = __webpack_require__(52);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function convertGeoBoundingBox(filter) {
  if (filter.meta.type !== 'geo_bounding_box') {
    throw new Error('Expected filter of type "geo_bounding_box", got "' + filter.meta.type + '"');
  }

  var _filter$meta = filter.meta,
      key = _filter$meta.key,
      params = _filter$meta.params;

  var camelParams = _lodash2.default.mapKeys(params, function (value, key) {
    return _lodash2.default.camelCase(key);
  });
  return _node_types.nodeTypes.function.buildNode('geoBoundingBox', key, camelParams);
}

/***/ }),
/* 2093 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertGeoPolygon = convertGeoPolygon;

var _node_types = __webpack_require__(52);

function convertGeoPolygon(filter) {
  if (filter.meta.type !== 'geo_polygon') {
    throw new Error('Expected filter of type "geo_polygon", got "' + filter.meta.type + '"');
  }

  var _filter$meta = filter.meta,
      key = _filter$meta.key,
      points = _filter$meta.params.points;

  return _node_types.nodeTypes.function.buildNode('geoPolygon', key, points);
}

/***/ }),
/* 2094 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildQueryFromLucene = buildQueryFromLucene;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _lucene_string_to_dsl = __webpack_require__(474);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function buildQueryFromLucene(queries, decorateQuery) {
  var combinedQueries = _lodash2.default.map(queries, function (query) {
    var queryDsl = (0, _lucene_string_to_dsl.luceneStringToDsl)(query.query);
    return decorateQuery(queryDsl);
  });

  return {
    must: [].concat(combinedQueries),
    filter: [],
    should: [],
    must_not: []
  };
}

/***/ }),
/* 2095 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

exports.SegmentedRequestProvider = SegmentedRequestProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _notifier = __webpack_require__(43);

var _search_request = __webpack_require__(767);

var _segmented_handle = __webpack_require__(2096);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function SegmentedRequestProvider(Private, timefilter, config) {
  var SearchRequest = Private(_search_request.SearchRequestProvider);
  var SegmentedHandle = Private(_segmented_handle.SegmentedHandleProvider);

  var notify = new _notifier.Notifier({
    location: 'Segmented Fetch'
  });

  var SegmentedReq = function (_SearchRequest) {
    _inherits(SegmentedReq, _SearchRequest);

    function SegmentedReq(source, defer, initFn) {
      _classCallCheck(this, SegmentedReq);

      var _this = _possibleConstructorReturn(this, (SegmentedReq.__proto__ || Object.getPrototypeOf(SegmentedReq)).call(this, source, defer));

      _this.type = 'segmented';

      // segmented request specific state
      _this._initFn = initFn;

      _this._desiredSize = null;
      _this._maxSegments = config.get('courier:maxSegmentCount');
      _this._direction = 'desc';
      _this._sortFn = null;
      _this._queueCreated = false;
      _this._handle = new SegmentedHandle(_this);

      _this._hitWindow = null;

      // prevent the source from changing between requests,
      // all calls will return the same promise
      _this._getFlattenedSource = _lodash2.default.once(_this._getFlattenedSource);
      return _this;
    }

    /*********
    ** SearchReq overrides
    *********/

    _createClass(SegmentedReq, [{
      key: 'start',
      value: function start() {
        var _this2 = this;

        return _get(SegmentedReq.prototype.__proto__ || Object.getPrototypeOf(SegmentedReq.prototype), 'start', this).call(this).then(function () {
          _this2._complete = [];
          _this2._active = null;
          _this2._segments = [];
          _this2._all = [];
          _this2._queue = [];

          _this2._mergedResp = {
            took: 0,
            hits: {
              hits: [],
              total: 0,
              max_score: 0
            }
          };

          // give the request consumer a chance to receive each segment and set
          // parameters via the handle
          if (_lodash2.default.isFunction(_this2._initFn)) _this2._initFn(_this2._handle);
          return _this2._createQueue();
        }).then(function (queue) {
          if (_this2.stopped) return;

          _this2._all = queue.slice(0);

          // Send the initial fetch status
          return _this2._reportStatus();
        });
      }
    }, {
      key: 'continue',
      value: function _continue() {
        return this._reportStatus();
      }
    }, {
      key: 'getFetchParams',
      value: function getFetchParams() {
        var _this3 = this;

        return this._getFlattenedSource().then(function (flatSource) {
          var params = _lodash2.default.cloneDeep(flatSource);

          // calculate the number of indices to fetch in this request in order to prevent
          // more than this._maxSegments requests. We use Math.max(1, n) to ensure that each request
          // has at least one index pattern, and Math.floor() to make sure that if the
          // number of indices does not round out evenly the extra index is tacked onto the last
          // request, making sure the first request returns faster.
          var remainingSegments = _this3._maxSegments - _this3._segments.length;
          var indexCount = Math.max(1, Math.floor(_this3._queue.length / remainingSegments));

          var indices = _this3._active = _this3._queue.splice(0, indexCount);
          params.index = _lodash2.default.pluck(indices, 'index');

          if (_lodash2.default.isNumber(_this3._desiredSize)) {
            params.body.size = _this3._pickSizeForIndices(indices);
          }

          return params;
        });
      }
    }, {
      key: 'handleResponse',
      value: function handleResponse(resp) {
        return this._consumeSegment(resp);
      }
    }, {
      key: 'filterError',
      value: function filterError(resp) {
        if (/ClusterBlockException.*index\sclosed/.test(resp.error)) {
          this._consumeSegment(false);
          return true;
        }
      }
    }, {
      key: 'isIncomplete',
      value: function isIncomplete() {
        var queueNotCreated = !this._queueCreated;
        var queueNotEmpty = this._queue.length > 0;
        return queueNotCreated || queueNotEmpty;
      }
    }, {
      key: 'clone',
      value: function clone() {
        return new SegmentedReq(this.source, this.defer, this._initFn);
      }
    }, {
      key: 'complete',
      value: function complete() {
        this._reportStatus();
        this._handle.emit('complete');
        return _get(SegmentedReq.prototype.__proto__ || Object.getPrototypeOf(SegmentedReq.prototype), 'complete', this).call(this);
      }

      /*********
      ** SegmentedReq specific methods
      *********/

      /**
      * Set the sort total number of segments to emit
      *
      * @param {number}
      */

    }, {
      key: 'setMaxSegments',
      value: function setMaxSegments(maxSegments) {
        this._maxSegments = Math.max(_lodash2.default.parseInt(maxSegments), 1);
      }

      /**
      * Set the sort direction for the request.
      *
      * @param {string} dir - one of 'asc' or 'desc'
      */

    }, {
      key: 'setDirection',
      value: function setDirection(dir) {
        switch (dir) {
          case 'asc':
          case 'desc':
            return this._direction = dir;
          default:
            throw new TypeError('unknown sort direction "' + dir + '"');
        }
      }

      /**
      * Set the function that will be used to sort the rows
      *
      * @param {fn}
      */

    }, {
      key: 'setSortFn',
      value: function setSortFn(sortFn) {
        this._sortFn = sortFn;
      }

      /**
      * Set the sort total number of documents to
      * emit
      *
      * Setting to false will not limit the documents,
      * if a number is set the size of the request to es
      * will be updated on each new request
      *
      * @param {number|false}
      */

    }, {
      key: 'setSize',
      value: function setSize(totalSize) {
        this._desiredSize = _lodash2.default.parseInt(totalSize);
        if (isNaN(this._desiredSize)) this._desiredSize = null;
      }
    }, {
      key: '_createQueue',
      value: function _createQueue() {
        var _this4 = this;

        var timeBounds = timefilter.getBounds();
        var indexPattern = this.source.get('index');
        this._queueCreated = false;

        return indexPattern.toDetailedIndexList(timeBounds.min, timeBounds.max, this._direction).then(function (queue) {
          _this4._queue = queue;
          _this4._queueCreated = true;
          return queue;
        });
      }
    }, {
      key: '_reportStatus',
      value: function _reportStatus() {
        return this._handle.emit('status', {
          total: this._queueCreated ? this._all.length : NaN,
          complete: this._queueCreated ? this._complete.length : NaN,
          remaining: this._queueCreated ? this._queue.length : NaN,
          hitCount: this._queueCreated ? this._mergedResp.hits.hits.length : NaN
        });
      }
    }, {
      key: '_getFlattenedSource',
      value: function _getFlattenedSource() {
        return this.source._flatten();
      }
    }, {
      key: '_consumeSegment',
      value: function _consumeSegment(seg) {
        var index = this._active;
        this._complete.push(index);
        if (!seg) return; // segment was ignored/filtered, don't store it

        var hadHits = _lodash2.default.get(this._mergedResp, 'hits.hits.length') > 0;
        var gotHits = _lodash2.default.get(seg, 'hits.hits.length') > 0;
        var firstHits = !hadHits && gotHits;
        var haveHits = hadHits || gotHits;

        this._mergeSegment(seg);
        this.resp = _lodash2.default.omit(this._mergedResp, '_bucketIndex');

        if (firstHits) this._handle.emit('first', seg);
        if (gotHits) this._handle.emit('segment', seg);
        if (haveHits) this._handle.emit('mergedSegment', this.resp);
      }
    }, {
      key: '_mergeHits',
      value: function _mergeHits(hits) {
        var mergedHits = this._mergedResp.hits.hits;
        var desiredSize = this._desiredSize;
        var sortFn = this._sortFn;

        _lodash2.default.pushAll(hits, mergedHits);

        if (sortFn) {
          notify.event('resort rows', function () {
            mergedHits.sort(sortFn);
          });
        }

        if (_lodash2.default.isNumber(desiredSize)) {
          this._mergedResp.hits.hits = mergedHits.slice(0, desiredSize);
        }
      }
    }, {
      key: '_mergeSegment',
      value: function _mergeSegment(seg) {
        var merged = this._mergedResp;

        this._segments.push(seg);

        merged.took += seg.took;
        merged.hits.total += seg.hits.total;
        merged.hits.max_score = Math.max(merged.hits.max_score, seg.hits.max_score);

        if (_lodash2.default.size(seg.hits.hits)) {
          this._mergeHits(seg.hits.hits);
          this._detectHitsWindow(merged.hits.hits);
        }

        if (!seg.aggregations) return;

        Object.keys(seg.aggregations).forEach(function (aggKey) {

          if (!merged.aggregations) {
            // start merging aggregations
            merged.aggregations = {};
            merged._bucketIndex = {};
          }

          if (!merged.aggregations[aggKey]) {
            merged.aggregations[aggKey] = {
              buckets: []
            };
          }

          seg.aggregations[aggKey].buckets.forEach(function (bucket) {
            var mbucket = merged._bucketIndex[bucket.key];
            if (mbucket) {
              mbucket.doc_count += bucket.doc_count;
              return;
            }

            mbucket = merged._bucketIndex[bucket.key] = bucket;
            merged.aggregations[aggKey].buckets.push(mbucket);
          });
        });
      }
    }, {
      key: '_detectHitsWindow',
      value: function _detectHitsWindow(hits) {
        hits = hits || [];
        var indexPattern = this.source.get('index');
        var desiredSize = this._desiredSize;

        var size = _lodash2.default.size(hits);
        if (!_lodash2.default.isNumber(desiredSize) || size < desiredSize) {
          this._hitWindow = {
            size: size,
            min: -Infinity,
            max: Infinity
          };
          return;
        }

        var min = void 0;
        var max = void 0;

        hits.forEach(function (deepHit) {
          var hit = indexPattern.flattenHit(deepHit);
          var time = hit[indexPattern.timeFieldName];
          if (min == null || time < min) min = time;
          if (max == null || time > max) max = time;
        });

        this._hitWindow = { size: size, min: min, max: max };
      }
    }, {
      key: '_pickSizeForIndices',
      value: function _pickSizeForIndices(indices) {
        var hitWindow = this._hitWindow;
        var desiredSize = this._desiredSize;

        if (!_lodash2.default.isNumber(desiredSize)) return null;
        // we don't have any hits yet, get us more info!
        if (!hitWindow) return desiredSize;
        // the order of documents isn't important, just get us more
        if (!this._sortFn) return Math.max(desiredSize - hitWindow.size, 0);
        // if all of the documents in every index fall outside of our current doc set, we can ignore them.
        var someOverlap = indices.some(function (index) {
          return index.min <= hitWindow.max && hitWindow.min <= index.max;
        });

        return someOverlap ? desiredSize : 0;
      }
    }]);

    return SegmentedReq;
  }(SearchRequest);

  SegmentedReq.prototype.mergedSegment = notify.timed('merge response segment', SegmentedReq.prototype.mergedSegment);

  return SegmentedReq;
}

/***/ }),
/* 2096 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.SegmentedHandleProvider = SegmentedHandleProvider;

var _events = __webpack_require__(133);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function SegmentedHandleProvider(Private) {
  var Events = Private(_events.EventsProvider);

  var segmentedRequest = Symbol('Actual Segmented Request');

  /**
   * Simple class for creating an object to send to the
   * requester of a SegmentedRequest. Since the SegmentedRequest
   * extends AbstractRequest, it wasn't able to be the event
   * emitter it was born to be. This provides a channel for
   * setting values on the segmented request, and an event
   * emitter for the request to speak outwardly
   *
   * @param {SegmentedRequest} - req - the requst this handle relates to
   */
  return function (_Events) {
    _inherits(SegmentedHandle, _Events);

    function SegmentedHandle(req) {
      _classCallCheck(this, SegmentedHandle);

      var _this = _possibleConstructorReturn(this, (SegmentedHandle.__proto__ || Object.getPrototypeOf(SegmentedHandle)).call(this));

      _this[segmentedRequest] = req;
      return _this;
    }

    _createClass(SegmentedHandle, [{
      key: 'setDirection',
      value: function setDirection() {
        var _segmentedRequest;

        (_segmentedRequest = this[segmentedRequest]).setDirection.apply(_segmentedRequest, arguments);
      }
    }, {
      key: 'setSize',
      value: function setSize() {
        var _segmentedRequest2;

        (_segmentedRequest2 = this[segmentedRequest]).setSize.apply(_segmentedRequest2, arguments);
      }
    }, {
      key: 'setMaxSegments',
      value: function setMaxSegments() {
        var _segmentedRequest3;

        (_segmentedRequest3 = this[segmentedRequest]).setMaxSegments.apply(_segmentedRequest3, arguments);
      }
    }, {
      key: 'setSortFn',
      value: function setSortFn() {
        var _segmentedRequest4;

        (_segmentedRequest4 = this[segmentedRequest]).setSortFn.apply(_segmentedRequest4, arguments);
      }
    }]);

    return SegmentedHandle;
  }(Events);
}

/***/ }),
/* 2097 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SearchLooperProvider = SearchLooperProvider;

var _fetch = __webpack_require__(471);

var _request_queue = __webpack_require__(250);

var _looper = __webpack_require__(2098);

function SearchLooperProvider(Private, Promise, $rootScope) {
  var fetchSoon = Private(_fetch.FetchSoonProvider);

  var Looper = Private(_looper.LooperProvider);

  /**
   * The Looper which will manage the doc fetch interval
   * @type {Looper}
   */
  var searchLooper = new Looper(null, function () {
    $rootScope.$broadcast('courier:searchRefresh');
    var requests = _request_queue.requestQueue.getInactive();
    // promise returned from fetch.these() only resolves when
    // the requests complete, but we want to continue even if
    // the requests abort so we make our own
    fetchSoon.these(requests);
    return Promise.all(requests.map(function (request) {
      return request.getCompleteOrAbortedPromise();
    }));
  });

  searchLooper.onHastyLoop = function () {
    if (searchLooper.afterHastyQueued) return;

    searchLooper.afterHastyQueued = Promise.resolve(searchLooper.active).then(function () {
      return searchLooper._loopTheLoop();
    }).finally(function () {
      searchLooper.afterHastyQueued = null;
    });
  };

  return searchLooper;
}

/***/ }),
/* 2098 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LooperProvider = LooperProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

__webpack_require__(236);

var _notifier = __webpack_require__(43);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function LooperProvider($timeout, Promise) {
  var notify = new _notifier.Notifier();

  function Looper(ms, fn) {
    this._fn = fn;
    this._ms = ms === void 0 ? 1500 : ms;
    this._timer = null;
    this._started = false;

    this._loopTheLoop = _lodash2.default.bind(this._loopTheLoop, this);
  }

  /**
   * Set the number of milliseconds between
   * each loop
   *
   * @param  {integer} ms
   * @chainable
   */
  Looper.prototype.ms = function (ms) {
    this._ms = _lodash2.default.parseInt(ms) || 0;

    if (!this._started) return;

    if (this._ms) {
      this.start(false);
    } else {
      this._unScheduleLoop();
    }

    return this;
  };

  /**
   * Cancels the current looper while keeping internal
   * state as started
   *
   * @chainable
   */
  Looper.prototype.pause = function () {
    this._unScheduleLoop();
    return this;
  };

  /**
   * Start the looping madness
   *
   * @chainable
   */
  Looper.prototype.start = function (loopOver) {
    if (loopOver == null) loopOver = true;

    if (!this._started) {
      this._started = true;
    } else {
      this._unScheduleLoop();
    }

    if (loopOver) {
      this._loopTheLoop();
    } else {
      this._scheduleLoop();
    }

    return this;
  };

  /**
   * ...
   *
   * @chainable
   */
  Looper.prototype.stop = function () {
    this._unScheduleLoop();
    this._started = false;
    return this;
  };

  /**
   * Restart the looper only if it is already started.
   * Called automatically when ms is changed
   *
   * @chainable
   */
  Looper.prototype.restart = function () {
    this.start(false);
    return this;
  };

  /**
   * Is the looper currently started/running/scheduled/going to execute
   *
   * @return {boolean}
   */
  Looper.prototype.started = function () {
    return !!this._started;
  };

  /**
   * Returns the current loop interval
   *
   * @return {number}
   */
  Looper.prototype.loopInterval = function () {
    return this._ms;
  };

  /**
   * Called when the loop is executed before the previous
   * run has completed.
   *
   * @override
   * @return {undefined}
   */
  Looper.prototype.onHastyLoop = function () {
    // override this in subclasses
  };

  /**
   * Wraps this._fn so that this._fn can be changed
   * without rescheduling and schedules
   * the next itteration
   *
   * @private
   * @return {undefined}
   */
  Looper.prototype._loopTheLoop = function () {
    var self = this;

    if (self.active) {
      self.onHastyLoop();
      return;
    }

    self.active = Promise.try(this._fn).then(function () {
      self._scheduleLoop();
    }).catch(function (err) {
      self.stop();
      notify.fatal(err);
    }).finally(function () {
      self.active = null;
    });
  };

  /**
   * Schedule the next itteration of the loop
   *
   * @private
   * @return {number} - the timer promise
   */
  Looper.prototype._scheduleLoop = function () {
    this._unScheduleLoop();
    this._timer = this._ms ? $timeout(this._loopTheLoop, this._ms) : null;
    return this._timer;
  };

  /**
   * Cancel the next itteration of the loop
   *
   * @private
   * @return {number} - the timer promise
   */
  Looper.prototype._unScheduleLoop = function () {
    if (this._timer) {
      $timeout.cancel(this._timer);
      this._timer = null;
    }
  };

  /**
   * execute the this._fn, and restart the timer
   */
  Looper.prototype.run = function () {
    this.start();
  };

  return Looper;
}

/***/ }),
/* 2099 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _saved_object = __webpack_require__(2100);

Object.defineProperty(exports, 'SavedObjectProvider', {
  enumerable: true,
  get: function get() {
    return _saved_object.SavedObjectProvider;
  }
});

/***/ }),
/* 2100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SavedObjectProvider = SavedObjectProvider;

var _angular = __webpack_require__(16);

var _angular2 = _interopRequireDefault(_angular);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _errors = __webpack_require__(37);

var _mapping_setup = __webpack_require__(755);

var _mapping_setup2 = _interopRequireDefault(_mapping_setup);

var _search_source = __webpack_require__(135);

var _saved_objects = __webpack_require__(76);

var _migrateLegacyQuery = __webpack_require__(326);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * An error message to be used when the user rejects a confirm overwrite.
 * @type {string}
 */
var OVERWRITE_REJECTED = 'Overwrite confirmation was rejected';

/**
 * An error message to be used when the user rejects a confirm save with duplicate title.
 * @type {string}
 */
/**
 * @name SavedObject
 *
 * NOTE: SavedObject seems to track a reference to an object in ES,
 * and surface methods for CRUD functionality (save and delete). This seems
 * similar to how Backbone Models work.
 *
 * This class seems to interface with ES primarily through the es Angular
 * service and the saved object api.
 */

var SAVE_DUPLICATE_REJECTED = 'Save with duplicate title confirmation was rejected';

/**
 * @param error {Error} the error
 * @return {boolean}
 */
function isErrorNonFatal(error) {
  if (!error) return false;
  return error.message === OVERWRITE_REJECTED || error.message === SAVE_DUPLICATE_REJECTED;
}

function SavedObjectProvider(Promise, Private, Notifier, confirmModalPromise, indexPatterns) {
  var savedObjectsClient = Private(_saved_objects.SavedObjectsClientProvider);
  var SearchSource = Private(_search_source.SearchSourceProvider);
  var mappingSetup = Private(_mapping_setup2.default);

  function SavedObject(config) {
    var _this = this;

    if (!_lodash2.default.isObject(config)) config = {};

    /************
     * Initialize config vars
     ************/

    // type name for this object, used as the ES-type
    var esType = config.type;

    this.getDisplayName = function () {
      return esType;
    };

    // NOTE: this.type (not set in this file, but somewhere else) is the sub type, e.g. 'area' or
    // 'data table', while esType is the more generic type - e.g. 'visualization' or 'saved search'.
    this.getEsType = function () {
      return esType;
    };

    /**
     * Flips to true during a save operation, and back to false once the save operation
     * completes.
     * @type {boolean}
     */
    this.isSaving = false;
    this.defaults = config.defaults || {};

    // mapping definition for the fields that this object will expose
    var mapping = mappingSetup.expandShorthand(config.mapping);

    var afterESResp = config.afterESResp || _lodash2.default.noop;
    var customInit = config.init || _lodash2.default.noop;

    // optional search source which this object configures
    this.searchSource = config.searchSource ? new SearchSource() : undefined;

    // the id of the document
    this.id = config.id || void 0;

    // Whether to create a copy when the object is saved. This should eventually go away
    // in favor of a better rename/save flow.
    this.copyOnSave = false;

    var parseSearchSource = function parseSearchSource(searchSourceJson) {
      if (!_this.searchSource) return;

      // if we have a searchSource, set its state based on the searchSourceJSON field
      var state = void 0;
      try {
        state = JSON.parse(searchSourceJson);
      } catch (e) {
        state = {};
      }

      var oldState = _this.searchSource.toJSON();
      var fnProps = _lodash2.default.transform(oldState, function (dynamic, val, name) {
        if (_lodash2.default.isFunction(val)) dynamic[name] = val;
      }, {});

      _this.searchSource.set(_lodash2.default.defaults(state, fnProps));

      if (!_lodash2.default.isUndefined(_this.searchSource.getOwn('query'))) {
        _this.searchSource.set('query', (0, _migrateLegacyQuery.migrateLegacyQuery)(_this.searchSource.getOwn('query')));
      }
    };

    /**
     * After creation or fetching from ES, ensure that the searchSources index indexPattern
     * is an bonafide IndexPattern object.
     *
     * @return {Promise<IndexPattern | null>}
     */
    this.hydrateIndexPattern = function (id) {
      if (!_this.searchSource) {
        return Promise.resolve(null);
      }

      if (config.clearSavedIndexPattern) {
        _this.searchSource.set('index', undefined);
        return Promise.resolve(null);
      }

      var index = id || config.indexPattern || _this.searchSource.getOwn('index');

      if (!index) {
        return Promise.resolve(null);
      }

      // If index is not an IndexPattern object at this point, then it's a string id of an index.
      if (!(index instanceof indexPatterns.IndexPattern)) {
        index = indexPatterns.get(index);
      }

      // At this point index will either be an IndexPattern, if cached, or a promise that
      // will return an IndexPattern, if not cached.
      return Promise.resolve(index).then(function (indexPattern) {
        _this.searchSource.set('index', indexPattern);
      });
    };

    /**
     * Asynchronously initialize this object - will only run
     * once even if called multiple times.
     *
     * @return {Promise}
     * @resolved {SavedObject}
     */
    this.init = _lodash2.default.once(function () {
      // ensure that the esType is defined
      if (!esType) throw new Error('You must define a type name to use SavedObject objects.');

      return Promise.resolve().then(function () {
        // If there is not id, then there is no document to fetch from elasticsearch
        if (!_this.id) {
          // just assign the defaults and be done
          _lodash2.default.assign(_this, _this.defaults);
          return _this.hydrateIndexPattern().then(function () {
            return afterESResp.call(_this);
          });
        }

        // fetch the object from ES
        return savedObjectsClient.get(esType, _this.id).then(function (resp) {
          // temporary compatability for savedObjectsClient

          return {
            _id: resp.id,
            _type: resp.type,
            _source: _lodash2.default.cloneDeep(resp.attributes),
            found: resp._version ? true : false
          };
        }).then(_this.applyESResp).catch(_this.applyEsResp);
      }).then(function () {
        return customInit.call(_this);
      }).then(function () {
        return _this;
      });
    });

    this.applyESResp = function (resp) {
      _this._source = _lodash2.default.cloneDeep(resp._source);

      if (resp.found != null && !resp.found) throw new _errors.SavedObjectNotFound(esType, _this.id);

      var meta = resp._source.kibanaSavedObjectMeta || {};
      delete resp._source.kibanaSavedObjectMeta;

      if (!config.indexPattern && _this._source.indexPattern) {
        config.indexPattern = _this._source.indexPattern;
        delete _this._source.indexPattern;
      }

      // assign the defaults to the response
      _lodash2.default.defaults(_this._source, _this.defaults);

      // transform the source using _deserializers
      _lodash2.default.forOwn(mapping, function (fieldMapping, fieldName) {
        if (fieldMapping._deserialize) {
          _this._source[fieldName] = fieldMapping._deserialize(_this._source[fieldName], resp, fieldName, fieldMapping);
        }
      });

      // Give obj all of the values in _source.fields
      _lodash2.default.assign(_this, _this._source);
      _this.lastSavedTitle = _this.title;

      return Promise.try(function () {
        parseSearchSource(meta.searchSourceJSON);
        return _this.hydrateIndexPattern();
      }).then(function () {
        return Promise.cast(afterESResp.call(_this, resp));
      });
    };

    /**
     * Serialize this object
     *
     * @return {Object}
     */
    this.serialize = function () {
      var body = {};

      _lodash2.default.forOwn(mapping, function (fieldMapping, fieldName) {
        if (_this[fieldName] != null) {
          body[fieldName] = fieldMapping._serialize ? fieldMapping._serialize(_this[fieldName]) : _this[fieldName];
        }
      });

      if (_this.searchSource) {
        body.kibanaSavedObjectMeta = {
          searchSourceJSON: _angular2.default.toJson(_lodash2.default.omit(_this.searchSource.toJSON(), ['sort', 'size']))
        };
      }

      return body;
    };

    /**
     * Returns true if the object's original title has been changed. New objects return false.
     * @return {boolean}
     */
    this.isTitleChanged = function () {
      return _this._source && _this._source.title !== _this.title;
    };

    /**
     * Attempts to create the current object using the serialized source. If an object already
     * exists, a warning message requests an overwrite confirmation.
     * @param source - serialized version of this object (return value from this.serialize())
     * What will be indexed into elasticsearch.
     * @returns {Promise} - A promise that is resolved with the objects id if the object is
     * successfully indexed. If the overwrite confirmation was rejected, an error is thrown with
     * a confirmRejected = true parameter so that case can be handled differently than
     * a create or index error.
     * @resolved {SavedObject}
     */
    var createSource = function createSource(source) {
      return savedObjectsClient.create(esType, source, { id: _this.id }).catch(function (err) {
        // record exists, confirm overwriting
        if (_lodash2.default.get(err, 'statusCode') === 409) {
          var confirmMessage = 'Are you sure you want to overwrite ' + _this.title + '?';

          return confirmModalPromise(confirmMessage, { confirmButtonText: 'Overwrite ' + _this.getDisplayName() }).then(function () {
            return savedObjectsClient.create(esType, source, { id: _this.id, overwrite: true });
          }).catch(function () {
            return Promise.reject(new Error(OVERWRITE_REJECTED));
          });
        }
        return Promise.reject(err);
      });
    };

    /**
     * Returns a promise that resolves to true if either the title is unique, or if the user confirmed they
     * wished to save the duplicate title.  Promise is rejected if the user rejects the confirmation.
     */
    var warnIfDuplicateTitle = function warnIfDuplicateTitle() {
      // Don't warn if the user isn't updating the title, otherwise that would become very annoying to have
      // to confirm the save every time, except when copyOnSave is true, then we do want to check.
      if (_this.title === _this.lastSavedTitle && !_this.copyOnSave) {
        return Promise.resolve();
      }

      return (0, _saved_objects.findObjectByTitle)(savedObjectsClient, _this.getEsType(), _this.title).then(function (duplicate) {
        if (!duplicate) return true;
        if (duplicate.id === _this.id) return true;

        var confirmMessage = 'A ' + _this.getDisplayName() + ' with the title \'' + _this.title + '\' already exists. Would you like to save anyway?';

        return confirmModalPromise(confirmMessage, { confirmButtonText: 'Save ' + _this.getDisplayName() }).catch(function () {
          return Promise.reject(new Error(SAVE_DUPLICATE_REJECTED));
        });
      });
    };

    /**
     * Saves this object.
     *
     * @param {object} [options={}]
     * @property {boolean} [options.confirmOverwrite=false] - If true, attempts to create the source so it
     * can confirm an overwrite if a document with the id already exists.
     * @return {Promise}
     * @resolved {String} - The id of the doc
     */
    this.save = function () {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          confirmOverwrite = _ref.confirmOverwrite;

      // Save the original id in case the save fails.
      var originalId = _this.id;
      // Read https://github.com/elastic/kibana/issues/9056 and
      // https://github.com/elastic/kibana/issues/9012 for some background into why this copyOnSave variable
      // exists.
      // The goal is to move towards a better rename flow, but since our users have been conditioned
      // to expect a 'save as' flow during a rename, we are keeping the logic the same until a better
      // UI/UX can be worked out.
      if (_this.copyOnSave) {
        _this.id = null;
      }

      var source = _this.serialize();

      _this.isSaving = true;

      return warnIfDuplicateTitle().then(function () {
        if (confirmOverwrite) {
          return createSource(source);
        } else {
          return savedObjectsClient.create(esType, source, { id: _this.id, overwrite: true });
        }
      }).then(function (resp) {
        _this.id = resp.id;
      }).then(function () {
        _this.isSaving = false;
        _this.lastSavedTitle = _this.title;
        return _this.id;
      }).catch(function (err) {
        _this.isSaving = false;
        _this.id = originalId;
        if (isErrorNonFatal(err)) {
          return;
        }
        return Promise.reject(err);
      });
    };

    this.destroy = function () {
      if (_this.searchSource) {
        _this.searchSource.cancelQueued();
      }
    };

    /**
     * Delete this object from Elasticsearch
     * @return {promise}
     */
    this.delete = function () {
      return savedObjectsClient.delete(esType, _this.id);
    };
  }

  return SavedObject;
}

/***/ }),
/* 2101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RedirectWhenMissingProvider = RedirectWhenMissingProvider;

var _errors = __webpack_require__(37);

function RedirectWhenMissingProvider($location, kbnUrl, Notifier, Promise) {
  var notify = new Notifier();

  /**
   * Creates an error handler that will redirect to a url when a SavedObjectNotFound
   * error is thrown
   *
   * @param  {string|object} mapping - a mapping of url's to redirect to based on the saved object that
   *                                 couldn't be found, or just a string that will be used for all types
   * @return {function} - the handler to pass to .catch()
   */
  return function (mapping) {
    if (typeof mapping === 'string') {
      mapping = { '*': mapping };
    }

    return function (err) {
      // if this error is not "404", rethrow
      var savedObjectNotFound = err instanceof _errors.SavedObjectNotFound;
      var unknownVisType = err.message.indexOf('Invalid type') === 0;
      if (unknownVisType) err.savedObjectType = 'visualization';else if (!savedObjectNotFound) throw err;

      var url = mapping[err.savedObjectType] || mapping['*'];
      if (!url) url = '/';

      url += (url.indexOf('?') >= 0 ? '&' : '?') + ('notFound=' + err.savedObjectType);

      notify.info(err);
      kbnUrl.redirect(url);
      return Promise.halt();
    };
  };
}

/***/ }),
/* 2102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DebounceProvider = undefined;

var _debounce = __webpack_require__(775);

Object.defineProperty(exports, 'DebounceProvider', {
  enumerable: true,
  get: function get() {
    return _debounce.DebounceProvider;
  }
});

__webpack_require__(775);

/***/ }),
/* 2103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(2104);

/***/ }),
/* 2104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _kbn_form_controller = __webpack_require__(2105);

var _kbn_model_controller = __webpack_require__(2106);

_modules.uiModules.get('kibana').config(function ($provide) {
  $provide.decorator('formDirective', _kbn_form_controller.decorateFormController);
  $provide.decorator('ngFormDirective', _kbn_form_controller.decorateFormController);
  $provide.decorator('ngModelDirective', _kbn_model_controller.decorateModelController);
});

/***/ }),
/* 2105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.decorateFormController = decorateFormController;

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function decorateFormController($delegate, $injector) {
  var _$delegate = _slicedToArray($delegate, 1),
      directive = _$delegate[0];

  var FormController = directive.controller;

  var KbnFormController = function (_FormController) {
    _inherits(KbnFormController, _FormController);

    function KbnFormController($scope, $element) {
      var _ref;

      _classCallCheck(this, KbnFormController);

      for (var _len = arguments.length, superArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        superArgs[_key - 2] = arguments[_key];
      }

      var _this = _possibleConstructorReturn(this, (_ref = KbnFormController.__proto__ || Object.getPrototypeOf(KbnFormController)).call.apply(_ref, [this].concat(superArgs)));

      var onSubmit = function onSubmit(event) {
        _this._markInvalidTouched(event);
      };

      $element.on('submit', onSubmit);
      $scope.$on('$destroy', function () {
        $element.off('submit', onSubmit);
      });
      return _this;
    }
    // prevent inheriting FormController's static $inject property
    // which is angular's cache of the DI arguments for a function


    _createClass(KbnFormController, [{
      key: 'errorCount',
      value: function errorCount() {
        return this._getInvalidModels().length;
      }

      // same as error count, but filters out untouched and pristine models

    }, {
      key: 'softErrorCount',
      value: function softErrorCount() {
        return this._getInvalidModels().filter(function (model) {
          return model.$touched || model.$dirty;
        }).length;
      }
    }, {
      key: 'describeErrors',
      value: function describeErrors() {
        var count = this.softErrorCount();
        return count + ' Error' + (count === 1 ? '' : 's');
      }
    }, {
      key: '$setTouched',
      value: function $setTouched() {
        this._getInvalidModels().forEach(function (model) {
          return model.$setTouched();
        });
      }
    }, {
      key: '_markInvalidTouched',
      value: function _markInvalidTouched(event) {
        if (this.errorCount()) {
          event.preventDefault();
          event.stopImmediatePropagation();
          this.$setTouched();
        }
      }
    }, {
      key: '_getInvalidModels',
      value: function _getInvalidModels() {
        return this.$$controls.reduce(function (acc, control) {
          // recurse into sub-form
          if (typeof control._getInvalidModels === 'function') {
            return [].concat(_toConsumableArray(acc), _toConsumableArray(control._getInvalidModels()));
          }

          if (control.$invalid) {
            return [].concat(_toConsumableArray(acc), [control]);
          }

          return acc;
        }, []);
      }
    }]);

    return KbnFormController;
  }(FormController);

  // replace controller with our wrapper


  KbnFormController.$inject = ['$scope', '$element'];
  directive.controller = [].concat(_toConsumableArray($injector.annotate(KbnFormController)), _toConsumableArray($injector.annotate(FormController)), [function () {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return new (Function.prototype.bind.apply(KbnFormController, [null].concat(args)))();
  }]);

  return $delegate;
}

/***/ }),
/* 2106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.decorateModelController = decorateModelController;

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function decorateModelController($delegate, $injector) {
  var _$delegate = _slicedToArray($delegate, 1),
      directive = _$delegate[0];

  var ModelController = directive.controller;

  var KbnModelController = function (_ModelController) {
    _inherits(KbnModelController, _ModelController);

    function KbnModelController($scope, $element) {
      var _ref;

      _classCallCheck(this, KbnModelController);

      for (var _len = arguments.length, superArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        superArgs[_key - 2] = arguments[_key];
      }

      var _this = _possibleConstructorReturn(this, (_ref = KbnModelController.__proto__ || Object.getPrototypeOf(KbnModelController)).call.apply(_ref, [this].concat(superArgs)));

      var onInvalid = function onInvalid() {
        _this.$setTouched();
      };

      // the browser emits an "invalid" event when browser supplied
      // validation fails, which implies that the user has indirectly
      // interacted with the control and it should be treated as "touched"
      $element.on('invalid', onInvalid);
      $scope.$on('$destroy', function () {
        $element.off('invalid', onInvalid);
      });
      return _this;
    }
    // prevent inheriting ModelController's static $inject property
    // which is angular's cache of the DI arguments for a function


    return KbnModelController;
  }(ModelController);

  // replace controller with our wrapper


  KbnModelController.$inject = ['$scope', '$element'];
  directive.controller = [].concat(_toConsumableArray($injector.annotate(KbnModelController)), _toConsumableArray($injector.annotate(ModelController)), [function () {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return new (Function.prototype.bind.apply(KbnModelController, [null].concat(args)))();
  }]);

  return $delegate;
}

/***/ }),
/* 2107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toggleFilterDisabled = exports.enableFilter = exports.disableFilter = undefined;

var _disable_filter = __webpack_require__(778);

Object.defineProperty(exports, 'disableFilter', {
  enumerable: true,
  get: function get() {
    return _disable_filter.disableFilter;
  }
});
Object.defineProperty(exports, 'enableFilter', {
  enumerable: true,
  get: function get() {
    return _disable_filter.enableFilter;
  }
});
Object.defineProperty(exports, 'toggleFilterDisabled', {
  enumerable: true,
  get: function get() {
    return _disable_filter.toggleFilterDisabled;
  }
});

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _filter_bar = __webpack_require__(2108);

var _filter_bar2 = _interopRequireDefault(_filter_bar);

__webpack_require__(779);

__webpack_require__(2109);

__webpack_require__(2138);

var _filter_applied_and_unwrap = __webpack_require__(2140);

var _map_and_flatten_filters = __webpack_require__(327);

var _map_flatten_and_wrap_filters = __webpack_require__(2153);

var _extract_time_filter = __webpack_require__(787);

var _filter_out_time_based_filter = __webpack_require__(788);

var _change_time_filter = __webpack_require__(789);

var _query_filter = __webpack_require__(119);

var _compare_filters = __webpack_require__(328);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');

_module.directive('filterBar', function (Private, Promise, getAppState) {
  var mapAndFlattenFilters = Private(_map_and_flatten_filters.FilterBarLibMapAndFlattenFiltersProvider);
  var mapFlattenAndWrapFilters = Private(_map_flatten_and_wrap_filters.FilterBarLibMapFlattenAndWrapFiltersProvider);
  var extractTimeFilter = Private(_extract_time_filter.FilterBarLibExtractTimeFilterProvider);
  var filterOutTimeBasedFilter = Private(_filter_out_time_based_filter.FilterBarLibFilterOutTimeBasedFilterProvider);
  var changeTimeFilter = Private(_change_time_filter.FilterBarLibChangeTimeFilterProvider);
  var queryFilter = Private(_query_filter.FilterBarQueryFilterProvider);

  return {
    template: _filter_bar2.default,
    restrict: 'E',
    scope: {
      indexPatterns: '='
    },
    link: function link($scope) {
      // bind query filter actions to the scope
      ['addFilters', 'toggleFilter', 'toggleAll', 'pinFilter', 'pinAll', 'invertFilter', 'invertAll', 'removeFilter', 'removeAll'].forEach(function (method) {
        $scope[method] = queryFilter[method];
      });

      $scope.state = getAppState();

      $scope.showAddFilterButton = function () {
        return _lodash2.default.compact($scope.indexPatterns).length > 0;
      };

      $scope.applyFilters = function (filters) {
        addAndInvertFilters((0, _filter_applied_and_unwrap.filterAppliedAndUnwrap)(filters));
        $scope.newFilters = [];

        // change time filter
        if ($scope.changeTimeFilter && $scope.changeTimeFilter.meta && $scope.changeTimeFilter.meta.apply) {
          changeTimeFilter($scope.changeTimeFilter);
        }
      };

      $scope.addFilter = function () {
        $scope.editingFilter = {
          meta: { isNew: true }
        };
      };

      $scope.deleteFilter = function (filter) {
        $scope.removeFilter(filter);
        if (filter === $scope.editingFilter) $scope.cancelEdit();
      };

      $scope.editFilter = function (filter) {
        $scope.editingFilter = filter;
      };

      $scope.cancelEdit = function () {
        delete $scope.editingFilter;
      };

      $scope.saveEdit = function (filter, newFilter, isPinned) {
        if (!filter.meta.isNew) $scope.removeFilter(filter);
        delete $scope.editingFilter;
        $scope.addFilters([newFilter], isPinned);
      };

      $scope.clearFilterBar = function () {
        $scope.newFilters = [];
        $scope.changeTimeFilter = null;
      };

      // update the scope filter list on filter changes
      $scope.$listen(queryFilter, 'update', function () {
        updateFilters();
      });

      // when appState changes, update scope's state
      $scope.$watch(getAppState, function (appState) {
        $scope.state = appState;
      });

      $scope.$watch('state.$newFilters', function (filters) {
        if (!filters) return;

        // If filters is not undefined and the length is greater than
        // one we need to set the newFilters attribute and allow the
        // users to decide what they want to apply.
        if (filters.length > 1) {
          return mapFlattenAndWrapFilters(filters).then(function (results) {
            extractTimeFilter(results).then(function (filter) {
              $scope.changeTimeFilter = filter;
            });
            return results;
          }).then(filterOutTimeBasedFilter).then(function (results) {
            $scope.newFilters = results;
          });
        }

        // Just add single filters to the state.
        if (filters.length === 1) {
          Promise.resolve(filters).then(function (filters) {
            extractTimeFilter(filters).then(function (timeFilter) {
              if (timeFilter) changeTimeFilter(timeFilter);
            });
            return filters;
          }).then(filterOutTimeBasedFilter).then(addAndInvertFilters);
        }
      });

      function addAndInvertFilters(filters) {
        var existingFilters = queryFilter.getFilters();
        var inversionFilters = _lodash2.default.filter(existingFilters, function (existingFilter) {
          var newMatchingFilter = _lodash2.default.find(filters, _lodash2.default.partial(_compare_filters.compareFilters, existingFilter));
          return newMatchingFilter && newMatchingFilter.meta && existingFilter.meta && existingFilter.meta.negate !== newMatchingFilter.meta.negate;
        });
        var newFilters = _lodash2.default.reject(filters, function (filter) {
          return _lodash2.default.find(inversionFilters, _lodash2.default.partial(_compare_filters.compareFilters, filter));
        });

        _lodash2.default.forEach(inversionFilters, $scope.invertFilter);
        $scope.addFilters(newFilters);
      }

      function updateFilters() {
        var filters = queryFilter.getFilters();
        mapAndFlattenFilters(filters).then(function (results) {
          // used to display the current filters in the state
          $scope.filters = _lodash2.default.sortBy(results, function (filter) {
            return !filter.meta.pinned;
          });
          $scope.$emit('filterbar:updated');
        });
      }

      updateFilters();
    }
  };
});

/***/ }),
/* 2108 */
/***/ (function(module, exports) {

module.exports = "<section aria-label=\"Filters\">\n  <div class=\"filter-bar-confirm\" ng-show=\"newFilters.length\">\n    <form ng-submit=\"applyFilters(newFilters)\">\n    <ul class=\"list-unstyled\">\n      <li>Apply these filters?</li>\n      <li ng-repeat=\"filter in newFilters track by $index\" class=\"filter\" ng-click=\"filter.meta.apply = !filter.meta.apply\"><input type=\"checkbox\" ng-checked=\"filter.meta.apply\"/>\n        <span ng-if=\"filter.meta.negate\">NOT </span> {{ filter.meta.key }}: {{ filter.meta.value }}\n      </li>\n      <li ng-if=\"changeTimeFilter\" class=\"changeTimeFilter filter\" ng-click=\"changeTimeFilter.meta.apply = !changeTimeFilter.meta.apply\"><input type=\"checkbox\" ng-checked=\"changeTimeFilter.meta.apply\"/> <strong>Change time to:</strong> {{changeTimeFilter.meta.value}} </li>\n      <li>\n        <div class=\"kuiButtonGroup\">\n          <button class=\"kuiButton kuiButton--primary kuiButton--small\">\n            Apply Now\n          </button>\n\n          <button\n            class=\"kuiButton kuiButton--hollow\"\n            ng-click=\"clearFilterBar();\"\n          >\n            Cancel\n          </button>\n        </div>\n      </li>\n    </ul>\n    </form>\n  </div>\n\n  <div\n    class=\"filter-bar\"\n    ng-show=\"filters.length || showAddFilterButton()\"\n  >\n    <filter-pill\n      ng-repeat=\"filter in filters track by $index\"\n      filter=\"filter\"\n      on-toggle-filter=\"toggleFilter\"\n      on-pin-filter=\"pinFilter\"\n      on-invert-filter=\"invertFilter\"\n      on-delete-filter=\"deleteFilter\"\n      on-edit-filter=\"editFilter\"\n    ></filter-pill>\n\n    <div\n      class=\"filter-link\"\n      ng-show=\"showAddFilterButton()\"\n    >\n      <div class=\"filter-description small\">\n        <button\n          ng-click=\"addFilter()\"\n          class=\"euiButtonEmpty euiButtonEmpty--primary euiButtonEmpty--small\"\n          data-test-subj=\"addFilter\"\n        >\n          Add a filter\n          <span class=\"fa fa-plus\"></span>\n        </button>\n      </div>\n    </div>\n\n    <div\n      class=\"filter-link pull-right\"\n      ng-show=\"filters.length\"\n    >\n      <div class=\"filter-description small\">\n        <a\n          ng-click=\"showFilterActions = !showFilterActions\"\n          kbn-accessible-click\n          aria-expanded=\"{{!!showFilterActions}}\"\n          aria-controls=\"filterActionsAllContainer\"\n        >\n          Actions\n          <span\n            class=\"fa\"\n            ng-class=\"{\n              'fa-caret-down': showFilterActions,\n              'fa-caret-right': !showFilterActions\n            }\"\n            data-test-subj=\"showFilterActions\"\n          ></span>\n        </a>\n      </div>\n    </div>\n\n    <div\n      class=\"filter-edit-container\"\n      ng-if=\"editingFilter\"\n    >\n      <filter-editor\n        filter=\"editingFilter\"\n        index-patterns=\"indexPatterns\"\n        on-delete=\"deleteFilter(editingFilter)\"\n        on-save=\"saveEdit(filter, newFilter, isPinned)\"\n        on-cancel=\"cancelEdit()\"\n      ></filter-editor>\n    </div>\n  </div>\n\n  <div\n    class=\"filter-bar filter-bar-condensed\"\n    ng-show=\"filters.length && showFilterActions\"\n    id=\"filterActionsAllContainer\"\n  >\n    <div class=\"filter-actions-all\">\n      <div class=\"filter-link\">\n        <div class=\"filter-description\"><strong>All filters:</strong></div>\n      </div>\n        <div class=\"filter-link\">\n          <div class=\"filter-description\"><a ng-click=\"toggleAll(false)\" kbn-accessible-click>Enable</a></div>\n        </div>\n      <div class=\"filter-link\">\n        <div class=\"filter-description\"><a ng-click=\"toggleAll(true)\" kbn-accessible-click>Disable</a></div>\n      </div>\n      <div class=\"filter-link\">\n        <div class=\"filter-description\"><a ng-click=\"pinAll(true)\" kbn-accessible-click>Pin</a></div>\n      </div>\n      <div class=\"filter-link\">\n        <div class=\"filter-description\"><a ng-click=\"pinAll(false)\" kbn-accessible-click>Unpin</a></div>\n      </div>\n      <div class=\"filter-link\">\n        <div class=\"filter-description\"><a ng-click=\"invertAll()\" kbn-accessible-click>Invert</a></div>\n      </div>\n      <div class=\"filter-link\">\n        <div class=\"filter-description\"><a ng-click=\"toggleAll()\" kbn-accessible-click>Toggle</a></div>\n      </div>\n      <div class=\"filter-link\">\n        <div class=\"filter-description\"><a ng-click=\"removeAll()\" data-test-subj=\"removeAllFilters\" kbn-accessible-click>Remove</a></div>\n      </div>\n    </div>\n  </div>\n</section>\n"

/***/ }),
/* 2109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(2110);

/***/ }),
/* 2110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _modules = __webpack_require__(2);

var _compat = __webpack_require__(203);

var _filter_operators = __webpack_require__(780);

var _filter_editor = __webpack_require__(2112);

var _filter_editor2 = _interopRequireDefault(_filter_editor);

__webpack_require__(118);

__webpack_require__(2114);

__webpack_require__(2120);

__webpack_require__(2125);

__webpack_require__(2127);

__webpack_require__(2136);

var _filter_editor_utils = __webpack_require__(478);

var _lib = __webpack_require__(2137);

var filterBuilder = _interopRequireWildcard(_lib);

var _key_map = __webpack_require__(483);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');
_module.directive('filterEditor', function ($timeout, indexPatterns) {
  return {
    restrict: 'E',
    template: _filter_editor2.default,
    scope: {
      indexPatterns: '=',
      filter: '=',
      onDelete: '&',
      onCancel: '&',
      onSave: '&'
    },
    controllerAs: 'filterEditor',
    bindToController: true,
    controller: (0, _compat.callAfterBindingsWorkaround)(function ($scope, $element) {
      var _this = this;

      this.init = function () {
        var filter = _this.filter;

        _this.alias = filter.meta.alias;
        _this.isEditingQueryDsl = false;
        _this.queryDsl = (0, _filter_editor_utils.getQueryDslFromFilter)(filter);
        if (filter.meta.isNew) {
          _this.setFocus('field');
        } else {
          (0, _filter_editor_utils.getFieldFromFilter)(filter, indexPatterns).then(function (field) {
            _this.setField(field);
            _this.setOperator((0, _filter_editor_utils.getOperatorFromFilter)(filter));
            _this.params = (0, _filter_editor_utils.getParamsFromFilter)(filter);
          });
        }
      };

      $scope.$watch(function () {
        return _this.filter;
      }, this.init);
      $scope.$watchCollection(function () {
        return _this.filter.meta;
      }, this.init);

      this.setQueryDsl = function (queryDsl) {
        _this.queryDsl = queryDsl;
      };

      this.setField = function (field) {
        _this.field = field;
        _this.operator = null;
        _this.params = {};
      };

      this.onFieldSelect = function (field) {
        _this.setField(field);
        _this.setFocus('operator');
      };

      this.setOperator = function (operator) {
        _this.operator = operator;
      };

      this.onOperatorSelect = function (operator) {
        _this.setOperator(operator);
        _this.setFocus('params');
      };

      this.setParams = function (params) {
        _this.params = params;
      };

      this.setFocus = function (name) {
        $timeout(function () {
          return $scope.$broadcast('focus-' + name);
        });
      };

      this.toggleEditingQueryDsl = function () {
        _this.isEditingQueryDsl = !_this.isEditingQueryDsl;
      };

      this.isQueryDslEditorVisible = function () {
        var _filter$meta = _this.filter.meta,
            type = _filter$meta.type,
            isNew = _filter$meta.isNew;

        return _this.isEditingQueryDsl || !isNew && !_filter_operators.FILTER_OPERATOR_TYPES.includes(type);
      };

      this.isValid = function () {
        if (_this.isQueryDslEditorVisible()) {
          return _lodash2.default.isObject(_this.queryDsl);
        }
        var field = _this.field,
            operator = _this.operator,
            params = _this.params;

        return (0, _filter_editor_utils.isFilterValid)({ field: field, operator: operator, params: params });
      };

      this.save = function () {
        var filter = _this.filter,
            field = _this.field,
            operator = _this.operator,
            params = _this.params,
            alias = _this.alias;


        var newFilter = void 0;
        if (_this.isQueryDslEditorVisible()) {
          var meta = _lodash2.default.pick(filter.meta, ['negate', 'index']);
          meta.index = meta.index || _this.indexPatterns[0].id;
          newFilter = Object.assign(_this.queryDsl, { meta: meta });
        } else {
          var indexPattern = field.indexPattern;
          newFilter = (0, _filter_editor_utils.buildFilter)({ indexPattern: indexPattern, field: field, operator: operator, params: params, filterBuilder: filterBuilder });
        }
        newFilter.meta.disabled = filter.meta.disabled;
        newFilter.meta.alias = alias;

        var isPinned = _lodash2.default.get(filter, ['$state', 'store']) === 'globalState';
        return _this.onSave({ filter: filter, newFilter: newFilter, isPinned: isPinned });
      };

      $element.on('keydown', function (event) {
        if (_key_map.keyMap[event.keyCode] === 'escape') {
          $timeout(function () {
            return _this.onCancel();
          });
        }
      });
    })
  };
});

/***/ }),
/* 2111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.callAfterBindingsWorkaround = callAfterBindingsWorkaround;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *  WHAT NEEDS THIS WORKAROUND?
 *  ===========================
 *  Any directive that meets all of the following criteria:
 *   - uses isolate scope bindings
 *   - sets `bindToController: true`
 *   - synchronously accesses the bound values in the controller constructor
 *
 *
 *
 *  HOW DO I GET RID OF IT?
 *  =======================
 *  The quick band-aid solution:
 *    Wrap your constructor logic so it doesn't access bound values
 *    synchronously. This can have subtle bugs which is why I didn't
 *    just wrap all of the offenders in $timeout() and made this
 *    workaround instead.
 *
 *  The more complete solution:
 *    Use the new component lifecycle methods, like `$onInit()`, to access
 *    bindings immediately after the constructor is called, which shouldn't
 *    have any observable effect outside of the constructor.
 *
 *    NOTE: `$onInit()` is not dependency injected, if you need controller specific
 *      dependencies like `$scope` then you're probably using watchers and should
 *      take a look at the new one-way data flow facitilies available to
 *      directives/components:
 *
 *      https://docs.angularjs.org/guide/component#component-based-application-architecture
 *
 */

var InitAfterBindingsWorkaround = exports.InitAfterBindingsWorkaround = function InitAfterBindingsWorkaround($injector, $attrs, $element, $scope, $transclude) {
  var _this = this;

  _classCallCheck(this, InitAfterBindingsWorkaround);

  if (!this.initAfterBindings) {
    throw new Error('When using inheritance you must move the logic in the constructor to the `initAfterBindings` method');
  }

  this.$onInit = function () {
    $injector.invoke(_this.initAfterBindings, _this, {
      $attrs: $attrs,
      $element: $element,
      $scope: $scope,
      $transclude: $transclude
    });
  };
};

InitAfterBindingsWorkaround.$inject = ['$injector', '$attrs', '$element', '$scope', '$transclude'];
function callAfterBindingsWorkaround(constructor) {
  return function InitAfterBindingsWrapper($injector, $attrs, $element, $scope, $transclude) {
    var _this2 = this;

    this.$onInit = function () {
      $injector.invoke(constructor, _this2, {
        $attrs: $attrs,
        $element: $element,
        $scope: $scope,
        $transclude: $transclude
      });
    };
  };
}

/***/ }),
/* 2112 */
/***/ (function(module, exports) {

module.exports = "<div class=\"filterEditor kuiModal\">\n  <div class=\"kuiModalHeader\">\n    <div class=\"kuiModalHeader__title\">\n      <span ng-show=\"filterEditor.filter.meta.isNew\">Add</span>\n      <span ng-hide=\"filterEditor.filter.meta.isNew\">Edit</span>\n      filter\n    </div>\n\n    <button\n      class=\"kuiModalHeaderCloseButton kuiIcon fa-times\"\n      ng-click=\"filterEditor.onCancel()\"\n      aria-label=\"Close filter popover\"\n    ></button>\n  </div>\n\n  <div class=\"kuiModalBody\">\n    <!-- Filter definition -->\n    <div class=\"kuiVerticalRhythm\">\n      <div class=\"kuiVerticalRhythmSmall filterEditor__labelBar\">\n        <label class=\"kuiLabel\">\n          Filter\n        </label>\n\n        <div>\n          <a\n            class=\"kuiLink\"\n            ng-click=\"filterEditor.toggleEditingQueryDsl()\"\n            kbn-accessible-click\n          >\n            <span ng-if=\"filterEditor.isEditingQueryDsl\">\n              Search filter values\n            </span>\n\n            <span ng-if=\"!filterEditor.isEditingQueryDsl\">\n              Edit Query DSL\n            </span>\n          </a>\n        </div>\n      </div>\n\n      <!-- Filter dropdowns -->\n      <div\n        class=\"kuiFieldGroup kuiVerticalRhythmSmall kuiFieldGroup--alignTop\"\n        ng-show=\"!filterEditor.isQueryDslEditorVisible()\"\n      >\n        <div class=\"kuiFieldGroupSection filterEditor__wideField\">\n          <filter-field-select\n            index-patterns=\"filterEditor.indexPatterns\"\n            field=\"filterEditor.field\"\n            on-select=\"filterEditor.onFieldSelect(field)\"\n          ></filter-field-select>\n        </div>\n\n        <div class=\"kuiFieldGroupSection\">\n          <filter-operator-select\n            ng-if=\"filterEditor.field\"\n            field=\"filterEditor.field\"\n            operator=\"filterEditor.operator\"\n            on-select=\"filterEditor.onOperatorSelect(operator)\"\n          ></filter-operator-select>\n        </div>\n\n        <div class=\"kuiFieldGroupSection kuiFieldGroupSection--wide filterEditor__wideField filterEditorParamsInput\">\n          <filter-params-editor\n            ng-if=\"filterEditor.field && filterEditor.operator\"\n            field=\"filterEditor.field\"\n            operator=\"filterEditor.operator\"\n            params=\"filterEditor.params\"\n          ></filter-params-editor>\n        </div>\n      </div>\n\n      <!-- DSL editor -->\n      <div\n        class=\"kuiVerticalRhythmSmall\"\n        ng-show=\"filterEditor.isQueryDslEditorVisible()\"\n      >\n        <filter-query-dsl-editor\n          class=\"kuiVerticalRhythmSmall\"\n          filter=\"filterEditor.filter\"\n          on-change=\"filterEditor.setQueryDsl(queryDsl)\"\n          is-visible=\"filterEditor.isQueryDslEditorVisible()\"\n        ></filter-query-dsl-editor>\n\n        <p class=\"kuiText kuiVerticalRhythmSmall\">\n          Filters are built using the <a class=\"kuiLink\" target=\"_blank\" rel=\"noopener noreferrer\" documentation-href=\"query.queryDsl\">Elasticsearch Query DSL</a>.\n        </p>\n      </div>\n    </div>\n\n    <!-- Label -->\n    <div class=\"kuiVerticalRhythm\">\n      <div class=\"kuiVerticalRhythmSmall\">\n        <label\n          class=\"kuiLabel\"\n          for=\"filterEditorLabelInput\"\n        >\n          Label\n        </label>\n      </div>\n\n      <input\n        class=\"kuiTextInput kuiVerticalRhythmSmall\"\n        placeholder=\"Optional\"\n        type=\"text\"\n        ng-model=\"filterEditor.alias\"\n        id=\"filterEditorLabelInput\"\n      />\n    </div>\n  </div>\n\n  <!-- Footer -->\n  <div class=\"kuiModalFooter kuiBar\">\n    <div class=\"kuiBarSection\" ng-hide=\"filterEditor.filter.meta.isNew\">\n      <button\n        class=\"kuiButton kuiButton--danger\"\n        ng-click=\"filterEditor.onDelete()\"\n        aria-label=\"Delete filter\"\n      >\n        <span\n          class=\"kuiIcon fa-trash\"\n          aria-hidden=\"true\"\n        ></span>\n      </button>\n    </div>\n\n    <div class=\"kuiBarSection\">\n      <button\n        class=\"kuiButton kuiButton--basic\"\n        ng-click=\"filterEditor.onCancel()\"\n      >\n        Cancel\n      </button>\n      <button\n        class=\"kuiButton kuiButton--primary\"\n        ng-disabled=\"!filterEditor.isValid()\"\n        ng-click=\"filterEditor.save()\"\n        data-test-subj=\"saveFilter\"\n      >\n        Save\n      </button>\n    </div>\n  </div>\n</div>\n"

/***/ }),
/* 2113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _documentation_links = __webpack_require__(475);

Object.defineProperty(exports, 'ELASTIC_WEBSITE_URL', {
  enumerable: true,
  get: function get() {
    return _documentation_links.ELASTIC_WEBSITE_URL;
  }
});
Object.defineProperty(exports, 'DOC_LINK_VERSION', {
  enumerable: true,
  get: function get() {
    return _documentation_links.DOC_LINK_VERSION;
  }
});
Object.defineProperty(exports, 'documentationLinks', {
  enumerable: true,
  get: function get() {
    return _documentation_links.documentationLinks;
  }
});

/***/ }),
/* 2114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(476);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _modules = __webpack_require__(2);

var _filter_query_dsl_editor = __webpack_require__(2118);

var _filter_query_dsl_editor2 = _interopRequireDefault(_filter_query_dsl_editor);

__webpack_require__(477);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');
_module.directive('filterQueryDslEditor', function () {
  return {
    restrict: 'E',
    template: _filter_query_dsl_editor2.default,
    scope: {
      isVisible: '=',
      filter: '=',
      onChange: '&'
    },
    link: {
      pre: function pre($scope) {
        var aceEditor = void 0;

        $scope.queryDsl = _lodash2.default.omit($scope.filter, ['meta', '$state']);
        $scope.aceLoaded = function (editor) {
          aceEditor = editor;
          editor.$blockScrolling = Infinity;
          var session = editor.getSession();
          session.setTabSize(2);
          session.setUseSoftTabs(true);
        };

        $scope.$watch('isVisible', function (isVisible) {
          // Tell the editor to re-render itself now that it's visible, otherwise it won't
          // show up in the UI.
          if (isVisible && aceEditor) {
            aceEditor.renderer.updateFull();
          }
        });
      }
    }
  };
});

/***/ }),
/* 2115 */,
/* 2116 */,
/* 2117 */,
/* 2118 */
/***/ (function(module, exports) {

module.exports = "<div\n  json-input\n  require-keys=\"true\"\n  kbn-ui-ace-keyboard-mode\n  ui-ace=\"{\n    mode: 'json',\n    onLoad: aceLoaded\n  }\"\n  ng-model=\"queryDsl\"\n  ng-change=\"onChange({\n    queryDsl: queryDsl\n  })\"\n></div>\n"

/***/ }),
/* 2119 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 2120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(253);

var _modules = __webpack_require__(2);

var _filter_editor_utils = __webpack_require__(478);

var _filter_field_select = __webpack_require__(2123);

var _filter_field_select2 = _interopRequireDefault(_filter_field_select);

__webpack_require__(254);

__webpack_require__(255);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');
_module.directive('filterFieldSelect', function () {
  return {
    restrict: 'E',
    template: _filter_field_select2.default,
    scope: {
      indexPatterns: '=',
      field: '=',
      onSelect: '&'
    },
    link: function link($scope) {
      $scope.$watch('indexPatterns', function (indexPatterns) {
        $scope.fieldOptions = (0, _filter_editor_utils.getFieldOptions)(indexPatterns);
      });

      $scope.getFieldIndexPattern = function (field) {
        return field.indexPattern.title;
      };
    }
  };
});

/***/ }),
/* 2121 */,
/* 2122 */,
/* 2123 */
/***/ (function(module, exports) {

module.exports = "<ui-select\n  ng-model=\"field\"\n  ui-select-focus-on=\"focus-field\"\n  on-select=\"onSelect({ field: field })\"\n>\n  <ui-select-match placeholder=\"Fields...\">\n    <span\n      class=\"uiSelectMatch--ellipsis\"\n      tooltip=\"{{$select.selected.name}}\"\n    >\n      {{$select.selected.name}}\n    </span>\n  </ui-select-match>\n  <ui-select-choices\n    class=\"uiSelectChoices--autoWidth\"\n    repeat=\"field in fieldOptions\n      | filter:{ name: $select.search }\n      | orderBy:'name'\n      | sortPrefixFirst:$select.search:'name'\"\n    group-by=\"getFieldIndexPattern\"\n  >\n    <div ng-bind-html=\"field.name | highlight: $select.search\"></div>\n  </ui-select-choices>\n</ui-select>\n"

/***/ }),
/* 2124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sortPrefixFirst = sortPrefixFirst;

var _lodash = __webpack_require__(1);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function sortPrefixFirst(array, prefix, property) {
  if (!prefix) return array;
  var lowerCasePrefix = ('' + prefix).toLowerCase();

  var partitions = (0, _lodash.partition)(array, function (entry) {
    var value = ('' + (property ? entry[property] : entry)).toLowerCase();
    return value.startsWith(lowerCasePrefix);
  });
  return [].concat(_toConsumableArray(partitions[0]), _toConsumableArray(partitions[1]));
}

/***/ }),
/* 2125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(253);

var _modules = __webpack_require__(2);

var _filter_editor_utils = __webpack_require__(478);

var _filter_operator_select = __webpack_require__(2126);

var _filter_operator_select2 = _interopRequireDefault(_filter_operator_select);

__webpack_require__(254);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');
_module.directive('filterOperatorSelect', function () {
  return {
    restrict: 'E',
    template: _filter_operator_select2.default,
    scope: {
      field: '=',
      operator: '=',
      onSelect: '&'
    },
    link: function link($scope) {
      $scope.$watch('field', function (field) {
        $scope.operatorOptions = (0, _filter_editor_utils.getOperatorOptions)(field);
      });
    }
  };
});

/***/ }),
/* 2126 */
/***/ (function(module, exports) {

module.exports = "<ui-select\n  ng-model=\"operator\"\n  ui-select-focus-on=\"focus-operator\"\n  on-select=\"onSelect({ operator: operator })\"\n>\n  <ui-select-match placeholder=\"Operators...\">\n    {{$select.selected.name}}\n  </ui-select-match>\n  <ui-select-choices repeat=\"operator in operatorOptions | filter:{ name: $select.search }\">\n    <div ng-bind-html=\"operator.name | highlight: $select.search\"></div>\n  </ui-select-choices>\n</ui-select>\n"

/***/ }),
/* 2127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _filter_params_editor = __webpack_require__(2128);

var _filter_params_editor2 = _interopRequireDefault(_filter_params_editor);

__webpack_require__(2129);

__webpack_require__(2132);

__webpack_require__(2134);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');
_module.directive('filterParamsEditor', function () {
  return {
    restrict: 'E',
    template: _filter_params_editor2.default,
    scope: {
      field: '=',
      operator: '=',
      params: '='
    }
  };
});

/***/ }),
/* 2128 */
/***/ (function(module, exports) {

module.exports = "<ng-switch on=\"operator.type\">\n  <filter-params-phrase-editor\n    ng-switch-when=\"phrase\"\n    field=\"field\"\n    params=\"params\"\n  ></filter-params-phrase-editor>\n\n  <filter-params-phrases-editor\n    ng-switch-when=\"phrases\"\n    field=\"field\"\n    params=\"params\"\n  ></filter-params-phrases-editor>\n\n  <filter-params-range-editor\n    ng-switch-when=\"range\"\n    field=\"field\"\n    params=\"params\"\n  ></filter-params-range-editor>\n</ng-switch>\n"

/***/ }),
/* 2129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(253);

var _modules = __webpack_require__(2);

var _filter_params_phrase_editor = __webpack_require__(2130);

var _filter_params_phrase_editor2 = _interopRequireDefault(_filter_params_phrase_editor);

var _filter_params_phrase_controller = __webpack_require__(781);

__webpack_require__(782);

__webpack_require__(118);

__webpack_require__(254);

__webpack_require__(481);

__webpack_require__(255);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');
_module.directive('filterParamsPhraseEditor', function () {
  return {
    restrict: 'E',
    template: _filter_params_phrase_editor2.default,
    scope: {
      field: '=',
      params: '='
    },
    controllerAs: 'filterParamsPhraseEditor',
    controller: _filter_params_phrase_controller.filterParamsPhraseController
  };
});

/***/ }),
/* 2130 */
/***/ (function(module, exports) {

module.exports = "<ui-select\n  ng-if=\"filterParamsPhraseEditor.shouldSuggestValues && field.aggregatable && field.type === 'string'\"\n  ng-model=\"params.phrase\"\n  ui-select-focus-on=\"focus-params\"\n  spinner-enabled=\"true\"\n  spinner-class=\"kuiIcon kuiIcon--basic fa-spinner fa-spin\"\n>\n  <ui-select-match placeholder=\"Values...\">\n    <span\n      class=\"uiSelectMatch--ellipsis\"\n      tooltip=\"{{$select.selected}}\"\n    >\n      {{$select.selected}}\n    </span>\n  </ui-select-match>\n  <ui-select-choices\n    class=\"uiSelectChoices--autoWidth\"\n    repeat=\"value in filterParamsPhraseEditor.compactUnion([$select.search, $select.selected], valueSuggestions) | filter:$select.search | sortPrefixFirst:$select.search\"\n    refresh=\"filterParamsPhraseEditor.refreshValueSuggestions($select.search)\"\n    refresh-delay=\"500\"\n  >\n    <div ng-bind=\"value\"></div>\n  </ui-select-choices>\n</ui-select>\n\n<filter-params-input-type\n  ng-if=\"!(filterParamsPhraseEditor.shouldSuggestValues && field.aggregatable && field.type === 'string')\"\n  placeholder=\"Value...\"\n  type=\"field.type\"\n  value=\"params.phrase\"\n  on-change=\"params.phrase = value\"\n  focus-on=\"focus-params\"\n></filter-params-input-type>\n\n<small>\n  <a\n    ng-if=\"field.type === 'date'\"\n    class=\"kuiLink\"\n    documentation-href=\"date.dateMath\"\n    target=\"_blank\"\n    rel=\"noopener noreferrer\"\n  >\n    Accepted date formats\n  </a>\n</small>\n"

/***/ }),
/* 2131 */
/***/ (function(module, exports) {

module.exports = "<div\n  ng-switch=\"type\"\n  class=\"kuiFieldGroupSection kuiFieldGroupSection--wide\"\n>\n  <input\n    ng-switch-when=\"string\"\n    type=\"text\"\n    placeholder=\"{{placeholder}}\"\n    class=\"kuiTextInput\"\n    ng-model=\"value\"\n    ng-change=\"onChange({ value: value })\"\n  />\n  <input\n    ng-switch-when=\"number\"\n    string-to-number\n    type=\"number\"\n    placeholder=\"{{placeholder}}\"\n    step=\"any\"\n    class=\"kuiTextInput\"\n    ng-model=\"value\"\n    ng-change=\"onChange({ value: value })\"\n  />\n  <input\n    ng-switch-when=\"date\"\n    type=\"text\"\n    placeholder=\"{{placeholder}}\"\n    validate-date-math\n    class=\"kuiTextInput\"\n    ng-model=\"value\"\n    ng-change=\"onChange({ value: value })\"\n  />\n  <input\n    ng-switch-when=\"ip\"\n    type=\"text\"\n    placeholder=\"{{placeholder}}\"\n    validate-ip\n    class=\"kuiTextInput\"\n    ng-model=\"value\"\n    ng-change=\"onChange({ value: value })\"\n  />\n  <div ng-switch-when=\"boolean\">\n    <select\n      class=\"kuiSelect\"\n      ng-model=\"value\"\n      ng-options=\"option for option in boolOptions\"\n      ng-change=\"onChange({ value: value })\"\n      ng-init=\"setDefaultBool()\"\n    ></select>\n  </div>\n</div>\n"

/***/ }),
/* 2132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(253);

var _modules = __webpack_require__(2);

var _filter_params_phrases_editor = __webpack_require__(2133);

var _filter_params_phrases_editor2 = _interopRequireDefault(_filter_params_phrases_editor);

var _filter_params_phrase_controller = __webpack_require__(781);

__webpack_require__(254);

__webpack_require__(255);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');
_module.directive('filterParamsPhrasesEditor', function () {
  return {
    restrict: 'E',
    template: _filter_params_phrases_editor2.default,
    scope: {
      field: '=',
      params: '='
    },
    controllerAs: 'filterParamsPhrasesEditor',
    controller: _filter_params_phrase_controller.filterParamsPhraseController
  };
});

/***/ }),
/* 2133 */
/***/ (function(module, exports) {

module.exports = "<ui-select\n  ng-model=\"params.phrases\"\n  multiple\n  ui-select-focus-on=\"focus-params\"\n  spinner-enabled=\"true\"\n  spinner-class=\"kuiIcon kuiIcon--basic fa-spinner fa-spin\"\n>\n  <ui-select-match\n    placeholder=\"Values...\"\n    class=\"uiSelectMatch--restrictToParent\"\n  >\n    <span\n      data-test-subj=\"filterEditorPhrases\"\n      class=\"uiSelectMatch--pillWithTooltip\"\n      tooltip=\"{{$item}}\"\n    >\n      {{$item}}\n    </span>\n  </ui-select-match>\n  <ui-select-choices\n    class=\"uiSelectChoices--autoWidth\"\n    repeat=\"value in filterParamsPhrasesEditor.compactUnion([$select.search], valueSuggestions) | filter:$select.search | sortPrefixFirst:$select.search\"\n    refresh=\"filterParamsPhrasesEditor.refreshValueSuggestions($select.search)\"\n    refresh-delay=\"500\"\n  >\n    <div ng-bind-html=\"value | highlight: $select.search\"></div>\n  </ui-select-choices>\n</ui-select>\n"

/***/ }),
/* 2134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _filter_params_range_editor = __webpack_require__(2135);

var _filter_params_range_editor2 = _interopRequireDefault(_filter_params_range_editor);

__webpack_require__(782);

__webpack_require__(118);

__webpack_require__(481);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');
_module.directive('filterParamsRangeEditor', function () {
  return {
    restrict: 'E',
    template: _filter_params_range_editor2.default,
    scope: {
      field: '=',
      params: '='
    }
  };
});

/***/ }),
/* 2135 */
/***/ (function(module, exports) {

module.exports = "<div class=\"kuiVerticalRhythm\">\n  <filter-params-input-type\n    placeholder=\"From...\"\n    type=\"field.type\"\n    value=\"params.range.from\"\n    on-change=\"params.range.from = value\"\n    focus-on=\"focus-params\"\n  ></filter-params-input-type>\n</div>\n\n<div class=\"kuiVerticalRhythm\">\n  <filter-params-input-type\n    placeholder=\"To...\"\n    type=\"field.type\"\n    value=\"params.range.to\"\n    on-change=\"params.range.to = value\"\n  ></filter-params-input-type>\n</div>\n\n<small>\n  <a\n    ng-if=\"field.type === 'date'\"\n    class=\"kuiLink\"\n    documentation-href=\"date.dateMath\"\n    target=\"_blank\"\n    rel=\"noopener noreferrer\"\n  >\n    Accepted date formats\n  </a>\n</small>\n"

/***/ }),
/* 2136 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 2137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _exists = __webpack_require__(785);

Object.defineProperty(exports, 'buildExistsFilter', {
  enumerable: true,
  get: function get() {
    return _exists.buildExistsFilter;
  }
});

var _phrase = __webpack_require__(175);

Object.defineProperty(exports, 'buildPhraseFilter', {
  enumerable: true,
  get: function get() {
    return _phrase.buildPhraseFilter;
  }
});

var _phrases = __webpack_require__(482);

Object.defineProperty(exports, 'buildPhrasesFilter', {
  enumerable: true,
  get: function get() {
    return _phrases.buildPhrasesFilter;
  }
});

var _query = __webpack_require__(786);

Object.defineProperty(exports, 'buildQueryFilter', {
  enumerable: true,
  get: function get() {
    return _query.buildQueryFilter;
  }
});

var _range = __webpack_require__(117);

Object.defineProperty(exports, 'buildRangeFilter', {
  enumerable: true,
  get: function get() {
    return _range.buildRangeFilter;
  }
});

/***/ }),
/* 2138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _filter_pill = __webpack_require__(2139);

var _filter_pill2 = _interopRequireDefault(_filter_pill);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');

_module.directive('filterPill', function () {
  return {
    template: _filter_pill2.default,
    restrict: 'E',
    scope: {
      filter: '=',
      onToggleFilter: '=',
      onPinFilter: '=',
      onInvertFilter: '=',
      onDeleteFilter: '=',
      onEditFilter: '='
    },
    bindToController: true,
    controllerAs: 'pill',
    controller: function filterPillController() {
      var _this = this;

      this.activateActions = function () {
        _this.areActionsActivated = true;
      };

      this.deactivateActions = function () {
        _this.areActionsActivated = false;
      };
    }
  };
});

/***/ }),
/* 2139 */
/***/ (function(module, exports) {

module.exports = "<div\n  class=\"filter\"\n  ng-class=\"{ negate: pill.filter.meta.negate, disabled: pill.filter.meta.disabled }\"\n  data-test-subj=\"filter filter-{{ pill.filter.meta.disabled ? 'disabled' : 'enabled' }} {{ pill.filter.meta.key ? 'filter-key-' + pill.filter.meta.key : '' }} {{ pill.filter.meta.value ? 'filter-value-' + pill.filter.meta.value : '' }}\"\n  ng-mouseover=\"pill.activateActions()\"\n  ng-mouseleave=\"pill.deactivateActions()\"\n>\n\n  <div\n    class=\"filter-description\"\n    ng-class=\"{'filter-description-deactivated': pill.areActionsActivated}\"\n    tabindex=\"0\"\n    aria-disabled=\"{{pill.filter.meta.disabled}}\"\n  >\n    <span ng-if=\"pill.filter.$state.store == 'globalState'\"><i class=\"fa fa-fw fa-thumb-tack pinned\"></i></span>\n    <span ng-if=\"pill.filter.meta.negate\">NOT</span>\n    <span ng-if=\"pill.filter.meta.alias\">{{ pill.filter.meta.alias }}</span>\n    <span ng-if=\"!pill.filter.meta.alias\">{{ pill.filter.meta.key }}:</span>\n    <span ng-if=\"!pill.filter.meta.alias\">\"{{ pill.filter.meta.value }}\"</span>\n  </div>\n\n  <div class=\"filter-actions\" ng-class=\"{'filter-actions-activated': pill.areActionsActivated}\">\n    <button\n      class=\"action filter-toggle\"\n      ng-click=\"pill.onToggleFilter(pill.filter)\"\n      data-test-subj=\"disableFilter-{{ pill.filter.meta.key }}\"\n      ng-focus=\"pill.activateActions()\"\n      ng-blur=\"pill.deactivateActions()\"\n      aria-label=\"{{pill.filter.meta.disabled ? 'Enable filter' : 'Disable filter'}}\"\n    >\n      <i ng-show=\"pill.filter.meta.disabled\" class=\"fa fa-fw fa-square-o disabled\"></i>\n      <i ng-hide=\"pill.filter.meta.disabled\" class=\"fa fa-fw fa-check-square-o enabled\"></i>\n    </button>\n\n    <button\n      class=\"action filter-pin\"\n      ng-click=\"pill.onPinFilter(pill.filter)\"\n      data-test-subj=\"pinFilter-{{ pill.filter.meta.key }}\"\n      ng-focus=\"pill.activateActions()\"\n      ng-blur=\"pill.deactivateActions()\"\n      aria-label=\"{{pill.filter.$state.store == 'globalState' ? 'Unpin filter' : 'Pin filter'}}\"\n    >\n      <i ng-show=\"pill.filter.$state.store == 'globalState'\" class=\"fa fa-fw fa-thumb-tack pinned\"></i>\n      <i ng-hide=\"pill.filter.$state.store == 'globalState'\" class=\"fa fa-fw fa-thumb-tack fa-rotate-270 unpinned\"></i>\n    </button>\n\n    <button\n      class=\"action filter-invert\"\n      ng-click=\"pill.onInvertFilter(pill.filter)\"\n      data-test-subj=\"invertFilter-{{ pill.filter.meta.key }}\"\n      ng-focus=\"pill.activateActions()\"\n      ng-blur=\"pill.deactivateActions()\"\n      aria-label=\"Invert filter\"\n    >\n      <i ng-show=\"pill.filter.meta.negate\" class=\"fa fa-fw fa-search-plus negative\"></i>\n      <i ng-hide=\"pill.filter.meta.negate\" class=\"fa fa-fw fa-search-minus positive\"></i>\n    </button>\n\n    <button\n      class=\"action filter-remove\"\n      ng-click=\"pill.onDeleteFilter(pill.filter)\"\n      ng-focus=\"pill.activateActions()\"\n      ng-blur=\"pill.deactivateActions()\"\n      aria-label=\"Remove filter\"\n    >\n      <i class=\"fa fa-fw fa-trash\" data-test-subj=\"removeFilter-{{ pill.filter.meta.key }}\"></i>\n    </button>\n\n    <button\n      class=\"action filter-edit\"\n      ng-click=\"pill.onEditFilter(pill.filter)\"\n      ng-focus=\"pill.activateActions()\"\n      ng-blur=\"pill.deactivateActions()\"\n      aria-label=\"Edit filter\"\n      data-test-subj=\"editFilter\"\n    >\n      <i class=\"fa fa-fw fa-edit\"></i>\n    </button>\n\n  </div>\n</div>\n"

/***/ }),
/* 2140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.filterAppliedAndUnwrap = filterAppliedAndUnwrap;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function filterAppliedAndUnwrap(filters) {
  return _lodash2.default.filter(filters, 'meta.apply');
}

/***/ }),
/* 2141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FilterBarLibMapFilterProvider = FilterBarLibMapFilterProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _generate_mapping_chain = __webpack_require__(2142);

var _map_match_all = __webpack_require__(2143);

var _map_phrase = __webpack_require__(2144);

var _map_phrases = __webpack_require__(2145);

var _map_range = __webpack_require__(2146);

var _map_exists = __webpack_require__(2147);

var _map_missing = __webpack_require__(2148);

var _map_query_string = __webpack_require__(2149);

var _map_geo_bounding_box = __webpack_require__(2150);

var _map_geo_polygon = __webpack_require__(2151);

var _map_default = __webpack_require__(2152);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function FilterBarLibMapFilterProvider(Promise, Private) {

  var generateMappingChain = Private(_generate_mapping_chain.FilterBarLibGenerateMappingChainProvider);

  /** Mappers **/

  // Each mapper is a simple promise function that test if the mapper can
  // handle the mapping or not. If it handles it then it will resolve with
  // and object that has the key and value for the filter. Otherwise it will
  // reject it with the original filter. We had to go down the promise interface
  // because mapTerms and mapRange need access to the indexPatterns to format
  // the values and that's only available through the field formatters.

  // The mappers to apply. Each mapper will either return
  // a result object with a key and value attribute or
  // undefined. If undefined is return then the next
  // mapper will get the opportunity to map the filter.
  // To create a new mapper you just need to create a function
  // that either handles the mapping operation or not
  // and add it here. ProTip: These are executed in order listed
  var mappers = [Private(_map_match_all.FilterBarLibMapMatchAllProvider), Private(_map_range.FilterBarLibMapRangeProvider), Private(_map_phrase.FilterBarLibMapPhraseProvider), Private(_map_phrases.FilterBarLibMapPhrasesProvider), Private(_map_exists.FilterBarLibMapExistsProvider), Private(_map_missing.FilterBarLibMapMissingProvider), Private(_map_query_string.FilterBarLibMapQueryStringProvider), Private(_map_geo_bounding_box.FilterBarLibMapGeoBoundingBoxProvider), Private(_map_geo_polygon.FilterBarLibMapGeoPolygonProvider), Private(_map_default.FilterBarLibMapDefaultProvider)];

  var noop = function noop() {
    return Promise.reject(new Error('No mappings have been found for filter.'));
  };

  // Create a chain of responsibility by reducing all the
  // mappers down into one function.
  var mapFn = _lodash2.default.reduceRight(mappers, function (memo, map) {
    var filterChainFn = generateMappingChain(map);
    return filterChainFn(memo);
  }, noop);

  /**
   * Map the filter into an object with the key and value exposed so it's
   * easier to work with in the template
   * @param {object} filter The filter the map
   * @returns {Promise}
   */
  return function (filter) {
    // Apply the mapping function
    return mapFn(filter).then(function (result) {
      filter.meta = filter.meta || {};
      filter.meta.type = result.type;
      filter.meta.key = result.key;
      filter.meta.value = result.value;
      filter.meta.params = result.params;
      filter.meta.disabled = !!filter.meta.disabled;
      filter.meta.negate = !!filter.meta.negate;
      filter.meta.alias = filter.meta.alias || null;
      return filter;
    });
  };
}

/***/ }),
/* 2142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FilterBarLibGenerateMappingChainProvider = FilterBarLibGenerateMappingChainProvider;
function FilterBarLibGenerateMappingChainProvider(Promise) {

  var noop = function noop() {
    return Promise.reject(new Error('No mappings have been found for filter.'));
  };

  return function (fn) {
    return function (next) {
      next = next || noop;
      return function (filter) {
        return fn(filter).catch(function (result) {
          if (result === filter) {
            return next(filter);
          }
          return Promise.reject(result);
        });
      };
    };
  };
}

/***/ }),
/* 2143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FilterBarLibMapMatchAllProvider = FilterBarLibMapMatchAllProvider;
function FilterBarLibMapMatchAllProvider(Promise) {
  return function (filter) {
    if (filter.match_all) {
      var type = 'match_all';
      var key = filter.meta.field;
      var value = filter.meta.formattedValue || 'all';
      return Promise.resolve({ type: type, key: key, value: value });
    }
    return Promise.reject(filter);
  };
}

/***/ }),
/* 2144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FilterBarLibMapPhraseProvider = FilterBarLibMapPhraseProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _errors = __webpack_require__(37);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function FilterBarLibMapPhraseProvider(Promise, courier) {
  return function (filter) {
    var isScriptedPhraseFilter = isScriptedPhrase(filter);
    if (!_lodash2.default.has(filter, ['query', 'match']) && !isScriptedPhraseFilter) {
      return Promise.reject(filter);
    }

    function getParams(indexPattern) {
      var type = 'phrase';
      var key = isScriptedPhraseFilter ? filter.meta.field : Object.keys(filter.query.match)[0];
      var params = isScriptedPhraseFilter ? filter.script.script.params : filter.query.match[key];
      var query = isScriptedPhraseFilter ? params.value : params.query;

      // Sometimes a filter will end up with an invalid index param. This could happen for a lot of reasons,
      // for example a user might manually edit the url or the index pattern's ID might change due to
      // external factors e.g. a reindex. We only need the index in order to grab the field formatter, so we fallback
      // on displaying the raw value if the index is invalid.
      var value = indexPattern ? indexPattern.fields.byName[key].format.convert(query) : query;
      return { type: type, key: key, value: value, params: params };
    }

    return courier.indexPatterns.get(filter.meta.index).then(getParams).catch(function (error) {
      if (error instanceof _errors.SavedObjectNotFound) {
        return getParams();
      }
      throw error;
    });
  };
}

function isScriptedPhrase(filter) {
  var params = _lodash2.default.get(filter, ['script', 'script', 'params']);
  return params && params.value;
}

/***/ }),
/* 2145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FilterBarLibMapPhrasesProvider = FilterBarLibMapPhrasesProvider;
function FilterBarLibMapPhrasesProvider(Promise) {
  return function (filter) {
    var _filter$meta = filter.meta,
        type = _filter$meta.type,
        key = _filter$meta.key,
        value = _filter$meta.value,
        params = _filter$meta.params;

    if (type !== 'phrases') {
      return Promise.reject(filter);
    } else {
      return Promise.resolve({ type: type, key: key, value: value, params: params });
    }
  };
}

/***/ }),
/* 2146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FilterBarLibMapRangeProvider = FilterBarLibMapRangeProvider;

var _lodash = __webpack_require__(1);

var _errors = __webpack_require__(37);

function FilterBarLibMapRangeProvider(Promise, courier) {
  return function (filter) {
    var isScriptedRangeFilter = isScriptedRange(filter);
    if (!filter.range && !isScriptedRangeFilter) {
      return Promise.reject(filter);
    }

    function getParams(indexPattern) {
      var type = 'range';
      var key = isScriptedRangeFilter ? filter.meta.field : Object.keys(filter.range)[0];
      var params = isScriptedRangeFilter ? filter.script.script.params : filter.range[key];

      var left = (0, _lodash.has)(params, 'gte') ? params.gte : params.gt;
      if (left == null) left = -Infinity;

      var right = (0, _lodash.has)(params, 'lte') ? params.lte : params.lt;
      if (right == null) right = Infinity;

      // Sometimes a filter will end up with an invalid index param. This could happen for a lot of reasons,
      // for example a user might manually edit the url or the index pattern's ID might change due to
      // external factors e.g. a reindex. We only need the index in order to grab the field formatter, so we fallback
      // on displaying the raw value if the index is invalid.
      var value = left + ' to ' + right;
      if (indexPattern) {
        var convert = indexPattern.fields.byName[key].format.getConverterFor('text');
        value = convert(left) + ' to ' + convert(right);
      }

      return { type: type, key: key, value: value, params: params };
    }

    return courier.indexPatterns.get(filter.meta.index).then(getParams).catch(function (error) {
      if (error instanceof _errors.SavedObjectNotFound) {
        return getParams();
      }
      throw error;
    });
  };
}

function isScriptedRange(filter) {
  var params = (0, _lodash.get)(filter, ['script', 'script', 'params']);
  return params && Object.keys(params).find(function (key) {
    return ['gte', 'gt', 'lte', 'lt'].includes(key);
  });
}

/***/ }),
/* 2147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FilterBarLibMapExistsProvider = FilterBarLibMapExistsProvider;
function FilterBarLibMapExistsProvider(Promise) {
  return function (filter) {
    if (filter.exists) {
      var type = 'exists';
      var key = filter.exists.field;
      var value = type;
      return Promise.resolve({ type: type, key: key, value: value });
    }
    return Promise.reject(filter);
  };
}

/***/ }),
/* 2148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FilterBarLibMapMissingProvider = FilterBarLibMapMissingProvider;
function FilterBarLibMapMissingProvider(Promise) {
  return function (filter) {
    if (filter.missing) {
      var type = 'missing';
      var key = filter.missing.field;
      var value = type;
      return Promise.resolve({ type: type, key: key, value: value });
    }
    return Promise.reject(filter);
  };
}

/***/ }),
/* 2149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FilterBarLibMapQueryStringProvider = FilterBarLibMapQueryStringProvider;
function FilterBarLibMapQueryStringProvider(Promise) {
  return function (filter) {
    if (filter.query && filter.query.query_string) {
      var type = 'query_string';
      var key = 'query';
      var value = filter.query.query_string.query;
      return Promise.resolve({ type: type, key: key, value: value });
    }
    return Promise.reject(filter);
  };
}

/***/ }),
/* 2150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FilterBarLibMapGeoBoundingBoxProvider = FilterBarLibMapGeoBoundingBoxProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _errors = __webpack_require__(37);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function FilterBarLibMapGeoBoundingBoxProvider(Promise, courier) {
  return function (filter) {
    if (filter.geo_bounding_box) {
      var getParams = function getParams(indexPattern) {
        var type = 'geo_bounding_box';
        var key = _lodash2.default.keys(filter.geo_bounding_box).filter(function (key) {
          return key !== 'ignore_unmapped';
        })[0];
        var params = filter.geo_bounding_box[key];

        // Sometimes a filter will end up with an invalid index param. This could happen for a lot of reasons,
        // for example a user might manually edit the url or the index pattern's ID might change due to
        // external factors e.g. a reindex. We only need the index in order to grab the field formatter, so we fallback
        // on displaying the raw value if the index is invalid.
        var topLeft = indexPattern ? indexPattern.fields.byName[key].format.convert(params.top_left) : JSON.stringify(params.top_left);
        var bottomRight = indexPattern ? indexPattern.fields.byName[key].format.convert(params.bottom_right) : JSON.stringify(params.bottom_right);
        var value = topLeft + ' to ' + bottomRight;
        return { type: type, key: key, value: value, params: params };
      };

      return courier.indexPatterns.get(filter.meta.index).then(getParams).catch(function (error) {
        if (error instanceof _errors.SavedObjectNotFound) {
          return getParams();
        }
        throw error;
      });
    }
    return Promise.reject(filter);
  };
}

/***/ }),
/* 2151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FilterBarLibMapGeoPolygonProvider = FilterBarLibMapGeoPolygonProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _errors = __webpack_require__(37);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function FilterBarLibMapGeoPolygonProvider(Promise, courier) {
  return function (filter) {
    if (filter.geo_polygon) {
      var getParams = function getParams(indexPattern) {
        var type = 'geo_polygon';
        var key = _lodash2.default.keys(filter.geo_polygon).filter(function (key) {
          return key !== 'ignore_unmapped';
        })[0];
        var params = filter.geo_polygon[key];

        // Sometimes a filter will end up with an invalid index param. This could happen for a lot of reasons,
        // for example a user might manually edit the url or the index pattern's ID might change due to
        // external factors e.g. a reindex. We only need the index in order to grab the field formatter, so we fallback
        // on displaying the raw value if the index is invalid.
        var points = params.points.map(function (point) {
          return indexPattern ? indexPattern.fields.byName[key].format.convert(point) : JSON.stringify(point);
        });
        var value = points.join(', ');
        return { type: type, key: key, value: value, params: params };
      };

      return courier.indexPatterns.get(filter.meta.index).then(getParams).catch(function (error) {
        if (error instanceof _errors.SavedObjectNotFound) {
          return getParams();
        }
        throw error;
      });
    }
    return Promise.reject(filter);
  };
}

/***/ }),
/* 2152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FilterBarLibMapDefaultProvider = FilterBarLibMapDefaultProvider;

var _angular = __webpack_require__(16);

var _angular2 = _interopRequireDefault(_angular);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function FilterBarLibMapDefaultProvider(Promise) {

  var metaProperty = /(^\$|meta)/;

  return function (filter) {
    var key = _lodash2.default.find(_lodash2.default.keys(filter), function (key) {
      return !key.match(metaProperty);
    });

    if (key) {
      var type = 'custom';
      var value = _angular2.default.toJson(filter[key]);
      return Promise.resolve({ type: type, key: key, value: value });
    }

    return Promise.reject(filter);
  };
}

/***/ }),
/* 2153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FilterBarLibMapFlattenAndWrapFiltersProvider = FilterBarLibMapFlattenAndWrapFiltersProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _map_and_flatten_filters = __webpack_require__(327);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function FilterBarLibMapFlattenAndWrapFiltersProvider(Private) {
  var mapAndFlattenFilters = Private(_map_and_flatten_filters.FilterBarLibMapAndFlattenFiltersProvider);
  return function (filters) {
    return mapAndFlattenFilters(filters).then(function (filters) {
      return _lodash2.default.map(filters, function (filter) {
        filter.meta = filter.meta || {};
        filter.meta.apply = true;
        return filter;
      });
    });
  };
}

/***/ }),
/* 2154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.onlyDisabled = onlyDisabled;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var pluckDisabled = function pluckDisabled(filter) {
  return _lodash2.default.get(filter, 'meta.disabled');
};

/**
 * Checks to see if only disabled filters have been changed
 * @returns {bool} Only disabled filters
 */
function onlyDisabled(newFilters, oldFilters) {
  return _lodash2.default.every(newFilters.concat(oldFilters), function (newFilter) {
    return pluckDisabled(newFilter);
  });
}

/***/ }),
/* 2155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.onlyStateChanged = onlyStateChanged;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _compare_filters = __webpack_require__(328);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var compareOptions = { disabled: true, negate: true };

/**
 * Checks to see if only disabled filters have been changed
 * @returns {bool} Only disabled filters
 */
function onlyStateChanged(newFilters, oldFilters) {
  return _lodash2.default.every(newFilters, function (newFilter) {
    var match = _lodash2.default.find(oldFilters, function (oldFilter) {
      return (0, _compare_filters.compareFilters)(newFilter, oldFilter, compareOptions);
    });
    return !!match;
  });
}

/***/ }),
/* 2156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FilterManagerProvider = FilterManagerProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _query_filter = __webpack_require__(119);

var _phrase = __webpack_require__(175);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Adds a filter to a passed state
function FilterManagerProvider(Private) {
  var queryFilter = Private(_query_filter.FilterBarQueryFilterProvider);
  var filterManager = {};

  filterManager.generate = function (field, values, operation, index) {
    values = Array.isArray(values) ? values : [values];
    var fieldName = _lodash2.default.isObject(field) ? field.name : field;
    var filters = _lodash2.default.flatten([queryFilter.getAppFilters()]);
    var newFilters = [];

    var negate = operation === '-';

    // TODO: On array fields, negating does not negate the combination, rather all terms
    _lodash2.default.each(values, function (value) {
      var filter = void 0;
      var existing = _lodash2.default.find(filters, function (filter) {
        if (!filter) return;

        if (fieldName === '_exists_' && filter.exists) {
          return filter.exists.field === value;
        }

        if (_lodash2.default.has(filter, 'query.match')) {
          return filter.query.match[fieldName] && filter.query.match[fieldName].query === value;
        }

        if (filter.script) {
          return filter.meta.field === fieldName && filter.script.script.params.value === value;
        }
      });

      if (existing) {
        existing.meta.disabled = false;
        if (existing.meta.negate !== negate) {
          queryFilter.invertFilter(existing);
        }
        return;
      }

      switch (fieldName) {
        case '_exists_':
          filter = {
            meta: { negate: negate, index: index },
            exists: {
              field: value
            }
          };
          break;
        default:
          if (field.scripted) {
            filter = {
              meta: { negate: negate, index: index, field: fieldName },
              script: (0, _phrase.getPhraseScript)(field, value)
            };
          } else {
            filter = { meta: { negate: negate, index: index }, query: { match: {} } };
            filter.query.match[fieldName] = { query: value, type: 'phrase' };
          }

          break;
      }

      newFilters.push(filter);
    });

    return newFilters;
  };

  filterManager.add = function (field, values, operation, index) {
    var newFilters = this.generate(field, values, operation, index);
    return queryFilter.addFilters(newFilters);
  };

  return filterManager;
}

/***/ }),
/* 2157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(2158);

/***/ }),
/* 2158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

_modules.uiModules.get('kibana').run(function ($rootScope) {

  /**
   * Helper that registers an event listener, and removes that listener when
   * the $scope is destroyed.
   *
   * @param  {EventEmitter} emitter - the event emitter to listen to
   * @param  {string} eventName - the event name
   * @param  {Function} handler - the event handler
   * @return {undefined}
   */
  $rootScope.constructor.prototype.$listen = function (emitter, eventName, handler) {
    emitter.on(eventName, handler);
    this.$on('$destroy', function () {
      emitter.off(eventName, handler);
    });
  };
});

/***/ }),
/* 2159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(2160);

/***/ }),
/* 2160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _to_user = __webpack_require__(2161);

var _from_user = __webpack_require__(2162);

var _modules = __webpack_require__(2);

_modules.uiModules.get('kibana').directive('parseQuery', function (Private) {
  var fromUser = Private(_from_user.ParseQueryLibFromUserProvider);

  return {
    restrict: 'A',
    require: 'ngModel',
    scope: {
      'ngModel': '='
    },
    link: function link($scope, elem, attr, ngModel) {
      var init = function init() {
        $scope.ngModel = fromUser($scope.ngModel);
      };

      ngModel.$parsers.push(fromUser);
      ngModel.$formatters.push(_to_user.toUser);

      init();
    }
  };
});

/***/ }),
/* 2161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toUser = toUser;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _angular = __webpack_require__(16);

var _angular2 = _interopRequireDefault(_angular);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Take text from the model and present it to the user as a string
 * @param {text} model value
 * @returns {string}
 */
function toUser(text) {
  if (text == null) return '';
  if (_lodash2.default.isObject(text)) {
    if (text.match_all) return '';
    if (text.query_string) return toUser(text.query_string.query);
    return _angular2.default.toJson(text);
  }
  return '' + text;
}

/***/ }),
/* 2162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ParseQueryLibFromUserProvider = ParseQueryLibFromUserProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ParseQueryLibFromUserProvider() {

  /**
   * Take userInput from the user and make it into a query object
   * @param {userInput} user's query input
   * @returns {object}
   */
  return function (userInput) {
    var matchAll = '';

    if (_lodash2.default.isObject(userInput)) {
      // If we get an empty object, treat it as a *
      if (!Object.keys(userInput).length) {
        return matchAll;
      }
      return userInput;
    }

    // Nope, not an object.
    userInput = (userInput || '').trim();
    if (userInput.length === 0) return matchAll;

    if (userInput[0] === '{') {
      try {
        return JSON.parse(userInput);
      } catch (e) {
        return userInput;
      }
    } else {
      return userInput;
    }
  };
}

/***/ }),
/* 2163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(2164);

/***/ }),
/* 2164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_modules.uiModules.get('kibana/persisted_log').factory('PersistedLog', function ($window, localStorage) {
  function PersistedLog(name, options) {
    options = options || {};
    this.name = name;
    this.maxLength = parseInt(options.maxLength, 10);
    this.filterDuplicates = options.filterDuplicates || false;
    this.items = localStorage.get(this.name) || [];
    if (!isNaN(this.maxLength)) this.items = _lodash2.default.take(this.items, this.maxLength);
  }

  PersistedLog.prototype.add = function (val) {
    if (val == null) {
      return this.items;
    }

    // remove any matching items from the stack if option is set
    if (this.filterDuplicates) {
      _lodash2.default.remove(this.items, function (item) {
        return _lodash2.default.isEqual(item, val);
      });
    }

    this.items.unshift(val);

    // if maxLength is set, truncate the stack
    if (!isNaN(this.maxLength)) this.items = _lodash2.default.take(this.items, this.maxLength);

    // persist the stack
    localStorage.set(this.name, this.items);
    return this.items;
  };

  PersistedLog.prototype.get = function () {
    return this.items;
  };

  return PersistedLog;
});

/***/ }),
/* 2165 */
/***/ (function(module, exports) {

module.exports = "<confirm-modal\n  data-test-subj=\"confirmModal\"\n  on-cancel=\"onCancel\"\n  on-confirm=\"onConfirm\"\n  confirm-button-text=\"confirmButtonText\"\n  cancel-button-text=\"cancelButtonText\"\n  children=\"message\"\n  title=\"title\"\n  default-focused-button=\"defaultFocusedButton\"\n></confirm-modal>\n"

/***/ }),
/* 2166 */
/***/ (function(module, exports) {

module.exports = "<div class=\"euiOverlayMask\" data-test-subj=\"modalOverlay\"></div>\n"

/***/ }),
/* 2167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

__webpack_require__(484);

var _module = _modules.uiModules.get('kibana');

/**
 * @typedef {Object} PromisifiedConfirmOptions
 * @property {String} confirmButtonText
 * @property {String=} cancelButtonText
 */

/**
 * A "promisified" version of ConfirmModal that binds onCancel and onConfirm to
 * Resolve and Reject methods.
 */
_module.factory('confirmModalPromise', function (Promise, confirmModal) {
  /**
   * @param {String} message
   * @param {PromisifiedConfirmOptions} customOptions
   */
  return function (message, customOptions) {
    return new Promise(function (resolve, reject) {
      var defaultOptions = {
        onConfirm: resolve,
        onCancel: reject
      };
      var confirmOptions = Object.assign(defaultOptions, customOptions);
      confirmModal(message, confirmOptions);
    });
  };
});

/***/ }),
/* 2168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(2169);

/***/ }),
/* 2169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

__webpack_require__(301);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var $style = (0, _jquery2.default)('<style>').appendTo('head').attr('id', 'style-compile');

_modules.uiModules.get('kibana').run(function ($rootScope, $compile, config) {
  var truncateGradientHeight = 15;
  var template = _lodash2.default.template(__webpack_require__(2170));
  var locals = {};

  // watch the value of the truncate:maxHeight config param
  $rootScope.$watch(function () {
    return config.get('truncate:maxHeight');
  }, function (maxHeight) {
    if (maxHeight > 0) {
      locals.truncateMaxHeight = maxHeight + 'px !important';
      locals.truncateGradientTop = maxHeight - truncateGradientHeight + 'px';
    } else {
      locals.truncateMaxHeight = 'none';
      locals.truncateGradientTop = '-' + truncateGradientHeight + 'px';
    }

    $style.html(template(locals));
  });
});

/***/ }),
/* 2170 */
/***/ (function(module, exports) {

module.exports = ".truncate-by-height {\n  max-height: <%= truncateMaxHeight %>;\n  display: inline-block;\n}\n.truncate-by-height:before {\n  top: <%= truncateGradientTop %>;\n}\n"

/***/ }),
/* 2171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _timepicker = __webpack_require__(2172);

var _timepicker2 = _interopRequireDefault(_timepicker);

__webpack_require__(2173);

__webpack_require__(2176);

__webpack_require__(2179);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _relative_options = __webpack_require__(486);

var _parse_relative_parts = __webpack_require__(2182);

var _datemath = __webpack_require__(90);

var _datemath2 = _interopRequireDefault(_datemath);

var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

var _notifier = __webpack_require__(43);

__webpack_require__(2183);

__webpack_require__(794);

__webpack_require__(487);

__webpack_require__(2184);

__webpack_require__(795);

__webpack_require__(2185);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('ui/timepicker');
var notify = new _notifier.Notifier({
  location: 'timepicker'
});

_module.directive('kbnTimepicker', function (timeUnits, refreshIntervals) {
  return {
    restrict: 'E',
    scope: {
      from: '=',
      to: '=',
      mode: '=',
      interval: '=',
      activeTab: '=',
      onFilterSelect: '&',
      onIntervalSelect: '&'
    },
    template: _timepicker2.default,
    controller: function controller($scope) {
      $scope.format = 'MMMM Do YYYY, HH:mm:ss.SSS';
      $scope.modes = ['quick', 'relative', 'absolute'];
      $scope.activeTab = $scope.activeTab || 'filter';

      if (_lodash2.default.isUndefined($scope.mode)) $scope.mode = 'quick';

      $scope.refreshLists = (0, _lodash2.default)(refreshIntervals).groupBy('section').values().value();

      $scope.relative = {
        from: {
          count: 1,
          unit: 'm',
          preview: undefined,
          round: false
        },
        to: {
          count: 0,
          unit: 's',
          preview: undefined,
          round: false
        }
      };

      $scope.absolute = {
        from: (0, _moment2.default)(),
        to: (0, _moment2.default)()
      };

      $scope.units = timeUnits;

      $scope.relativeOptions = _relative_options.relativeOptions;

      $scope.$watch('from', function (date) {
        if (_moment2.default.isMoment(date) && $scope.mode === 'absolute') {
          $scope.absolute.from = date;
        }
      });

      $scope.$watch('to', function (date) {
        if (_moment2.default.isMoment(date) && $scope.mode === 'absolute') {
          $scope.absolute.to = date;
        }
      });

      // If we always return a new object from the getters below (pickFromDate and pickToDate) we'll create an
      // infinite digest loop, so we maintain these copies to return instead.
      $scope.$watch('absolute.from', function (newDate) {
        _lodash2.default.set($scope, 'browserAbsolute.from', new Date(newDate.year(), newDate.month(), newDate.date()));
      });

      $scope.$watch('absolute.to', function (newDate) {
        _lodash2.default.set($scope, 'browserAbsolute.to', new Date(newDate.year(), newDate.month(), newDate.date()));
      });

      // The datepicker directive uses native Javascript Dates, ignoring moment's default timezone. This causes
      // the datepicker and the text input above it to get out of sync if the user changed the `dateFormat:tz` config
      // in advanced settings. The text input will show the date in the user selected timezone, the datepicker will
      // show the date in the local browser timezone. Since we really just want a day, month, year from the datepicker
      // instead of a moment in time, we grab those individual values from the native date.
      $scope.pickFromDate = function (date) {
        if (!date) return _lodash2.default.get($scope, 'browserAbsolute.from');

        var defaultTimeZoneDate = (0, _moment2.default)({
          year: date.getFullYear(),
          month: date.getMonth(),
          day: date.getDate(),
          hour: 0,
          minute: 0,
          second: 0,
          millisecond: 0
        });
        return $scope.absolute.from = defaultTimeZoneDate;
      };

      $scope.pickToDate = function (date) {
        if (!date) return _lodash2.default.get($scope, 'browserAbsolute.to');

        var defaultTimeZoneDate = (0, _moment2.default)({
          year: date.getFullYear(),
          month: date.getMonth(),
          day: date.getDate(),
          hour: 23,
          minute: 59,
          second: 59,
          millisecond: 999
        });
        return $scope.absolute.to = defaultTimeZoneDate;
      };

      $scope.setMode = function (thisMode) {
        switch (thisMode) {
          case 'quick':
            break;
          case 'relative':
            $scope.relative = (0, _parse_relative_parts.parseRelativeParts)($scope.from, $scope.to);
            $scope.formatRelative('from');
            $scope.formatRelative('to');
            break;
          case 'absolute':
            $scope.absolute.from = _datemath2.default.parse($scope.from || (0, _moment2.default)().subtract(15, 'minutes'));
            $scope.absolute.to = _datemath2.default.parse($scope.to || (0, _moment2.default)(), true);
            break;
        }

        $scope.mode = thisMode;
      };

      $scope.setQuick = function (from, to) {
        $scope.onFilterSelect({ from: from, to: to });
      };

      $scope.setToNow = function (key) {
        $scope.absolute[key] = (0, _moment2.default)();
      };

      $scope.setRelativeToNow = function (key) {
        $scope.relative[key].count = 0;
        $scope.relative[key].round = false;
        $scope.formatRelative(key);
      };

      $scope.checkRelative = function () {
        if ($scope.relative.from.count != null && $scope.relative.to.count != null) {
          var from = _datemath2.default.parse(getRelativeString('from'));
          var to = _datemath2.default.parse(getRelativeString('to'), true);
          if (to && from) return to.isBefore(from);
          return true;
        }
      };

      $scope.formatRelative = function (key) {
        var relativeString = getRelativeString(key);
        var parsed = _datemath2.default.parse(relativeString, key === 'to');
        var preview = void 0;
        if (relativeString === 'now') {
          preview = 'Now';
        } else {
          preview = parsed ? parsed.format($scope.format) : undefined;
        }
        _lodash2.default.set($scope, 'relative.' + key + '.preview', preview);
        return parsed;
      };

      $scope.applyRelative = function () {
        $scope.onFilterSelect({
          from: getRelativeString('from'),
          to: getRelativeString('to')
        });
      };

      function getRelativeString(key) {
        var count = _lodash2.default.get($scope, 'relative.' + key + '.count', 0);
        var round = _lodash2.default.get($scope, 'relative.' + key + '.round', false);
        var matches = _lodash2.default.get($scope, 'relative.' + key + '.unit', 's').match(/([smhdwMy])(\+)?/);
        var unit = void 0;
        var operator = '-';
        if (matches && matches[1]) unit = matches[1];
        if (matches && matches[2]) operator = matches[2];
        if (count === 0 && !round) return 'now';
        var result = 'now' + operator + count + unit;
        result += round ? '/' + unit : '';
        return result;
      }

      $scope.applyAbsolute = function () {
        $scope.onFilterSelect({
          from: (0, _moment2.default)($scope.absolute.from),
          to: (0, _moment2.default)($scope.absolute.to)
        });
      };

      $scope.setRefreshInterval = function (interval) {
        interval = _lodash2.default.clone(interval || {});
        notify.log('before: ' + interval.pause);
        interval.pause = interval.pause == null || interval.pause === false ? false : true;

        notify.log('after: ' + interval.pause);

        $scope.onIntervalSelect({ interval: interval });
      };

      $scope.setMode($scope.mode);
    }
  };
});

/***/ }),
/* 2172 */
/***/ (function(module, exports) {

module.exports = "<div class=\"kbn-timepicker\" data-test-subj=\"timePicker\">\n\n  <div class=\"tab-content kbn-timepicker-content\">\n    <!-- Filters -->\n    <div ng-show=\"activeTab === 'filter'\" role=\"tabpanel\" class=\"tab-pane active\">\n      <div class=\"kbn-timepicker-title\">\n        <h2 class=\"kuiLocalDropdownTitle kbn-timepicker-title__text\">\n          Time Range\n        </h2>\n      </div>\n\n      <div class=\"kuiVerticalRhythmSmall\">\n        <div role=\"tablist\" class=\"euiTabs euiTabs--small kbn-timepicker-modes kbn-timepicker-title__section\">\n          <button\n            id=\"timepickerQuick\"\n            role=\"tab\"\n            class=\"euiTab\"\n            ng-class=\"{'euiTab-isSelected': mode === 'quick' }\"\n            ng-click=\"setMode('quick')\"\n            aria-selected=\"{{mode === 'quick'}}\"\n            data-test-subj=\"timepicker-quick-button\"\n          >\n            Quick\n          </button>\n\n          <button\n            id=\"timepickerRelative\"\n            role=\"tab\"\n            class=\"euiTab\"\n            ng-class=\"{'euiTab-isSelected': mode === 'relative' }\"\n            ng-click=\"setMode('relative')\"\n            aria-selected=\"{{mode === 'relative'}}\"\n            data-test-subj=\"timepicker-relative-button\"\n          >\n            Relative\n          </button>\n\n          <button\n            id=\"timepickerAbsolute\"\n            role=\"tab\"\n            class=\"euiTab\"\n            ng-class=\"{'euiTab-isSelected': mode === 'absolute' }\"\n            ng-click=\"setMode('absolute')\"\n            aria-selected=\"{{mode === 'absolute'}}\"\n            data-test-subj=\"timepicker-absolute-button\"\n          >\n            Absolute\n          </button>\n        </div>\n      </div>\n\n      <div\n        class=\"kuiVerticalRhythmSmall\"\n        ng-switch\n        on=\"mode\"\n      >\n        <kbn-timepicker-quick-panel\n          ng-switch-when=\"quick\"\n          set-quick=\"setQuick(from, to)\"\n          role=\"tabpanel\"\n          aria-labelledby=\"timepickerQuick\"\n        ></kbn-timepicker-quick-panel>\n\n        <kbn-timepicker-relative-panel\n          ng-switch-when=\"relative\"\n          apply-relative=\"applyRelative()\"\n          check-relative=\"checkRelative()\"\n          format-relative=\"formatRelative(key)\"\n          relative=\"relative\"\n          relative-options=\"relativeOptions\"\n          set-relative-to-now=\"setRelativeToNow(key)\"\n          units=\"units\"\n          role=\"tabpanel\"\n          aria-labelledby=\"timepickerRelative\"\n        ></kbn-timepicker-relative-panel>\n\n        <kbn-timepicker-absolute-panel\n          ng-switch-when=\"absolute\"\n          absolute=\"absolute\"\n          apply-absolute=\"applyAbsolute()\"\n          format=\"format\"\n          pick-from-date=\"pickFromDate\"\n          pick-to-date=\"pickToDate\"\n          set-to-now=\"setToNow(key)\"\n          role=\"tabpanel\"\n          aria-labelledby=\"timepickerAbsolute\"\n        ></kbn-timepicker-absolute-panel>\n      </div>\n    </div>\n\n    <!-- Refresh Intervals -->\n    <div ng-show=\"activeTab === 'interval'\" role=\"tabpanel\" class=\"tab-pane active\">\n      <h2 class=\"kuiLocalDropdownTitle\">\n        Refresh Interval\n      </h2>\n\n      <div ng-repeat=\"list in refreshLists\" class=\"kbn-refresh-section\">\n        <ul class=\"list-unstyled\">\n          <li ng-repeat=\"inter in list\">\n            <a\n              class=\"refresh-interval\"\n              ng-class=\"{ 'refresh-interval-active': interval.value === inter.value }\"\n              ng-click=\"setRefreshInterval(inter)\"\n              kbn-accessible-click\n            >\n              {{inter.display}}\n            </a>\n          </li>\n        </ul>\n      </div>\n    </div>\n  </div>\n</div>\n"

/***/ }),
/* 2173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(2174);

/***/ }),
/* 2174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _kbn_timepicker_quick_panel = __webpack_require__(2175);

var _kbn_timepicker_quick_panel2 = _interopRequireDefault(_kbn_timepicker_quick_panel);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('ui/timepicker');

_module.directive('kbnTimepickerQuickPanel', function (config) {
  return {
    restrict: 'E',
    replace: true,
    scope: {
      setQuick: '&'
    },
    template: _kbn_timepicker_quick_panel2.default,
    controller: function controller($scope) {
      var quickRanges = config.get('timepicker:quickRanges');
      $scope.quickLists = (0, _lodash2.default)(quickRanges).groupBy('section').values().value();
    }
  };
});

/***/ }),
/* 2175 */
/***/ (function(module, exports) {

module.exports = "<div class=\"kbn-timepicker-body\">\n  <div ng-repeat=\"list in quickLists\" class=\"kbn-timepicker-section\">\n    <ul class=\"list-unstyled\">\n      <li ng-repeat=\"option in list\">\n        <a\n          class=\"kuiLink\"\n          ng-click=\"setQuick({from: option.from, to: option.to})\"\n          ng-bind=\"::option.display\"\n          kbn-accessible-click\n        ></a>\n      </li>\n    </ul>\n  </div>\n</div>\n"

/***/ }),
/* 2176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(2177);

/***/ }),
/* 2177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _kbn_timepicker_relative_panel = __webpack_require__(2178);

var _kbn_timepicker_relative_panel2 = _interopRequireDefault(_kbn_timepicker_relative_panel);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('ui/timepicker');

_module.directive('kbnTimepickerRelativePanel', function () {
  return {
    restrict: 'E',
    replace: true,
    scope: {
      applyRelative: '&',
      checkRelative: '&',
      formatRelative: '&',
      relative: '=',
      relativeOptions: '=',
      setRelativeToNow: '&',
      units: '='
    },
    template: _kbn_timepicker_relative_panel2.default,
    controller: function controller() {}
  };
});

/***/ }),
/* 2178 */
/***/ (function(module, exports) {

module.exports = "<form role=\"form\" ng-submit=\"applyRelative()\" class=\"form-inline\" name=\"relativeTime\">\n  <div class=\"kbn-timepicker-body kuiVerticalRhythm\">\n    <div class=\"kbn-timepicker-section kbn-timepicker-body-column\">\n      <div class=\"kuiLocalDropdownHeader kbn-timepicker-form-header\">\n        <label class=\"kuiLocalDropdownHeader__label\">\n          From\n        </label>\n\n        <div class=\"kuiLocalDropdownHeader__actions\">\n          <a\n            class=\"kuiLocalDropdownHeader__action\"\n            ng-click=\"setRelativeToNow({key:'from'})\"\n            kbn-accessible-click\n          >\n            Set To Now\n          </a>\n        </div>\n      </div>\n\n      <div class=\"kuiLocalDropdownFormNote kuiVerticalRhythmSmall\">\n        <span ng-show=\"relative.from.preview\">\n          {{relative.from.preview}}\n        </span>\n        <span ng-hide=\"relative.from.preview\">\n          <em>Invalid Expression</em>\n        </span>\n      </div>\n\n      <div class=\"kuiFieldGroup kuiVerticalRhythmSmall\">\n        <div class=\"kuiFieldGroupSection kuiFieldGroupSection--wide\">\n          <input\n            required\n            ng-model=\"relative.from.count\"\n            ng-change=\"formatRelative({key:'from'})\"\n            greater-than=\"-1\"\n            min=\"0\"\n            type=\"number\"\n            ng-class=\"{ 'kuiTextInput-isInvalid' : checkRelative() }\"\n            class=\"kuiTextInput fullWidth\"\n          >\n        </div>\n\n        <div class=\"kuiFieldGroupSection\">\n          <select\n            ng-model=\"relative.from.unit\"\n            ng-options=\"opt.value as opt.text for opt in relativeOptions\"\n            ng-change=\"formatRelative({key:'from'})\"\n            ng-class=\"{ 'kuiSelect-isInvalid': checkRelative() }\"\n            class=\"kuiSelect fullWidth\"\n          >\n          </select>\n        </div>\n      </div>\n\n      <div class=\"kuiVerticalRhythmSmall\">\n        <label class=\"kuiCheckBoxLabel\">\n          <input\n            class=\"kuiCheckBox\"\n            type=\"checkbox\"\n            ng-model=\"relative.from.round\"\n            ng-checked=\"relative.from.round\"\n            ng-change=\"formatRelative({key:'from'})\"\n          >\n          <span class=\"kuiCheckBoxLabel__text\">\n            round to the {{units[relative.from.unit.substring(0,1)]}}\n          </span>\n        </label>\n      </div>\n    </div>\n\n    <div class=\"kbn-timepicker-section kbn-timepicker-body-column\">\n      <div class=\"kuiLocalDropdownHeader kbn-timepicker-form-header\">\n        <label class=\"kuiLocalDropdownHeader__label\">\n          To\n        </label>\n\n        <div class=\"kuiLocalDropdownHeader__actions\">\n          <a\n            class=\"kuiLocalDropdownHeader__action\"\n            ng-click=\"setRelativeToNow({key:'to'})\"\n            kbn-accessible-click\n          >\n            Set To Now\n          </a>\n        </div>\n      </div>\n\n      <div class=\"kuiLocalDropdownFormNote kuiVerticalRhythmSmall\">\n        <span ng-show=\"relative.to.preview\">\n          {{relative.to.preview}}\n        </span>\n        <span ng-hide=\"relative.to.preview\">\n          <em>Invalid Expression</em>\n        </span>\n      </div>\n\n      <div class=\"kuiFieldGroup kuiVerticalRhythmSmall\">\n        <div class=\"kuiFieldGroupSection kuiFieldGroupSection--wide\">\n          <input\n            required\n            ng-model=\"relative.to.count\"\n            ng-change=\"formatRelative({key:'to'})\"\n            greater-than=\"-1\"\n            min=\"0\"\n            type=\"number\"\n            ng-class=\"{ 'kuiTextInput-isInvalid': checkRelative() }\"\n            class=\"kuiTextInput fullWidth\"\n          >\n        </div>\n\n        <div class=\"kuiFieldGroupSection\">\n          <select\n            ng-model=\"relative.to.unit\"\n            ng-options=\"opt.value as opt.text for opt in relativeOptions\"\n            ng-change=\"formatRelative({key:'to'})\"\n            ng-class=\"{ 'kuiSelect-isInvalid': checkRelative() }\"\n            class=\"kuiSelect fullWidth\"\n          >\n          </select>\n        </div>\n      </div>\n\n      <div class=\"kuiVerticalRhythmSmall\">\n        <label class=\"kuiCheckBoxLabel\">\n          <input\n            class=\"kuiCheckBox\"\n            type=\"checkbox\"\n            ng-model=\"relative.to.round\"\n            ng-checked=\"relative.to.round\"\n            ng-change=\"formatRelative({key:'to'})\"\n          >\n          <span class=\"kuiCheckBoxLabel__text\">\n            round to the {{units[relative.to.unit.substring(0,1)]}}\n          </span>\n        </label>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"kbn-timepicker-actions kuiVerticalRhythm\">\n    <span\n      class=\"kbn-timepicker-action-item kbn-timepicker-error\"\n      ng-show=\"checkRelative()\"\n    >\n      <strong>From</strong> must occur before <strong>To</strong>\n    </span>\n    <button\n      type=\"submit\"\n      class=\"kuiButton kuiButton--primary kbn-timepicker-submit-button\"\n      ng-disabled=\"!(relative.from.preview && relative.to.preview) || checkRelative()\"\n      data-test-subj=\"timepickerGoButton\"\n    >\n      Go\n    </button>\n  </div>\n</form>\n"

/***/ }),
/* 2179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(2180);

/***/ }),
/* 2180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _kbn_timepicker_absolute_panel = __webpack_require__(2181);

var _kbn_timepicker_absolute_panel2 = _interopRequireDefault(_kbn_timepicker_absolute_panel);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('ui/timepicker');

_module.directive('kbnTimepickerAbsolutePanel', function () {
  return {
    restrict: 'E',
    replace: true,
    scope: {
      absolute: '=',
      applyAbsolute: '&',
      format: '=',
      pickFromDate: '=',
      pickToDate: '=',
      setToNow: '&'
    },
    template: _kbn_timepicker_absolute_panel2.default,
    controller: function controller() {}
  };
});

/***/ }),
/* 2181 */
/***/ (function(module, exports) {

module.exports = "<form name=\"absoluteTime\" ng-submit=\"applyAbsolute()\">\n  <div class=\"kbn-timepicker-body\">\n    <div class=\"kbn-timepicker-section kbn-timepicker-body-column\">\n      <div class=\"kuiLocalDropdownHeader kbn-timepicker-form-header\">\n        <label class=\"kuiLocalDropdownHeader__label\">\n          From\n        </label>\n\n        <div class=\"kuiLocalDropdownHeader__actions\">\n          <a\n            class=\"kuiLocalDropdownHeader__action\"\n            ng-click=\"setToNow({key:'from'})\"\n            kbn-accessible-click\n          >\n            Set To Now\n          </a>\n        </div>\n      </div>\n\n      <input\n        type=\"text\"\n        required\n        class=\"kuiTextInput fullWidth\"\n        input-datetime=\"{{format}}\"\n        ng-model=\"absolute.from\"\n      >\n      <div ng-show=\"!absolute.from\"><em>Invalid Date</em></div>\n\n      <div>\n        <datepicker ng-model=\"pickFromDate\" ng-model-options=\"{ getterSetter: true }\" max-date=\"absolute.to\" show-weeks=\"false\"></datepicker>\n      </div>\n    </div>\n\n    <div class=\"kbn-timepicker-section kbn-timepicker-body-column\">\n      <div class=\"kuiLocalDropdownHeader kbn-timepicker-form-header\">\n        <label class=\"kuiLocalDropdownHeader__label\">\n          To\n        </label>\n\n        <div class=\"kuiLocalDropdownHeader__actions\">\n          <a\n            class=\"kuiLocalDropdownHeader__action\"\n            ng-click=\"setToNow({key:'to'})\"\n            kbn-accessible-click\n          >\n            Set To Now\n          </a>\n        </div>\n      </div>\n\n      <span ng-show=\"!absolute.to\"><em>Invalid Date</em></span>\n      <input\n        type=\"text\"\n        required\n        class=\"kuiTextInput fullWidth\"\n        input-datetime=\"{{format}}\"\n        ng-model=\"absolute.to\"\n      >\n\n      <div>\n        <datepicker ng-model=\"pickToDate\" ng-model-options=\"{ getterSetter: true }\" min-date=\"absolute.from\" show-weeks=\"false\"></datepicker>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"kbn-timepicker-actions kuiVerticalRhythm\">\n    <span\n      class=\"kbn-timepicker-action-item kbn-timepicker-error\"\n      ng-show=\"absolute.from > absolute.to\"\n    >\n      <strong>From</strong> must occur before <strong>To</strong>\n    </span>\n    <button\n      type=\"submit\"\n      class=\"kuiButton kuiButton--primary kbn-timepicker-submit-button\"\n      ng-disabled=\"absolute.from > absolute.to || !absolute.from || !absolute.to\"\n      data-test-subj=\"timepickerGoButton\"\n    >\n      Go\n    </button>\n  </div>\n</form>\n"

/***/ }),
/* 2182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseRelativeString = parseRelativeString;
exports.parseRelativeParts = parseRelativeParts;

var _datemath = __webpack_require__(90);

var _datemath2 = _interopRequireDefault(_datemath);

var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _relative_options = __webpack_require__(486);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parseRelativeString(part) {
  var results = {};
  var matches = _lodash2.default.isString(part) && part.match(/now(([\-\+])([0-9]+)([smhdwMy])(\/[smhdwMy])?)?/);

  var isNow = matches && !matches[1];
  var opperator = matches && matches[2];
  var count = matches && matches[3];
  var unit = matches && matches[4];
  var roundBy = matches && matches[5];

  if (isNow) {
    return { count: 0, unit: 's', round: false };
  }

  if (count && unit) {
    results.count = parseInt(count, 10);
    results.unit = unit;
    if (opperator === '+') results.unit += '+';
    results.round = roundBy ? true : false;
    return results;
  } else {
    results = { count: 0, unit: 's', round: false };
    var duration = _moment2.default.duration((0, _moment2.default)().diff(_datemath2.default.parse(part)));
    var units = _lodash2.default.pluck(_lodash2.default.clone(_relative_options.relativeOptions).reverse(), 'value').filter(function (s) {
      return (/^[smhdwMy]$/.test(s)
      );
    });
    var unitOp = '';
    for (var i = 0; i < units.length; i++) {
      var as = duration.as(units[i]);
      if (as < 0) unitOp = '+';
      if (Math.abs(as) > 1) {
        results.count = Math.round(Math.abs(as));
        results.unit = units[i] + unitOp;
        results.round = false;
        break;
      }
    }
    return results;
  }
}

function parseRelativeParts(from, to) {
  var results = {};
  results.from = parseRelativeString(from);
  results.to = parseRelativeString(to);
  if (results.from && results.to) return results;
}

/***/ }),
/* 2183 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 2184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _module = _modules.uiModules.get('kibana');

_module.constant('refreshIntervals', [{ value: 0, display: 'Off', section: 0 }, { value: 5000, display: '5 seconds', section: 1 }, { value: 10000, display: '10 seconds', section: 1 }, { value: 30000, display: '30 seconds', section: 1 }, { value: 45000, display: '45 seconds', section: 1 }, { value: 60000, display: '1 minute', section: 2 }, { value: 300000, display: '5 minutes', section: 2 }, { value: 900000, display: '15 minutes', section: 2 }, { value: 1800000, display: '30 minutes', section: 2 }, { value: 3600000, display: '1 hour', section: 3 }, { value: 7200000, display: '2 hour', section: 3 }, { value: 43200000, display: '12 hour', section: 3 }, { value: 86400000, display: '1 day', section: 3 }]);

/***/ }),
/* 2185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _lodash = __webpack_require__(1);

var _kbn_global_timepicker = __webpack_require__(2186);

var _kbn_global_timepicker2 = _interopRequireDefault(_kbn_global_timepicker);

var _time_navigation = __webpack_require__(2187);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_modules.uiModules.get('kibana').directive('kbnGlobalTimepicker', function (timefilter, globalState, $rootScope) {
  var listenForUpdates = (0, _lodash.once)(function ($scope) {
    $scope.$listen(timefilter, 'update', function () {
      globalState.time = (0, _lodash.clone)(timefilter.time);
      globalState.refreshInterval = (0, _lodash.clone)(timefilter.refreshInterval);
      globalState.save();
    });
  });

  return {
    template: _kbn_global_timepicker2.default,
    replace: true,
    require: '^kbnTopNav',
    link: function link($scope, element, attributes, kbnTopNav) {
      listenForUpdates($rootScope);

      $rootScope.timefilter = timefilter;
      $rootScope.toggleRefresh = function () {
        timefilter.refreshInterval.pause = !timefilter.refreshInterval.pause;
      };

      $scope.forward = function () {
        timefilter.time = _time_navigation.timeNavigation.stepForward(timefilter.getBounds());
      };

      $scope.back = function () {
        timefilter.time = _time_navigation.timeNavigation.stepBackward(timefilter.getBounds());
      };

      $scope.updateFilter = function (from, to) {
        timefilter.time.from = from;
        timefilter.time.to = to;
        kbnTopNav.close('filter');
      };

      $scope.updateInterval = function (interval) {
        timefilter.refreshInterval = interval;
        kbnTopNav.close('interval');
      };
    }
  };
});

/***/ }),
/* 2186 */
/***/ (function(module, exports) {

module.exports = "<div ng-show=\"timefilter.isAutoRefreshSelectorEnabled || timefilter.isTimeRangeSelectorEnabled\" data-shared-timefilter=\"{{timefilter.isAutoRefreshSelectorEnabled || timefilter.isTimeRangeSelectorEnabled}}\" class=\"kuiLocalMenu\" data-test-subj=\"globalTimepicker\">\n  <button\n    class=\"kuiLocalMenuItem\"\n    aria-label=\"{{ timefilter.refreshInterval.pause ? 'Resume refreshing data' : 'Pause refreshing data' }}\"\n    ng-click=\"toggleRefresh()\"\n    ng-show=\"timefilter.isAutoRefreshSelectorEnabled && (timefilter.refreshInterval.value > 0)\"\n  >\n    <span\n      class=\"kuiIcon\"\n      aria-hidden=\"true\"\n      ng-class=\"timefilter.refreshInterval.pause ? 'fa-play' : 'fa-pause'\"\n    ></span>\n  </button>\n\n  <button\n    class=\"kuiLocalMenuItem navbar-timepicker-auto-refresh-desc\"\n    ng-class=\"{'kuiLocalMenuItem-isSelected': kbnTopNav.isCurrent('interval') }\"\n    ng-show=\"timefilter.isAutoRefreshSelectorEnabled\"\n    ng-click=\"kbnTopNav.toggle('interval')\"\n  >\n    <span ng-show=\"timefilter.refreshInterval.value === 0\">\n      <span aria-hidden=\"true\" class=\"kuiIcon fa-repeat\"></span> Auto-refresh\n    </span>\n\n    <span\n      ng-show=\"timefilter.refreshInterval.value > 0\"\n      aria-label=\"{{ 'Data will refresh every ' + timefilter.refreshInterval.display }}\"\n    >\n      {{ timefilter.refreshInterval.display }}\n    </span>\n  </button>\n\n  <button\n    ng-show=\"timefilter.isTimeRangeSelectorEnabled\"\n    class=\"kuiLocalMenuItem\"\n    ng-click=\"back()\"\n    aria-label=\"Move backward in time\"\n  >\n    <span\n      class=\"kuiIcon fa-chevron-left\"\n      aria-hidden=\"true\"\n      tooltip=\"Move backward in time\"\n    ></span>\n  </button>\n\n  <button\n    ng-show=\"timefilter.isTimeRangeSelectorEnabled\"\n    data-test-subj=\"globalTimepickerButton\"\n    class=\"kuiLocalMenuItem navbar-timepicker-time-desc\"\n    ng-class=\"{'kuiLocalMenuItem-isSelected': kbnTopNav.isCurrent('filter')}\"\n    ng-click=\"kbnTopNav.toggle('filter')\"\n    aria-label=\"Open time range picker\"\n    aria-haspopup=\"true\"\n  >\n    <span aria-hidden=\"true\" class=\"kuiIcon fa-clock-o\"></span>\n    <pretty-duration\n      from=\"timefilter.time.from\"\n      to=\"timefilter.time.to\"\n      data-test-subj=\"globalTimepickerRange\"\n    ></pretty-duration>\n  </button>\n\n  <button\n    ng-show=\"timefilter.isTimeRangeSelectorEnabled\"\n    class=\"kuiLocalMenuItem\"\n    ng-click=\"forward()\"\n    aria-label=\"Move forward in time\"\n  >\n    <span\n      aria-hidden=\"true\"\n      class=\"kuiIcon fa-chevron-right\"\n      tooltip=\"Move forward in time\"\n    ></span>\n  </button>\n</div>\n"

/***/ }),
/* 2187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.timeNavigation = undefined;

var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var timeNavigation = exports.timeNavigation = {
  // travel forward in time based on the interval between from and to
  stepForward: function stepForward(_ref) {
    var min = _ref.min,
        max = _ref.max;

    var diff = max.diff(min);
    return {
      from: (0, _moment2.default)(max).add(1, 'ms').toISOString(),
      to: (0, _moment2.default)(max).add(diff + 1, 'ms').toISOString(),
      mode: 'absolute'
    };
  },


  // travel backwards in time based on the interval between from and to
  stepBackward: function stepBackward(_ref2) {
    var min = _ref2.min,
        max = _ref2.max;

    var diff = max.diff(min);
    return {
      from: (0, _moment2.default)(min).subtract(diff + 1, 'ms').toISOString(),
      to: (0, _moment2.default)(min).subtract(1, 'ms').toISOString(),
      mode: 'absolute'
    };
  },


  // zoom out, doubling the difference between start and end, keeping the same time range center
  zoomOut: function zoomOut(_ref3) {
    var min = _ref3.min,
        max = _ref3.max;

    var diff = max.diff(min);
    return {
      from: (0, _moment2.default)(min).subtract(diff / 2, 'ms').toISOString(),
      to: (0, _moment2.default)(max).add(diff / 2, 'ms').toISOString(),
      mode: 'absolute'
    };
  },


  // zoom in, halving the difference between start and end, keeping the same time range center
  zoomIn: function zoomIn(_ref4) {
    var min = _ref4.min,
        max = _ref4.max;

    var diff = max.diff(min);
    return {
      from: (0, _moment2.default)(min).add(diff / 4, 'ms').toISOString(),
      to: (0, _moment2.default)(max).subtract(diff / 4, 'ms').toISOString(),
      mode: 'absolute'
    };
  }
};

/***/ }),
/* 2188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _tooltip = __webpack_require__(2189);

var _tooltip2 = _interopRequireDefault(_tooltip);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

__webpack_require__(2190).config(function ($tooltipProvider) {
  $tooltipProvider.options({
    placement: 'bottom',
    animation: true,
    popupDelay: 150,
    appendToBody: false
  });
}).directive('kbnTooltip', function () {
  return {
    restrict: 'E',
    template: _tooltip2.default,
    transclude: true,
    replace: true,
    scope: true,
    link: function link($scope, $el, attr) {
      $scope.text = attr.text;
      $scope.placement = attr.placement || 'top';
      $scope.delay = attr.delay || 400;
      $scope.appendToBody = attr.appendToBody || 0;
    }
  };
});

/***/ }),
/* 2189 */
/***/ (function(module, exports) {

module.exports = "<span\n  tooltip=\"{{text}}\"\n  tooltip-placement=\"{{placement}}\"\n  tooltip-popup-delay=\"{{delay}}\"\n  tooltip-append-to-body=\"{{appendToBody}}\"\n  ng-transclude></span>"

/***/ }),
/* 2190 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(16);
__webpack_require__(2191);
var uiModules = __webpack_require__(2).uiModules;

var kibana = uiModules.get('kibana', ['ui.bootstrap']);

module.exports = kibana.config(function ($tooltipProvider) {
  $tooltipProvider.setTriggers({ 'mouseenter': 'mouseleave click' });
});


/***/ }),
/* 2191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(2192);

__webpack_require__(2193);

__webpack_require__(2194);

__webpack_require__(2195);

__webpack_require__(2196);

__webpack_require__(2197);

__webpack_require__(2198);

__webpack_require__(2199);

__webpack_require__(2200);

__webpack_require__(2201);

__webpack_require__(2202);

__webpack_require__(2203);

__webpack_require__(2204);

__webpack_require__(2205);

__webpack_require__(2206);

__webpack_require__(2207);

__webpack_require__(2208);

__webpack_require__(2209);

__webpack_require__(2210);

var _alert = __webpack_require__(2211);

var _alert2 = _interopRequireDefault(_alert);

var _datepicker = __webpack_require__(2212);

var _datepicker2 = _interopRequireDefault(_datepicker);

var _day = __webpack_require__(2213);

var _day2 = _interopRequireDefault(_day);

var _month = __webpack_require__(2214);

var _month2 = _interopRequireDefault(_month);

var _popup = __webpack_require__(2215);

var _popup2 = _interopRequireDefault(_popup);

var _year = __webpack_require__(2216);

var _year2 = _interopRequireDefault(_year);

var _backdrop = __webpack_require__(2217);

var _backdrop2 = _interopRequireDefault(_backdrop);

var _window = __webpack_require__(2218);

var _window2 = _interopRequireDefault(_window);

var _pager = __webpack_require__(2219);

var _pager2 = _interopRequireDefault(_pager);

var _pagination = __webpack_require__(2220);

var _pagination2 = _interopRequireDefault(_pagination);

var _tooltipHtmlUnsafePopup = __webpack_require__(2221);

var _tooltipHtmlUnsafePopup2 = _interopRequireDefault(_tooltipHtmlUnsafePopup);

var _tooltipPopup = __webpack_require__(2222);

var _tooltipPopup2 = _interopRequireDefault(_tooltipPopup);

var _popover = __webpack_require__(2223);

var _popover2 = _interopRequireDefault(_popover);

var _bar = __webpack_require__(2224);

var _bar2 = _interopRequireDefault(_bar);

var _progress = __webpack_require__(2225);

var _progress2 = _interopRequireDefault(_progress);

var _progressbar = __webpack_require__(2226);

var _progressbar2 = _interopRequireDefault(_progressbar);

var _rating = __webpack_require__(2227);

var _rating2 = _interopRequireDefault(_rating);

var _tab = __webpack_require__(2228);

var _tab2 = _interopRequireDefault(_tab);

var _tabset = __webpack_require__(2229);

var _tabset2 = _interopRequireDefault(_tabset);

var _timepicker = __webpack_require__(2230);

var _timepicker2 = _interopRequireDefault(_timepicker);

var _typeaheadMatch = __webpack_require__(2231);

var _typeaheadMatch2 = _interopRequireDefault(_typeaheadMatch);

var _typeaheadPopup = __webpack_require__(2232);

var _typeaheadPopup2 = _interopRequireDefault(_typeaheadPopup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable */

/**
 * TODO: Write custom components that address our needs to directly and deprecate these Bootstrap components.
 */

/*
 * angular-ui-bootstrap
 * http://angular-ui.github.io/bootstrap/

 * Version: 0.12.1 - 2015-02-20
 * License: MIT
 */
angular.module('ui.bootstrap', ['ui.bootstrap.tpls', 'ui.bootstrap.transition', 'ui.bootstrap.collapse', 'ui.bootstrap.alert', 'ui.bootstrap.bindHtml', 'ui.bootstrap.buttons', 'ui.bootstrap.dateparser', 'ui.bootstrap.position', 'ui.bootstrap.datepicker', 'ui.bootstrap.dropdown', 'ui.bootstrap.modal', 'ui.bootstrap.pagination', 'ui.bootstrap.tooltip', 'ui.bootstrap.popover', 'ui.bootstrap.progressbar', 'ui.bootstrap.rating', 'ui.bootstrap.tabs', 'ui.bootstrap.timepicker', 'ui.bootstrap.typeahead']);

angular.module('ui.bootstrap.tpls', ['template/alert/alert.html', 'template/datepicker/datepicker.html', 'template/datepicker/day.html', 'template/datepicker/month.html', 'template/datepicker/popup.html', 'template/datepicker/year.html', 'template/modal/backdrop.html', 'template/modal/window.html', 'template/pagination/pager.html', 'template/pagination/pagination.html', 'template/tooltip/tooltip-html-unsafe-popup.html', 'template/tooltip/tooltip-popup.html', 'template/popover/popover.html', 'template/progressbar/bar.html', 'template/progressbar/progress.html', 'template/progressbar/progressbar.html', 'template/rating/rating.html', 'template/tabs/tab.html', 'template/tabs/tabset.html', 'template/timepicker/timepicker.html', 'template/typeahead/typeahead-match.html', 'template/typeahead/typeahead-popup.html']);

angular.module('template/alert/alert.html', []).run(['$templateCache', function ($templateCache) {
  $templateCache.put('template/alert/alert.html', _alert2.default);
}]);

angular.module('template/datepicker/datepicker.html', []).run(['$templateCache', function ($templateCache) {
  $templateCache.put('template/datepicker/datepicker.html', _datepicker2.default);
}]);

angular.module('template/datepicker/day.html', []).run(['$templateCache', function ($templateCache) {
  $templateCache.put('template/datepicker/day.html', _day2.default);
}]);

angular.module('template/datepicker/month.html', []).run(['$templateCache', function ($templateCache) {
  $templateCache.put('template/datepicker/month.html', _month2.default);
}]);

angular.module('template/datepicker/popup.html', []).run(['$templateCache', function ($templateCache) {
  $templateCache.put('template/datepicker/popup.html', _popup2.default);
}]);

angular.module('template/datepicker/year.html', []).run(['$templateCache', function ($templateCache) {
  $templateCache.put('template/datepicker/year.html', _year2.default);
}]);

angular.module('template/modal/backdrop.html', []).run(['$templateCache', function ($templateCache) {
  $templateCache.put('template/modal/backdrop.html', _backdrop2.default);
}]);

angular.module('template/modal/window.html', []).run(['$templateCache', function ($templateCache) {
  $templateCache.put('template/modal/window.html', _window2.default);
}]);

angular.module('template/pagination/pager.html', []).run(['$templateCache', function ($templateCache) {
  $templateCache.put('template/pagination/pager.html', _pager2.default);
}]);

angular.module('template/pagination/pagination.html', []).run(['$templateCache', function ($templateCache) {
  $templateCache.put('template/pagination/pagination.html', _pagination2.default);
}]);

angular.module('template/tooltip/tooltip-html-unsafe-popup.html', []).run(['$templateCache', function ($templateCache) {
  $templateCache.put('template/tooltip/tooltip-html-unsafe-popup.html', _tooltipHtmlUnsafePopup2.default);
}]);

angular.module('template/tooltip/tooltip-popup.html', []).run(['$templateCache', function ($templateCache) {
  $templateCache.put('template/tooltip/tooltip-popup.html', _tooltipPopup2.default);
}]);

angular.module('template/popover/popover.html', []).run(['$templateCache', function ($templateCache) {
  $templateCache.put('template/popover/popover.html', _popover2.default);
}]);

angular.module('template/progressbar/bar.html', []).run(['$templateCache', function ($templateCache) {
  $templateCache.put('template/progressbar/bar.html', _bar2.default);
}]);

angular.module('template/progressbar/progress.html', []).run(['$templateCache', function ($templateCache) {
  $templateCache.put('template/progressbar/progress.html', _progress2.default);
}]);

angular.module('template/progressbar/progressbar.html', []).run(['$templateCache', function ($templateCache) {
  $templateCache.put('template/progressbar/progressbar.html', _progressbar2.default);
}]);

angular.module('template/rating/rating.html', []).run(['$templateCache', function ($templateCache) {
  $templateCache.put('template/rating/rating.html', _rating2.default);
}]);

angular.module('template/tabs/tab.html', []).run(['$templateCache', function ($templateCache) {
  $templateCache.put('template/tabs/tab.html', _tab2.default);
}]);

angular.module('template/tabs/tabset.html', []).run(['$templateCache', function ($templateCache) {
  $templateCache.put('template/tabs/tabset.html', _tabset2.default);
}]);

angular.module('template/timepicker/timepicker.html', []).run(['$templateCache', function ($templateCache) {
  $templateCache.put('template/timepicker/timepicker.html', _timepicker2.default);
}]);

angular.module('template/typeahead/typeahead-match.html', []).run(['$templateCache', function ($templateCache) {
  $templateCache.put('template/typeahead/typeahead-match.html', _typeaheadMatch2.default);
}]);

angular.module('template/typeahead/typeahead-popup.html', []).run(['$templateCache', function ($templateCache) {
  $templateCache.put('template/typeahead/typeahead-popup.html', _typeaheadPopup2.default);
}]);

/***/ }),
/* 2192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse']).constant('accordionConfig', {
  closeOthers: true
}).controller('AccordionController', ['$scope', '$attrs', 'accordionConfig', function ($scope, $attrs, accordionConfig) {

  // This array keeps track of the accordion groups
  this.groups = [];

  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
  this.closeOthers = function (openGroup) {
    var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
    if (closeOthers) {
      angular.forEach(this.groups, function (group) {
        if (group !== openGroup) {
          group.isOpen = false;
        }
      });
    }
  };

  // This is called from the accordion-group directive to add itself to the accordion
  this.addGroup = function (groupScope) {
    var that = this;
    this.groups.push(groupScope);

    groupScope.$on('$destroy', function (event) {
      that.removeGroup(groupScope);
    });
  };

  // This is called from the accordion-group directive when to remove itself
  this.removeGroup = function (group) {
    var index = this.groups.indexOf(group);
    if (index !== -1) {
      this.groups.splice(index, 1);
    }
  };
}])

// The accordion directive simply sets up the directive controller
// and adds an accordion CSS class to itself element.
.directive('accordion', function () {
  return {
    restrict: 'EA',
    controller: 'AccordionController',
    transclude: true,
    replace: false,
    templateUrl: 'template/accordion/accordion.html'
  };
})

// The accordion-group directive indicates a block of html that will expand and collapse in an accordion
.directive('accordionGroup', function () {
  return {
    require: '^accordion', // We need this directive to be inside an accordion
    restrict: 'EA',
    transclude: true, // It transcludes the contents of the directive into the template
    replace: true, // The element containing the directive will be replaced with the template
    templateUrl: 'template/accordion/accordion-group.html',
    scope: {
      heading: '@', // Interpolate the heading attribute onto this scope
      isOpen: '=?',
      isDisabled: '=?'
    },
    controller: function controller() {
      this.setHeading = function (element) {
        this.heading = element;
      };
    },
    link: function link(scope, element, attrs, accordionCtrl) {
      accordionCtrl.addGroup(scope);

      scope.$watch('isOpen', function (value) {
        if (value) {
          accordionCtrl.closeOthers(scope);
        }
      });

      scope.toggleOpen = function () {
        if (!scope.isDisabled) {
          scope.isOpen = !scope.isOpen;
        }
      };
    }
  };
})

// Use accordion-heading below an accordion-group to provide a heading containing HTML
// <accordion-group>
//   <accordion-heading>Heading containing HTML - <img src="..."></accordion-heading>
// </accordion-group>
.directive('accordionHeading', function () {
  return {
    restrict: 'EA',
    transclude: true, // Grab the contents to be used as the heading
    template: '', // In effect remove this element!
    replace: true,
    require: '^accordionGroup',
    link: function link(scope, element, attr, accordionGroupCtrl, transclude) {
      // Pass the heading to the accordion-group controller
      // so that it can be transcluded into the right place in the template
      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
      accordionGroupCtrl.setHeading(transclude(scope, function () {}));
    }
  };
})

// Use in the accordion-group template to indicate where you want the heading to be transcluded
// You must provide the property on the accordion-group controller that will hold the transcluded element
// <div class="accordion-group">
//   <div class="accordion-heading" ><a ... accordion-transclude="heading">...</a></div>
//   ...
// </div>
.directive('accordionTransclude', function () {
  return {
    require: '^accordionGroup',
    link: function link(scope, element, attr, controller) {
      scope.$watch(function () {
        return controller[attr.accordionTransclude];
      }, function (heading) {
        if (heading) {
          element.html('');
          element.append(heading);
        }
      });
    }
  };
});

/***/ }),
/* 2193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


angular.module('ui.bootstrap.alert', []).controller('AlertController', ['$scope', '$attrs', function ($scope, $attrs) {
  $scope.closeable = 'close' in $attrs;
  this.close = $scope.close;
}]).directive('alert', function () {
  return {
    restrict: 'EA',
    controller: 'AlertController',
    templateUrl: 'template/alert/alert.html',
    transclude: true,
    replace: true,
    scope: {
      type: '@',
      close: '&'
    }
  };
}).directive('dismissOnTimeout', ['$timeout', function ($timeout) {
  return {
    require: 'alert',
    link: function link(scope, element, attrs, alertCtrl) {
      $timeout(function () {
        alertCtrl.close();
      }, parseInt(attrs.dismissOnTimeout, 10));
    }
  };
}]);

/***/ }),
/* 2194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


angular.module('ui.bootstrap.bindHtml', []).directive('bindHtmlUnsafe', function () {
  return function (scope, element, attr) {
    element.addClass('ng-binding').data('$binding', attr.bindHtmlUnsafe);
    scope.$watch(attr.bindHtmlUnsafe, function bindHtmlUnsafeWatchAction(value) {
      element.html(value || '');
    });
  };
});

/***/ }),
/* 2195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


angular.module('ui.bootstrap.buttons', []).constant('buttonConfig', {
  activeClass: 'active',
  toggleEvent: 'click'
}).controller('ButtonsController', ['buttonConfig', function (buttonConfig) {
  this.activeClass = buttonConfig.activeClass || 'active';
  this.toggleEvent = buttonConfig.toggleEvent || 'click';
}]).directive('btnRadio', function () {
  return {
    require: ['btnRadio', 'ngModel'],
    controller: 'ButtonsController',
    link: function link(scope, element, attrs, ctrls) {
      var buttonsCtrl = ctrls[0],
          ngModelCtrl = ctrls[1];

      //model -> UI
      ngModelCtrl.$render = function () {
        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));
      };

      //ui->model
      element.bind(buttonsCtrl.toggleEvent, function () {
        var isActive = element.hasClass(buttonsCtrl.activeClass);

        if (!isActive || angular.isDefined(attrs.uncheckable)) {
          scope.$apply(function () {
            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio));
            ngModelCtrl.$render();
          });
        }
      });
    }
  };
}).directive('btnCheckbox', function () {
  return {
    require: ['btnCheckbox', 'ngModel'],
    controller: 'ButtonsController',
    link: function link(scope, element, attrs, ctrls) {
      var buttonsCtrl = ctrls[0],
          ngModelCtrl = ctrls[1];

      function getTrueValue() {
        return getCheckboxValue(attrs.btnCheckboxTrue, true);
      }

      function getFalseValue() {
        return getCheckboxValue(attrs.btnCheckboxFalse, false);
      }

      function getCheckboxValue(attributeValue, defaultValue) {
        var val = scope.$eval(attributeValue);
        return angular.isDefined(val) ? val : defaultValue;
      }

      //model -> UI
      ngModelCtrl.$render = function () {
        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
      };

      //ui->model
      element.bind(buttonsCtrl.toggleEvent, function () {
        scope.$apply(function () {
          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
          ngModelCtrl.$render();
        });
      });
    }
  };
});

/***/ }),
/* 2196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


angular.module('ui.bootstrap.collapse', ['ui.bootstrap.transition']).directive('collapse', ['$transition', function ($transition) {

  return {
    link: function link(scope, element, attrs) {

      var initialAnimSkip = true;
      var currentTransition;

      function doTransition(change) {
        var newTransition = $transition(element, change);
        if (currentTransition) {
          currentTransition.cancel();
        }
        currentTransition = newTransition;
        newTransition.then(newTransitionDone, newTransitionDone);
        return newTransition;

        function newTransitionDone() {
          // Make sure it's this transition, otherwise, leave it alone.
          if (currentTransition === newTransition) {
            currentTransition = undefined;
          }
        }
      }

      function expand() {
        if (initialAnimSkip) {
          initialAnimSkip = false;
          expandDone();
        } else {
          element.removeClass('collapse').addClass('collapsing');
          doTransition({ height: element[0].scrollHeight + 'px' }).then(expandDone);
        }
      }

      function expandDone() {
        element.removeClass('collapsing');
        element.addClass('collapse in');
        element.css({ height: 'auto' });
      }

      function collapse() {
        if (initialAnimSkip) {
          initialAnimSkip = false;
          collapseDone();
          element.css({ height: 0 });
        } else {
          // CSS transitions don't work with height: auto, so we have to manually change the height to a specific value
          element.css({ height: element[0].scrollHeight + 'px' });
          //trigger reflow so a browser realizes that height was updated from auto to a specific value
          var x = element[0].offsetWidth;

          element.removeClass('collapse in').addClass('collapsing');

          doTransition({ height: 0 }).then(collapseDone);
        }
      }

      function collapseDone() {
        element.removeClass('collapsing');
        element.addClass('collapse');
      }

      scope.$watch(attrs.collapse, function (shouldCollapse) {
        if (shouldCollapse) {
          collapse();
        } else {
          expand();
        }
      });
    }
  };
}]);

/***/ }),
/* 2197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


angular.module('ui.bootstrap.dateparser', []).service('dateParser', ['$locale', 'orderByFilter', function ($locale, orderByFilter) {

  this.parsers = {};

  var formatCodeToRegex = {
    'yyyy': {
      regex: '\\d{4}',
      apply: function apply(value) {
        this.year = +value;
      }
    },
    'yy': {
      regex: '\\d{2}',
      apply: function apply(value) {
        this.year = +value + 2000;
      }
    },
    'y': {
      regex: '\\d{1,4}',
      apply: function apply(value) {
        this.year = +value;
      }
    },
    'MMMM': {
      regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
      apply: function apply(value) {
        this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value);
      }
    },
    'MMM': {
      regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
      apply: function apply(value) {
        this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value);
      }
    },
    'MM': {
      regex: '0[1-9]|1[0-2]',
      apply: function apply(value) {
        this.month = value - 1;
      }
    },
    'M': {
      regex: '[1-9]|1[0-2]',
      apply: function apply(value) {
        this.month = value - 1;
      }
    },
    'dd': {
      regex: '[0-2][0-9]{1}|3[0-1]{1}',
      apply: function apply(value) {
        this.date = +value;
      }
    },
    'd': {
      regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
      apply: function apply(value) {
        this.date = +value;
      }
    },
    'EEEE': {
      regex: $locale.DATETIME_FORMATS.DAY.join('|')
    },
    'EEE': {
      regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|')
    }
  };

  function createParser(format) {
    var map = [],
        regex = format.split('');

    angular.forEach(formatCodeToRegex, function (data, code) {
      var index = format.indexOf(code);

      if (index > -1) {
        format = format.split('');

        regex[index] = '(' + data.regex + ')';
        format[index] = '$'; // Custom symbol to define consumed part of format
        for (var i = index + 1, n = index + code.length; i < n; i++) {
          regex[i] = '';
          format[i] = '$';
        }
        format = format.join('');

        map.push({ index: index, apply: data.apply });
      }
    });

    return {
      regex: new RegExp('^' + regex.join('') + '$'),
      map: orderByFilter(map, 'index')
    };
  }

  this.parse = function (input, format) {
    if (!angular.isString(input) || !format) {
      return input;
    }

    format = $locale.DATETIME_FORMATS[format] || format;

    if (!this.parsers[format]) {
      this.parsers[format] = createParser(format);
    }

    var parser = this.parsers[format],
        regex = parser.regex,
        map = parser.map,
        results = input.match(regex);

    if (results && results.length) {
      var fields = { year: 1900, month: 0, date: 1, hours: 0 },
          dt;

      for (var i = 1, n = results.length; i < n; i++) {
        var mapper = map[i - 1];
        if (mapper.apply) {
          mapper.apply.call(fields, results[i]);
        }
      }

      if (isValid(fields.year, fields.month, fields.date)) {
        dt = new Date(fields.year, fields.month, fields.date, fields.hours);
      }

      return dt;
    }
  };

  // Check if date is valid for specific month (and year for February).
  // Month: 0 = Jan, 1 = Feb, etc
  function isValid(year, month, date) {
    if (month === 1 && date > 28) {
      return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);
    }

    if (month === 3 || month === 5 || month === 8 || month === 10) {
      return date < 31;
    }

    return true;
  }
}]);

/***/ }),
/* 2198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.position']).constant('datepickerConfig', {
  formatDay: 'dd',
  formatMonth: 'MMMM',
  formatYear: 'yyyy',
  formatDayHeader: 'EEE',
  formatDayTitle: 'MMMM yyyy',
  formatMonthTitle: 'yyyy',
  datepickerMode: 'day',
  minMode: 'day',
  maxMode: 'year',
  showWeeks: true,
  startingDay: 0,
  yearRange: 20,
  minDate: null,
  maxDate: null
}).controller('DatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$timeout', '$log', 'dateFilter', 'datepickerConfig', function ($scope, $attrs, $parse, $interpolate, $timeout, $log, dateFilter, datepickerConfig) {
  var self = this,
      ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;

  // Modes chain
  this.modes = ['day', 'month', 'year'];

  // Configuration attributes
  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle', 'minMode', 'maxMode', 'showWeeks', 'startingDay', 'yearRange'], function (key, index) {
    self[key] = angular.isDefined($attrs[key]) ? index < 8 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key]) : datepickerConfig[key];
  });

  // Watchable date attributes
  angular.forEach(['minDate', 'maxDate'], function (key) {
    if ($attrs[key]) {
      $scope.$parent.$watch($parse($attrs[key]), function (value) {
        self[key] = value ? new Date(value) : null;
        self.refreshView();
      });
    } else {
      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;
    }
  });

  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;
  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);
  this.activeDate = angular.isDefined($attrs.initDate) ? $scope.$parent.$eval($attrs.initDate) : new Date();

  $scope.isActive = function (dateObject) {
    if (self.compare(dateObject.date, self.activeDate) === 0) {
      $scope.activeDateId = dateObject.uid;
      return true;
    }
    return false;
  };

  this.init = function (ngModelCtrl_) {
    ngModelCtrl = ngModelCtrl_;

    ngModelCtrl.$render = function () {
      self.render();
    };
  };

  this.render = function () {
    if (ngModelCtrl.$modelValue) {
      var date = new Date(ngModelCtrl.$modelValue),
          isValid = !isNaN(date);

      if (isValid) {
        this.activeDate = date;
      } else {
        $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
      }
      ngModelCtrl.$setValidity('date', isValid);
    }
    this.refreshView();
  };

  this.refreshView = function () {
    if (this.element) {
      this._refreshView();

      var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null;
      ngModelCtrl.$setValidity('date-disabled', !date || this.element && !this.isDisabled(date));
    }
  };

  this.createDateObject = function (date, format) {
    var model = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null;
    return {
      date: date,
      label: dateFilter(date, format),
      selected: model && this.compare(date, model) === 0,
      disabled: this.isDisabled(date),
      current: this.compare(date, new Date()) === 0
    };
  };

  this.isDisabled = function (date) {
    return this.minDate && this.compare(date, this.minDate) < 0 || this.maxDate && this.compare(date, this.maxDate) > 0 || $attrs.dateDisabled && $scope.dateDisabled({ date: date, mode: $scope.datepickerMode });
  };

  // Split array into smaller arrays
  this.split = function (arr, size) {
    var arrays = [];
    while (arr.length > 0) {
      arrays.push(arr.splice(0, size));
    }
    return arrays;
  };

  $scope.select = function (date) {
    if ($scope.datepickerMode === self.minMode) {
      var dt = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : new Date(0, 0, 0, 0, 0, 0, 0);
      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
      ngModelCtrl.$setViewValue(dt);
      ngModelCtrl.$render();
    } else {
      self.activeDate = date;
      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];
      focusElement();
    }
  };

  $scope.move = function (direction) {
    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
        month = self.activeDate.getMonth() + direction * (self.step.months || 0);
    self.activeDate.setFullYear(year, month, 1);
    self.refreshView();
  };

  $scope.toggleMode = function (direction) {
    direction = direction || 1;

    if ($scope.datepickerMode === self.maxMode && direction === 1 || $scope.datepickerMode === self.minMode && direction === -1) {
      return;
    }

    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];
    focusElement();
  };

  // Key event mapper
  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };

  var focusElement = function focusElement() {
    $timeout(function () {
      self.element[0].focus();
    }, 0, false);
  };

  // Listen for focus requests from popup directive
  $scope.$on('datepicker.focus', focusElement);
}]).directive('datepicker', function () {
  return {
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/datepicker/datepicker.html',
    scope: {
      datepickerMode: '=?',
      dateDisabled: '&'
    },
    require: ['datepicker', '?^ngModel'],
    controller: 'DatepickerController',
    link: function link(scope, element, attrs, ctrls) {
      var datepickerCtrl = ctrls[0],
          ngModelCtrl = ctrls[1];

      if (ngModelCtrl) {
        datepickerCtrl.init(ngModelCtrl);
      }
    }
  };
}).directive('daypicker', ['dateFilter', function (dateFilter) {
  return {
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/datepicker/day.html',
    require: '^datepicker',
    link: function link(scope, element, attrs, ctrl) {
      scope.showWeeks = ctrl.showWeeks;

      ctrl.step = { months: 1 };
      ctrl.element = element;

      var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function getDaysInMonth(year, month) {
        return month === 1 && year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];
      }

      function getDates(startDate, n) {
        var dates = new Array(n),
            current = new Date(startDate),
            i = 0;
        current.setHours(12); // Prevent repeated dates because of timezone bug
        while (i < n) {
          dates[i++] = new Date(current);
          current.setDate(current.getDate() + 1);
        }
        return dates;
      }

      ctrl._refreshView = function () {
        var year = ctrl.activeDate.getFullYear(),
            month = ctrl.activeDate.getMonth(),
            firstDayOfMonth = new Date(year, month, 1),
            difference = ctrl.startingDay - firstDayOfMonth.getDay(),
            numDisplayedFromPreviousMonth = difference > 0 ? 7 - difference : -difference,
            firstDate = new Date(firstDayOfMonth);

        if (numDisplayedFromPreviousMonth > 0) {
          firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
        }

        // 42 is the number of days on a six-month calendar
        var days = getDates(firstDate, 42);
        for (var i = 0; i < 42; i++) {
          days[i] = angular.extend(ctrl.createDateObject(days[i], ctrl.formatDay), {
            secondary: days[i].getMonth() !== month,
            uid: scope.uniqueId + '-' + i
          });
        }

        scope.labels = new Array(7);
        for (var j = 0; j < 7; j++) {
          scope.labels[j] = {
            abbr: dateFilter(days[j].date, ctrl.formatDayHeader),
            full: dateFilter(days[j].date, 'EEEE')
          };
        }

        scope.title = dateFilter(ctrl.activeDate, ctrl.formatDayTitle);
        scope.rows = ctrl.split(days, 7);

        if (scope.showWeeks) {
          scope.weekNumbers = [];
          var weekNumber = getISO8601WeekNumber(scope.rows[0][0].date),
              numWeeks = scope.rows.length;
          while (scope.weekNumbers.push(weekNumber++) < numWeeks) {}
        }
      };

      ctrl.compare = function (date1, date2) {
        return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
      };

      function getISO8601WeekNumber(date) {
        var checkDate = new Date(date);
        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday
        var time = checkDate.getTime();
        checkDate.setMonth(0); // Compare with Jan 1
        checkDate.setDate(1);
        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
      }

      ctrl.handleKeyDown = function (key, evt) {
        var date = ctrl.activeDate.getDate();

        if (key === 'left') {
          date = date - 1; // up
        } else if (key === 'up') {
          date = date - 7; // down
        } else if (key === 'right') {
          date = date + 1; // down
        } else if (key === 'down') {
          date = date + 7;
        } else if (key === 'pageup' || key === 'pagedown') {
          var month = ctrl.activeDate.getMonth() + (key === 'pageup' ? -1 : 1);
          ctrl.activeDate.setMonth(month, 1);
          date = Math.min(getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth()), date);
        } else if (key === 'home') {
          date = 1;
        } else if (key === 'end') {
          date = getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth());
        }
        ctrl.activeDate.setDate(date);
      };

      ctrl.refreshView();
    }
  };
}]).directive('monthpicker', ['dateFilter', function (dateFilter) {
  return {
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/datepicker/month.html',
    require: '^datepicker',
    link: function link(scope, element, attrs, ctrl) {
      ctrl.step = { years: 1 };
      ctrl.element = element;

      ctrl._refreshView = function () {
        var months = new Array(12),
            year = ctrl.activeDate.getFullYear();

        for (var i = 0; i < 12; i++) {
          months[i] = angular.extend(ctrl.createDateObject(new Date(year, i, 1), ctrl.formatMonth), {
            uid: scope.uniqueId + '-' + i
          });
        }

        scope.title = dateFilter(ctrl.activeDate, ctrl.formatMonthTitle);
        scope.rows = ctrl.split(months, 3);
      };

      ctrl.compare = function (date1, date2) {
        return new Date(date1.getFullYear(), date1.getMonth()) - new Date(date2.getFullYear(), date2.getMonth());
      };

      ctrl.handleKeyDown = function (key, evt) {
        var date = ctrl.activeDate.getMonth();

        if (key === 'left') {
          date = date - 1; // up
        } else if (key === 'up') {
          date = date - 3; // down
        } else if (key === 'right') {
          date = date + 1; // down
        } else if (key === 'down') {
          date = date + 3;
        } else if (key === 'pageup' || key === 'pagedown') {
          var year = ctrl.activeDate.getFullYear() + (key === 'pageup' ? -1 : 1);
          ctrl.activeDate.setFullYear(year);
        } else if (key === 'home') {
          date = 0;
        } else if (key === 'end') {
          date = 11;
        }
        ctrl.activeDate.setMonth(date);
      };

      ctrl.refreshView();
    }
  };
}]).directive('yearpicker', ['dateFilter', function (dateFilter) {
  return {
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/datepicker/year.html',
    require: '^datepicker',
    link: function link(scope, element, attrs, ctrl) {
      var range = ctrl.yearRange;

      ctrl.step = { years: range };
      ctrl.element = element;

      function getStartingYear(year) {
        return parseInt((year - 1) / range, 10) * range + 1;
      }

      ctrl._refreshView = function () {
        var years = new Array(range);

        for (var i = 0, start = getStartingYear(ctrl.activeDate.getFullYear()); i < range; i++) {
          years[i] = angular.extend(ctrl.createDateObject(new Date(start + i, 0, 1), ctrl.formatYear), {
            uid: scope.uniqueId + '-' + i
          });
        }

        scope.title = [years[0].label, years[range - 1].label].join(' - ');
        scope.rows = ctrl.split(years, 5);
        scope.yearRange = ctrl.yearRange;
      };

      ctrl.compare = function (date1, date2) {
        return date1.getFullYear() - date2.getFullYear();
      };

      ctrl.handleKeyDown = function (key, evt) {
        var date = ctrl.activeDate.getFullYear();

        if (key === 'left') {
          date = date - 1; // up
        } else if (key === 'up') {
          date = date - 5; // down
        } else if (key === 'right') {
          date = date + 1; // down
        } else if (key === 'down') {
          date = date + 5;
        } else if (key === 'pageup' || key === 'pagedown') {
          date += (key === 'pageup' ? -1 : 1) * ctrl.step.years;
        } else if (key === 'home') {
          date = getStartingYear(ctrl.activeDate.getFullYear());
        } else if (key === 'end') {
          date = getStartingYear(ctrl.activeDate.getFullYear()) + range - 1;
        }
        ctrl.activeDate.setFullYear(date);
      };

      ctrl.refreshView();
    }
  };
}]).constant('datepickerPopupConfig', {
  datepickerPopup: 'yyyy-MM-dd',
  currentText: 'Today',
  clearText: 'Clear',
  closeText: 'Done',
  closeOnDateSelection: true,
  appendToBody: false,
  showButtonBar: true
}).directive('datepickerPopup', ['$compile', '$parse', '$document', '$position', 'dateFilter', 'dateParser', 'datepickerPopupConfig', function ($compile, $parse, $document, $position, dateFilter, dateParser, datepickerPopupConfig) {
  return {
    restrict: 'EA',
    require: 'ngModel',
    scope: {
      isOpen: '=?',
      currentText: '@',
      clearText: '@',
      closeText: '@',
      dateDisabled: '&'
    },
    link: function link(scope, element, attrs, ngModel) {
      var dateFormat,
          closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection,
          appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;

      scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;

      scope.getText = function (key) {
        return scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
      };

      attrs.$observe('datepickerPopup', function (value) {
        dateFormat = value || datepickerPopupConfig.datepickerPopup;
        ngModel.$render();
      });

      // popup element used to display calendar
      var popupEl = angular.element('<div datepicker-popup-wrap><div datepicker></div></div>');
      popupEl.attr({
        'ng-model': 'date',
        'ng-change': 'dateSelection()'
      });

      function cameltoDash(string) {
        return string.replace(/([A-Z])/g, function ($1) {
          return '-' + $1.toLowerCase();
        });
      }

      // datepicker element
      var datepickerEl = angular.element(popupEl.children()[0]);
      if (attrs.datepickerOptions) {
        angular.forEach(scope.$parent.$eval(attrs.datepickerOptions), function (value, option) {
          datepickerEl.attr(cameltoDash(option), value);
        });
      }

      scope.watchData = {};
      angular.forEach(['minDate', 'maxDate', 'datepickerMode'], function (key) {
        if (attrs[key]) {
          var getAttribute = $parse(attrs[key]);
          scope.$parent.$watch(getAttribute, function (value) {
            scope.watchData[key] = value;
          });
          datepickerEl.attr(cameltoDash(key), 'watchData.' + key);

          // Propagate changes from datepicker to outside
          if (key === 'datepickerMode') {
            var setAttribute = getAttribute.assign;
            scope.$watch('watchData.' + key, function (value, oldvalue) {
              if (value !== oldvalue) {
                setAttribute(scope.$parent, value);
              }
            });
          }
        }
      });
      if (attrs.dateDisabled) {
        datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');
      }

      function parseDate(viewValue) {
        if (!viewValue) {
          ngModel.$setValidity('date', true);
          return null;
        } else if (angular.isDate(viewValue) && !isNaN(viewValue)) {
          ngModel.$setValidity('date', true);
          return viewValue;
        } else if (angular.isString(viewValue)) {
          var date = dateParser.parse(viewValue, dateFormat) || new Date(viewValue);
          if (isNaN(date)) {
            ngModel.$setValidity('date', false);
            return undefined;
          } else {
            ngModel.$setValidity('date', true);
            return date;
          }
        } else {
          ngModel.$setValidity('date', false);
          return undefined;
        }
      }
      ngModel.$parsers.unshift(parseDate);

      // Inner change
      scope.dateSelection = function (dt) {
        if (angular.isDefined(dt)) {
          scope.date = dt;
        }
        ngModel.$setViewValue(scope.date);
        ngModel.$render();

        if (closeOnDateSelection) {
          scope.isOpen = false;
          element[0].focus();
        }
      };

      element.bind('input change keyup', function () {
        scope.$apply(function () {
          scope.date = ngModel.$modelValue;
        });
      });

      // Outter change
      ngModel.$render = function () {
        var date = ngModel.$viewValue ? dateFilter(ngModel.$viewValue, dateFormat) : '';
        element.val(date);
        scope.date = parseDate(ngModel.$modelValue);
      };

      var documentClickBind = function documentClickBind(event) {
        if (scope.isOpen && event.target !== element[0]) {
          scope.$apply(function () {
            scope.isOpen = false;
          });
        }
      };

      var keydown = function keydown(evt, noApply) {
        scope.keydown(evt);
      };
      element.bind('keydown', keydown);

      scope.keydown = function (evt) {
        if (evt.which === 27) {
          evt.preventDefault();
          evt.stopPropagation();
          scope.close();
        } else if (evt.which === 40 && !scope.isOpen) {
          scope.isOpen = true;
        }
      };

      scope.$watch('isOpen', function (value) {
        if (value) {
          scope.$broadcast('datepicker.focus');
          scope.position = appendToBody ? $position.offset(element) : $position.position(element);
          scope.position.top = scope.position.top + element.prop('offsetHeight');

          $document.bind('click', documentClickBind);
        } else {
          $document.unbind('click', documentClickBind);
        }
      });

      scope.select = function (date) {
        if (date === 'today') {
          var today = new Date();
          if (angular.isDate(ngModel.$modelValue)) {
            date = new Date(ngModel.$modelValue);
            date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
          } else {
            date = new Date(today.setHours(0, 0, 0, 0));
          }
        }
        scope.dateSelection(date);
      };

      scope.close = function () {
        scope.isOpen = false;
        element[0].focus();
      };

      var $popup = $compile(popupEl)(scope);
      // Prevent jQuery cache memory leak (template is now redundant after linking)
      popupEl.remove();

      if (appendToBody) {
        $document.find('body').append($popup);
      } else {
        element.after($popup);
      }

      scope.$on('$destroy', function () {
        $popup.remove();
        element.unbind('keydown', keydown);
        $document.unbind('click', documentClickBind);
      });
    }
  };
}]).directive('datepickerPopupWrap', function () {
  return {
    restrict: 'EA',
    replace: true,
    transclude: true,
    templateUrl: 'template/datepicker/popup.html',
    link: function link(scope, element, attrs) {
      element.bind('click', function (event) {
        event.preventDefault();
        event.stopPropagation();
      });
    }
  };
});

/***/ }),
/* 2199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


angular.module('ui.bootstrap.dropdown', []).constant('dropdownConfig', {
  openClass: 'open'
}).service('dropdownService', ['$document', function ($document) {
  var openScope = null;

  this.open = function (dropdownScope) {
    if (!openScope) {
      $document.bind('click', closeDropdown);
      $document.bind('keydown', escapeKeyBind);
    }

    if (openScope && openScope !== dropdownScope) {
      openScope.isOpen = false;
    }

    openScope = dropdownScope;
  };

  this.close = function (dropdownScope) {
    if (openScope === dropdownScope) {
      openScope = null;
      $document.unbind('click', closeDropdown);
      $document.unbind('keydown', escapeKeyBind);
    }
  };

  var closeDropdown = function closeDropdown(evt) {
    // This method may still be called during the same mouse event that
    // unbound this event handler. So check openScope before proceeding.
    if (!openScope) {
      return;
    }

    var toggleElement = openScope.getToggleElement();
    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
      return;
    }

    openScope.$apply(function () {
      openScope.isOpen = false;
    });
  };

  var escapeKeyBind = function escapeKeyBind(evt) {
    if (evt.which === 27) {
      openScope.focusToggleElement();
      closeDropdown();
    }
  };
}]).controller('DropdownController', ['$scope', '$attrs', '$parse', 'dropdownConfig', 'dropdownService', '$animate', function ($scope, $attrs, $parse, dropdownConfig, dropdownService, $animate) {
  var self = this,
      scope = $scope.$new(),
      // create a child scope so we are not polluting original one
  openClass = dropdownConfig.openClass,
      getIsOpen,
      setIsOpen = angular.noop,
      toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop;

  this.init = function (element) {
    self.$element = element;

    if ($attrs.isOpen) {
      getIsOpen = $parse($attrs.isOpen);
      setIsOpen = getIsOpen.assign;

      $scope.$watch(getIsOpen, function (value) {
        scope.isOpen = !!value;
      });
    }
  };

  this.toggle = function (open) {
    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;
  };

  // Allow other directives to watch status
  this.isOpen = function () {
    return scope.isOpen;
  };

  scope.getToggleElement = function () {
    return self.toggleElement;
  };

  scope.focusToggleElement = function () {
    if (self.toggleElement) {
      self.toggleElement[0].focus();
    }
  };

  scope.$watch('isOpen', function (isOpen, wasOpen) {
    $animate[isOpen ? 'addClass' : 'removeClass'](self.$element, openClass);

    if (isOpen) {
      scope.focusToggleElement();
      dropdownService.open(scope);
    } else {
      dropdownService.close(scope);
    }

    setIsOpen($scope, isOpen);
    if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
      toggleInvoker($scope, { open: !!isOpen });
    }
  });

  $scope.$on('$locationChangeSuccess', function () {
    scope.isOpen = false;
  });

  $scope.$on('$destroy', function () {
    scope.$destroy();
  });
}]).directive('dropdown', function () {
  return {
    controller: 'DropdownController',
    link: function link(scope, element, attrs, dropdownCtrl) {
      dropdownCtrl.init(element);
    }
  };
}).directive('dropdownToggle', function () {
  return {
    require: '?^dropdown',
    link: function link(scope, element, attrs, dropdownCtrl) {
      if (!dropdownCtrl) {
        return;
      }

      dropdownCtrl.toggleElement = element;

      var toggleDropdown = function toggleDropdown(event) {
        event.preventDefault();

        if (!element.hasClass('disabled') && !attrs.disabled) {
          scope.$apply(function () {
            dropdownCtrl.toggle();
          });
        }
      };

      element.bind('click', toggleDropdown);

      // WAI-ARIA
      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });
      scope.$watch(dropdownCtrl.isOpen, function (isOpen) {
        element.attr('aria-expanded', !!isOpen);
      });

      scope.$on('$destroy', function () {
        element.unbind('click', toggleDropdown);
      });
    }
  };
});

/***/ }),
/* 2200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


angular.module('ui.bootstrap.modal', ['ui.bootstrap.transition'])

/**
 * A helper, internal data structure that acts as a map but also allows getting / removing
 * elements in the LIFO order
 */
.factory('$$stackedMap', function () {
  return {
    createNew: function createNew() {
      var stack = [];

      return {
        add: function add(key, value) {
          stack.push({
            key: key,
            value: value
          });
        },
        get: function get(key) {
          for (var i = 0; i < stack.length; i++) {
            if (key == stack[i].key) {
              return stack[i];
            }
          }
        },
        keys: function keys() {
          var keys = [];
          for (var i = 0; i < stack.length; i++) {
            keys.push(stack[i].key);
          }
          return keys;
        },
        top: function top() {
          return stack[stack.length - 1];
        },
        remove: function remove(key) {
          var idx = -1;
          for (var i = 0; i < stack.length; i++) {
            if (key == stack[i].key) {
              idx = i;
              break;
            }
          }
          return stack.splice(idx, 1)[0];
        },
        removeTop: function removeTop() {
          return stack.splice(stack.length - 1, 1)[0];
        },
        length: function length() {
          return stack.length;
        }
      };
    }
  };
})

/**
 * A helper directive for the $modal service. It creates a backdrop element.
 */
.directive('modalBackdrop', ['$timeout', function ($timeout) {
  return {
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/modal/backdrop.html',
    link: function link(scope, element, attrs) {
      scope.backdropClass = attrs.backdropClass || '';

      scope.animate = false;

      //trigger CSS transitions
      $timeout(function () {
        scope.animate = true;
      });
    }
  };
}]).directive('modalWindow', ['$modalStack', '$timeout', function ($modalStack, $timeout) {
  return {
    restrict: 'EA',
    scope: {
      index: '@',
      animate: '='
    },
    replace: true,
    transclude: true,
    templateUrl: function templateUrl(tElement, tAttrs) {
      return tAttrs.templateUrl || 'template/modal/window.html';
    },
    link: function link(scope, element, attrs) {
      element.addClass(attrs.windowClass || '');
      scope.size = attrs.size;

      $timeout(function () {
        // trigger CSS transitions
        scope.animate = true;

        /**
         * Auto-focusing of a freshly-opened modal element causes any child elements
         * with the autofocus attribute to lose focus. This is an issue on touch
         * based devices which will show and then hide the onscreen keyboard.
         * Attempts to refocus the autofocus element via JavaScript will not reopen
         * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus
         * the modal element if the modal does not contain an autofocus element.
         */
        if (!element[0].querySelectorAll('[autofocus]').length) {
          element[0].focus();
        }
      });

      scope.close = function (evt) {
        var modal = $modalStack.getTop();
        if (modal && modal.value.backdrop && modal.value.backdrop != 'static' && evt.target === evt.currentTarget) {
          evt.preventDefault();
          evt.stopPropagation();
          $modalStack.dismiss(modal.key, 'backdrop click');
        }
      };
    }
  };
}]).directive('modalTransclude', function () {
  return {
    link: function link($scope, $element, $attrs, controller, $transclude) {
      $transclude($scope.$parent, function (clone) {
        $element.empty();
        $element.append(clone);
      });
    }
  };
}).factory('$modalStack', ['$transition', '$timeout', '$document', '$compile', '$rootScope', '$$stackedMap', function ($transition, $timeout, $document, $compile, $rootScope, $$stackedMap) {

  var OPENED_MODAL_CLASS = 'modal-open';

  var backdropDomEl, backdropScope;
  var openedWindows = $$stackedMap.createNew();
  var $modalStack = {};

  function backdropIndex() {
    var topBackdropIndex = -1;
    var opened = openedWindows.keys();
    for (var i = 0; i < opened.length; i++) {
      if (openedWindows.get(opened[i]).value.backdrop) {
        topBackdropIndex = i;
      }
    }
    return topBackdropIndex;
  }

  $rootScope.$watch(backdropIndex, function (newBackdropIndex) {
    if (backdropScope) {
      backdropScope.index = newBackdropIndex;
    }
  });

  function removeModalWindow(modalInstance) {

    var body = $document.find('body').eq(0);
    var modalWindow = openedWindows.get(modalInstance).value;

    //clean up the stack
    openedWindows.remove(modalInstance);

    //remove window DOM element
    removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, 300, function () {
      modalWindow.modalScope.$destroy();
      body.toggleClass(OPENED_MODAL_CLASS, openedWindows.length() > 0);
      checkRemoveBackdrop();
    });
  }

  function checkRemoveBackdrop() {
    //remove backdrop if no longer needed
    if (backdropDomEl && backdropIndex() == -1) {
      var backdropScopeRef = backdropScope;
      removeAfterAnimate(backdropDomEl, backdropScope, 150, function () {
        backdropScopeRef.$destroy();
        backdropScopeRef = null;
      });
      backdropDomEl = undefined;
      backdropScope = undefined;
    }
  }

  function removeAfterAnimate(domEl, scope, emulateTime, done) {
    // Closing animation
    scope.animate = false;

    var transitionEndEventName = $transition.transitionEndEventName;
    if (transitionEndEventName) {
      // transition out
      var timeout = $timeout(afterAnimating, emulateTime);

      domEl.bind(transitionEndEventName, function () {
        $timeout.cancel(timeout);
        afterAnimating();
        scope.$apply();
      });
    } else {
      // Ensure this call is async
      $timeout(afterAnimating);
    }

    function afterAnimating() {
      if (afterAnimating.done) {
        return;
      }
      afterAnimating.done = true;

      domEl.remove();
      if (done) {
        done();
      }
    }
  }

  $document.bind('keydown', function (evt) {
    var modal;

    if (evt.which === 27) {
      modal = openedWindows.top();
      if (modal && modal.value.keyboard) {
        evt.preventDefault();
        $rootScope.$apply(function () {
          $modalStack.dismiss(modal.key, 'escape key press');
        });
      }
    }
  });

  $modalStack.open = function (modalInstance, modal) {

    openedWindows.add(modalInstance, {
      deferred: modal.deferred,
      modalScope: modal.scope,
      backdrop: modal.backdrop,
      keyboard: modal.keyboard
    });

    var body = $document.find('body').eq(0),
        currBackdropIndex = backdropIndex();

    if (currBackdropIndex >= 0 && !backdropDomEl) {
      backdropScope = $rootScope.$new(true);
      backdropScope.index = currBackdropIndex;
      var angularBackgroundDomEl = angular.element('<div modal-backdrop></div>');
      angularBackgroundDomEl.attr('backdrop-class', modal.backdropClass);
      backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope);
      body.append(backdropDomEl);
    }

    var angularDomEl = angular.element('<div modal-window></div>');
    angularDomEl.attr({
      'template-url': modal.windowTemplateUrl,
      'window-class': modal.windowClass,
      'size': modal.size,
      'index': openedWindows.length() - 1,
      'animate': 'animate'
    }).html(modal.content);

    var modalDomEl = $compile(angularDomEl)(modal.scope);
    openedWindows.top().value.modalDomEl = modalDomEl;
    body.append(modalDomEl);
    body.addClass(OPENED_MODAL_CLASS);
  };

  $modalStack.close = function (modalInstance, result) {
    var modalWindow = openedWindows.get(modalInstance);
    if (modalWindow) {
      modalWindow.value.deferred.resolve(result);
      removeModalWindow(modalInstance);
    }
  };

  $modalStack.dismiss = function (modalInstance, reason) {
    var modalWindow = openedWindows.get(modalInstance);
    if (modalWindow) {
      modalWindow.value.deferred.reject(reason);
      removeModalWindow(modalInstance);
    }
  };

  $modalStack.dismissAll = function (reason) {
    var topModal = this.getTop();
    while (topModal) {
      this.dismiss(topModal.key, reason);
      topModal = this.getTop();
    }
  };

  $modalStack.getTop = function () {
    return openedWindows.top();
  };

  return $modalStack;
}]).provider('$modal', function () {

  var $modalProvider = {
    options: {
      backdrop: true, //can be also false or 'static'
      keyboard: true
    },
    $get: ['$injector', '$rootScope', '$q', '$http', '$templateCache', '$controller', '$modalStack', function ($injector, $rootScope, $q, $http, $templateCache, $controller, $modalStack) {

      var $modal = {};

      function getTemplatePromise(options) {
        return options.template ? $q.when(options.template) : $http.get(angular.isFunction(options.templateUrl) ? options.templateUrl() : options.templateUrl, { cache: $templateCache }).then(function (result) {
          return result.data;
        });
      }

      function getResolvePromises(resolves) {
        var promisesArr = [];
        angular.forEach(resolves, function (value) {
          if (angular.isFunction(value) || angular.isArray(value)) {
            promisesArr.push($q.when($injector.invoke(value)));
          }
        });
        return promisesArr;
      }

      $modal.open = function (modalOptions) {

        var modalResultDeferred = $q.defer();
        var modalOpenedDeferred = $q.defer();

        //prepare an instance of a modal to be injected into controllers and returned to a caller
        var modalInstance = {
          result: modalResultDeferred.promise,
          opened: modalOpenedDeferred.promise,
          close: function close(result) {
            $modalStack.close(modalInstance, result);
          },
          dismiss: function dismiss(reason) {
            $modalStack.dismiss(modalInstance, reason);
          }
        };

        //merge and clean up options
        modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
        modalOptions.resolve = modalOptions.resolve || {};

        //verify options
        if (!modalOptions.template && !modalOptions.templateUrl) {
          throw new Error('One of template or templateUrl options is required.');
        }

        var templateAndResolvePromise = $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));

        templateAndResolvePromise.then(function resolveSuccess(tplAndVars) {

          var modalScope = (modalOptions.scope || $rootScope).$new();
          modalScope.$close = modalInstance.close;
          modalScope.$dismiss = modalInstance.dismiss;

          var ctrlInstance,
              ctrlLocals = {};
          var resolveIter = 1;

          //controllers
          if (modalOptions.controller) {
            ctrlLocals.$scope = modalScope;
            ctrlLocals.$modalInstance = modalInstance;
            angular.forEach(modalOptions.resolve, function (value, key) {
              ctrlLocals[key] = tplAndVars[resolveIter++];
            });

            ctrlInstance = $controller(modalOptions.controller, ctrlLocals);
            if (modalOptions.controllerAs) {
              modalScope[modalOptions.controllerAs] = ctrlInstance;
            }
          }

          $modalStack.open(modalInstance, {
            scope: modalScope,
            deferred: modalResultDeferred,
            content: tplAndVars[0],
            backdrop: modalOptions.backdrop,
            keyboard: modalOptions.keyboard,
            backdropClass: modalOptions.backdropClass,
            windowClass: modalOptions.windowClass,
            windowTemplateUrl: modalOptions.windowTemplateUrl,
            size: modalOptions.size
          });
        }, function resolveError(reason) {
          modalResultDeferred.reject(reason);
        });

        templateAndResolvePromise.then(function () {
          modalOpenedDeferred.resolve(true);
        }, function () {
          modalOpenedDeferred.reject(false);
        });

        return modalInstance;
      };

      return $modal;
    }]
  };

  return $modalProvider;
});

/***/ }),
/* 2201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


angular.module('ui.bootstrap.pagination', []).controller('PaginationController', ['$scope', '$attrs', '$parse', function ($scope, $attrs, $parse) {
  var self = this,
      ngModelCtrl = { $setViewValue: angular.noop },
      // nullModelCtrl
  setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;

  this.init = function (ngModelCtrl_, config) {
    ngModelCtrl = ngModelCtrl_;
    this.config = config;

    ngModelCtrl.$render = function () {
      self.render();
    };

    if ($attrs.itemsPerPage) {
      $scope.$parent.$watch($parse($attrs.itemsPerPage), function (value) {
        self.itemsPerPage = parseInt(value, 10);
        $scope.totalPages = self.calculateTotalPages();
      });
    } else {
      this.itemsPerPage = config.itemsPerPage;
    }
  };

  this.calculateTotalPages = function () {
    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
    return Math.max(totalPages || 0, 1);
  };

  this.render = function () {
    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;
  };

  $scope.selectPage = function (page) {
    if ($scope.page !== page && page > 0 && page <= $scope.totalPages) {
      ngModelCtrl.$setViewValue(page);
      ngModelCtrl.$render();
    }
  };

  $scope.getText = function (key) {
    return $scope[key + 'Text'] || self.config[key + 'Text'];
  };
  $scope.noPrevious = function () {
    return $scope.page === 1;
  };
  $scope.noNext = function () {
    return $scope.page === $scope.totalPages;
  };

  $scope.$watch('totalItems', function () {
    $scope.totalPages = self.calculateTotalPages();
  });

  $scope.$watch('totalPages', function (value) {
    setNumPages($scope.$parent, value); // Readonly variable

    if ($scope.page > value) {
      $scope.selectPage(value);
    } else {
      ngModelCtrl.$render();
    }
  });
}]).constant('paginationConfig', {
  itemsPerPage: 10,
  boundaryLinks: false,
  directionLinks: true,
  firstText: 'First',
  previousText: 'Previous',
  nextText: 'Next',
  lastText: 'Last',
  rotate: true
}).directive('pagination', ['$parse', 'paginationConfig', function ($parse, paginationConfig) {
  return {
    restrict: 'EA',
    scope: {
      totalItems: '=',
      firstText: '@',
      previousText: '@',
      nextText: '@',
      lastText: '@'
    },
    require: ['pagination', '?ngModel'],
    controller: 'PaginationController',
    templateUrl: 'template/pagination/pagination.html',
    replace: true,
    link: function link(scope, element, attrs, ctrls) {
      var paginationCtrl = ctrls[0],
          ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
        return; // do nothing if no ng-model
      }

      // Setup configuration parameters
      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,
          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;
      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;
      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;

      paginationCtrl.init(ngModelCtrl, paginationConfig);

      if (attrs.maxSize) {
        scope.$parent.$watch($parse(attrs.maxSize), function (value) {
          maxSize = parseInt(value, 10);
          paginationCtrl.render();
        });
      }

      // Create page object used in template
      function makePage(number, text, isActive) {
        return {
          number: number,
          text: text,
          active: isActive
        };
      }

      function getPages(currentPage, totalPages) {
        var pages = [];

        // Default page limits
        var startPage = 1,
            endPage = totalPages;
        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;

        // recompute if maxSize
        if (isMaxSized) {
          if (rotate) {
            // Current page is displayed in the middle of the visible ones
            startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
            endPage = startPage + maxSize - 1;

            // Adjust if limit is exceeded
            if (endPage > totalPages) {
              endPage = totalPages;
              startPage = endPage - maxSize + 1;
            }
          } else {
            // Visible pages are paginated with maxSize
            startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;

            // Adjust last page if limit is exceeded
            endPage = Math.min(startPage + maxSize - 1, totalPages);
          }
        }

        // Add page number links
        for (var number = startPage; number <= endPage; number++) {
          var page = makePage(number, number, number === currentPage);
          pages.push(page);
        }

        // Add links to move between page sets
        if (isMaxSized && !rotate) {
          if (startPage > 1) {
            var previousPageSet = makePage(startPage - 1, '...', false);
            pages.unshift(previousPageSet);
          }

          if (endPage < totalPages) {
            var nextPageSet = makePage(endPage + 1, '...', false);
            pages.push(nextPageSet);
          }
        }

        return pages;
      }

      var originalRender = paginationCtrl.render;
      paginationCtrl.render = function () {
        originalRender();
        if (scope.page > 0 && scope.page <= scope.totalPages) {
          scope.pages = getPages(scope.page, scope.totalPages);
        }
      };
    }
  };
}]).constant('pagerConfig', {
  itemsPerPage: 10,
  previousText: ' Previous',
  nextText: 'Next ',
  align: true
}).directive('pager', ['pagerConfig', function (pagerConfig) {
  return {
    restrict: 'EA',
    scope: {
      totalItems: '=',
      previousText: '@',
      nextText: '@'
    },
    require: ['pager', '?ngModel'],
    controller: 'PaginationController',
    templateUrl: 'template/pagination/pager.html',
    replace: true,
    link: function link(scope, element, attrs, ctrls) {
      var paginationCtrl = ctrls[0],
          ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
        return; // do nothing if no ng-model
      }

      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;
      paginationCtrl.init(ngModelCtrl, pagerConfig);
    }
  };
}]);

/***/ }),
/* 2202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The following features are still outstanding: popup delay, animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html popovers, and selector delegatation.
 */
angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip']).directive('popoverPopup', function () {
  return {
    restrict: 'EA',
    replace: true,
    scope: { title: '@', content: '@', placement: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/popover/popover.html'
  };
}).directive('popover', ['$tooltip', function ($tooltip) {
  return $tooltip('popover', 'popover', 'click');
}]);

/***/ }),
/* 2203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


angular.module('ui.bootstrap.position', [])

/**
 * A set of utility methods that can be use to retrieve position of DOM elements.
 * It is meant to be used where we need to absolute-position DOM elements in
 * relation to other, existing elements (this is the case for tooltips, popovers,
 * typeahead suggestions etc.).
 */
.factory('$position', ['$document', '$window', function ($document, $window) {

  function getStyle(el, cssprop) {
    if (el.currentStyle) {
      //IE
      return el.currentStyle[cssprop];
    } else if ($window.getComputedStyle) {
      return $window.getComputedStyle(el)[cssprop];
    }
    // finally try and get inline style
    return el.style[cssprop];
  }

  /**
   * Checks if a given element is statically positioned
   * @param element - raw DOM element
   */
  function isStaticPositioned(element) {
    return (getStyle(element, 'position') || 'static') === 'static';
  }

  /**
   * returns the closest, non-statically positioned parentOffset of a given element
   * @param element
   */
  var parentOffsetEl = function parentOffsetEl(element) {
    var docDomEl = $document[0];
    var offsetParent = element.offsetParent || docDomEl;
    while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent)) {
      offsetParent = offsetParent.offsetParent;
    }
    return offsetParent || docDomEl;
  };

  return {
    /**
     * Provides read-only equivalent of jQuery's position function:
     * http://api.jquery.com/position/
     */
    position: function position(element) {
      var elBCR = this.offset(element);
      var offsetParentBCR = { top: 0, left: 0 };
      var offsetParentEl = parentOffsetEl(element[0]);
      if (offsetParentEl != $document[0]) {
        offsetParentBCR = this.offset(angular.element(offsetParentEl));
        offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
        offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
      }

      var boundingClientRect = element[0].getBoundingClientRect();
      return {
        width: boundingClientRect.width || element.prop('offsetWidth'),
        height: boundingClientRect.height || element.prop('offsetHeight'),
        top: elBCR.top - offsetParentBCR.top,
        left: elBCR.left - offsetParentBCR.left
      };
    },

    /**
     * Provides read-only equivalent of jQuery's offset function:
     * http://api.jquery.com/offset/
     */
    offset: function offset(element) {
      var boundingClientRect = element[0].getBoundingClientRect();
      return {
        width: boundingClientRect.width || element.prop('offsetWidth'),
        height: boundingClientRect.height || element.prop('offsetHeight'),
        top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
        left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
      };
    },

    /**
     * Provides coordinates for the targetEl in relation to hostEl
     */
    positionElements: function positionElements(hostEl, targetEl, positionStr, appendToBody) {

      var positionStrParts = positionStr.split('-');
      var pos0 = positionStrParts[0],
          pos1 = positionStrParts[1] || 'center';

      var hostElPos, targetElWidth, targetElHeight, targetElPos;

      hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);

      targetElWidth = targetEl.prop('offsetWidth');
      targetElHeight = targetEl.prop('offsetHeight');

      var shiftWidth = {
        center: function center() {
          return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;
        },
        left: function left() {
          return hostElPos.left;
        },
        right: function right() {
          return hostElPos.left + hostElPos.width;
        }
      };

      var shiftHeight = {
        center: function center() {
          return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;
        },
        top: function top() {
          return hostElPos.top;
        },
        bottom: function bottom() {
          return hostElPos.top + hostElPos.height;
        }
      };

      switch (pos0) {
        case 'right':
          targetElPos = {
            top: shiftHeight[pos1](),
            left: shiftWidth[pos0]()
          };
          break;
        case 'left':
          targetElPos = {
            top: shiftHeight[pos1](),
            left: hostElPos.left - targetElWidth
          };
          break;
        case 'bottom':
          targetElPos = {
            top: shiftHeight[pos0](),
            left: shiftWidth[pos1]()
          };
          break;
        default:
          targetElPos = {
            top: hostElPos.top - targetElHeight,
            left: shiftWidth[pos1]()
          };
          break;
      }

      return targetElPos;
    }
  };
}]);

/***/ }),
/* 2204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


angular.module('ui.bootstrap.progressbar', []).constant('progressConfig', {
    animate: true,
    max: 100
}).controller('ProgressController', ['$scope', '$attrs', 'progressConfig', function ($scope, $attrs, progressConfig) {
    var self = this,
        animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;

    this.bars = [];
    $scope.max = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : progressConfig.max;

    this.addBar = function (bar, element) {
        if (!animate) {
            element.css({ 'transition': 'none' });
        }

        this.bars.push(bar);

        bar.$watch('value', function (value) {
            bar.percent = +(100 * value / $scope.max).toFixed(2);
        });

        bar.$on('$destroy', function () {
            element = null;
            self.removeBar(bar);
        });
    };

    this.removeBar = function (bar) {
        this.bars.splice(this.bars.indexOf(bar), 1);
    };
}]).directive('progress', function () {
    return {
        restrict: 'EA',
        replace: true,
        transclude: true,
        controller: 'ProgressController',
        require: 'progress',
        scope: {},
        templateUrl: 'template/progressbar/progress.html'
    };
}).directive('bar', function () {
    return {
        restrict: 'EA',
        replace: true,
        transclude: true,
        require: '^progress',
        scope: {
            value: '=',
            type: '@'
        },
        templateUrl: 'template/progressbar/bar.html',
        link: function link(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, element);
        }
    };
}).directive('progressbar', function () {
    return {
        restrict: 'EA',
        replace: true,
        transclude: true,
        controller: 'ProgressController',
        scope: {
            value: '=',
            type: '@'
        },
        templateUrl: 'template/progressbar/progressbar.html',
        link: function link(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, angular.element(element.children()[0]));
        }
    };
});

/***/ }),
/* 2205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


angular.module('ui.bootstrap.rating', []).constant('ratingConfig', {
  max: 5,
  stateOn: null,
  stateOff: null
}).controller('RatingController', ['$scope', '$attrs', 'ratingConfig', function ($scope, $attrs, ratingConfig) {
  var ngModelCtrl = { $setViewValue: angular.noop };

  this.init = function (ngModelCtrl_) {
    ngModelCtrl = ngModelCtrl_;
    ngModelCtrl.$render = this.render;

    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;

    var ratingStates = angular.isDefined($attrs.ratingStates) ? $scope.$parent.$eval($attrs.ratingStates) : new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
    $scope.range = this.buildTemplateObjects(ratingStates);
  };

  this.buildTemplateObjects = function (states) {
    for (var i = 0, n = states.length; i < n; i++) {
      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff }, states[i]);
    }
    return states;
  };

  $scope.rate = function (value) {
    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
      ngModelCtrl.$setViewValue(value);
      ngModelCtrl.$render();
    }
  };

  $scope.enter = function (value) {
    if (!$scope.readonly) {
      $scope.value = value;
    }
    $scope.onHover({ value: value });
  };

  $scope.reset = function () {
    $scope.value = ngModelCtrl.$viewValue;
    $scope.onLeave();
  };

  $scope.onKeydown = function (evt) {
    if (/(37|38|39|40)/.test(evt.which)) {
      evt.preventDefault();
      evt.stopPropagation();
      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
    }
  };

  this.render = function () {
    $scope.value = ngModelCtrl.$viewValue;
  };
}]).directive('rating', function () {
  return {
    restrict: 'EA',
    require: ['rating', 'ngModel'],
    scope: {
      readonly: '=?',
      onHover: '&',
      onLeave: '&'
    },
    controller: 'RatingController',
    templateUrl: 'template/rating/rating.html',
    replace: true,
    link: function link(scope, element, attrs, ctrls) {
      var ratingCtrl = ctrls[0],
          ngModelCtrl = ctrls[1];

      if (ngModelCtrl) {
        ratingCtrl.init(ngModelCtrl);
      }
    }
  };
});

/***/ }),
/* 2206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @ngdoc overview
 * @name ui.bootstrap.tabs
 *
 * @description
 * AngularJS version of the tabs directive.
 */

angular.module('ui.bootstrap.tabs', []).controller('TabsetController', ['$scope', function TabsetCtrl($scope) {
  var ctrl = this,
      tabs = ctrl.tabs = $scope.tabs = [];

  ctrl.select = function (selectedTab) {
    angular.forEach(tabs, function (tab) {
      if (tab.active && tab !== selectedTab) {
        tab.active = false;
        tab.onDeselect();
      }
    });
    selectedTab.active = true;
    selectedTab.onSelect();
  };

  ctrl.addTab = function addTab(tab) {
    tabs.push(tab);
    // we can't run the select function on the first tab
    // since that would select it twice
    if (tabs.length === 1) {
      tab.active = true;
    } else if (tab.active) {
      ctrl.select(tab);
    }
  };

  ctrl.removeTab = function removeTab(tab) {
    var index = tabs.indexOf(tab);
    //Select a new tab if the tab to be removed is selected and not destroyed
    if (tab.active && tabs.length > 1 && !destroyed) {
      //If this is the last tab, select the previous tab. else, the next tab.
      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
      ctrl.select(tabs[newActiveIndex]);
    }
    tabs.splice(index, 1);
  };

  var destroyed;
  $scope.$on('$destroy', function () {
    destroyed = true;
  });
}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tabset
 * @restrict EA
 *
 * @description
 * Tabset is the outer container for the tabs directive
 *
 * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.
 * @param {boolean=} justified Whether or not to use justified styling for the tabs.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <tabset>
      <tab heading="Tab 1"><b>First</b> Content!</tab>
      <tab heading="Tab 2"><i>Second</i> Content!</tab>
    </tabset>
    <hr />
    <tabset vertical="true">
      <tab heading="Vertical Tab 1"><b>First</b> Vertical Content!</tab>
      <tab heading="Vertical Tab 2"><i>Second</i> Vertical Content!</tab>
    </tabset>
    <tabset justified="true">
      <tab heading="Justified Tab 1"><b>First</b> Justified Content!</tab>
      <tab heading="Justified Tab 2"><i>Second</i> Justified Content!</tab>
    </tabset>
  </file>
</example>
 */
.directive('tabset', function () {
  return {
    restrict: 'EA',
    transclude: true,
    replace: true,
    scope: {
      type: '@'
    },
    controller: 'TabsetController',
    templateUrl: 'template/tabs/tabset.html',
    link: function link(scope, element, attrs) {
      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
    }
  };
})

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tab
 * @restrict EA
 *
 * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.
 * @param {string=} select An expression to evaluate when the tab is selected.
 * @param {boolean=} active A binding, telling whether or not this tab is selected.
 * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.
 *
 * @description
 * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <div ng-controller="TabsDemoCtrl">
      <button class="kuiButton kuiButton--small" ng-click="items[0].active = true">
        Select item 1, using active binding
      </button>
      <button class="kuiButton kuiButton--small" ng-click="items[1].disabled = !items[1].disabled">
        Enable/disable item 2, using disabled binding
      </button>
      <br />
      <tabset>
        <tab heading="Tab 1">First Tab</tab>
        <tab select="alertMe()">
          <tab-heading><i class="icon-bell"></i> Alert me!</tab-heading>
          Second Tab, with alert callback and html heading!
        </tab>
        <tab ng-repeat="item in items"
          heading="{{item.title}}"
          disabled="item.disabled"
          active="item.active">
          {{item.content}}
        </tab>
      </tabset>
    </div>
  </file>
  <file name="script.js">
    function TabsDemoCtrl($scope) {
      $scope.items = [
        { title:"Dynamic Title 1", content:"Dynamic Item 0" },
        { title:"Dynamic Title 2", content:"Dynamic Item 1", disabled: true }
      ];

      $scope.alertMe = function() {
        setTimeout(function() {
          alert("You've selected the alert tab!");
        });
      };
    };
  </file>
</example>
 */

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tabHeading
 * @restrict EA
 *
 * @description
 * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <tabset>
      <tab>
        <tab-heading><b>HTML</b> in my titles?!</tab-heading>
        And some content, too!
      </tab>
      <tab>
        <tab-heading><i class="icon-heart"></i> Icon heading?!?</tab-heading>
        That's right.
      </tab>
    </tabset>
  </file>
</example>
 */
.directive('tab', ['$parse', function ($parse) {
  return {
    require: '^tabset',
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/tabs/tab.html',
    transclude: true,
    scope: {
      active: '=?',
      heading: '@',
      onSelect: '&select', //This callback is called in contentHeadingTransclude
      //once it inserts the tab's content into the dom
      onDeselect: '&deselect'
    },
    controller: function controller() {
      //Empty controller so other directives can require being 'under' a tab
    },
    compile: function compile(elm, attrs, transclude) {
      return function postLink(scope, elm, attrs, tabsetCtrl) {
        scope.$watch('active', function (active) {
          if (active) {
            tabsetCtrl.select(scope);
          }
        });

        scope.disabled = false;
        if (attrs.disabled) {
          scope.$parent.$watch($parse(attrs.disabled), function (value) {
            scope.disabled = !!value;
          });
        }

        scope.select = function () {
          if (!scope.disabled) {
            scope.active = true;
          }
        };

        tabsetCtrl.addTab(scope);
        scope.$on('$destroy', function () {
          tabsetCtrl.removeTab(scope);
        });

        //We need to transclude later, once the content container is ready.
        //when this link happens, we're inside a tab heading.
        scope.$transcludeFn = transclude;
      };
    }
  };
}]).directive('tabHeadingTransclude', [function () {
  return {
    restrict: 'A',
    require: '^tab',
    link: function link(scope, elm, attrs, tabCtrl) {
      scope.$watch('headingElement', function updateHeadingElement(heading) {
        if (heading) {
          elm.html('');
          elm.append(heading);
        }
      });
    }
  };
}]).directive('tabContentTransclude', function () {
  return {
    restrict: 'A',
    require: '^tabset',
    link: function link(scope, elm, attrs) {
      var tab = scope.$eval(attrs.tabContentTransclude);

      //Now our tab is ready to be transcluded: both the tab heading area
      //and the tab content area are loaded.  Transclude 'em both.
      tab.$transcludeFn(tab.$parent, function (contents) {
        angular.forEach(contents, function (node) {
          if (isTabHeading(node)) {
            //Let tabHeadingTransclude know.
            tab.headingElement = node;
          } else {
            elm.append(node);
          }
        });
      });
    }
  };
  function isTabHeading(node) {
    return node.tagName && (node.hasAttribute('tab-heading') || node.hasAttribute('data-tab-heading') || node.tagName.toLowerCase() === 'tab-heading' || node.tagName.toLowerCase() === 'data-tab-heading');
  }
});

/***/ }),
/* 2207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


angular.module('ui.bootstrap.timepicker', []).constant('timepickerConfig', {
  hourStep: 1,
  minuteStep: 1,
  showMeridian: true,
  meridians: null,
  readonlyInput: false,
  mousewheel: true
}).controller('TimepickerController', ['$scope', '$attrs', '$parse', '$log', '$locale', 'timepickerConfig', function ($scope, $attrs, $parse, $log, $locale, timepickerConfig) {
  var selected = new Date(),
      ngModelCtrl = { $setViewValue: angular.noop },
      // nullModelCtrl
  meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;

  this.init = function (ngModelCtrl_, inputs) {
    ngModelCtrl = ngModelCtrl_;
    ngModelCtrl.$render = this.render;

    var hoursInputEl = inputs.eq(0),
        minutesInputEl = inputs.eq(1);

    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;
    if (mousewheel) {
      this.setupMousewheelEvents(hoursInputEl, minutesInputEl);
    }

    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
    this.setupInputEvents(hoursInputEl, minutesInputEl);
  };

  var hourStep = timepickerConfig.hourStep;
  if ($attrs.hourStep) {
    $scope.$parent.$watch($parse($attrs.hourStep), function (value) {
      hourStep = parseInt(value, 10);
    });
  }

  var minuteStep = timepickerConfig.minuteStep;
  if ($attrs.minuteStep) {
    $scope.$parent.$watch($parse($attrs.minuteStep), function (value) {
      minuteStep = parseInt(value, 10);
    });
  }

  // 12H / 24H mode
  $scope.showMeridian = timepickerConfig.showMeridian;
  if ($attrs.showMeridian) {
    $scope.$parent.$watch($parse($attrs.showMeridian), function (value) {
      $scope.showMeridian = !!value;

      if (ngModelCtrl.$error.time) {
        // Evaluate from template
        var hours = getHoursFromTemplate(),
            minutes = getMinutesFromTemplate();
        if (angular.isDefined(hours) && angular.isDefined(minutes)) {
          selected.setHours(hours);
          refresh();
        }
      } else {
        updateTemplate();
      }
    });
  }

  // Get $scope.hours in 24H mode if valid
  function getHoursFromTemplate() {
    var hours = parseInt($scope.hours, 10);
    var valid = $scope.showMeridian ? hours > 0 && hours < 13 : hours >= 0 && hours < 24;
    if (!valid) {
      return undefined;
    }

    if ($scope.showMeridian) {
      if (hours === 12) {
        hours = 0;
      }
      if ($scope.meridian === meridians[1]) {
        hours = hours + 12;
      }
    }
    return hours;
  }

  function getMinutesFromTemplate() {
    var minutes = parseInt($scope.minutes, 10);
    return minutes >= 0 && minutes < 60 ? minutes : undefined;
  }

  function pad(value) {
    return angular.isDefined(value) && value.toString().length < 2 ? '0' + value : value;
  }

  // Respond on mousewheel spin
  this.setupMousewheelEvents = function (hoursInputEl, minutesInputEl) {
    var isScrollingUp = function isScrollingUp(e) {
      if (e.originalEvent) {
        e = e.originalEvent;
      }
      //pick correct delta variable depending on event
      var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
      return e.detail || delta > 0;
    };

    hoursInputEl.bind('mousewheel wheel', function (e) {
      $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
      e.preventDefault();
    });

    minutesInputEl.bind('mousewheel wheel', function (e) {
      $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
      e.preventDefault();
    });
  };

  this.setupInputEvents = function (hoursInputEl, minutesInputEl) {
    if ($scope.readonlyInput) {
      $scope.updateHours = angular.noop;
      $scope.updateMinutes = angular.noop;
      return;
    }

    var invalidate = function invalidate(invalidHours, invalidMinutes) {
      ngModelCtrl.$setViewValue(null);
      ngModelCtrl.$setValidity('time', false);
      if (angular.isDefined(invalidHours)) {
        $scope.invalidHours = invalidHours;
      }
      if (angular.isDefined(invalidMinutes)) {
        $scope.invalidMinutes = invalidMinutes;
      }
    };

    $scope.updateHours = function () {
      var hours = getHoursFromTemplate();

      if (angular.isDefined(hours)) {
        selected.setHours(hours);
        refresh('h');
      } else {
        invalidate(true);
      }
    };

    hoursInputEl.bind('blur', function (e) {
      if (!$scope.invalidHours && $scope.hours < 10) {
        $scope.$apply(function () {
          $scope.hours = pad($scope.hours);
        });
      }
    });

    $scope.updateMinutes = function () {
      var minutes = getMinutesFromTemplate();

      if (angular.isDefined(minutes)) {
        selected.setMinutes(minutes);
        refresh('m');
      } else {
        invalidate(undefined, true);
      }
    };

    minutesInputEl.bind('blur', function (e) {
      if (!$scope.invalidMinutes && $scope.minutes < 10) {
        $scope.$apply(function () {
          $scope.minutes = pad($scope.minutes);
        });
      }
    });
  };

  this.render = function () {
    var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null;

    if (isNaN(date)) {
      ngModelCtrl.$setValidity('time', false);
      $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
    } else {
      if (date) {
        selected = date;
      }
      makeValid();
      updateTemplate();
    }
  };

  // Call internally when we know that model is valid.
  function refresh(keyboardChange) {
    makeValid();
    ngModelCtrl.$setViewValue(new Date(selected));
    updateTemplate(keyboardChange);
  }

  function makeValid() {
    ngModelCtrl.$setValidity('time', true);
    $scope.invalidHours = false;
    $scope.invalidMinutes = false;
  }

  function updateTemplate(keyboardChange) {
    var hours = selected.getHours(),
        minutes = selected.getMinutes();

    if ($scope.showMeridian) {
      hours = hours === 0 || hours === 12 ? 12 : hours % 12; // Convert 24 to 12 hour system
    }

    $scope.hours = keyboardChange === 'h' ? hours : pad(hours);
    $scope.minutes = keyboardChange === 'm' ? minutes : pad(minutes);
    $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
  }

  function addMinutes(minutes) {
    var dt = new Date(selected.getTime() + minutes * 60000);
    selected.setHours(dt.getHours(), dt.getMinutes());
    refresh();
  }

  $scope.incrementHours = function () {
    addMinutes(hourStep * 60);
  };
  $scope.decrementHours = function () {
    addMinutes(-hourStep * 60);
  };
  $scope.incrementMinutes = function () {
    addMinutes(minuteStep);
  };
  $scope.decrementMinutes = function () {
    addMinutes(-minuteStep);
  };
  $scope.toggleMeridian = function () {
    addMinutes(12 * 60 * (selected.getHours() < 12 ? 1 : -1));
  };
}]).directive('timepicker', function () {
  return {
    restrict: 'EA',
    require: ['timepicker', '?^ngModel'],
    controller: 'TimepickerController',
    replace: true,
    scope: {},
    templateUrl: 'template/timepicker/timepicker.html',
    link: function link(scope, element, attrs, ctrls) {
      var timepickerCtrl = ctrls[0],
          ngModelCtrl = ctrls[1];

      if (ngModelCtrl) {
        timepickerCtrl.init(ngModelCtrl, element.find('input'));
      }
    }
  };
});

/***/ }),
/* 2208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The following features are still outstanding: animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html tooltips, and selector delegation.
 */
angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.bindHtml'])

/**
 * The $tooltip service creates tooltip- and popover-like directives as well as
 * houses global options for them.
 */
.provider('$tooltip', function () {
  // The default options tooltip and popover.
  var defaultOptions = {
    placement: 'top',
    animation: true,
    popupDelay: 0
  };

  // Default hide triggers for each show trigger
  var triggerMap = {
    'mouseenter': 'mouseleave',
    'click': 'click',
    'focus': 'blur'
  };

  // The options specified to the provider globally.
  var globalOptions = {};

  /**
   * `options({})` allows global configuration of all tooltips in the
   * application.
   *
   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {
   *     // place tooltips left instead of top by default
   *     $tooltipProvider.options( { placement: 'left' } );
   *   });
   */
  this.options = function (value) {
    angular.extend(globalOptions, value);
  };

  /**
   * This allows you to extend the set of trigger mappings available. E.g.:
   *
   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );
   */
  this.setTriggers = function setTriggers(triggers) {
    angular.extend(triggerMap, triggers);
  };

  /**
   * This is a helper function for translating camel-case to snake-case.
   */
  function snake_case(name) {
    var regexp = /[A-Z]/g;
    var separator = '-';
    return name.replace(regexp, function (letter, pos) {
      return (pos ? separator : '') + letter.toLowerCase();
    });
  }

  /**
   * Returns the actual instance of the $tooltip service.
   * TODO support multiple triggers
   */
  this.$get = ['$window', '$compile', '$timeout', '$document', '$position', '$interpolate', function ($window, $compile, $timeout, $document, $position, $interpolate) {
    return function $tooltip(type, prefix, defaultTriggerShow) {
      var options = angular.extend({}, defaultOptions, globalOptions);

      /**
       * Returns an object of show and hide triggers.
       *
       * If a trigger is supplied,
       * it is used to show the tooltip; otherwise, it will use the `trigger`
       * option passed to the `$tooltipProvider.options` method; else it will
       * default to the trigger supplied to this directive factory.
       *
       * The hide trigger is based on the show trigger. If the `trigger` option
       * was passed to the `$tooltipProvider.options` method, it will use the
       * mapped trigger from `triggerMap` or the passed trigger if the map is
       * undefined; otherwise, it uses the `triggerMap` value of the show
       * trigger; else it will just use the show trigger.
       */
      function getTriggers(trigger) {
        var show = trigger || options.trigger || defaultTriggerShow;
        var hide = triggerMap[show] || show;
        return {
          show: show,
          hide: hide
        };
      }

      var directiveName = snake_case(type);

      var startSym = $interpolate.startSymbol();
      var endSym = $interpolate.endSymbol();
      var template = '<div ' + directiveName + '-popup ' + 'title="' + startSym + 'title' + endSym + '" ' + 'content="' + startSym + 'content' + endSym + '" ' + 'placement="' + startSym + 'placement' + endSym + '" ' + 'animation="animation" ' + 'is-open="isOpen"' + '>' + '</div>';

      return {
        restrict: 'EA',
        compile: function compile(tElem, tAttrs) {
          var tooltipLinker = $compile(template);

          return function link(scope, element, attrs) {
            var tooltip;
            var tooltipLinkedScope;
            var transitionTimeout;
            var popupTimeout;
            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
            var triggers = getTriggers(undefined);
            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
            var ttScope = scope.$new(true);

            var positionTooltip = function positionTooltip() {

              var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
              ttPosition.top += 'px';
              ttPosition.left += 'px';

              // Now set the calculated positioning.
              tooltip.css(ttPosition);
            };

            // By default, the tooltip is not open.
            // TODO add ability to start tooltip opened
            ttScope.isOpen = false;

            function toggleTooltipBind() {
              if (!ttScope.isOpen) {
                showTooltipBind();
              } else {
                hideTooltipBind();
              }
            }

            // Show the tooltip with delay if specified, otherwise show it immediately
            function showTooltipBind() {
              if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {
                return;
              }

              prepareTooltip();

              if (ttScope.popupDelay) {
                // Do nothing if the tooltip was already scheduled to pop-up.
                // This happens if show is triggered multiple times before any hide is triggered.
                if (!popupTimeout) {
                  popupTimeout = $timeout(show, ttScope.popupDelay, false);
                  popupTimeout.then(function (reposition) {
                    return reposition();
                  }).catch(function (error) {
                    // if the timeout is canceled then the string `canceled` is thrown. To prevent
                    // this from triggering an 'unhandled promise rejection' in angular 1.5+ the
                    // $timeout service explicitely tells $q that the promise it generated is "handled"
                    // but that does not include down chain promises like the one created by calling
                    // `popupTimeout.then()`. Because of this we need to ignore the "canceled" string
                    // and only propagate real errors
                    if (error !== 'canceled') {
                      throw error;
                    }
                  });
                }
              } else {
                show()();
              }
            }

            function hideTooltipBind() {
              scope.$evalAsync(function () {
                hide();
              });
            }

            // Show the tooltip popup element.
            function show() {

              popupTimeout = null;

              // If there is a pending remove transition, we must cancel it, lest the
              // tooltip be mysteriously removed.
              if (transitionTimeout) {
                $timeout.cancel(transitionTimeout);
                transitionTimeout = null;
              }

              // Don't show empty tooltips.
              if (!ttScope.content) {
                return angular.noop;
              }

              createTooltip();

              // Set the initial positioning.
              tooltip.css({ top: 0, left: 0, display: 'block' });
              ttScope.$digest();

              positionTooltip();

              // And show the tooltip.
              ttScope.isOpen = true;
              ttScope.$digest(); // digest required as $apply is not called

              // Return positioning function as promise callback for correct
              // positioning after draw.
              return positionTooltip;
            }

            // Hide the tooltip popup element.
            function hide() {
              // First things first: we don't show it anymore.
              ttScope.isOpen = false;

              //if tooltip is going to be shown after delay, we must cancel this
              $timeout.cancel(popupTimeout);
              popupTimeout = null;

              // And now we remove it from the DOM. However, if we have animation, we
              // need to wait for it to expire beforehand.
              // FIXME: this is a placeholder for a port of the transitions library.
              if (ttScope.animation) {
                if (!transitionTimeout) {
                  transitionTimeout = $timeout(removeTooltip, 500);
                }
              } else {
                removeTooltip();
              }
            }

            function createTooltip() {
              // There can only be one tooltip element per directive shown at once.
              if (tooltip) {
                removeTooltip();
              }
              tooltipLinkedScope = ttScope.$new();
              tooltip = tooltipLinker(tooltipLinkedScope, function (tooltip) {
                if (appendToBody) {
                  $document.find('body').append(tooltip);
                } else {
                  element.after(tooltip);
                }
              });
            }

            function removeTooltip() {
              transitionTimeout = null;
              if (tooltip) {
                tooltip.remove();
                tooltip = null;
              }
              if (tooltipLinkedScope) {
                tooltipLinkedScope.$destroy();
                tooltipLinkedScope = null;
              }
            }

            function prepareTooltip() {
              prepPlacement();
              prepPopupDelay();
            }

            /**
             * Observe the relevant attributes.
             */
            attrs.$observe(type, function (val) {
              ttScope.content = val;

              if (!val && ttScope.isOpen) {
                hide();
              }
            });

            attrs.$observe(prefix + 'Title', function (val) {
              ttScope.title = val;
            });

            function prepPlacement() {
              var val = attrs[prefix + 'Placement'];
              ttScope.placement = angular.isDefined(val) ? val : options.placement;
            }

            function prepPopupDelay() {
              var val = attrs[prefix + 'PopupDelay'];
              var delay = parseInt(val, 10);
              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
            }

            var unregisterTriggers = function unregisterTriggers() {
              element.unbind(triggers.show, showTooltipBind);
              element.unbind(triggers.hide, hideTooltipBind);
            };

            function prepTriggers() {
              var val = attrs[prefix + 'Trigger'];
              unregisterTriggers();

              triggers = getTriggers(val);

              if (triggers.show === triggers.hide) {
                element.bind(triggers.show, toggleTooltipBind);
              } else {
                element.bind(triggers.show, showTooltipBind);
                element.bind(triggers.hide, hideTooltipBind);
              }
            }
            prepTriggers();

            var animation = scope.$eval(attrs[prefix + 'Animation']);
            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;

            var appendToBodyVal = scope.$eval(attrs[prefix + 'AppendToBody']);
            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;

            // if a tooltip is attached to <body> we need to remove it on
            // location change as its parent scope will probably not be destroyed
            // by the change.
            if (appendToBody) {
              scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess() {
                if (ttScope.isOpen) {
                  hide();
                }
              });
            }

            // Make sure tooltip is destroyed and removed.
            scope.$on('$destroy', function onDestroyTooltip() {
              $timeout.cancel(transitionTimeout);
              $timeout.cancel(popupTimeout);
              unregisterTriggers();
              removeTooltip();
              ttScope = null;
            });
          };
        }
      };
    };
  }];
}).directive('tooltipPopup', function () {
  return {
    restrict: 'EA',
    replace: true,
    scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/tooltip/tooltip-popup.html'
  };
}).directive('tooltip', ['$tooltip', function ($tooltip) {
  return $tooltip('tooltip', 'tooltip', 'mouseenter');
}]).directive('tooltipHtmlUnsafePopup', function () {
  return {
    restrict: 'EA',
    replace: true,
    scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/tooltip/tooltip-html-unsafe-popup.html'
  };
}).directive('tooltipHtmlUnsafe', ['$tooltip', function ($tooltip) {
  return $tooltip('tooltipHtmlUnsafe', 'tooltip', 'mouseenter');
}]);

/***/ }),
/* 2209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


angular.module('ui.bootstrap.transition', [])

/**
 * $transition service provides a consistent interface to trigger CSS 3 transitions and to be informed when they complete.
 * @param  {DOMElement} element  The DOMElement that will be animated.
 * @param  {string|object|function} trigger  The thing that will cause the transition to start:
 *   - As a string, it represents the css class to be added to the element.
 *   - As an object, it represents a hash of style attributes to be applied to the element.
 *   - As a function, it represents a function to be called that will cause the transition to occur.
 * @return {Promise}  A promise that is resolved when the transition finishes.
 */
.factory('$transition', ['$q', '$timeout', '$rootScope', function ($q, $timeout, $rootScope) {

  var $transition = function $transition(element, trigger, options) {
    options = options || {};
    var deferred = $q.defer();
    var endEventName = $transition[options.animation ? 'animationEndEventName' : 'transitionEndEventName'];

    var transitionEndHandler = function transitionEndHandler(event) {
      $rootScope.$apply(function () {
        element.unbind(endEventName, transitionEndHandler);
        deferred.resolve(element);
      });
    };

    if (endEventName) {
      element.bind(endEventName, transitionEndHandler);
    }

    // Wrap in a timeout to allow the browser time to update the DOM before the transition is to occur
    $timeout(function () {
      if (angular.isString(trigger)) {
        element.addClass(trigger);
      } else if (angular.isFunction(trigger)) {
        trigger(element);
      } else if (angular.isObject(trigger)) {
        element.css(trigger);
      }
      //If browser does not support transitions, instantly resolve
      if (!endEventName) {
        deferred.resolve(element);
      }
    });

    // Add our custom cancel function to the promise that is returned
    // We can call this if we are about to run a new transition, which we know will prevent this transition from ending,
    // i.e. it will therefore never raise a transitionEnd event for that transition
    deferred.promise.cancel = function () {
      if (endEventName) {
        element.unbind(endEventName, transitionEndHandler);
      }
      deferred.reject('Transition cancelled');
    };

    return deferred.promise;
  };

  // Work out the name of the transitionEnd event
  var transElement = document.createElement('trans');
  var transitionEndEventNames = {
    'WebkitTransition': 'webkitTransitionEnd',
    'MozTransition': 'transitionend',
    'OTransition': 'oTransitionEnd',
    'transition': 'transitionend'
  };
  var animationEndEventNames = {
    'WebkitTransition': 'webkitAnimationEnd',
    'MozTransition': 'animationend',
    'OTransition': 'oAnimationEnd',
    'transition': 'animationend'
  };
  function findEndEventName(endEventNames) {
    for (var name in endEventNames) {
      if (transElement.style[name] !== undefined) {
        return endEventNames[name];
      }
    }
  }
  $transition.transitionEndEventName = findEndEventName(transitionEndEventNames);
  $transition.animationEndEventName = findEndEventName(animationEndEventNames);
  return $transition;
}]);

/***/ }),
/* 2210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position', 'ui.bootstrap.bindHtml'])

/**
 * A helper service that can parse typeahead's syntax (string provided by users)
 * Extracted to a separate service for ease of unit testing
 */
.factory('typeaheadParser', ['$parse', function ($parse) {

  //                      00000111000000000000022200000000000000003333333333333330000000000044000
  var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;

  return {
    parse: function parse(input) {

      var match = input.match(TYPEAHEAD_REGEXP);
      if (!match) {
        throw new Error('Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' + ' but got "' + input + '".');
      }

      return {
        itemName: match[3],
        source: $parse(match[4]),
        viewMapper: $parse(match[2] || match[1]),
        modelMapper: $parse(match[1])
      };
    }
  };
}]).directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$position', 'typeaheadParser', function ($compile, $parse, $q, $timeout, $document, $position, typeaheadParser) {

  var HOT_KEYS = [9, 13, 27, 38, 40];

  return {
    require: 'ngModel',
    link: function link(originalScope, element, attrs, modelCtrl) {

      //SUPPORTED ATTRIBUTES (OPTIONS)

      //minimal no of characters that needs to be entered before typeahead kicks-in
      var minSearch = originalScope.$eval(attrs.typeaheadMinLength) || 1;

      //minimal wait time after last character typed before typehead kicks-in
      var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;

      //should it restrict model values to the ones selected from the popup only?
      var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;

      //binding to a variable that indicates if matches are being retrieved asynchronously
      var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;

      //a callback executed when a match is selected
      var onSelectCallback = $parse(attrs.typeaheadOnSelect);

      var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;

      var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;

      var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;

      //INTERNAL VARIABLES

      //model setter executed upon match selection
      var $setModelValue = $parse(attrs.ngModel).assign;

      //expressions used by typeahead
      var parserResult = typeaheadParser.parse(attrs.typeahead);

      var hasFocus;

      //create a child scope for the typeahead directive so we are not polluting original scope
      //with typeahead-specific data (matches, query etc.)
      var scope = originalScope.$new();
      originalScope.$on('$destroy', function () {
        scope.$destroy();
      });

      // WAI-ARIA
      var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
      element.attr({
        'aria-autocomplete': 'list',
        'aria-expanded': false,
        'aria-owns': popupId
      });

      //pop-up element used to display matches
      var popUpEl = angular.element('<div typeahead-popup></div>');
      popUpEl.attr({
        id: popupId,
        matches: 'matches',
        active: 'activeIdx',
        select: 'select(activeIdx)',
        query: 'query',
        position: 'position'
      });
      //custom item template
      if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
        popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
      }

      var resetMatches = function resetMatches() {
        scope.matches = [];
        scope.activeIdx = -1;
        element.attr('aria-expanded', false);
      };

      var getMatchId = function getMatchId(index) {
        return popupId + '-option-' + index;
      };

      // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.
      // This attribute is added or removed automatically when the `activeIdx` changes.
      scope.$watch('activeIdx', function (index) {
        if (index < 0) {
          element.removeAttr('aria-activedescendant');
        } else {
          element.attr('aria-activedescendant', getMatchId(index));
        }
      });

      var getMatchesAsync = function getMatchesAsync(inputValue) {

        var locals = { $viewValue: inputValue };
        isLoadingSetter(originalScope, true);
        $q.when(parserResult.source(originalScope, locals)).then(function (matches) {

          //it might happen that several async queries were in progress if a user were typing fast
          //but we are interested only in responses that correspond to the current view value
          var onCurrentRequest = inputValue === modelCtrl.$viewValue;
          if (onCurrentRequest && hasFocus) {
            if (matches.length > 0) {

              scope.activeIdx = focusFirst ? 0 : -1;
              scope.matches.length = 0;

              //transform labels
              for (var i = 0; i < matches.length; i++) {
                locals[parserResult.itemName] = matches[i];
                scope.matches.push({
                  id: getMatchId(i),
                  label: parserResult.viewMapper(scope, locals),
                  model: matches[i]
                });
              }

              scope.query = inputValue;
              //position pop-up with matches - we need to re-calculate its position each time we are opening a window
              //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
              //due to other elements being rendered
              scope.position = appendToBody ? $position.offset(element) : $position.position(element);
              scope.position.top = scope.position.top + element.prop('offsetHeight');

              element.attr('aria-expanded', true);
            } else {
              resetMatches();
            }
          }
          if (onCurrentRequest) {
            isLoadingSetter(originalScope, false);
          }
        }, function () {
          resetMatches();
          isLoadingSetter(originalScope, false);
        });
      };

      resetMatches();

      //we need to propagate user's query so we can higlight matches
      scope.query = undefined;

      //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
      var timeoutPromise;

      var scheduleSearchWithTimeout = function scheduleSearchWithTimeout(inputValue) {
        timeoutPromise = $timeout(function () {
          getMatchesAsync(inputValue);
        }, waitTime);
      };

      var cancelPreviousTimeout = function cancelPreviousTimeout() {
        if (timeoutPromise) {
          $timeout.cancel(timeoutPromise);
        }
      };

      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
      modelCtrl.$parsers.unshift(function (inputValue) {

        hasFocus = true;

        if (inputValue && inputValue.length >= minSearch) {
          if (waitTime > 0) {
            cancelPreviousTimeout();
            scheduleSearchWithTimeout(inputValue);
          } else {
            getMatchesAsync(inputValue);
          }
        } else {
          isLoadingSetter(originalScope, false);
          cancelPreviousTimeout();
          resetMatches();
        }

        if (isEditable) {
          return inputValue;
        } else {
          if (!inputValue) {
            // Reset in case user had typed something previously.
            modelCtrl.$setValidity('editable', true);
            return inputValue;
          } else {
            modelCtrl.$setValidity('editable', false);
            return undefined;
          }
        }
      });

      modelCtrl.$formatters.push(function (modelValue) {

        var candidateViewValue, emptyViewValue;
        var locals = {};

        if (inputFormatter) {

          locals.$model = modelValue;
          return inputFormatter(originalScope, locals);
        } else {

          //it might happen that we don't have enough info to properly render input value
          //we need to check for this situation and simply return model value if we can't apply custom formatting
          locals[parserResult.itemName] = modelValue;
          candidateViewValue = parserResult.viewMapper(originalScope, locals);
          locals[parserResult.itemName] = undefined;
          emptyViewValue = parserResult.viewMapper(originalScope, locals);

          return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
        }
      });

      scope.select = function (activeIdx) {
        //called from within the $digest() cycle
        var locals = {};
        var model, item;

        locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
        model = parserResult.modelMapper(originalScope, locals);
        $setModelValue(originalScope, model);
        modelCtrl.$setValidity('editable', true);

        onSelectCallback(originalScope, {
          $item: item,
          $model: model,
          $label: parserResult.viewMapper(originalScope, locals)
        });

        resetMatches();

        //return focus to the input element if a match was selected via a mouse click event
        // use timeout to avoid $rootScope:inprog error
        $timeout(function () {
          element[0].focus();
        }, 0, false);
      };

      //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
      element.bind('keydown', function (evt) {

        //typeahead is open and an "interesting" key was pressed
        if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
          return;
        }

        // if there's nothing selected (i.e. focusFirst) and enter is hit, don't do anything
        if (scope.activeIdx == -1 && (evt.which === 13 || evt.which === 9)) {
          return;
        }

        evt.preventDefault();

        if (evt.which === 40) {
          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
          scope.$digest();
        } else if (evt.which === 38) {
          scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
          scope.$digest();
        } else if (evt.which === 13 || evt.which === 9) {
          scope.$apply(function () {
            scope.select(scope.activeIdx);
          });
        } else if (evt.which === 27) {
          evt.stopPropagation();

          resetMatches();
          scope.$digest();
        }
      });

      element.bind('blur', function (evt) {
        hasFocus = false;
      });

      // Keep reference to click handler to unbind it.
      var dismissClickHandler = function dismissClickHandler(evt) {
        if (element[0] !== evt.target) {
          resetMatches();
          scope.$digest();
        }
      };

      $document.bind('click', dismissClickHandler);

      originalScope.$on('$destroy', function () {
        $document.unbind('click', dismissClickHandler);
        if (appendToBody) {
          $popup.remove();
        }
      });

      var $popup = $compile(popUpEl)(scope);
      if (appendToBody) {
        $document.find('body').append($popup);
      } else {
        element.after($popup);
      }
    }
  };
}]).directive('typeaheadPopup', function () {
  return {
    restrict: 'EA',
    scope: {
      matches: '=',
      query: '=',
      active: '=',
      position: '=',
      select: '&'
    },
    replace: true,
    templateUrl: 'template/typeahead/typeahead-popup.html',
    link: function link(scope, element, attrs) {

      scope.templateUrl = attrs.templateUrl;

      scope.isOpen = function () {
        return scope.matches.length > 0;
      };

      scope.isActive = function (matchIdx) {
        return scope.active == matchIdx;
      };

      scope.selectActive = function (matchIdx) {
        scope.active = matchIdx;
      };

      scope.selectMatch = function (activeIdx) {
        scope.select({ activeIdx: activeIdx });
      };
    }
  };
}).directive('typeaheadMatch', ['$http', '$templateCache', '$compile', '$parse', function ($http, $templateCache, $compile, $parse) {
  return {
    restrict: 'EA',
    scope: {
      index: '=',
      match: '=',
      query: '='
    },
    link: function link(scope, element, attrs) {
      var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';
      $http.get(tplUrl, { cache: $templateCache }).then(function (resp) {
        element.replaceWith($compile(resp.data.trim())(scope));
      });
    }
  };
}]).filter('typeaheadHighlight', function () {

  function escapeRegexp(queryToEscape) {
    return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
  }

  return function (matchItem, query) {
    return query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem;
  };
});

/***/ }),
/* 2211 */
/***/ (function(module, exports) {

module.exports = "<div class=\"alert\" ng-class=\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissable' : null]\" role=\"alert\">\n    <button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close()\">\n        <span aria-hidden=\"true\">&times;</span>\n        <span class=\"euiScreenReaderOnly\">Close</span>\n    </button>\n    <div ng-transclude></div>\n</div>\n"

/***/ }),
/* 2212 */
/***/ (function(module, exports) {

module.exports = "<div ng-switch=\"datepickerMode\" role=\"application\">\n  <daypicker ng-switch-when=\"day\" tabindex=\"0\"></daypicker>\n  <monthpicker ng-switch-when=\"month\" tabindex=\"0\"></monthpicker>\n  <yearpicker ng-switch-when=\"year\" tabindex=\"0\"></yearpicker>\n</div>\n"

/***/ }),
/* 2213 */
/***/ (function(module, exports) {

module.exports = "<table\n  class=\"kuiDatePicker fullWidth\"\n  role=\"grid\"\n  aria-labelledby=\"{{uniqueId}}-title\"\n  aria-activedescendant=\"{{activeDateId}}\"\n>\n  <thead>\n    <tr>\n      <th\n        class=\"kuiDatePickerNavigationCell\"\n        colspan=\"{{7 + showWeeks}}\"\n      >\n        <div class=\"kuiDatePickerNavigation\">\n          <button\n            type=\"button\"\n            class=\"kuiDatePickerNavigationButton\"\n            ng-click=\"move(-1)\"\n            aria-label=\"Previous month\"\n          >\n            <span class=\"kuiIcon fa-chevron-left\"></span>\n          </button>\n\n          <button\n            id=\"{{uniqueId}}-title\"\n            role=\"heading\"\n            aria-live=\"assertive\"\n            aria-atomic=\"true\"\n            type=\"button\"\n            class=\"kuiDatePickerNavigationButton\"\n            ng-click=\"toggleMode()\"\n          >\n            <strong>{{title}}</strong>\n          </button>\n\n          <button\n            type=\"button\"\n            class=\"kuiDatePickerNavigationButton\"\n            ng-click=\"move(1)\"\n            aria-label=\"Next month\"\n          >\n            <span class=\"kuiIcon fa-chevron-right\"></span>\n          </button>\n        </div>\n      </th>\n    </tr>\n    <tr>\n      <th ng-show=\"showWeeks\" class=\"text-center\"></th>\n      <th\n        ng-repeat=\"label in labels track by $index\"\n        class=\"kuiDatePickerHeaderCell\"\n      >\n        <small aria-label=\"{{label.full}}\">{{label.abbr}}</small>\n      </th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr ng-repeat=\"row in rows track by $index\">\n      <td ng-show=\"showWeeks\">\n        <em>{{ weekNumbers[$index] }}</em>\n      </td>\n\n      <td\n        ng-repeat=\"dt in row track by dt.date\"\n        class=\"kuiDatePickerRowCell\"\n        ng-class=\"{'kuiDatePickerRowCell-isBlocked': dt.disabled && !dt.secondary}\"\n        id=\"{{dt.uid}}\"\n        aria-disabled=\"{{!!dt.disabled}}\"\n      >\n        <button\n          type=\"button\"\n          class=\"kuiDatePickerRowCellContent\"\n          ng-class=\"{'kuiDatePickerRowCellContent-isSelected': dt.selected, 'kuiDatePickerRowCellContent-isCurrent': dt.current, 'kuiDatePickerRowCellContent-isOtherMonth': dt.secondary}\"\n          ng-click=\"select(dt.date)\"\n          ng-disabled=\"dt.disabled\"\n        >\n          <span>{{dt.label}}</span>\n        </button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n"

/***/ }),
/* 2214 */
/***/ (function(module, exports) {

module.exports = "<table\n  class=\"kuiDatePicker fullWidth\"\n  role=\"grid\"\n  aria-labelledby=\"{{uniqueId}}-title\"\n  aria-activedescendant=\"{{activeDateId}}\"\n>\n  <thead>\n    <tr>\n      <th\n        class=\"kuiDatePickerNavigationCell\"\n        colspan=\"3\"\n      >\n        <div class=\"kuiDatePickerNavigation\">\n          <button\n            type=\"button\"\n            class=\"kuiDatePickerNavigationButton\"\n            ng-click=\"move(-1)\"\n            aria-label=\"Previous year\"\n          >\n            <span class=\"kuiIcon fa-chevron-left\"></span>\n          </button>\n\n          <button\n            id=\"{{uniqueId}}-title\"\n            role=\"heading\"\n            aria-live=\"assertive\"\n            aria-atomic=\"true\"\n            type=\"button\"\n            class=\"kuiDatePickerNavigationButton\"\n            ng-click=\"toggleMode()\"\n          >\n            <strong>{{title}}</strong>\n          </button>\n\n          <button\n            type=\"button\"\n            class=\"kuiDatePickerNavigationButton\"\n            ng-click=\"move(1)\"\n            aria-label=\"Next year\"\n          >\n            <span class=\"kuiIcon fa-chevron-right\"></span>\n          </button>\n        </div>\n      </th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr ng-repeat=\"row in rows track by $index\">\n      <td\n        ng-repeat=\"dt in row track by dt.date\"\n        class=\"kuiDatePickerRowCell\"\n        ng-class=\"{'kuiDatePickerRowCell-isBlocked': dt.disabled && !dt.secondary}\"\n        id=\"{{dt.uid}}\"\n        aria-disabled=\"{{!!dt.disabled}}\"\n      >\n        <button\n          type=\"button\"\n          class=\"kuiDatePickerRowCellContent\"\n          ng-class=\"{'kuiDatePickerRowCellContent-isSelected': dt.selected, 'kuiDatePickerRowCellContent-isCurrent': dt.current}\"\n          ng-click=\"select(dt.date)\"\n          ng-disabled=\"dt.disabled\"\n        >\n          <span>{{dt.label}}</span>\n        </button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n"

/***/ }),
/* 2215 */
/***/ (function(module, exports) {

module.exports = "<ul class=\"dropdown-menu\" ng-style=\"{display: (isOpen && 'block') || 'none', top: position.top+'px', left: position.left+'px'}\" ng-keydown=\"keydown($event)\">\n\t<li ng-transclude></li>\n\t<li ng-if=\"showButtonBar\" style=\"padding:10px 9px 2px\">\n\t\t<span class=\"kuiButtonGroup pull-left\">\n\t\t\t<button type=\"button\" class=\"kuiButton kuiButton--small kuiButton--primary\" ng-click=\"select('today')\">{{ getText('current') }}</button>\n\t\t\t<button type=\"button\" class=\"kuiButton kuiButton--small kuiButton--danger\" ng-click=\"select(null)\">{{ getText('clear') }}</button>\n\t\t</span>\n\t\t<button type=\"button\" class=\"kuiButton kuiButton--small kuiButton--primary pull-right\" ng-click=\"close()\">{{ getText('close') }}</button>\n\t</li>\n</ul>\n"

/***/ }),
/* 2216 */
/***/ (function(module, exports) {

module.exports = "<table\n  class=\"kuiDatePicker fullWidth\"\n  role=\"grid\"\n  aria-labelledby=\"{{uniqueId}}-title\"\n  aria-activedescendant=\"{{activeDateId}}\"\n>\n  <thead>\n    <tr>\n      <th\n        class=\"kuiDatePickerNavigationCell\"\n        colspan=\"5\"\n      >\n        <div class=\"kuiDatePickerNavigation\">\n          <button\n            type=\"button\"\n            class=\"kuiDatePickerNavigationButton\"\n            ng-click=\"move(-1)\"\n            aria-label=\"Previous {{yearRange}} years\"\n          >\n            <span class=\"kuiIcon fa-chevron-left\"></span>\n          </button>\n\n          <button\n            id=\"{{uniqueId}}-title\"\n            role=\"heading\"\n            aria-live=\"assertive\"\n            aria-atomic=\"true\"\n            type=\"button\"\n            class=\"kuiDatePickerNavigationButton\"\n            ng-click=\"toggleMode()\"\n          >\n            <strong>{{title}}</strong>\n          </button>\n\n          <button\n            type=\"button\"\n            class=\"kuiDatePickerNavigationButton\"\n            ng-click=\"move(1)\"\n            aria-label=\"Next {{yearRange}} years\"\n          >\n            <span class=\"kuiIcon fa-chevron-right\"></span>\n          </button>\n        </div>\n      </th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr ng-repeat=\"row in rows track by $index\">\n      <td\n        ng-repeat=\"dt in row track by dt.date\"\n        class=\"kuiDatePickerRowCell\"\n        ng-class=\"{'kuiDatePickerRowCell-isBlocked': dt.disabled && !dt.secondary}\"\n        id=\"{{dt.uid}}\"\n        aria-disabled=\"{{!!dt.disabled}}\"\n      >\n        <button\n          type=\"button\"\n          class=\"kuiDatePickerRowCellContent\"\n          ng-class=\"{'kuiDatePickerRowCellContent-isSelected': dt.selected, 'kuiDatePickerRowCellContent-isCurrent': dt.current}\"\n          ng-click=\"select(dt.date)\"\n          ng-disabled=\"dt.disabled\"\n        >\n          <span>{{dt.label}}</span>\n        </button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n"

/***/ }),
/* 2217 */
/***/ (function(module, exports) {

module.exports = "<div class=\"modal-backdrop fade {{ backdropClass }}\"\n     ng-class=\"{in: animate}\"\n     ng-style=\"{'z-index': 1040 + (index && 1 || 0) + index*10}\"\n></div>\n"

/***/ }),
/* 2218 */
/***/ (function(module, exports) {

module.exports = "<div tabindex=\"-1\" role=\"dialog\" class=\"modal fade\" ng-class=\"{in: animate}\" ng-style=\"{'z-index': 1050 + index*10, display: 'block'}\" ng-click=\"close($event)\">\n    <div class=\"modal-dialog\" ng-class=\"{'modal-sm': size == 'sm', 'modal-lg': size == 'lg'}\"><div class=\"modal-content\" modal-transclude></div></div>\n</div>"

/***/ }),
/* 2219 */
/***/ (function(module, exports) {

module.exports = "<ul class=\"pager\">\n  <li ng-class=\"{disabled: noPrevious(), previous: align}\"><a href ng-click=\"selectPage(page - 1)\">{{getText('previous')}}</a></li>\n  <li ng-class=\"{disabled: noNext(), next: align}\"><a href ng-click=\"selectPage(page + 1)\">{{getText('next')}}</a></li>\n</ul>"

/***/ }),
/* 2220 */
/***/ (function(module, exports) {

module.exports = "<ul class=\"pagination\">\n  <li ng-if=\"boundaryLinks\" ng-class=\"{disabled: noPrevious()}\"><a href ng-click=\"selectPage(1)\">{{getText('first')}}</a></li>\n  <li ng-if=\"directionLinks\" ng-class=\"{disabled: noPrevious()}\"><a href ng-click=\"selectPage(page - 1)\">{{getText('previous')}}</a></li>\n  <li ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active}\"><a href ng-click=\"selectPage(page.number)\">{{page.text}}</a></li>\n  <li ng-if=\"directionLinks\" ng-class=\"{disabled: noNext()}\"><a href ng-click=\"selectPage(page + 1)\">{{getText('next')}}</a></li>\n  <li ng-if=\"boundaryLinks\" ng-class=\"{disabled: noNext()}\"><a href ng-click=\"selectPage(totalPages)\">{{getText('last')}}</a></li>\n</ul>"

/***/ }),
/* 2221 */
/***/ (function(module, exports) {

module.exports = "<div class=\"bsTooltip {{placement}}\" ng-class=\"{ in: isOpen(), fade: animation() }\">\n  <div class=\"bsTooltip-arrow\"></div>\n  <div class=\"bsTooltip-inner\" bind-html-unsafe=\"content\"></div>\n</div>\n"

/***/ }),
/* 2222 */
/***/ (function(module, exports) {

module.exports = "<div class=\"bsTooltip {{placement}}\" ng-class=\"{ in: isOpen(), fade: animation() }\">\n  <div class=\"bsTooltip-arrow\"></div>\n  <div class=\"bsTooltip-inner\" ng-bind=\"content\"></div>\n</div>\n"

/***/ }),
/* 2223 */
/***/ (function(module, exports) {

module.exports = "<div class=\"popover {{placement}}\" ng-class=\"{ in: isOpen(), fade: animation() }\">\n  <div class=\"arrow\"></div>\n\n  <div class=\"popover-inner\">\n      <h3 class=\"popover-title\" ng-bind=\"title\" ng-show=\"title\"></h3>\n      <div class=\"popover-content\" ng-bind=\"content\"></div>\n  </div>\n</div>\n"

/***/ }),
/* 2224 */
/***/ (function(module, exports) {

module.exports = "<div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: percent + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" ng-transclude></div>"

/***/ }),
/* 2225 */
/***/ (function(module, exports) {

module.exports = "<div class=\"progress\" ng-transclude></div>"

/***/ }),
/* 2226 */
/***/ (function(module, exports) {

module.exports = "<div class=\"progress\">\n  <div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: percent + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" ng-transclude></div>\n</div>"

/***/ }),
/* 2227 */
/***/ (function(module, exports) {

module.exports = "<span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\">\n    <i ng-repeat=\"r in range track by $index\" ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\">\n        <span class=\"euiScreenReaderOnly\">({{ $index < value ? '*' : ' ' }})</span>\n    </i>\n</span>\n"

/***/ }),
/* 2228 */
/***/ (function(module, exports) {

module.exports = "<li ng-class=\"{active: active, disabled: disabled}\">\n  <a href ng-click=\"select()\" tab-heading-transclude>{{heading}}</a>\n</li>\n"

/***/ }),
/* 2229 */
/***/ (function(module, exports) {

module.exports = "<div>\n  <ul class=\"nav nav-{{type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n  <div class=\"tab-content\">\n    <div class=\"tab-pane\" \n         ng-repeat=\"tab in tabs\" \n         ng-class=\"{active: tab.active}\"\n         tab-content-transclude=\"tab\">\n    </div>\n  </div>\n</div>\n"

/***/ }),
/* 2230 */
/***/ (function(module, exports) {

module.exports = "<table>\n\t<tbody>\n\t\t<tr class=\"text-center\">\n\t\t\t<td><a ng-click=\"incrementHours()\" class=\"kuiButton kuiButton--hollow\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n\t\t\t<td>&nbsp;</td>\n\t\t\t<td><a ng-click=\"incrementMinutes()\" class=\"kuiButton kuiButton--hollow\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n\t\t\t<td ng-show=\"showMeridian\"></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"width:50px;\" class=\"form-group\" ng-class=\"{'has-error': invalidHours}\">\n\t\t\t\t<input type=\"text\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-mousewheel=\"incrementHours()\" ng-readonly=\"readonlyInput\" maxlength=\"2\">\n\t\t\t</td>\n\t\t\t<td>:</td>\n\t\t\t<td style=\"width:50px;\" class=\"form-group\" ng-class=\"{'has-error': invalidMinutes}\">\n\t\t\t\t<input type=\"text\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\">\n\t\t\t</td>\n\t\t\t<td ng-show=\"showMeridian\"><button type=\"button\" class=\"kuiButton kuiButton--basic text-center\" ng-click=\"toggleMeridian()\">{{meridian}}</button></td>\n\t\t</tr>\n\t\t<tr class=\"text-center\">\n\t\t\t<td><a ng-click=\"decrementHours()\" class=\"kuiButton kuiButton--hollow\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n\t\t\t<td>&nbsp;</td>\n\t\t\t<td><a ng-click=\"decrementMinutes()\" class=\"kuiButton kuiButton--hollow\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n\t\t\t<td ng-show=\"showMeridian\"></td>\n\t\t</tr>\n\t</tbody>\n</table>\n"

/***/ }),
/* 2231 */
/***/ (function(module, exports) {

module.exports = "<a tabindex=\"-1\" bind-html-unsafe=\"match.label | typeaheadHighlight:query\"></a>"

/***/ }),
/* 2232 */
/***/ (function(module, exports) {

module.exports = "<ul class=\"dropdown-menu\" ng-show=\"isOpen()\" ng-style=\"{top: position.top+'px', left: position.left+'px'}\" style=\"display: block;\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\">\n    <li ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index)\" role=\"option\" id=\"{{match.id}}\">\n        <div typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\n    </li>\n</ul>\n"

/***/ }),
/* 2233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(2234);

/***/ }),
/* 2234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

__webpack_require__(2235);

__webpack_require__(2236);

__webpack_require__(2237);

var _modules = __webpack_require__(2);

var _eui = __webpack_require__(11);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var typeahead = _modules.uiModules.get('kibana/typeahead');

typeahead.directive('kbnTypeahead', function () {
  return {
    restrict: 'A',
    scope: {
      historyKey: '@kbnTypeahead',
      onSelect: '&'
    },
    controllerAs: 'typeahead',

    controller: function controller($scope, PersistedLog, config) {
      var self = this;
      self.query = '';
      self.hidden = true;
      self.focused = false;
      self.mousedOver = false;

      self.setInputModel = function (model) {
        $scope.inputModel = model;

        // watch for changes to the query parameter, delegate to typeaheadCtrl
        $scope.$watch('inputModel.$viewValue', self.filterItemsByQuery);
      };

      self.setHidden = function (hidden) {
        self.hidden = !!hidden;
      };

      self.setFocused = function (focused) {
        self.focused = !!focused;
      };

      self.setMouseover = function (mousedOver) {
        self.mousedOver = !!mousedOver;
      };

      // activation methods
      self.activateItem = function (item) {
        self.active = item;
      };

      self.getActiveIndex = function () {
        if (!self.active) {
          return;
        }

        return $scope.filteredItems.indexOf(self.active);
      };

      self.getItems = function () {
        return $scope.filteredItems;
      };

      self.activateNext = function () {
        var index = self.getActiveIndex();
        if (index == null) {
          index = 0;
        } else if (index < $scope.filteredItems.length - 1) {
          ++index;
        }

        self.activateItem($scope.filteredItems[index]);
      };

      self.activatePrev = function () {
        var index = self.getActiveIndex();

        if (index > 0 && index != null) {
          --index;
        } else if (index === 0) {
          self.active = false;
          return;
        }

        self.activateItem($scope.filteredItems[index]);
      };

      self.isActive = function (item) {
        return item === self.active;
      };

      // selection methods
      self.selectItem = function (item, ev) {
        self.hidden = true;
        self.active = false;
        $scope.inputModel.$setViewValue(item);
        $scope.inputModel.$render();
        self.persistEntry();

        if (ev && ev.type === 'click') {
          $scope.onSelect();
        }
      };

      self.persistEntry = function () {
        if ($scope.inputModel.$viewValue.length) {
          // push selection into the history
          $scope.items = self.history.add($scope.inputModel.$viewValue);
        }
      };

      self.selectActive = function () {
        if (self.active) {
          self.selectItem(self.active);
        }
      };

      self.keypressHandler = function (ev) {
        var keyCode = ev.which || ev.keyCode;

        if (self.focused) {
          self.hidden = false;
        }

        // hide on escape
        if (_lodash2.default.contains([_eui.comboBoxKeyCodes.ESCAPE], keyCode)) {
          self.hidden = true;
          self.active = false;
        }

        // change selection with arrow up/down
        // on down key, attempt to load all items if none are loaded
        if (_lodash2.default.contains([_eui.comboBoxKeyCodes.DOWN], keyCode) && $scope.filteredItems.length === 0) {
          $scope.filteredItems = $scope.items;
          $scope.$digest();
        } else if (_lodash2.default.contains([_eui.comboBoxKeyCodes.UP, _eui.comboBoxKeyCodes.DOWN], keyCode)) {
          if (self.isVisible() && $scope.filteredItems.length) {
            ev.preventDefault();

            if (keyCode === _eui.comboBoxKeyCodes.DOWN) {
              self.activateNext();
            } else {
              self.activatePrev();
            }
          }
        }

        // persist selection on enter, when not selecting from the list
        if (_lodash2.default.contains([_eui.comboBoxKeyCodes.ENTER], keyCode)) {
          if (!self.active) {
            self.persistEntry();
          }
        }

        // select on enter or tab
        if (_lodash2.default.contains([_eui.comboBoxKeyCodes.ENTER, _eui.comboBoxKeyCodes.TAB], keyCode)) {
          self.selectActive();
          self.hidden = true;
        }
      };

      self.filterItemsByQuery = function (query) {
        // cache query so we can call it again if needed
        if (query) {
          self.query = query;
        }

        // if the query is empty, clear the list items
        if (!self.query.length) {
          $scope.filteredItems = [];
          return;
        }

        // update the filteredItems using the query
        var beginningMatches = $scope.items.filter(function (item) {
          return item.indexOf(query) === 0;
        });

        var otherMatches = $scope.items.filter(function (item) {
          return item.indexOf(query) > 0;
        });

        $scope.filteredItems = beginningMatches.concat(otherMatches);
      };

      self.isVisible = function () {
        return !self.hidden && $scope.filteredItems.length > 0 && (self.focused || self.mousedOver);
      };

      $scope.$watch('historyKey', function () {
        self.history = new PersistedLog('typeahead:' + $scope.historyKey, {
          maxLength: config.get('history:limit'),
          filterDuplicates: true
        });

        $scope.items = self.history.get();
        $scope.filteredItems = [];
      });

      // handle updates to parent scope history
      $scope.$watch('items', function () {
        if (self.query) {
          self.filterItemsByQuery(self.query);
        }
      });

      // watch for changes to the filtered item list
      $scope.$watch('filteredItems', function (filteredItems) {

        // if list is empty, or active item is missing, unset active item
        if (!filteredItems.length || !_lodash2.default.contains(filteredItems, self.active)) {
          self.active = false;
        }
      });
    },

    link: function link($scope, $el, attrs) {
      if (!_lodash2.default.has(attrs, 'onSelect')) {
        throw new Error('on-select must be defined');
      }

      $scope.$watch('typeahead.isVisible()', function (vis) {
        $el.toggleClass('visible', vis);
      });
    }
  };
});

/***/ }),
/* 2235 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 2236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(438);

var _modules = __webpack_require__(2);

var typeahead = _modules.uiModules.get('kibana/typeahead');

typeahead.directive('kbnTypeaheadInput', function () {

  return {
    restrict: 'A',
    require: ['^ngModel', '^kbnTypeahead'],

    link: function link($scope, $el, $attr, deps) {
      var model = deps[0];
      var typeaheadCtrl = deps[1];

      typeaheadCtrl.setInputModel(model);

      // disable browser autocomplete
      $el.attr('autocomplete', 'off');

      // handle keypresses
      $el.on('keydown', function (ev) {
        $scope.$evalAsync(function () {
          return typeaheadCtrl.keypressHandler(ev);
        });
      });

      // update focus state based on the input focus state
      $el.on('focus', function () {
        $scope.$evalAsync(function () {
          return typeaheadCtrl.setFocused(true);
        });
      });

      $el.on('blur', function () {
        $scope.$evalAsync(function () {
          return typeaheadCtrl.setFocused(false);
        });
      });

      // unbind event listeners
      $scope.$on('$destroy', function () {
        $el.off();
      });
    }
  };
});

/***/ }),
/* 2237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeaheadItems = __webpack_require__(2238);

var _typeaheadItems2 = _interopRequireDefault(_typeaheadItems);

__webpack_require__(438);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var typeahead = _modules.uiModules.get('kibana/typeahead');

typeahead.directive('kbnTypeaheadItems', function () {
  return {
    restrict: 'E',
    require: '^kbnTypeahead',
    replace: true,
    template: _typeaheadItems2.default,

    link: function link($scope, $el, attr, typeaheadCtrl) {
      $scope.typeahead = typeaheadCtrl;
    }
  };
});

/***/ }),
/* 2238 */
/***/ (function(module, exports) {

module.exports = "<div\n  ng-show=\"typeahead.isVisible()\"\n  ng-mouseenter=\"typeahead.setMouseover(true);\"\n  ng-mouseleave=\"typeahead.setMouseover(false);\"\n  class=\"typeahead-items\"\n>\n  <div\n    ng-repeat=\"item in typeahead.getItems()\"\n    ng-class=\"{active: item === typeahead.active}\"\n    ng-click=\"typeahead.selectItem(item, $event);\"\n    ng-mouseenter=\"typeahead.activateItem(item);\"\n    class=\"typeahead-item\"\n    >\n    {{item}}\n  </div>\n</div>\n"

/***/ }),
/* 2239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _saved_object_save_as_checkbox = __webpack_require__(2240);

var _saved_object_save_as_checkbox2 = _interopRequireDefault(_saved_object_save_as_checkbox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_modules.uiModules.get('kibana').directive('savedObjectSaveAsCheckBox', function () {
  return {
    restrict: 'E',
    template: _saved_object_save_as_checkbox2.default,
    replace: true,
    scope: {
      savedObject: '='
    }
  };
});

/***/ }),
/* 2240 */
/***/ (function(module, exports) {

module.exports = "<div ng-hide=\"!savedObject.id || savedObject.isSaving\">\n  <div ng-hide=\"!savedObject.isTitleChanged() || savedObject.copyOnSave\" class=\"kuiLocalDropdownWarning kuiVerticalRhythmSmall\">\n    In previous versions of Kibana, changing the name of a {{savedObject.getDisplayName()}} would make a copy with the new name. Use the 'Save as a new {{savedObject.getDisplayName()}}' checkbox to do this now.\n  </div>\n\n  <label class=\"kuiCheckBoxLabel kuiVerticalRhythmSmall\">\n    <input\n      class=\"kuiCheckBox\"\n      type=\"checkbox\"\n      data-test-subj=\"saveAsNewCheckbox\"\n      ng-model=\"savedObject.copyOnSave\"\n      ng-checked=\"savedObject.copyOnSave\"\n    >\n\n    <span class=\"kuiCheckBoxLabel__text\">\n      Save as a new {{savedObject.getDisplayName()}}\n    </span>\n  </label>\n</div>\n\n"

/***/ }),
/* 2241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(2242);

var _components = __webpack_require__(53);

var _eui = __webpack_require__(11);

var _modules = __webpack_require__(2);

var app = _modules.uiModules.get('app/kibana', ['react']);
app.directive('toolBarSearchBox', function (reactDirective) {
  return reactDirective(_components.KuiToolBarSearchBox);
});
app.directive('confirmModal', function (reactDirective) {
  return reactDirective(_eui.EuiConfirmModal);
});

/***/ }),
/* 2242 */,
/* 2243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _action_item = __webpack_require__(2244);

Object.defineProperty(exports, 'KuiActionItem', {
  enumerable: true,
  get: function get() {
    return _action_item.KuiActionItem;
  }
});

/***/ }),
/* 2244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiActionItem = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiActionItem = function KuiActionItem(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiActionItem', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
};
exports.KuiActionItem = KuiActionItem;
KuiActionItem.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2245 */,
/* 2246 */,
/* 2247 */,
/* 2248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keyboard_accessible = __webpack_require__(2249);

Object.defineProperty(exports, 'KuiKeyboardAccessible', {
  enumerable: true,
  get: function get() {
    return _keyboard_accessible.KuiKeyboardAccessible;
  }
});

var _screen_reader = __webpack_require__(2260);

Object.defineProperty(exports, 'KuiScreenReaderOnly', {
  enumerable: true,
  get: function get() {
    return _screen_reader.KuiScreenReaderOnly;
  }
});

/***/ }),
/* 2249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiKeyboardAccessible = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _services = __webpack_require__(120);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Interactive elements must be able to receive focus.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Ideally, this means using elements that are natively keyboard accessible (<a href="">,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * <input type="button">, or <button>). Note that links should be used when navigating and buttons
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * should be used when performing an action on the page.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * If, however, you need to use elements that aren't natively keyboard accessible (for example, <div>,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * <p>, or <a> without the href attribute), then you need to allow them to receive focus and to
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * respond to keyboard input. The workaround is to:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   - Give the element tabindex="0" so that it can receive keyboard focus.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   - Add a JavaScript onkeyup event handler that triggers element functionality if the Enter key
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     is pressed while the element is focused. This is necessary because some browsers do not trigger
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *    onclick events for such elements when activated via the keyboard.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   - If the item is meant to function as a button, the onkeyup event handler should also detect the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     Spacebar in addition to the Enter key, and the element should be given role="button".
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Wrap any such elements that aren't natively keyboard accessible in this component to automatically
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * apply the above workaround to them.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var KuiKeyboardAccessible = exports.KuiKeyboardAccessible = function (_Component) {
  _inherits(KuiKeyboardAccessible, _Component);

  function KuiKeyboardAccessible() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, KuiKeyboardAccessible);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = KuiKeyboardAccessible.__proto__ || Object.getPrototypeOf(KuiKeyboardAccessible)).call.apply(_ref, [this].concat(args))), _this), _this.onKeyDown = function (e) {
      // Prevent a scroll from occurring if the user has hit space.
      if (e.keyCode === _services.keyCodes.SPACE) {
        e.preventDefault();
      }
    }, _this.onKeyUp = function (e) {
      // Support keyboard accessibility by emulating mouse click on ENTER or SPACE keypress.
      if (e.keyCode === _services.keyCodes.ENTER || e.keyCode === _services.keyCodes.SPACE) {
        // Delegate to the click handler on the element.
        _this.props.children.props.onClick(e);
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(KuiKeyboardAccessible, [{
    key: 'applyKeyboardAccessibility',
    value: function applyKeyboardAccessibility(child) {
      // Add attributes required for accessibility unless they are already specified.
      var props = _extends({
        tabIndex: '0',
        role: 'button'
      }, child.props, {
        onKeyDown: this.onKeyDown,
        onKeyUp: this.onKeyUp
      });

      return (0, _react.cloneElement)(child, props);
    }
  }, {
    key: 'render',
    value: function render() {
      return this.applyKeyboardAccessibility(this.props.children);
    }
  }]);

  return KuiKeyboardAccessible;
}(_react.Component);

var keyboardInaccessibleElement = function keyboardInaccessibleElement(props, propName, componentName) {
  var child = props.children;

  if (!child) {
    throw new Error(componentName + ' needs to wrap an element with which the user interacts.');
  }

  // The whole point of this component is to hack in functionality that native buttons provide
  // by default.
  if (child.type === 'button') {
    throw new Error(componentName + ' doesn\'t need to be used on a button.');
  }

  if (child.type === 'a' && child.props.href !== undefined) {
    throw new Error(componentName + ' doesn\'t need to be used on a link if it has a href attribute.');
  }

  // We're emulating a click action, so we should already have a regular click handler defined.
  if (!child.props.onClick) {
    throw new Error(componentName + ' needs to wrap an element which has an onClick prop assigned.');
  }

  if (typeof child.props.onClick !== 'function') {
    throw new Error(componentName + '\'s child\'s onClick prop needs to be a function.');
  }

  if (child.props.onKeyDown) {
    throw new Error(componentName + '\'s child can\'t have an onKeyDown prop because the implementation will override it.');
  }

  if (child.props.onKeyUp) {
    throw new Error(componentName + '\'s child can\'t have an onKeyUp prop because the implementation will override it.');
  }
};

KuiKeyboardAccessible.propTypes = {
  children: keyboardInaccessibleElement
};

/***/ }),
/* 2250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _accessible_click_keys = __webpack_require__(2251);

Object.defineProperty(exports, 'accessibleClickKeys', {
  enumerable: true,
  get: function get() {
    return _accessible_click_keys.accessibleClickKeys;
  }
});

var _cascading_menu_key_codes = __webpack_require__(2252);

Object.defineProperty(exports, 'cascadingMenuKeyCodes', {
  enumerable: true,
  get: function get() {
    return _cascading_menu_key_codes.cascadingMenuKeyCodes;
  }
});

var _combo_box_key_codes = __webpack_require__(2253);

Object.defineProperty(exports, 'comboBoxKeyCodes', {
  enumerable: true,
  get: function get() {
    return _combo_box_key_codes.comboBoxKeyCodes;
  }
});

var _html_id_generator = __webpack_require__(2254);

Object.defineProperty(exports, 'htmlIdGenerator', {
  enumerable: true,
  get: function get() {
    return _html_id_generator.htmlIdGenerator;
  }
});

/***/ }),
/* 2251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.accessibleClickKeys = undefined;

var _accessibleClickKeys;

var _key_codes = __webpack_require__(329);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// These keys are used to execute click actions on interactive elements like buttons and links.
var accessibleClickKeys = exports.accessibleClickKeys = (_accessibleClickKeys = {}, _defineProperty(_accessibleClickKeys, _key_codes.ENTER, 'enter'), _defineProperty(_accessibleClickKeys, _key_codes.SPACE, 'space'), _accessibleClickKeys);

/***/ }),
/* 2252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cascadingMenuKeyCodes = undefined;

var _key_codes = __webpack_require__(329);

var cascadingMenuKeyCodes = exports.cascadingMenuKeyCodes = {
  DOWN: _key_codes.DOWN,
  ESCAPE: _key_codes.ESCAPE,
  LEFT: _key_codes.LEFT,
  RIGHT: _key_codes.RIGHT,
  TAB: _key_codes.TAB,
  UP: _key_codes.UP
}; /**
    * These keys are used for navigating cascading menu UI components.
    *
    * UP: Select the previous item in the list.
    * DOWN: Select the next item in the list.
    * LEFT: Show the previous menu.
    * RIGHT: Show the next menu for the selected item.
    * ESC: Deselect the current selection and hide the list.
    */

/***/ }),
/* 2253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.comboBoxKeyCodes = undefined;

var _key_codes = __webpack_require__(329);

var comboBoxKeyCodes = exports.comboBoxKeyCodes = {
  DOWN: _key_codes.DOWN,
  ENTER: _key_codes.ENTER,
  ESCAPE: _key_codes.ESCAPE,
  TAB: _key_codes.TAB,
  UP: _key_codes.UP
}; /**
    * These keys are used for navigating combobox UI components.
    *
    * UP: Select the previous item in the list.
    * DOWN: Select the next item in the list.
    * ENTER / TAB: Complete input with the current selection.
    * ESC: Deselect the current selection and hide the list.
    */

/***/ }),
/* 2254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.htmlIdGenerator = htmlIdGenerator;

var _uuid = __webpack_require__(65);

var _uuid2 = _interopRequireDefault(_uuid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This function returns a function to generate ids.
 * This can be used to generate unique, but predictable ids to pair labels
 * with their inputs. It takes an optional prefix as a parameter. If you don't
 * specify it, it generates a random id prefix.
 */
function htmlIdGenerator(idPrefix) {
  var prefix = idPrefix || _uuid2.default.v1();
  return function (suffix) {
    return prefix + '_' + (suffix || _uuid2.default.v1());
  };
}

/***/ }),
/* 2255 */,
/* 2256 */,
/* 2257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _sortable_properties = __webpack_require__(2258);

Object.defineProperty(exports, 'SortableProperties', {
  enumerable: true,
  get: function get() {
    return _sortable_properties.SortableProperties;
  }
});

/***/ }),
/* 2258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SortableProperties = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @typedef {Object} SortableProperty
 * @property {string} sortableProperty.name - Name of the property.
 * @property {function} sortableProperty.getValue - A function that takes in an object and returns a value to sort
 * by.
 * @property {boolean} sortableProperty.isAscending - The direction of the last sort by this property. Used to preserve
 * past sort orders.
 */

/**
 * Stores sort information for a set of SortableProperties, including which property is currently being sorted on, as
 * well as the last sort order for each property.
 */
var SortableProperties = exports.SortableProperties = function () {
  /**
   * @param {Array<SortableProperty>} sortableProperties - a set of sortable properties.
   * @param {string} initialSortablePropertyName - Which sort property should be sorted on by default.
   */
  function SortableProperties(sortableProperties, initialSortablePropertyName) {
    _classCallCheck(this, SortableProperties);

    this.sortableProperties = sortableProperties;
    /**
     * The current property that is being sorted on.
     * @type {SortableProperty}
     */
    this.currentSortedProperty = this.getSortablePropertyByName(initialSortablePropertyName);
    if (!this.currentSortedProperty) {
      throw new Error('No property with the name ' + initialSortablePropertyName);
    }
  }

  /**
   * @returns {SortableProperty} The current property that is being sorted on. Undefined if no sort order is applied.
   */


  _createClass(SortableProperties, [{
    key: 'getSortedProperty',
    value: function getSortedProperty() {
      return this.currentSortedProperty;
    }

    /**
     * Sorts the items passed in and returns a newly sorted array.
     * @param items {Array.<Object>}
     * @returns {Array.<Object>} sorted array of items, based off the sort properties.
     */

  }, {
    key: 'sortItems',
    value: function sortItems(items) {
      return this.isCurrentSortAscending() ? _lodash2.default.sortBy(items, this.getSortedProperty().getValue) : _lodash2.default.sortBy(items, this.getSortedProperty().getValue).reverse();
    }

    /**
     * Returns the SortProperty with the given name, if found.
     * @param {String} propertyName
     * @returns {SortableProperty|undefined}
     */

  }, {
    key: 'getSortablePropertyByName',
    value: function getSortablePropertyByName(propertyName) {
      return this.sortableProperties.find(function (property) {
        return property.name === propertyName;
      });
    }

    /**
     * Updates the sort property, potentially flipping the sort order based on whether the same
     * property was already being sorted.
     * @param propertyName {String}
     */

  }, {
    key: 'sortOn',
    value: function sortOn(propertyName) {
      var newSortedProperty = this.getSortablePropertyByName(propertyName);
      var sortedProperty = this.getSortedProperty();
      if (sortedProperty.name === newSortedProperty.name) {
        this.flipCurrentSortOrder();
      } else {
        this.currentSortedProperty = newSortedProperty;
      }
    }

    /**
     * @returns {boolean} True if the current sortable property is sorted in ascending order.
     */

  }, {
    key: 'isCurrentSortAscending',
    value: function isCurrentSortAscending() {
      var sortedProperty = this.getSortedProperty();
      return sortedProperty ? this.isAscendingByName(sortedProperty.name) : false;
    }

    /**
     * @param {string} propertyName
     * @returns {boolean} True if the given sort property is sorted in ascending order.
     */

  }, {
    key: 'isAscendingByName',
    value: function isAscendingByName(propertyName) {
      var sortedProperty = this.getSortablePropertyByName(propertyName);
      return sortedProperty ? sortedProperty.isAscending : false;
    }

    /**
     * Flips the current sorted property sort order.
     */

  }, {
    key: 'flipCurrentSortOrder',
    value: function flipCurrentSortOrder() {
      this.currentSortedProperty.isAscending = !this.currentSortedProperty.isAscending;
    }
  }]);

  return SortableProperties;
}();

/***/ }),
/* 2259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var LEFT_ALIGNMENT = exports.LEFT_ALIGNMENT = 'left';
var RIGHT_ALIGNMENT = exports.RIGHT_ALIGNMENT = 'right';

/***/ }),
/* 2260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiScreenReaderOnly = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var KuiScreenReaderOnly = exports.KuiScreenReaderOnly = function KuiScreenReaderOnly(_ref) {
  var children = _ref.children;

  var classes = (0, _classnames2.default)('kuiScreenReaderOnly', children.props.className);

  var props = _extends({}, children.props, {
    className: classes
  });

  return (0, _react.cloneElement)(children, props);
};

KuiScreenReaderOnly.propTypes = {
  children: _propTypes2.default.node
};

/***/ }),
/* 2261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _bar_section = __webpack_require__(2262);

Object.defineProperty(exports, 'KuiBarSection', {
  enumerable: true,
  get: function get() {
    return _bar_section.KuiBarSection;
  }
});

var _bar = __webpack_require__(2263);

Object.defineProperty(exports, 'KuiBar', {
  enumerable: true,
  get: function get() {
    return _bar.KuiBar;
  }
});

/***/ }),
/* 2262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiBarSection = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiBarSection = function KuiBarSection(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiBarSection', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
};
exports.KuiBarSection = KuiBarSection;
KuiBarSection.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiBar = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiBar = function KuiBar(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiBar', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
};
exports.KuiBar = KuiBar;
KuiBar.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiSubmitButton = exports.KuiLinkButton = exports.KuiButton = exports.BUTTON_TYPES = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _button_icon = __webpack_require__(801);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var accessibleIconButton = function accessibleIconButton(props, propName, componentName) {
  if (props.children) {
    return;
  }

  if (props['aria-label']) {
    return;
  }

  if (props['aria-labelledby']) {
    return;
  }

  throw new Error(componentName + ' requires aria-label or aria-labelledby to be specified if it does not have children. ' + 'This is because we\'re assuming you\'re creating an icon-only button, which is screen-reader-inaccessible.');
};

var BUTTON_TYPES = ['basic', 'hollow', 'danger', 'warning', 'primary', 'secondary'];

var ICON_POSITIONS = ['left', 'right'];

var DEFAULT_ICON_POSITION = 'left';

var buttonTypeToClassNameMap = {
  basic: 'kuiButton--basic',
  hollow: 'kuiButton--hollow',
  danger: 'kuiButton--danger',
  warning: 'kuiButton--warning',
  primary: 'kuiButton--primary',
  secondary: 'kuiButton--secondary'
};

var getClassName = function getClassName(_ref) {
  var className = _ref.className,
      buttonType = _ref.buttonType,
      _ref$hasIcon = _ref.hasIcon,
      hasIcon = _ref$hasIcon === undefined ? false : _ref$hasIcon;
  return (0, _classnames2.default)('kuiButton', className, buttonTypeToClassNameMap[buttonType], {
    'kuiButton--iconText': hasIcon
  });
};

var ContentWithIcon = function ContentWithIcon(_ref2) {
  var children = _ref2.children,
      icon = _ref2.icon,
      iconPosition = _ref2.iconPosition,
      isLoading = _ref2.isLoading;

  var iconOrLoading = isLoading ? _react2.default.createElement(_button_icon.KuiButtonIcon, { type: 'loading' }) : icon;

  // We need to wrap the children so that the icon's :first-child etc. pseudo-selectors get applied
  // correctly.
  var wrappedChildren = children ? _react2.default.createElement(
    'span',
    null,
    children
  ) : undefined;

  switch (iconPosition) {
    case 'left':
      return _react2.default.createElement(
        'span',
        { className: 'kuiButton__inner' },
        iconOrLoading,
        wrappedChildren
      );

    case 'right':
      return _react2.default.createElement(
        'span',
        { className: 'kuiButton__inner' },
        wrappedChildren,
        iconOrLoading
      );
  }
};

var KuiButton = function KuiButton(_ref3) {
  var isLoading = _ref3.isLoading,
      _ref3$iconPosition = _ref3.iconPosition,
      iconPosition = _ref3$iconPosition === undefined ? DEFAULT_ICON_POSITION : _ref3$iconPosition,
      className = _ref3.className,
      buttonType = _ref3.buttonType,
      icon = _ref3.icon,
      children = _ref3.children,
      rest = _objectWithoutProperties(_ref3, ['isLoading', 'iconPosition', 'className', 'buttonType', 'icon', 'children']);

  return _react2.default.createElement(
    'button',
    _extends({
      className: getClassName({
        className: className,
        buttonType: buttonType,
        hasIcon: icon || isLoading
      })
    }, rest),
    _react2.default.createElement(
      ContentWithIcon,
      {
        icon: icon,
        iconPosition: iconPosition,
        isLoading: isLoading
      },
      children
    )
  );
};

KuiButton.propTypes = {
  icon: _propTypes2.default.node,
  iconPosition: _propTypes2.default.oneOf(ICON_POSITIONS),
  children: _propTypes2.default.node,
  isLoading: _propTypes2.default.bool,
  buttonType: _propTypes2.default.oneOf(BUTTON_TYPES),
  className: _propTypes2.default.string,
  'aria-label': accessibleIconButton
};

var KuiLinkButton = function KuiLinkButton(_ref4) {
  var isLoading = _ref4.isLoading,
      icon = _ref4.icon,
      _ref4$iconPosition = _ref4.iconPosition,
      iconPosition = _ref4$iconPosition === undefined ? DEFAULT_ICON_POSITION : _ref4$iconPosition,
      className = _ref4.className,
      disabled = _ref4.disabled,
      buttonType = _ref4.buttonType,
      children = _ref4.children,
      rest = _objectWithoutProperties(_ref4, ['isLoading', 'icon', 'iconPosition', 'className', 'disabled', 'buttonType', 'children']);

  var onClick = function onClick(e) {
    if (disabled) {
      e.preventDefault();
    }
  };

  var classes = (0, _classnames2.default)(getClassName({
    className: className,
    buttonType: buttonType,
    hasIcon: icon || isLoading
  }), { 'kuiButton-isDisabled': disabled });

  return _react2.default.createElement(
    'a',
    _extends({
      className: classes,
      onClick: onClick
    }, rest),
    _react2.default.createElement(
      ContentWithIcon,
      {
        icon: icon,
        iconPosition: iconPosition,
        isLoading: isLoading
      },
      children
    )
  );
};

KuiLinkButton.propTypes = {
  icon: _propTypes2.default.node,
  iconPosition: _propTypes2.default.oneOf(ICON_POSITIONS),
  isLoading: _propTypes2.default.bool,
  buttonType: _propTypes2.default.oneOf(BUTTON_TYPES),
  className: _propTypes2.default.string,
  children: _propTypes2.default.node,
  'aria-label': accessibleIconButton
};

var KuiSubmitButton = function KuiSubmitButton(_ref5) {
  var className = _ref5.className,
      buttonType = _ref5.buttonType,
      children = _ref5.children,
      rest = _objectWithoutProperties(_ref5, ['className', 'buttonType', 'children']);

  // NOTE: The `input` element is a void element and can't contain children.
  return _react2.default.createElement('input', _extends({
    type: 'submit',
    value: children,
    className: getClassName({ className: className, buttonType: buttonType })
  }, rest));
};

KuiSubmitButton.propTypes = {
  children: _propTypes2.default.string,
  buttonType: _propTypes2.default.oneOf(BUTTON_TYPES),
  className: _propTypes2.default.string
};

exports.BUTTON_TYPES = BUTTON_TYPES;
exports.KuiButton = KuiButton;
exports.KuiLinkButton = KuiLinkButton;
exports.KuiSubmitButton = KuiSubmitButton;

/***/ }),
/* 2265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiButtonGroup = undefined;

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var KuiButtonGroup = function KuiButtonGroup(props) {
  var classes = (0, _classnames2.default)('kuiButtonGroup', {
    'kuiButtonGroup--united': props.isUnited
  });

  return _react2.default.createElement(
    'div',
    { className: classes, role: 'group' },
    props.children
  );
};

KuiButtonGroup.propTypes = {
  children: _propTypes2.default.node,
  isUnited: _propTypes2.default.bool
};

exports.KuiButtonGroup = KuiButtonGroup;

/***/ }),
/* 2266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _card = __webpack_require__(2267);

Object.defineProperty(exports, 'KuiCard', {
  enumerable: true,
  get: function get() {
    return _card.KuiCard;
  }
});

var _card_description_text = __webpack_require__(2268);

Object.defineProperty(exports, 'KuiCardDescriptionText', {
  enumerable: true,
  get: function get() {
    return _card_description_text.KuiCardDescriptionText;
  }
});

var _card_description_title = __webpack_require__(2269);

Object.defineProperty(exports, 'KuiCardDescriptionTitle', {
  enumerable: true,
  get: function get() {
    return _card_description_title.KuiCardDescriptionTitle;
  }
});

var _card_description = __webpack_require__(2270);

Object.defineProperty(exports, 'KuiCardDescription', {
  enumerable: true,
  get: function get() {
    return _card_description.KuiCardDescription;
  }
});

var _card_footer = __webpack_require__(2271);

Object.defineProperty(exports, 'KuiCardFooter', {
  enumerable: true,
  get: function get() {
    return _card_footer.KuiCardFooter;
  }
});

var _card_group = __webpack_require__(2272);

Object.defineProperty(exports, 'KuiCardGroup', {
  enumerable: true,
  get: function get() {
    return _card_group.KuiCardGroup;
  }
});

/***/ }),
/* 2267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiCard = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiCard = function KuiCard(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiCard', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
};
exports.KuiCard = KuiCard;
KuiCard.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiCardDescriptionText = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiCardDescriptionText = function KuiCardDescriptionText(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiCard__descriptionText', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
};
exports.KuiCardDescriptionText = KuiCardDescriptionText;
KuiCardDescriptionText.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiCardDescriptionTitle = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiCardDescriptionTitle = function KuiCardDescriptionTitle(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiCard__descriptionTitle', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes, role: 'heading' }, rest),
    children
  );
};
exports.KuiCardDescriptionTitle = KuiCardDescriptionTitle;
KuiCardDescriptionTitle.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiCardDescription = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiCardDescription = function KuiCardDescription(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiCard__description', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
};
exports.KuiCardDescription = KuiCardDescription;
KuiCardDescription.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiCardFooter = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiCardFooter = function KuiCardFooter(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiCard__footer', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
};
exports.KuiCardFooter = KuiCardFooter;
KuiCardFooter.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiCardGroup = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiCardGroup = function KuiCardGroup(_ref) {
  var children = _ref.children,
      className = _ref.className,
      isUnited = _ref.isUnited,
      rest = _objectWithoutProperties(_ref, ['children', 'className', 'isUnited']);

  var classes = (0, _classnames2.default)('kuiCardGroup', className, { 'kuiCardGroup--united': isUnited });
  return _react2.default.createElement(
    'div',
    _extends({ className: classes, role: 'group' }, rest),
    children
  );
};

exports.KuiCardGroup = KuiCardGroup;
KuiCardGroup.defaultProps = {
  isUnited: false
};

KuiCardGroup.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string,
  isUnited: _propTypes2.default.bool
};

/***/ }),
/* 2273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _code_editor = __webpack_require__(2274);

Object.defineProperty(exports, 'KuiCodeEditor', {
  enumerable: true,
  get: function get() {
    return _code_editor.KuiCodeEditor;
  }
});

/***/ }),
/* 2274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiCodeEditor = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _reactAce = __webpack_require__(726);

var _reactAce2 = _interopRequireDefault(_reactAce);

var _services = __webpack_require__(120);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var KuiCodeEditor = exports.KuiCodeEditor = function (_Component) {
  _inherits(KuiCodeEditor, _Component);

  function KuiCodeEditor() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, KuiCodeEditor);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = KuiCodeEditor.__proto__ || Object.getPrototypeOf(KuiCodeEditor)).call.apply(_ref, [this].concat(args))), _this), _initialiseProps.call(_this), _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(KuiCodeEditor, [{
    key: 'stopEditing',
    value: function stopEditing() {
      this.setState({
        isHintActive: true,
        isEditing: false
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          width = _props.width,
          height = _props.height,
          onBlur = _props.onBlur,
          isReadOnly = _props.isReadOnly,
          setOptions = _props.setOptions,
          cursorStart = _props.cursorStart,
          rest = _objectWithoutProperties(_props, ['width', 'height', 'onBlur', 'isReadOnly', 'setOptions', 'cursorStart']);

      var classes = (0, _classnames2.default)('kuiCodeEditorWrapper', {
        'kuiCodeEditorWrapper-isEditing': this.state.isEditing
      });

      var promptClasses = (0, _classnames2.default)('kuiCodeEditorKeyboardHint', {
        'kuiCodeEditorKeyboardHint-isInactive': !this.state.isHintActive
      });

      var filteredCursorStart = void 0;

      var options = _extends({}, setOptions);

      if (isReadOnly) {
        // Put the cursor at the beginning of the editor, so that it doesn't look like
        // a prompt to begin typing.
        filteredCursorStart = -1;

        Object.assign(options, {
          readOnly: true,
          highlightActiveLine: false,
          highlightGutterLine: false
        });
      } else {
        filteredCursorStart = cursorStart;
      }

      var activity = isReadOnly ? 'interacting with the code' : 'editing';

      var prompt = _react2.default.createElement(
        'div',
        {
          className: promptClasses,
          id: this.idGenerator('codeEditor'),
          ref: function ref(hint) {
            _this2.editorHint = hint;
          },
          tabIndex: '0',
          role: 'button',
          onClick: this.startEditing,
          onKeyDown: this.onKeyDownHint,
          'data-test-subj': 'codeEditorHint'
        },
        _react2.default.createElement(
          'p',
          { className: 'kuiText kuiVerticalRhythmSmall' },
          'Press Enter to start ',
          activity,
          '.'
        ),
        _react2.default.createElement(
          'p',
          { className: 'kuiText kuiVerticalRhythmSmall' },
          'When you\u2019re done, press Escape to stop ',
          activity,
          '.'
        )
      );

      return _react2.default.createElement(
        'div',
        {
          className: classes,
          style: { width: width, height: height }
        },
        prompt,
        _react2.default.createElement(_reactAce2.default, _extends({
          ref: this.aceEditorRef,
          width: width,
          height: height,
          onFocus: this.onFocusAce,
          onBlur: this.onBlurAce,
          setOptions: options,
          cursorStart: filteredCursorStart
        }, rest))
      );
    }
  }]);

  return KuiCodeEditor;
}(_react.Component);

var _initialiseProps = function _initialiseProps() {
  var _this3 = this;

  this.state = {
    isHintActive: true,
    isEditing: false
  };
  this.idGenerator = (0, _services.htmlIdGenerator)();

  this.aceEditorRef = function (aceEditor) {
    if (aceEditor) {
      _this3.aceEditor = aceEditor;
      aceEditor.editor.textInput.getElement().tabIndex = -1;
      aceEditor.editor.textInput.getElement().addEventListener('keydown', _this3.onKeydownAce);
    }
  };

  this.onKeydownAce = function (ev) {
    if (ev.keyCode === _services.keyCodes.ESCAPE) {
      ev.preventDefault();
      ev.stopPropagation();
      _this3.stopEditing();
      _this3.editorHint.focus();
    }
  };

  this.onFocusAce = function () {
    _this3.setState({
      isEditing: true
    });
    if (_this3.props.onFocus) {
      var _props2;

      (_props2 = _this3.props).onFocus.apply(_props2, arguments);
    }
  };

  this.onBlurAce = function () {
    _this3.stopEditing();
    if (_this3.props.onBlur) {
      var _props3;

      (_props3 = _this3.props).onBlur.apply(_props3, arguments);
    }
  };

  this.onKeyDownHint = function (ev) {
    if (ev.keyCode === _services.keyCodes.ENTER) {
      ev.preventDefault();
      _this3.startEditing();
    }
  };

  this.startEditing = function () {
    _this3.setState({
      isHintActive: false
    });
    _this3.aceEditor.editor.textInput.focus();
  };
};

KuiCodeEditor.propTypes = {
  width: _propTypes2.default.string,
  height: _propTypes2.default.string,
  onBlur: _propTypes2.default.func,
  isReadOnly: _propTypes2.default.bool,
  setOptions: _propTypes2.default.object,
  cursorStart: _propTypes2.default.number
};

KuiCodeEditor.defaultProps = {
  setOptions: {}
};

/***/ }),
/* 2275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _color_picker = __webpack_require__(2276);

Object.defineProperty(exports, 'KuiColorPicker', {
  enumerable: true,
  get: function get() {
    return _color_picker.KuiColorPicker;
  }
});

/***/ }),
/* 2276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiColorPicker = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _reactColor = __webpack_require__(2277);

var _outside_click_detector = __webpack_require__(512);

var _color_picker_swatch = __webpack_require__(2524);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var KuiColorPicker = exports.KuiColorPicker = function (_React$Component) {
  _inherits(KuiColorPicker, _React$Component);

  function KuiColorPicker(props) {
    _classCallCheck(this, KuiColorPicker);

    var _this = _possibleConstructorReturn(this, (KuiColorPicker.__proto__ || Object.getPrototypeOf(KuiColorPicker)).call(this, props));

    _this.closeColorSelector = function () {
      _this.setState({ showColorSelector: false });
    };

    _this.toggleColorSelector = function () {
      _this.setState({ showColorSelector: !_this.state.showColorSelector });
    };

    _this.handleColorSelection = function (color) {
      _this.props.onChange(color.hex);
    };

    _this.state = {
      showColorSelector: false
    };
    return _this;
  }

  _createClass(KuiColorPicker, [{
    key: 'getColorLabel',
    value: function getColorLabel() {
      var color = this.props.color;

      var colorValue = color === null ? '(transparent)' : color;
      return _react2.default.createElement(
        'div',
        {
          className: 'kuiColorPicker__label',
          'aria-label': 'Color selection is ' + colorValue
        },
        colorValue
      );
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          color = _props.color,
          className = _props.className,
          showColorLabel = _props.showColorLabel;

      var classes = (0, _classnames2.default)('kuiColorPicker', className);
      return _react2.default.createElement(
        _outside_click_detector.KuiOutsideClickDetector,
        { onOutsideClick: this.closeColorSelector },
        _react2.default.createElement(
          'div',
          {
            className: classes,
            'data-test-subj': this.props['data-test-subj']
          },
          _react2.default.createElement(
            'div',
            {
              className: 'kuiColorPicker__preview',
              onClick: this.toggleColorSelector
            },
            _react2.default.createElement(_color_picker_swatch.KuiColorPickerSwatch, { color: color, 'aria-label': this.props['aria-label'] }),
            showColorLabel ? this.getColorLabel() : null
          ),
          this.state.showColorSelector ? _react2.default.createElement(
            'div',
            { className: 'kuiColorPickerPopUp', 'data-test-subj': 'colorPickerPopup' },
            _react2.default.createElement(_reactColor.ChromePicker, {
              color: color ? color : '#ffffff',
              disableAlpha: true,
              onChange: this.handleColorSelection
            })
          ) : null
        )
      );
    }
  }]);

  return KuiColorPicker;
}(_react2.default.Component);

KuiColorPicker.propTypes = {
  className: _propTypes2.default.string,
  color: _propTypes2.default.string,
  onChange: _propTypes2.default.func.isRequired,
  showColorLabel: _propTypes2.default.bool
};

KuiColorPicker.defaultProps = {
  'aria-label': 'Select a color',
  showColorLabel: true
};

/***/ }),
/* 2277 */,
/* 2278 */,
/* 2279 */,
/* 2280 */,
/* 2281 */,
/* 2282 */,
/* 2283 */,
/* 2284 */,
/* 2285 */,
/* 2286 */,
/* 2287 */,
/* 2288 */,
/* 2289 */,
/* 2290 */,
/* 2291 */,
/* 2292 */,
/* 2293 */,
/* 2294 */,
/* 2295 */,
/* 2296 */,
/* 2297 */,
/* 2298 */,
/* 2299 */,
/* 2300 */,
/* 2301 */,
/* 2302 */,
/* 2303 */,
/* 2304 */,
/* 2305 */,
/* 2306 */,
/* 2307 */,
/* 2308 */,
/* 2309 */,
/* 2310 */,
/* 2311 */,
/* 2312 */,
/* 2313 */,
/* 2314 */,
/* 2315 */,
/* 2316 */,
/* 2317 */,
/* 2318 */,
/* 2319 */,
/* 2320 */,
/* 2321 */,
/* 2322 */,
/* 2323 */,
/* 2324 */,
/* 2325 */,
/* 2326 */,
/* 2327 */,
/* 2328 */,
/* 2329 */,
/* 2330 */,
/* 2331 */,
/* 2332 */,
/* 2333 */,
/* 2334 */,
/* 2335 */,
/* 2336 */,
/* 2337 */,
/* 2338 */,
/* 2339 */,
/* 2340 */,
/* 2341 */,
/* 2342 */,
/* 2343 */,
/* 2344 */,
/* 2345 */,
/* 2346 */,
/* 2347 */,
/* 2348 */,
/* 2349 */,
/* 2350 */,
/* 2351 */,
/* 2352 */,
/* 2353 */,
/* 2354 */,
/* 2355 */,
/* 2356 */,
/* 2357 */,
/* 2358 */,
/* 2359 */,
/* 2360 */,
/* 2361 */,
/* 2362 */,
/* 2363 */,
/* 2364 */,
/* 2365 */,
/* 2366 */,
/* 2367 */,
/* 2368 */,
/* 2369 */,
/* 2370 */,
/* 2371 */,
/* 2372 */,
/* 2373 */,
/* 2374 */,
/* 2375 */,
/* 2376 */,
/* 2377 */,
/* 2378 */,
/* 2379 */,
/* 2380 */,
/* 2381 */,
/* 2382 */,
/* 2383 */,
/* 2384 */,
/* 2385 */,
/* 2386 */,
/* 2387 */,
/* 2388 */,
/* 2389 */,
/* 2390 */,
/* 2391 */,
/* 2392 */,
/* 2393 */,
/* 2394 */,
/* 2395 */,
/* 2396 */,
/* 2397 */,
/* 2398 */,
/* 2399 */,
/* 2400 */,
/* 2401 */,
/* 2402 */,
/* 2403 */,
/* 2404 */,
/* 2405 */,
/* 2406 */,
/* 2407 */,
/* 2408 */,
/* 2409 */,
/* 2410 */,
/* 2411 */,
/* 2412 */,
/* 2413 */,
/* 2414 */,
/* 2415 */,
/* 2416 */,
/* 2417 */,
/* 2418 */,
/* 2419 */,
/* 2420 */,
/* 2421 */,
/* 2422 */,
/* 2423 */,
/* 2424 */,
/* 2425 */,
/* 2426 */,
/* 2427 */,
/* 2428 */,
/* 2429 */,
/* 2430 */,
/* 2431 */,
/* 2432 */,
/* 2433 */,
/* 2434 */,
/* 2435 */,
/* 2436 */,
/* 2437 */,
/* 2438 */,
/* 2439 */,
/* 2440 */,
/* 2441 */,
/* 2442 */,
/* 2443 */,
/* 2444 */,
/* 2445 */,
/* 2446 */,
/* 2447 */,
/* 2448 */,
/* 2449 */,
/* 2450 */,
/* 2451 */,
/* 2452 */,
/* 2453 */,
/* 2454 */,
/* 2455 */,
/* 2456 */,
/* 2457 */,
/* 2458 */,
/* 2459 */,
/* 2460 */,
/* 2461 */,
/* 2462 */,
/* 2463 */,
/* 2464 */,
/* 2465 */,
/* 2466 */,
/* 2467 */,
/* 2468 */,
/* 2469 */,
/* 2470 */,
/* 2471 */,
/* 2472 */,
/* 2473 */,
/* 2474 */,
/* 2475 */,
/* 2476 */,
/* 2477 */,
/* 2478 */,
/* 2479 */,
/* 2480 */,
/* 2481 */,
/* 2482 */,
/* 2483 */,
/* 2484 */,
/* 2485 */,
/* 2486 */,
/* 2487 */,
/* 2488 */,
/* 2489 */,
/* 2490 */,
/* 2491 */,
/* 2492 */,
/* 2493 */,
/* 2494 */,
/* 2495 */,
/* 2496 */,
/* 2497 */,
/* 2498 */,
/* 2499 */,
/* 2500 */,
/* 2501 */,
/* 2502 */,
/* 2503 */,
/* 2504 */,
/* 2505 */,
/* 2506 */,
/* 2507 */,
/* 2508 */,
/* 2509 */,
/* 2510 */,
/* 2511 */,
/* 2512 */,
/* 2513 */,
/* 2514 */,
/* 2515 */,
/* 2516 */,
/* 2517 */,
/* 2518 */,
/* 2519 */,
/* 2520 */,
/* 2521 */,
/* 2522 */,
/* 2523 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiOutsideClickDetector = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var KuiOutsideClickDetector = exports.KuiOutsideClickDetector = function (_Component) {
  _inherits(KuiOutsideClickDetector, _Component);

  function KuiOutsideClickDetector() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, KuiOutsideClickDetector);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = KuiOutsideClickDetector.__proto__ || Object.getPrototypeOf(KuiOutsideClickDetector)).call.apply(_ref, [this].concat(args))), _this), _this.onClickOutside = function (event) {
      if (!_this.wrapperRef) {
        return;
      }

      if (_this.wrapperRef === event.target) {
        return;
      }

      if (_this.wrapperRef.contains(event.target)) {
        return;
      }

      _this.props.onOutsideClick();
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(KuiOutsideClickDetector, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      document.addEventListener('mousedown', this.onClickOutside);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      document.removeEventListener('mousedown', this.onClickOutside);
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var props = _extends({}, this.props.children.props, {
        ref: function ref(node) {
          _this2.wrapperRef = node;
        }
      });

      var child = _react.Children.only(this.props.children);
      return (0, _react.cloneElement)(child, props);
    }
  }]);

  return KuiOutsideClickDetector;
}(_react.Component);

KuiOutsideClickDetector.propTypes = {
  children: _propTypes2.default.node.isRequired,
  onOutsideClick: _propTypes2.default.func.isRequired
};

/***/ }),
/* 2524 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiColorPickerSwatch = KuiColorPickerSwatch;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _color_picker_empty_swatch = __webpack_require__(2525);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function KuiColorPickerSwatch(props) {
  var color = props.color,
      className = props.className;

  var isClear = !color;
  var classes = (0, _classnames2.default)('kuiColorPicker__swatch', className, {
    'kuiColorPicker__emptySwatch': isClear
  });
  var children = void 0;

  if (isClear) {
    children = _react2.default.createElement(_color_picker_empty_swatch.KuiColorPickerEmptySwatch, null);
  }

  return _react2.default.createElement(
    'div',
    {
      className: classes,
      'aria-label': props['aria-label'],
      'data-test-subj': 'colorSwatch',
      style: { background: color ? color : '' }
    },
    children
  );
}

KuiColorPickerSwatch.propTypes = {
  className: _propTypes2.default.string,
  color: _propTypes2.default.string
};

/***/ }),
/* 2525 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiColorPickerEmptySwatch = KuiColorPickerEmptySwatch;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function KuiColorPickerEmptySwatch() {
  return _react2.default.createElement(
    "svg",
    null,
    _react2.default.createElement("line", { x1: "0", y1: "100%", x2: "100%", y2: "0" })
  );
}

/***/ }),
/* 2526 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _collapse_button = __webpack_require__(2527);

Object.defineProperty(exports, 'KuiCollapseButton', {
  enumerable: true,
  get: function get() {
    return _collapse_button.KuiCollapseButton;
  }
});

/***/ }),
/* 2527 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiCollapseButton = exports.DIRECTIONS = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var DIRECTIONS = ['down', 'up', 'left', 'right'];

var directionToClassNameMap = {
  down: 'fa-chevron-circle-down',
  up: 'fa-chevron-circle-up',
  left: 'fa-chevron-circle-left',
  right: 'fa-chevron-circle-right'
};

var KuiCollapseButton = function KuiCollapseButton(_ref) {
  var className = _ref.className,
      direction = _ref.direction,
      rest = _objectWithoutProperties(_ref, ['className', 'direction']);

  var classes = (0, _classnames2.default)('kuiCollapseButton', className);
  var childClasses = (0, _classnames2.default)('kuiIcon', directionToClassNameMap[direction]);

  return _react2.default.createElement(
    'button',
    _extends({
      type: 'button',
      className: classes
    }, rest),
    _react2.default.createElement('span', { className: childClasses })
  );
};

KuiCollapseButton.propTypes = {
  className: _propTypes2.default.string,
  direction: _propTypes2.default.oneOf(DIRECTIONS).isRequired
};

exports.DIRECTIONS = DIRECTIONS;
exports.KuiCollapseButton = KuiCollapseButton;

/***/ }),
/* 2528 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _context_menu = __webpack_require__(2529);

Object.defineProperty(exports, 'KuiContextMenu', {
  enumerable: true,
  get: function get() {
    return _context_menu.KuiContextMenu;
  }
});

var _context_menu_panel = __webpack_require__(859);

Object.defineProperty(exports, 'KuiContextMenuPanel', {
  enumerable: true,
  get: function get() {
    return _context_menu_panel.KuiContextMenuPanel;
  }
});

var _context_menu_item = __webpack_require__(860);

Object.defineProperty(exports, 'KuiContextMenuItem', {
  enumerable: true,
  get: function get() {
    return _context_menu_item.KuiContextMenuItem;
  }
});

/***/ }),
/* 2529 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiContextMenu = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _context_menu_panel = __webpack_require__(859);

var _context_menu_item = __webpack_require__(860);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function mapIdsToPanels(panels) {
  var map = {};

  panels.forEach(function (panel) {
    map[panel.id] = panel;
  });

  return map;
}

function mapIdsToPreviousPanels(panels) {
  var idToPreviousPanelIdMap = {};

  panels.forEach(function (panel) {
    if (Array.isArray(panel.items)) {
      panel.items.forEach(function (item) {
        var isCloseable = item.panel !== undefined;
        if (isCloseable) {
          idToPreviousPanelIdMap[item.panel] = panel.id;
        }
      });
    }
  });

  return idToPreviousPanelIdMap;
}

function mapPanelItemsToPanels(panels) {
  var idAndItemIndexToPanelIdMap = {};

  panels.forEach(function (panel) {
    idAndItemIndexToPanelIdMap[panel.id] = {};

    if (panel.items) {
      panel.items.forEach(function (item, index) {
        if (item.panel) {
          idAndItemIndexToPanelIdMap[panel.id][index] = item.panel;
        }
      });
    }
  });

  return idAndItemIndexToPanelIdMap;
}

var KuiContextMenu = exports.KuiContextMenu = function (_Component) {
  _inherits(KuiContextMenu, _Component);

  function KuiContextMenu(props) {
    _classCallCheck(this, KuiContextMenu);

    var _this = _possibleConstructorReturn(this, (KuiContextMenu.__proto__ || Object.getPrototypeOf(KuiContextMenu)).call(this, props));

    _this.hasPreviousPanel = function (panelId) {
      var previousPanelId = _this.idToPreviousPanelIdMap[panelId];
      return typeof previousPanelId !== 'undefined';
    };

    _this.showNextPanel = function (itemIndex) {
      var nextPanelId = _this.idAndItemIndexToPanelIdMap[_this.state.incomingPanelId][itemIndex];
      if (nextPanelId) {
        if (_this.state.isUsingKeyboardToNavigate) {
          _this.setState({
            focusedItemIndex: 0
          });
        }

        _this.showPanel(nextPanelId, 'next');
      }
    };

    _this.showPreviousPanel = function () {
      // If there's a previous panel, then we can close the current panel to go back to it.
      if (_this.hasPreviousPanel(_this.state.incomingPanelId)) {
        var previousPanelId = _this.idToPreviousPanelIdMap[_this.state.incomingPanelId];

        // Set focus on the item which shows the panel we're leaving.
        var previousPanel = _this.idToPanelMap[previousPanelId];
        var focusedItemIndex = previousPanel.items.findIndex(function (item) {
          return item.panel === _this.state.incomingPanelId;
        });

        if (focusedItemIndex !== -1) {
          _this.setState({
            focusedItemIndex: focusedItemIndex
          });
        }

        _this.showPanel(previousPanelId, 'previous');
      }
    };

    _this.onIncomingPanelHeightChange = function (height) {
      _this.setState({
        height: height
      });
    };

    _this.onOutGoingPanelTransitionComplete = function () {
      _this.setState({
        isOutgoingPanelVisible: false
      });
    };

    _this.onUseKeyboardToNavigate = function () {
      if (!_this.state.isUsingKeyboardToNavigate) {
        _this.setState({
          isUsingKeyboardToNavigate: true
        });
      }
    };

    _this.idToPanelMap = {};
    _this.idToPreviousPanelIdMap = {};
    _this.idAndItemIndexToPanelIdMap = {};

    _this.state = {
      height: undefined,
      outgoingPanelId: undefined,
      incomingPanelId: props.initialPanelId,
      transitionDirection: undefined,
      isOutgoingPanelVisible: false,
      focusedItemIndex: undefined,
      isUsingKeyboardToNavigate: false
    };
    return _this;
  }

  _createClass(KuiContextMenu, [{
    key: 'showPanel',
    value: function showPanel(panelId, direction) {
      this.setState({
        outgoingPanelId: this.state.incomingPanelId,
        incomingPanelId: panelId,
        transitionDirection: direction,
        isOutgoingPanelVisible: true
      });
    }
  }, {
    key: 'updatePanelMaps',
    value: function updatePanelMaps(panels) {
      this.idToPanelMap = mapIdsToPanels(panels);
      this.idToPreviousPanelIdMap = mapIdsToPreviousPanels(panels);
      this.idAndItemIndexToPanelIdMap = mapPanelItemsToPanels(panels);
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.updatePanelMaps(this.props.panels);
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.panels !== this.props.panels) {
        this.updatePanelMaps(nextProps.panels);
      }
    }
  }, {
    key: 'renderItems',
    value: function renderItems() {
      var _this2 = this;

      var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      return items.map(function (item, index) {
        var panel = item.panel,
            name = item.name,
            icon = item.icon,
            onClick = item.onClick,
            rest = _objectWithoutProperties(item, ['panel', 'name', 'icon', 'onClick']);

        var onClickHandler = panel ? function () {
          // This component is commonly wrapped in a KuiOutsideClickDetector, which means we'll
          // need to wait for that logic to complete before re-rendering the DOM via showPanel.
          window.requestAnimationFrame(function () {
            if (onClick) onClick();
            _this2.showNextPanel(index);
          });
        } : onClick;

        return _react2.default.createElement(
          _context_menu_item.KuiContextMenuItem,
          _extends({
            key: name,
            icon: icon,
            onClick: onClickHandler,
            hasPanel: Boolean(panel)
          }, rest),
          name
        );
      });
    }
  }, {
    key: 'renderPanel',
    value: function renderPanel(panelId, transitionType) {
      var _this3 = this;

      var panel = this.idToPanelMap[panelId];

      if (!panel) {
        return;
      }

      // As above, we need to wait for KuiOutsideClickDetector to complete its logic before
      // re-rendering via showPanel.
      var onClose = void 0;
      if (this.hasPreviousPanel(panelId)) {
        onClose = function onClose() {
          return window.requestAnimationFrame(_this3.showPreviousPanel);
        };
      }

      return _react2.default.createElement(
        _context_menu_panel.KuiContextMenuPanel,
        {
          key: panelId,
          className: 'kuiContextMenu__panel',
          onHeightChange: transitionType === 'in' ? this.onIncomingPanelHeightChange : undefined,
          onTransitionComplete: transitionType === 'out' ? this.onOutGoingPanelTransitionComplete : undefined,
          title: panel.title,
          onClose: onClose,
          transitionType: this.state.isOutgoingPanelVisible ? transitionType : undefined,
          transitionDirection: this.state.isOutgoingPanelVisible ? this.state.transitionDirection : undefined,
          hasFocus: transitionType === 'in',
          items: this.renderItems(panel.items),
          initialFocusedItemIndex: this.state.isUsingKeyboardToNavigate ? this.state.focusedItemIndex : undefined,
          onUseKeyboardToNavigate: this.onUseKeyboardToNavigate,
          showNextPanel: this.showNextPanel,
          showPreviousPanel: this.showPreviousPanel
        },
        panel.content
      );
    }
  }, {
    key: 'render',
    value: function render() {
      var _this4 = this;

      var _props = this.props,
          panels = _props.panels,
          className = _props.className,
          initialPanelId = _props.initialPanelId,
          rest = _objectWithoutProperties(_props, ['panels', 'className', 'initialPanelId']);

      var incomingPanel = this.renderPanel(this.state.incomingPanelId, 'in');
      var outgoingPanel = void 0;

      if (this.state.isOutgoingPanelVisible) {
        outgoingPanel = this.renderPanel(this.state.outgoingPanelId, 'out');
      }

      var classes = (0, _classnames2.default)('kuiContextMenu', className);

      return _react2.default.createElement(
        'div',
        _extends({
          ref: function ref(node) {
            _this4.menu = node;
          },
          className: classes,
          style: { height: this.state.height }
        }, rest),
        outgoingPanel,
        incomingPanel
      );
    }
  }]);

  return KuiContextMenu;
}(_react.Component);

KuiContextMenu.propTypes = {
  className: _propTypes2.default.string,
  panels: _propTypes2.default.array,
  initialPanelId: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number])
};
KuiContextMenu.defaultProps = {
  panels: []
};

/***/ }),
/* 2530 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _empty_table_prompt_message = __webpack_require__(861);

Object.defineProperty(exports, 'KuiEmptyTablePromptMessage', {
  enumerable: true,
  get: function get() {
    return _empty_table_prompt_message.KuiEmptyTablePromptMessage;
  }
});

var _empty_table_prompt_panel = __webpack_require__(2531);

Object.defineProperty(exports, 'KuiEmptyTablePromptPanel', {
  enumerable: true,
  get: function get() {
    return _empty_table_prompt_panel.KuiEmptyTablePromptPanel;
  }
});

var _empty_table_prompt = __webpack_require__(2532);

Object.defineProperty(exports, 'KuiEmptyTablePrompt', {
  enumerable: true,
  get: function get() {
    return _empty_table_prompt.KuiEmptyTablePrompt;
  }
});

/***/ }),
/* 2531 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiEmptyTablePromptPanel = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiEmptyTablePromptPanel = function KuiEmptyTablePromptPanel(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiPanel kuiPanel--centered kuiPanel--withToolBar', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
};
exports.KuiEmptyTablePromptPanel = KuiEmptyTablePromptPanel;
KuiEmptyTablePromptPanel.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2532 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.KuiEmptyTablePrompt = KuiEmptyTablePrompt;

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _empty_table_prompt_message = __webpack_require__(861);

var _empty_table_prompt_actions = __webpack_require__(2533);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function KuiEmptyTablePrompt(_ref) {
  var actions = _ref.actions,
      message = _ref.message,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['actions', 'message', 'className']);

  var classes = (0, _classnames2.default)('kuiEmptyTablePrompt', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    _react2.default.createElement(
      _empty_table_prompt_message.KuiEmptyTablePromptMessage,
      null,
      message
    ),
    _react2.default.createElement(
      _empty_table_prompt_actions.KuiEmptyTablePromptActions,
      null,
      actions
    )
  );
}

KuiEmptyTablePrompt.propTypes = {
  message: _propTypes2.default.string.isRequired,
  actions: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2533 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiEmptyTablePromptActions = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiEmptyTablePromptActions = function KuiEmptyTablePromptActions(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiEmptyTablePrompt__actions', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
};
exports.KuiEmptyTablePromptActions = KuiEmptyTablePromptActions;
KuiEmptyTablePromptActions.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2534 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _event = __webpack_require__(2535);

Object.defineProperty(exports, 'KuiEvent', {
  enumerable: true,
  get: function get() {
    return _event.KuiEvent;
  }
});

var _event_symbol = __webpack_require__(2536);

Object.defineProperty(exports, 'KuiEventSymbol', {
  enumerable: true,
  get: function get() {
    return _event_symbol.KuiEventSymbol;
  }
});

var _event_body = __webpack_require__(2537);

Object.defineProperty(exports, 'KuiEventBody', {
  enumerable: true,
  get: function get() {
    return _event_body.KuiEventBody;
  }
});

var _event_body_message = __webpack_require__(2538);

Object.defineProperty(exports, 'KuiEventBodyMessage', {
  enumerable: true,
  get: function get() {
    return _event_body_message.KuiEventBodyMessage;
  }
});

var _event_body_metadata = __webpack_require__(2539);

Object.defineProperty(exports, 'KuiEventBodyMetadata', {
  enumerable: true,
  get: function get() {
    return _event_body_metadata.KuiEventBodyMetadata;
  }
});

/***/ }),
/* 2535 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiEvent = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiEvent = function KuiEvent(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiEvent', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
};
exports.KuiEvent = KuiEvent;
KuiEvent.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2536 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiEventSymbol = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiEventSymbol = function KuiEventSymbol(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiEventSymbol', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
};
exports.KuiEventSymbol = KuiEventSymbol;
KuiEventSymbol.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2537 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiEventBody = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiEventBody = function KuiEventBody(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiEventBody', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
};
exports.KuiEventBody = KuiEventBody;
KuiEventBody.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2538 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiEventBodyMessage = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiEventBodyMessage = function KuiEventBodyMessage(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiEventBody__message', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
};
exports.KuiEventBodyMessage = KuiEventBodyMessage;
KuiEventBodyMessage.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2539 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiEventBodyMetadata = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiEventBodyMetadata = function KuiEventBodyMetadata(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiEventBody__metadata', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
};
exports.KuiEventBodyMetadata = KuiEventBodyMetadata;
KuiEventBodyMetadata.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2540 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _expression = __webpack_require__(2541);

Object.defineProperty(exports, 'KuiExpression', {
  enumerable: true,
  get: function get() {
    return _expression.KuiExpression;
  }
});

var _expression_button = __webpack_require__(2542);

Object.defineProperty(exports, 'KuiExpressionButton', {
  enumerable: true,
  get: function get() {
    return _expression_button.KuiExpressionButton;
  }
});

/***/ }),
/* 2541 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiExpression = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiExpression = function KuiExpression(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiExpression', className);

  return _react2.default.createElement(
    'div',
    _extends({
      className: classes
    }, rest),
    children
  );
};

exports.KuiExpression = KuiExpression;
KuiExpression.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2542 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiExpressionButton = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiExpressionButton = function KuiExpressionButton(_ref) {
  var className = _ref.className,
      description = _ref.description,
      buttonValue = _ref.buttonValue,
      isActive = _ref.isActive,
      onClick = _ref.onClick,
      rest = _objectWithoutProperties(_ref, ['className', 'description', 'buttonValue', 'isActive', 'onClick']);

  var classes = (0, _classnames2.default)('kuiExpressionButton', className, {
    'kuiExpressionButton-isActive': isActive
  });

  return _react2.default.createElement(
    'button',
    _extends({
      className: classes,
      onClick: onClick
    }, rest),
    _react2.default.createElement(
      'span',
      { className: 'kuiExpressionButton__description' },
      description
    ),
    ' ',
    _react2.default.createElement(
      'span',
      { className: 'kuiExpressionButton__value' },
      buttonValue
    )
  );
};

exports.KuiExpressionButton = KuiExpressionButton;
KuiExpressionButton.propTypes = {
  className: _propTypes2.default.string,
  description: _propTypes2.default.string.isRequired,
  buttonValue: _propTypes2.default.string.isRequired,
  isActive: _propTypes2.default.bool.isRequired,
  onClick: _propTypes2.default.func.isRequired
};

KuiExpressionButton.defaultProps = {
  isActive: false
};

/***/ }),
/* 2543 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _flex_group = __webpack_require__(2544);

Object.defineProperty(exports, 'KuiFlexGroup', {
  enumerable: true,
  get: function get() {
    return _flex_group.KuiFlexGroup;
  }
});

var _flex_grid = __webpack_require__(2545);

Object.defineProperty(exports, 'KuiFlexGrid', {
  enumerable: true,
  get: function get() {
    return _flex_grid.KuiFlexGrid;
  }
});

var _flex_item = __webpack_require__(2546);

Object.defineProperty(exports, 'KuiFlexItem', {
  enumerable: true,
  get: function get() {
    return _flex_item.KuiFlexItem;
  }
});

/***/ }),
/* 2544 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiFlexGroup = exports.JUSTIFY_CONTENTS = exports.ALIGN_ITEMS = exports.GUTTER_SIZES = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var gutterSizeToClassNameMap = {
  none: '',
  small: 'kuiFlexGroup--gutterSmall',
  medium: 'kuiFlexGroup--gutterMedium',
  large: 'kuiFlexGroup--gutterLarge',
  extraLarge: 'kuiFlexGroup--gutterExtraLarge'
};

var GUTTER_SIZES = exports.GUTTER_SIZES = Object.keys(gutterSizeToClassNameMap);

var alignItemsToClassNameMap = {
  stretch: '',
  flexStart: 'kuiFlexGroup--alignItemsStart',
  flexEnd: 'kuiFlexGroup--alignItemsEnd',
  center: 'kuiFlexGroup--alignItemsCenter'
};

var ALIGN_ITEMS = exports.ALIGN_ITEMS = Object.keys(alignItemsToClassNameMap);

var justifyContentToClassNameMap = {
  flexStart: '',
  flexEnd: 'kuiFlexGroup--justifyContentFlexEnd',
  center: 'kuiFlexGroup--justifyContentCenter',
  spaceBetween: 'kuiFlexGroup--justifyContentSpaceBetween',
  spaceAround: 'kuiFlexGroup--justifyContentSpaceAround',
  spaceEvenly: 'kuiFlexGroup--justifyContentSpaceEvenly'
};

var JUSTIFY_CONTENTS = exports.JUSTIFY_CONTENTS = Object.keys(justifyContentToClassNameMap);

var KuiFlexGroup = function KuiFlexGroup(_ref) {
  var children = _ref.children,
      className = _ref.className,
      gutterSize = _ref.gutterSize,
      alignItems = _ref.alignItems,
      justifyContent = _ref.justifyContent,
      wrap = _ref.wrap,
      rest = _objectWithoutProperties(_ref, ['children', 'className', 'gutterSize', 'alignItems', 'justifyContent', 'wrap']);

  var classes = (0, _classnames2.default)('kuiFlexGroup', gutterSizeToClassNameMap[gutterSize], alignItemsToClassNameMap[alignItems], justifyContentToClassNameMap[justifyContent], className, {
    'kuiFlexGroup--wrap': wrap
  });

  return _react2.default.createElement(
    'div',
    _extends({
      className: classes
    }, rest),
    children
  );
};

exports.KuiFlexGroup = KuiFlexGroup;
KuiFlexGroup.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string,
  gutterSize: _propTypes2.default.oneOf(GUTTER_SIZES),
  alignItems: _propTypes2.default.oneOf(ALIGN_ITEMS),
  justifyContent: _propTypes2.default.oneOf(JUSTIFY_CONTENTS),
  wrap: _propTypes2.default.bool
};

KuiFlexGroup.defaultProps = {
  gutterSize: 'large',
  alignItems: 'stretch',
  justifyContent: 'flexStart',
  wrap: false
};

/***/ }),
/* 2545 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiFlexGrid = exports.COLUMNS = exports.GUTTER_SIZES = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var gutterSizeToClassNameMap = {
  none: '',
  small: 'kuiFlexGrid--gutterSmall',
  medium: 'kuiFlexGrid--gutterMedium',
  large: 'kuiFlexGrid--gutterLarge',
  extraLarge: 'kuiFlexGrid--gutterXLarge'
};

var GUTTER_SIZES = exports.GUTTER_SIZES = Object.keys(gutterSizeToClassNameMap);

var columnsToClassNameMap = {
  0: 'kuiFlexGrid--wrap',
  2: 'kuiFlexGrid--halves',
  3: 'kuiFlexGrid--thirds',
  4: 'kuiFlexGrid--fourths'
};

var COLUMNS = exports.COLUMNS = Object.keys(columnsToClassNameMap).map(function (columns) {
  return parseInt(columns, 10);
});

var KuiFlexGrid = function KuiFlexGrid(_ref) {
  var children = _ref.children,
      className = _ref.className,
      gutterSize = _ref.gutterSize,
      columns = _ref.columns,
      rest = _objectWithoutProperties(_ref, ['children', 'className', 'gutterSize', 'columns']);

  var classes = (0, _classnames2.default)('kuiFlexGrid', gutterSizeToClassNameMap[gutterSize], columnsToClassNameMap[columns], className);

  return _react2.default.createElement(
    'div',
    _extends({
      className: classes
    }, rest),
    children
  );
};

exports.KuiFlexGrid = KuiFlexGrid;
KuiFlexGrid.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string,
  gutterSize: _propTypes2.default.oneOf(GUTTER_SIZES),
  columns: _propTypes2.default.oneOf(COLUMNS).isRequired
};

KuiFlexGrid.defaultProps = {
  gutterSize: 'large',
  columns: 0
};

/***/ }),
/* 2546 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiFlexItem = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var validGrowNumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

var KuiFlexItem = function KuiFlexItem(_ref) {
  var children = _ref.children,
      className = _ref.className,
      grow = _ref.grow,
      rest = _objectWithoutProperties(_ref, ['children', 'className', 'grow']);

  var classes = (0, _classnames2.default)('kuiFlexItem', _defineProperty({
    'kuiFlexItem--flexGrowZero': !grow
  }, 'kuiFlexItem--flexGrow' + grow, validGrowNumbers.indexOf(grow) >= 0), className);

  return _react2.default.createElement(
    'div',
    _extends({
      className: classes
    }, rest),
    children
  );
};

exports.KuiFlexItem = KuiFlexItem;
KuiFlexItem.propTypes = {
  children: _propTypes2.default.node,
  grow: growPropType
};

function growPropType(props, propName, componentName) {
  var value = props[propName];

  var validValues = [null, undefined, true, false].concat(validGrowNumbers);

  if (validValues.indexOf(value) === -1) {
    return new Error('Prop `' + propName + '` supplied to `' + componentName + '` must be a boolean or an integer between 1 and 10.');
  }
}

KuiFlexItem.defaultProps = {
  grow: true
};

/***/ }),
/* 2547 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _field_group = __webpack_require__(2548);

Object.defineProperty(exports, 'KuiFieldGroup', {
  enumerable: true,
  get: function get() {
    return _field_group.KuiFieldGroup;
  }
});

var _field_group_section = __webpack_require__(2549);

Object.defineProperty(exports, 'KuiFieldGroupSection', {
  enumerable: true,
  get: function get() {
    return _field_group_section.KuiFieldGroupSection;
  }
});

/***/ }),
/* 2548 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiFieldGroup = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiFieldGroup = function KuiFieldGroup(_ref) {
  var isAlignedTop = _ref.isAlignedTop,
      children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['isAlignedTop', 'children', 'className']);

  var classes = (0, _classnames2.default)('kuiFieldGroup', className, {
    'kuiFieldGroup--alignTop': isAlignedTop
  });
  return _react2.default.createElement(
    'div',
    _extends({
      className: classes
    }, rest),
    children
  );
};

exports.KuiFieldGroup = KuiFieldGroup;
KuiFieldGroup.defaultProps = {
  isAlignedTop: false
};

KuiFieldGroup.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string,
  isAlignedTop: _propTypes2.default.bool
};

/***/ }),
/* 2549 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiFieldGroupSection = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiFieldGroupSection = function KuiFieldGroupSection(_ref) {
  var isWide = _ref.isWide,
      children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['isWide', 'children', 'className']);

  var classes = (0, _classnames2.default)('kuiFieldGroupSection', className, {
    'kuiFieldGroupSection--wide': isWide
  });
  return _react2.default.createElement(
    'div',
    _extends({
      className: classes
    }, rest),
    children
  );
};

exports.KuiFieldGroupSection = KuiFieldGroupSection;
KuiFieldGroupSection.defaultProps = {
  isWide: false
};

KuiFieldGroupSection.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string,
  isWide: _propTypes2.default.bool
};

/***/ }),
/* 2550 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gallery = __webpack_require__(2551);

Object.defineProperty(exports, 'KuiGallery', {
  enumerable: true,
  get: function get() {
    return _gallery.KuiGallery;
  }
});

var _gallery_item = __webpack_require__(2552);

Object.defineProperty(exports, 'KuiGalleryItem', {
  enumerable: true,
  get: function get() {
    return _gallery_item.KuiGalleryItem;
  }
});

var _gallery_item_icon = __webpack_require__(2553);

Object.defineProperty(exports, 'KuiGalleryItemIcon', {
  enumerable: true,
  get: function get() {
    return _gallery_item_icon.KuiGalleryItemIcon;
  }
});

var _gallery_item_image = __webpack_require__(2554);

Object.defineProperty(exports, 'KuiGalleryItemImage', {
  enumerable: true,
  get: function get() {
    return _gallery_item_image.KuiGalleryItemImage;
  }
});

var _gallery_item_label = __webpack_require__(2555);

Object.defineProperty(exports, 'KuiGalleryItemLabel', {
  enumerable: true,
  get: function get() {
    return _gallery_item_label.KuiGalleryItemLabel;
  }
});

/***/ }),
/* 2551 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiGallery = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiGallery = function KuiGallery(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiGallery', className);
  return _react2.default.createElement(
    'div',
    _extends({
      className: classes
    }, rest),
    children
  );
};
exports.KuiGallery = KuiGallery;
KuiGallery.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2552 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiGalleryItem = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var checkHrefAndOnClick = function checkHrefAndOnClick(props, propName, componentName) {
  if (props.href && props.onClick) {
    throw new Error(componentName + ' must either specify an href property (if it should be a link) ' + 'or an onClick property (if it should be a button), but not both.');
  }
};

var KuiGalleryItem = function KuiGalleryItem(_ref) {
  var children = _ref.children,
      className = _ref.className,
      href = _ref.href,
      rest = _objectWithoutProperties(_ref, ['children', 'className', 'href']);

  var classes = (0, _classnames2.default)('kuiGalleryItem', className);
  if (href) {
    return _react2.default.createElement(
      'a',
      _extends({
        className: classes,
        href: href
      }, rest),
      children
    );
  } else {
    return _react2.default.createElement(
      'button',
      _extends({
        className: classes
      }, rest),
      children
    );
  }
};
exports.KuiGalleryItem = KuiGalleryItem;
KuiGalleryItem.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string,
  href: checkHrefAndOnClick,
  onClick: _propTypes2.default.func
};

/***/ }),
/* 2553 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiGalleryItemIcon = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiGalleryItemIcon = function KuiGalleryItemIcon(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiGalleryItem__icon', 'kuiIcon', className);
  return _react2.default.createElement(
    'div',
    _extends({
      className: classes
    }, rest),
    children
  );
};
exports.KuiGalleryItemIcon = KuiGalleryItemIcon;
KuiGalleryItemIcon.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2554 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiGalleryItemImage = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiGalleryItemImage = function KuiGalleryItemImage(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiGalleryItem__image', className);
  return _react2.default.createElement(
    'div',
    _extends({
      className: classes
    }, rest),
    children
  );
};
exports.KuiGalleryItemImage = KuiGalleryItemImage;
KuiGalleryItemImage.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2555 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiGalleryItemLabel = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiGalleryItemLabel = function KuiGalleryItemLabel(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiGalleryItem__label', className);
  return _react2.default.createElement(
    'div',
    _extends({
      className: classes
    }, rest),
    children
  );
};
exports.KuiGalleryItemLabel = KuiGalleryItemLabel;
KuiGalleryItemLabel.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2556 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _header_bar = __webpack_require__(2557);

Object.defineProperty(exports, 'KuiHeaderBar', {
  enumerable: true,
  get: function get() {
    return _header_bar.KuiHeaderBar;
  }
});

var _header_bar_section = __webpack_require__(2558);

Object.defineProperty(exports, 'KuiHeaderBarSection', {
  enumerable: true,
  get: function get() {
    return _header_bar_section.KuiHeaderBarSection;
  }
});

/***/ }),
/* 2557 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiHeaderBar = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiHeaderBar = function KuiHeaderBar(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiHeaderBar', className);
  return _react2.default.createElement(
    'div',
    _extends({
      className: classes
    }, rest),
    children
  );
};
exports.KuiHeaderBar = KuiHeaderBar;
KuiHeaderBar.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2558 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiHeaderBarSection = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiHeaderBarSection = function KuiHeaderBarSection(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiHeaderBarSection', className);
  return _react2.default.createElement(
    'div',
    _extends({
      className: classes
    }, rest),
    children
  );
};
exports.KuiHeaderBarSection = KuiHeaderBarSection;
KuiHeaderBarSection.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2559 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _info_button = __webpack_require__(2560);

Object.defineProperty(exports, 'KuiInfoButton', {
  enumerable: true,
  get: function get() {
    return _info_button.KuiInfoButton;
  }
});

/***/ }),
/* 2560 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiInfoButton = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var KuiInfoButton = function KuiInfoButton(props) {
  var iconClasses = (0, _classnames2.default)('kuiInfoButton', props.className);

  return _react2.default.createElement(
    'button',
    _extends({ className: iconClasses }, props),
    _react2.default.createElement('span', { className: 'kuiIcon fa-info-circle' })
  );
};

KuiInfoButton.propTypes = {
  'aria-label': _propTypes2.default.string,
  className: _propTypes2.default.string
};

KuiInfoButton.defaultProps = {
  'aria-label': 'Info'
};

exports.KuiInfoButton = KuiInfoButton;

/***/ }),
/* 2561 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _label = __webpack_require__(2562);

Object.defineProperty(exports, 'KuiLabel', {
  enumerable: true,
  get: function get() {
    return _label.KuiLabel;
  }
});

var _text_input = __webpack_require__(2564);

Object.defineProperty(exports, 'KuiTextInput', {
  enumerable: true,
  get: function get() {
    return _text_input.KuiTextInput;
  }
});

var _text_area = __webpack_require__(2566);

Object.defineProperty(exports, 'KuiTextArea', {
  enumerable: true,
  get: function get() {
    return _text_area.KuiTextArea;
  }
});

var _select = __webpack_require__(2568);

Object.defineProperty(exports, 'KuiSelect', {
  enumerable: true,
  get: function get() {
    return _select.KuiSelect;
  }
});

var _check_box = __webpack_require__(2570);

Object.defineProperty(exports, 'KuiCheckBox', {
  enumerable: true,
  get: function get() {
    return _check_box.KuiCheckBox;
  }
});
Object.defineProperty(exports, 'KuiCheckBoxLabel', {
  enumerable: true,
  get: function get() {
    return _check_box.KuiCheckBoxLabel;
  }
});

/***/ }),
/* 2562 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _label = __webpack_require__(2563);

Object.defineProperty(exports, 'KuiLabel', {
  enumerable: true,
  get: function get() {
    return _label.KuiLabel;
  }
});

/***/ }),
/* 2563 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiLabel = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiLabel = function KuiLabel(_ref) {
  var className = _ref.className,
      children = _ref.children,
      rest = _objectWithoutProperties(_ref, ['className', 'children']);

  var classes = (0, _classnames2.default)('kuiLabel', className);

  return _react2.default.createElement(
    'label',
    _extends({
      className: classes
    }, rest),
    children
  );
};

exports.KuiLabel = KuiLabel;
KuiLabel.propTypes = {
  className: _propTypes2.default.string,
  children: _propTypes2.default.node
};

/***/ }),
/* 2564 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _text_input = __webpack_require__(2565);

Object.defineProperty(exports, 'KuiTextInput', {
  enumerable: true,
  get: function get() {
    return _text_input.KuiTextInput;
  }
});

/***/ }),
/* 2565 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiTextInput = exports.TEXTINPUT_SIZE = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var sizeToClassNameMap = {
  small: 'kuiTextInput--small',
  medium: undefined,
  large: 'kuiTextInput--large'
};

var TEXTINPUT_SIZE = exports.TEXTINPUT_SIZE = Object.keys(sizeToClassNameMap);

var KuiTextInput = function KuiTextInput(_ref) {
  var className = _ref.className,
      onChange = _ref.onChange,
      isInvalid = _ref.isInvalid,
      isDisabled = _ref.isDisabled,
      size = _ref.size,
      rest = _objectWithoutProperties(_ref, ['className', 'onChange', 'isInvalid', 'isDisabled', 'size']);

  var classes = (0, _classnames2.default)('kuiTextInput', className, {
    'kuiTextInput-isInvalid': isInvalid
  }, sizeToClassNameMap[size]);

  return _react2.default.createElement('input', _extends({
    type: 'text',
    className: classes,
    onChange: onChange,
    disabled: isDisabled
  }, rest));
};

exports.KuiTextInput = KuiTextInput;
KuiTextInput.defaultProps = {
  isInvalid: false,
  isDisabled: false,
  size: 'medium'
};

KuiTextInput.propTypes = {
  className: _propTypes2.default.string,
  onChange: _propTypes2.default.func.isRequired,
  isInvalid: _propTypes2.default.bool,
  isDisabled: _propTypes2.default.bool,
  size: _propTypes2.default.oneOf(TEXTINPUT_SIZE)
};

/***/ }),
/* 2566 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _text_area = __webpack_require__(2567);

Object.defineProperty(exports, 'KuiTextArea', {
  enumerable: true,
  get: function get() {
    return _text_area.KuiTextArea;
  }
});

/***/ }),
/* 2567 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiTextArea = exports.TEXTAREA_SIZE = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var sizeToClassNameMap = {
  small: 'kuiTextArea--small',
  medium: undefined,
  large: 'kuiTextArea--large'
};

var TEXTAREA_SIZE = exports.TEXTAREA_SIZE = Object.keys(sizeToClassNameMap);

var KuiTextArea = function KuiTextArea(_ref) {
  var className = _ref.className,
      onChange = _ref.onChange,
      isInvalid = _ref.isInvalid,
      isNonResizable = _ref.isNonResizable,
      isDisabled = _ref.isDisabled,
      size = _ref.size,
      rest = _objectWithoutProperties(_ref, ['className', 'onChange', 'isInvalid', 'isNonResizable', 'isDisabled', 'size']);

  var classes = (0, _classnames2.default)('kuiTextArea', className, {
    'kuiTextArea-isInvalid': isInvalid,
    'kuiTextArea--nonResizable': isNonResizable
  }, sizeToClassNameMap[size]);

  return _react2.default.createElement('textarea', _extends({
    className: classes,
    onChange: onChange,
    disabled: isDisabled
  }, rest));
};

exports.KuiTextArea = KuiTextArea;
KuiTextArea.defaultProps = {
  isInvalid: false,
  isNonResizable: false,
  isDisabled: false,
  size: 'medium'
};

KuiTextArea.propTypes = {
  className: _propTypes2.default.string,
  onChange: _propTypes2.default.func.isRequired,
  isInvalid: _propTypes2.default.bool,
  isNonResizable: _propTypes2.default.bool,
  isDisabled: _propTypes2.default.bool,
  size: _propTypes2.default.oneOf(TEXTAREA_SIZE)
};

/***/ }),
/* 2568 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _select = __webpack_require__(2569);

Object.defineProperty(exports, 'KuiSelect', {
  enumerable: true,
  get: function get() {
    return _select.KuiSelect;
  }
});

/***/ }),
/* 2569 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiSelect = exports.SELECT_SIZE = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var sizeToClassNameMap = {
  small: 'kuiSelect--small',
  medium: undefined,
  large: 'kuiSelect--large'
};

var SELECT_SIZE = exports.SELECT_SIZE = Object.keys(sizeToClassNameMap);

var KuiSelect = function KuiSelect(_ref) {
  var className = _ref.className,
      onChange = _ref.onChange,
      isInvalid = _ref.isInvalid,
      isDisabled = _ref.isDisabled,
      size = _ref.size,
      children = _ref.children,
      rest = _objectWithoutProperties(_ref, ['className', 'onChange', 'isInvalid', 'isDisabled', 'size', 'children']);

  var classes = (0, _classnames2.default)('kuiSelect', className, {
    'kuiSelect-isInvalid': isInvalid
  }, sizeToClassNameMap[size]);

  return _react2.default.createElement(
    'select',
    _extends({
      className: classes,
      onChange: onChange,
      disabled: isDisabled
    }, rest),
    children
  );
};

exports.KuiSelect = KuiSelect;
KuiSelect.defaultProps = {
  isInvalid: false,
  isDisabled: false,
  size: 'medium'
};

KuiSelect.propTypes = {
  className: _propTypes2.default.string,
  onChange: _propTypes2.default.func.isRequired,
  isInvalid: _propTypes2.default.bool,
  isDisabled: _propTypes2.default.bool,
  size: _propTypes2.default.oneOf(SELECT_SIZE),
  children: _propTypes2.default.node
};

/***/ }),
/* 2570 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _check_box = __webpack_require__(862);

Object.defineProperty(exports, 'KuiCheckBox', {
  enumerable: true,
  get: function get() {
    return _check_box.KuiCheckBox;
  }
});

var _check_box_label = __webpack_require__(2571);

Object.defineProperty(exports, 'KuiCheckBoxLabel', {
  enumerable: true,
  get: function get() {
    return _check_box_label.KuiCheckBoxLabel;
  }
});

/***/ }),
/* 2571 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiCheckBoxLabel = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _check_box = __webpack_require__(862);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiCheckBoxLabel = function KuiCheckBoxLabel(_ref) {
  var className = _ref.className,
      text = _ref.text,
      isChecked = _ref.isChecked,
      isDisabled = _ref.isDisabled,
      onChange = _ref.onChange,
      rest = _objectWithoutProperties(_ref, ['className', 'text', 'isChecked', 'isDisabled', 'onChange']);

  var classes = (0, _classnames2.default)('kuiCheckBoxLabel', className);

  return _react2.default.createElement(
    'label',
    _extends({
      className: classes
    }, rest),
    _react2.default.createElement(_check_box.KuiCheckBox, {
      isChecked: isChecked,
      isDisabled: isDisabled,
      onChange: onChange
    }),
    _react2.default.createElement(
      'span',
      { className: 'kuiCheckBoxLabel__text' },
      text
    )
  );
};

exports.KuiCheckBoxLabel = KuiCheckBoxLabel;
KuiCheckBoxLabel.defaultProps = {
  isChecked: false,
  isDisabled: false
};

KuiCheckBoxLabel.propTypes = {
  className: _propTypes2.default.string,
  text: _propTypes2.default.string,
  isChecked: _propTypes2.default.bool,
  isDisabled: _propTypes2.default.bool,
  onChange: _propTypes2.default.func.isRequired
};

/***/ }),
/* 2572 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _local_nav = __webpack_require__(2573);

Object.defineProperty(exports, 'KuiLocalNav', {
  enumerable: true,
  get: function get() {
    return _local_nav.KuiLocalNav;
  }
});

var _local_nav_row = __webpack_require__(2574);

Object.defineProperty(exports, 'KuiLocalNavRow', {
  enumerable: true,
  get: function get() {
    return _local_nav_row.KuiLocalNavRow;
  }
});

var _local_nav_row_section = __webpack_require__(2575);

Object.defineProperty(exports, 'KuiLocalNavRowSection', {
  enumerable: true,
  get: function get() {
    return _local_nav_row_section.KuiLocalNavRowSection;
  }
});

var _local_tab = __webpack_require__(2576);

Object.defineProperty(exports, 'KuiLocalTab', {
  enumerable: true,
  get: function get() {
    return _local_tab.KuiLocalTab;
  }
});

var _local_tabs = __webpack_require__(2577);

Object.defineProperty(exports, 'KuiLocalTabs', {
  enumerable: true,
  get: function get() {
    return _local_tabs.KuiLocalTabs;
  }
});

var _local_title = __webpack_require__(2578);

Object.defineProperty(exports, 'KuiLocalTitle', {
  enumerable: true,
  get: function get() {
    return _local_title.KuiLocalTitle;
  }
});

/***/ }),
/* 2573 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.KuiLocalNav = KuiLocalNav;

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function KuiLocalNav(_ref) {
  var className = _ref.className,
      children = _ref.children,
      rest = _objectWithoutProperties(_ref, ['className', 'children']);

  var classes = (0, _classnames2.default)('kuiLocalNav', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
}

KuiLocalNav.propTypes = {
  className: _propTypes2.default.string,
  children: _propTypes2.default.node
};

/***/ }),
/* 2574 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.KuiLocalNavRow = KuiLocalNavRow;

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function KuiLocalNavRow(_ref) {
  var className = _ref.className,
      children = _ref.children,
      isSecondary = _ref.isSecondary,
      rest = _objectWithoutProperties(_ref, ['className', 'children', 'isSecondary']);

  var classes = (0, _classnames2.default)('kuiLocalNavRow', className, {
    'kuiLocalNavRow--secondary': isSecondary
  });
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
}

KuiLocalNavRow.propTypes = {
  className: _propTypes2.default.string,
  children: _propTypes2.default.node,
  isSecondary: _propTypes2.default.bool
};

KuiLocalNavRow.defaultProps = {
  isSecondary: false
};

/***/ }),
/* 2575 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.KuiLocalNavRowSection = KuiLocalNavRowSection;

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function KuiLocalNavRowSection(_ref) {
  var className = _ref.className,
      children = _ref.children,
      rest = _objectWithoutProperties(_ref, ['className', 'children']);

  var classes = (0, _classnames2.default)('kuiLocalNavRow__section', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
}

KuiLocalNavRowSection.propTypes = {
  className: _propTypes2.default.string,
  children: _propTypes2.default.node
};

/***/ }),
/* 2576 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.KuiLocalTab = KuiLocalTab;

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function KuiLocalTab(_ref) {
  var className = _ref.className,
      children = _ref.children,
      isDisabled = _ref.isDisabled,
      isSelected = _ref.isSelected,
      rest = _objectWithoutProperties(_ref, ['className', 'children', 'isDisabled', 'isSelected']);

  var classes = (0, _classnames2.default)('kuiLocalTab', className, {
    'kuiLocalTab-isDisabled': isDisabled,
    'kuiLocalTab-isSelected': isSelected
  });
  return _react2.default.createElement(
    'a',
    _extends({ className: classes }, rest),
    children
  );
}

KuiLocalTab.propTypes = {
  className: _propTypes2.default.string,
  children: _propTypes2.default.node,
  isDisabled: _propTypes2.default.bool,
  isSelected: _propTypes2.default.bool
};

KuiLocalTab.defaultProps = {
  isDisabled: false,
  isSelected: false
};

/***/ }),
/* 2577 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.KuiLocalTabs = KuiLocalTabs;

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function KuiLocalTabs(_ref) {
  var className = _ref.className,
      children = _ref.children,
      rest = _objectWithoutProperties(_ref, ['className', 'children']);

  var classes = (0, _classnames2.default)('kuiLocalTabs', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
}

KuiLocalTabs.propTypes = {
  className: _propTypes2.default.string,
  children: _propTypes2.default.node
};

/***/ }),
/* 2578 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.KuiLocalTitle = KuiLocalTitle;

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function KuiLocalTitle(_ref) {
  var className = _ref.className,
      children = _ref.children,
      rest = _objectWithoutProperties(_ref, ['className', 'children']);

  var classes = (0, _classnames2.default)('kuiLocalTitle', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
}

KuiLocalTitle.propTypes = {
  className: _propTypes2.default.string,
  children: _propTypes2.default.node
};

/***/ }),
/* 2579 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _menu = __webpack_require__(2580);

Object.defineProperty(exports, 'KuiMenu', {
  enumerable: true,
  get: function get() {
    return _menu.KuiMenu;
  }
});

var _menu_item = __webpack_require__(2581);

Object.defineProperty(exports, 'KuiMenuItem', {
  enumerable: true,
  get: function get() {
    return _menu_item.KuiMenuItem;
  }
});

/***/ }),
/* 2580 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiMenu = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiMenu = function KuiMenu(_ref) {
  var contained = _ref.contained,
      className = _ref.className,
      children = _ref.children,
      rest = _objectWithoutProperties(_ref, ['contained', 'className', 'children']);

  var classes = (0, _classnames2.default)('kuiMenu', className, {
    'kuiMenu--contained': contained
  });

  return _react2.default.createElement(
    'ul',
    _extends({
      className: classes
    }, rest),
    children
  );
};

exports.KuiMenu = KuiMenu;
KuiMenu.propTypes = {
  contained: _propTypes2.default.bool,
  className: _propTypes2.default.string,
  children: _propTypes2.default.node
};

/***/ }),
/* 2581 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiMenuItem = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiMenuItem = function KuiMenuItem(_ref) {
  var className = _ref.className,
      children = _ref.children,
      rest = _objectWithoutProperties(_ref, ['className', 'children']);

  return _react2.default.createElement(
    'li',
    _extends({
      className: (0, _classnames2.default)('kuiMenuItem', className)
    }, rest),
    children
  );
};

exports.KuiMenuItem = KuiMenuItem;
KuiMenuItem.propTypes = {
  className: _propTypes2.default.string,
  children: _propTypes2.default.node
};

/***/ }),
/* 2582 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _confirm_modal = __webpack_require__(2583);

Object.defineProperty(exports, 'KuiConfirmModal', {
  enumerable: true,
  get: function get() {
    return _confirm_modal.KuiConfirmModal;
  }
});
Object.defineProperty(exports, 'KUI_MODAL_CONFIRM_BUTTON', {
  enumerable: true,
  get: function get() {
    return _confirm_modal.CONFIRM_BUTTON;
  }
});
Object.defineProperty(exports, 'KUI_MODAL_CANCEL_BUTTON', {
  enumerable: true,
  get: function get() {
    return _confirm_modal.CANCEL_BUTTON;
  }
});

var _modal = __webpack_require__(863);

Object.defineProperty(exports, 'KuiModal', {
  enumerable: true,
  get: function get() {
    return _modal.KuiModal;
  }
});

var _modal_footer = __webpack_require__(865);

Object.defineProperty(exports, 'KuiModalFooter', {
  enumerable: true,
  get: function get() {
    return _modal_footer.KuiModalFooter;
  }
});

var _modal_header = __webpack_require__(866);

Object.defineProperty(exports, 'KuiModalHeader', {
  enumerable: true,
  get: function get() {
    return _modal_header.KuiModalHeader;
  }
});

var _modal_overlay = __webpack_require__(2584);

Object.defineProperty(exports, 'KuiModalOverlay', {
  enumerable: true,
  get: function get() {
    return _modal_overlay.KuiModalOverlay;
  }
});

var _modal_body = __webpack_require__(868);

Object.defineProperty(exports, 'KuiModalBody', {
  enumerable: true,
  get: function get() {
    return _modal_body.KuiModalBody;
  }
});

var _modal_header_title = __webpack_require__(867);

Object.defineProperty(exports, 'KuiModalHeaderTitle', {
  enumerable: true,
  get: function get() {
    return _modal_header_title.KuiModalHeaderTitle;
  }
});

/***/ }),
/* 2583 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CANCEL_BUTTON = exports.CONFIRM_BUTTON = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.KuiConfirmModal = KuiConfirmModal;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _modal = __webpack_require__(863);

var _modal_footer = __webpack_require__(865);

var _modal_header = __webpack_require__(866);

var _modal_header_title = __webpack_require__(867);

var _modal_body = __webpack_require__(868);

var _components = __webpack_require__(101);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var CONFIRM_BUTTON = exports.CONFIRM_BUTTON = 'confirm';
var CANCEL_BUTTON = exports.CANCEL_BUTTON = 'cancel';

var CONFIRM_MODAL_BUTTONS = [CONFIRM_BUTTON, CANCEL_BUTTON];

function KuiConfirmModal(_ref) {
  var children = _ref.children,
      title = _ref.title,
      onCancel = _ref.onCancel,
      onConfirm = _ref.onConfirm,
      cancelButtonText = _ref.cancelButtonText,
      confirmButtonText = _ref.confirmButtonText,
      className = _ref.className,
      defaultFocusedButton = _ref.defaultFocusedButton,
      rest = _objectWithoutProperties(_ref, ['children', 'title', 'onCancel', 'onConfirm', 'cancelButtonText', 'confirmButtonText', 'className', 'defaultFocusedButton']);

  var classes = (0, _classnames2.default)('kuiModal--confirmation', className);

  var modalTitle = void 0;

  if (title) {
    modalTitle = _react2.default.createElement(
      _modal_header.KuiModalHeader,
      null,
      _react2.default.createElement(
        _modal_header_title.KuiModalHeaderTitle,
        { 'data-test-subj': 'confirmModalTitleText' },
        title
      )
    );
  }

  var message = void 0;

  if (typeof children === 'string') {
    message = _react2.default.createElement(
      'p',
      { className: 'kuiText' },
      children
    );
  } else {
    message = children;
  }

  return _react2.default.createElement(
    _modal.KuiModal,
    _extends({
      className: classes,
      onClose: onCancel
    }, rest),
    modalTitle,
    _react2.default.createElement(
      _modal_body.KuiModalBody,
      null,
      _react2.default.createElement(
        'div',
        { 'data-test-subj': 'confirmModalBodyText' },
        message
      )
    ),
    _react2.default.createElement(
      _modal_footer.KuiModalFooter,
      null,
      _react2.default.createElement(
        _components.KuiButton,
        {
          buttonType: 'hollow',
          autoFocus: defaultFocusedButton === CANCEL_BUTTON,
          'data-test-subj': 'confirmModalCancelButton',
          onClick: onCancel
        },
        cancelButtonText
      ),
      _react2.default.createElement(
        _components.KuiButton,
        {
          buttonType: 'primary',
          autoFocus: defaultFocusedButton === CONFIRM_BUTTON,
          'data-test-subj': 'confirmModalConfirmButton',
          onClick: onConfirm
        },
        confirmButtonText
      )
    )
  );
}

KuiConfirmModal.propTypes = {
  children: _propTypes2.default.node,
  title: _propTypes2.default.string,
  cancelButtonText: _propTypes2.default.string,
  confirmButtonText: _propTypes2.default.string,
  onCancel: _propTypes2.default.func.isRequired,
  onConfirm: _propTypes2.default.func,
  className: _propTypes2.default.string,
  defaultFocusedButton: _propTypes2.default.oneOf(CONFIRM_MODAL_BUTTONS)
};

/***/ }),
/* 2584 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.KuiModalOverlay = KuiModalOverlay;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function KuiModalOverlay(_ref) {
  var className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['className']);

  var classes = (0, _classnames2.default)('kuiModalOverlay', className);
  return _react2.default.createElement('div', _extends({
    className: classes
  }, rest));
}

KuiModalOverlay.propTypes = {
  className: _propTypes2.default.string
};

/***/ }),
/* 2585 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _pager = __webpack_require__(2586);

Object.defineProperty(exports, 'KuiPager', {
  enumerable: true,
  get: function get() {
    return _pager.KuiPager;
  }
});

var _pager_button_group = __webpack_require__(869);

Object.defineProperty(exports, 'KuiPagerButtonGroup', {
  enumerable: true,
  get: function get() {
    return _pager_button_group.KuiPagerButtonGroup;
  }
});

/***/ }),
/* 2586 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.KuiPager = KuiPager;

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _pager_button_group = __webpack_require__(869);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function KuiPager(_ref) {
  var className = _ref.className,
      startNumber = _ref.startNumber,
      endNumber = _ref.endNumber,
      totalItems = _ref.totalItems,
      hasPreviousPage = _ref.hasPreviousPage,
      hasNextPage = _ref.hasNextPage,
      onNextPage = _ref.onNextPage,
      onPreviousPage = _ref.onPreviousPage,
      rest = _objectWithoutProperties(_ref, ['className', 'startNumber', 'endNumber', 'totalItems', 'hasPreviousPage', 'hasNextPage', 'onNextPage', 'onPreviousPage']);

  var classes = (0, _classnames2.default)('kuiPager', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    _react2.default.createElement(
      'div',
      { className: 'kuiPagerText' },
      startNumber,
      '\u2013',
      endNumber,
      ' of ',
      totalItems
    ),
    startNumber === 1 && endNumber === totalItems ? null : _react2.default.createElement(_pager_button_group.KuiPagerButtonGroup, {
      hasNext: hasNextPage,
      hasPrevious: hasPreviousPage,
      onNext: onNextPage,
      onPrevious: onPreviousPage
    })
  );
}

KuiPager.propTypes = {
  startNumber: _propTypes2.default.number.isRequired,
  endNumber: _propTypes2.default.number.isRequired,
  totalItems: _propTypes2.default.number.isRequired,
  hasPreviousPage: _propTypes2.default.bool.isRequired,
  hasNextPage: _propTypes2.default.bool.isRequired,
  onNextPage: _propTypes2.default.func.isRequired,
  onPreviousPage: _propTypes2.default.func.isRequired,
  className: _propTypes2.default.string
};

/***/ }),
/* 2587 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiPanelSimple = exports.SIZES = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var paddingSizeToClassNameMap = {
  'none': null,
  's': 'kuiPanelSimple--paddingSmall',
  'm': 'kuiPanelSimple--paddingMedium',
  'l': 'kuiPanelSimple--paddingLarge'
};

var SIZES = exports.SIZES = Object.keys(paddingSizeToClassNameMap);

var KuiPanelSimple = function KuiPanelSimple(_ref) {
  var children = _ref.children,
      className = _ref.className,
      paddingSize = _ref.paddingSize,
      hasShadow = _ref.hasShadow,
      grow = _ref.grow,
      panelRef = _ref.panelRef,
      rest = _objectWithoutProperties(_ref, ['children', 'className', 'paddingSize', 'hasShadow', 'grow', 'panelRef']);

  var classes = (0, _classnames2.default)('kuiPanelSimple', paddingSizeToClassNameMap[paddingSize], {
    'kuiPanelSimple--shadow': hasShadow,
    'kuiPanelSimple--flexGrowZero': !grow
  }, className);

  return _react2.default.createElement(
    'div',
    _extends({
      ref: panelRef,
      className: classes
    }, rest),
    children
  );
};

exports.KuiPanelSimple = KuiPanelSimple;
KuiPanelSimple.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string,
  hasShadow: _propTypes2.default.bool,
  paddingSize: _propTypes2.default.oneOf(SIZES),
  grow: _propTypes2.default.bool,
  panelRef: _propTypes2.default.func
};

KuiPanelSimple.defaultProps = {
  paddingSize: 'm',
  hasShadow: false,
  grow: true
};

/***/ }),
/* 2588 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _popover = __webpack_require__(2589);

Object.defineProperty(exports, 'KuiPopover', {
  enumerable: true,
  get: function get() {
    return _popover.KuiPopover;
  }
});

var _popover_title = __webpack_require__(2590);

Object.defineProperty(exports, 'KuiPopoverTitle', {
  enumerable: true,
  get: function get() {
    return _popover_title.KuiPopoverTitle;
  }
});

/***/ }),
/* 2589 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiPopover = exports.ANCHOR_POSITIONS = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _focusTrapReact = __webpack_require__(864);

var _focusTrapReact2 = _interopRequireDefault(_focusTrapReact);

var _tabbable = __webpack_require__(314);

var _tabbable2 = _interopRequireDefault(_tabbable);

var _services = __webpack_require__(120);

var _outside_click_detector = __webpack_require__(512);

var _panel_simple = __webpack_require__(870);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var anchorPositionToClassNameMap = {
  'center': '',
  'left': 'kuiPopover--anchorLeft',
  'right': 'kuiPopover--anchorRight'
};

var ANCHOR_POSITIONS = exports.ANCHOR_POSITIONS = Object.keys(anchorPositionToClassNameMap);

var KuiPopover = exports.KuiPopover = function (_Component) {
  _inherits(KuiPopover, _Component);

  function KuiPopover(props) {
    _classCallCheck(this, KuiPopover);

    var _this = _possibleConstructorReturn(this, (KuiPopover.__proto__ || Object.getPrototypeOf(KuiPopover)).call(this, props));

    _this.onKeyDown = function (e) {
      if (e.keyCode === _services.cascadingMenuKeyCodes.ESCAPE) {
        _this.props.closePopover();
      }
    };

    _this.panelRef = function (node) {
      if (_this.props.ownFocus) {
        _this.panel = node;
      }
    };

    _this.closingTransitionTimeout = undefined;

    _this.state = {
      isClosing: false,
      isOpening: false
    };
    return _this;
  }

  _createClass(KuiPopover, [{
    key: 'updateFocus',
    value: function updateFocus() {
      var _this2 = this;

      // Wait for the DOM to update.
      window.requestAnimationFrame(function () {
        if (!_this2.panel) {
          return;
        }

        // If we've already focused on something inside the panel, everything's fine.
        if (_this2.panel.contains(document.activeElement)) {
          return;
        }

        // Otherwise let's focus the first tabbable item and expedite input from the user.
        var tabbableItems = (0, _tabbable2.default)(_this2.panel);
        if (tabbableItems.length) {
          tabbableItems[0].focus();
        }
      });
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.updateFocus();
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var _this3 = this;

      // The popover is being opened.
      if (!this.props.isOpen && nextProps.isOpen) {
        clearTimeout(this.closingTransitionTimeout);
        // We need to set this state a beat after the render takes place, so that the CSS
        // transition can take effect.
        window.requestAnimationFrame(function () {
          _this3.setState({
            isOpening: true
          });
        });
      }

      // The popover is being closed.
      if (this.props.isOpen && !nextProps.isOpen) {
        // If the user has just closed the popover, queue up the removal of the content after the
        // transition is complete.
        this.setState({
          isClosing: true,
          isOpening: false
        });

        this.closingTransitionTimeout = setTimeout(function () {
          _this3.setState({
            isClosing: false
          });
        }, 250);
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      this.updateFocus();
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      clearTimeout(this.closingTransitionTimeout);
    }
  }, {
    key: 'render',
    value: function render() {
      var _this4 = this;

      var _props = this.props,
          anchorPosition = _props.anchorPosition,
          button = _props.button,
          isOpen = _props.isOpen,
          ownFocus = _props.ownFocus,
          withTitle = _props.withTitle,
          children = _props.children,
          className = _props.className,
          closePopover = _props.closePopover,
          panelClassName = _props.panelClassName,
          panelPaddingSize = _props.panelPaddingSize,
          rest = _objectWithoutProperties(_props, ['anchorPosition', 'button', 'isOpen', 'ownFocus', 'withTitle', 'children', 'className', 'closePopover', 'panelClassName', 'panelPaddingSize']);

      var classes = (0, _classnames2.default)('kuiPopover', anchorPositionToClassNameMap[anchorPosition], className, {
        'kuiPopover-isOpen': this.state.isOpening,
        'kuiPopover--withTitle': withTitle
      });

      var panelClasses = (0, _classnames2.default)('kuiPopover__panel', panelClassName);

      var panel = void 0;

      if (isOpen || this.state.isClosing) {
        var tabIndex = void 0;
        var initialFocus = void 0;

        if (ownFocus) {
          tabIndex = '0';
          initialFocus = function initialFocus() {
            return _this4.panel;
          };
        }

        panel = _react2.default.createElement(
          _focusTrapReact2.default,
          {
            focusTrapOptions: {
              clickOutsideDeactivates: true,
              initialFocus: initialFocus
            }
          },
          _react2.default.createElement(
            _panel_simple.KuiPanelSimple,
            {
              panelRef: this.panelRef,
              className: panelClasses,
              paddingSize: panelPaddingSize,
              tabIndex: tabIndex,
              hasShadow: true
            },
            children
          )
        );
      }

      return _react2.default.createElement(
        _outside_click_detector.KuiOutsideClickDetector,
        { onOutsideClick: closePopover },
        _react2.default.createElement(
          'div',
          _extends({
            className: classes,
            onKeyDown: this.onKeyDown
          }, rest),
          button,
          panel
        )
      );
    }
  }]);

  return KuiPopover;
}(_react.Component);

KuiPopover.propTypes = {
  isOpen: _propTypes2.default.bool,
  ownFocus: _propTypes2.default.bool,
  withTitle: _propTypes2.default.bool,
  closePopover: _propTypes2.default.func.isRequired,
  button: _propTypes2.default.node.isRequired,
  children: _propTypes2.default.node,
  anchorPosition: _propTypes2.default.oneOf(ANCHOR_POSITIONS),
  panelClassName: _propTypes2.default.string,
  panelPaddingSize: _propTypes2.default.oneOf(_panel_simple.SIZES)
};

KuiPopover.defaultProps = {
  isOpen: false,
  ownFocus: false,
  anchorPosition: 'center',
  panelPaddingSize: 'm'
};

/***/ }),
/* 2590 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiPopoverTitle = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiPopoverTitle = function KuiPopoverTitle(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiPopoverTitle', className);

  return _react2.default.createElement(
    'div',
    _extends({
      className: classes
    }, rest),
    children
  );
};

exports.KuiPopoverTitle = KuiPopoverTitle;
KuiPopoverTitle.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2591 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _tabs = __webpack_require__(2592);

Object.defineProperty(exports, 'KuiTabs', {
  enumerable: true,
  get: function get() {
    return _tabs.KuiTabs;
  }
});

var _tab = __webpack_require__(2593);

Object.defineProperty(exports, 'KuiTab', {
  enumerable: true,
  get: function get() {
    return _tab.KuiTab;
  }
});

/***/ }),
/* 2592 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiTabs = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiTabs = function KuiTabs(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiTabs', className);

  return _react2.default.createElement(
    'div',
    _extends({
      role: 'tablist',
      className: classes
    }, rest),
    children
  );
};

exports.KuiTabs = KuiTabs;
KuiTabs.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2593 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiTab = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiTab = function KuiTab(_ref) {
  var isSelected = _ref.isSelected,
      onClick = _ref.onClick,
      children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['isSelected', 'onClick', 'children', 'className']);

  var classes = (0, _classnames2.default)('kuiTab', className, {
    'kuiTab-isSelected': isSelected
  });

  return _react2.default.createElement(
    'button',
    _extends({
      role: 'tab',
      'aria-selected': !!isSelected,
      className: classes,
      onClick: onClick
    }, rest),
    children
  );
};

exports.KuiTab = KuiTab;
KuiTab.defaultProps = {
  isSelected: false
};

KuiTab.propTypes = {
  isSelected: _propTypes2.default.bool,
  onClick: _propTypes2.default.func.isRequired,
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2594 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiTable = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiTable = function KuiTable(_ref) {
  var children = _ref.children,
      shrinkToContent = _ref.shrinkToContent,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'shrinkToContent', 'className']);

  var classes = (0, _classnames2.default)('kuiTable', className, {
    'kuiTable--fluid': shrinkToContent
  });
  return _react2.default.createElement(
    'table',
    _extends({ className: classes }, rest),
    children
  );
};
exports.KuiTable = KuiTable;
KuiTable.propTypes = {
  shrinkToContent: _propTypes2.default.bool,
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};
KuiTable.defaultProps = {
  shrinkToContent: false
};

/***/ }),
/* 2595 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiTableRow = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiTableRow = function KuiTableRow(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiTableRow', className);
  return _react2.default.createElement(
    'tr',
    _extends({ className: classes }, rest),
    children
  );
};
exports.KuiTableRow = KuiTableRow;
KuiTableRow.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2596 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiControlledTable = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiControlledTable = function KuiControlledTable(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiControlledTable', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
};
exports.KuiControlledTable = KuiControlledTable;
KuiControlledTable.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2597 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiTableInfo = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiTableInfo = function KuiTableInfo(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiTableInfo', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
};
exports.KuiTableInfo = KuiTableInfo;
KuiTableInfo.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2598 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiTableRowCheckBoxCell = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _table_row_cell = __webpack_require__(873);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiTableRowCheckBoxCell = function KuiTableRowCheckBoxCell(_ref) {
  var onChange = _ref.onChange,
      isChecked = _ref.isChecked,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['onChange', 'isChecked', 'className']);

  var classes = (0, _classnames2.default)('kuiTableRowCell--checkBox', className);
  return _react2.default.createElement(
    _table_row_cell.KuiTableRowCell,
    _extends({
      className: classes
    }, rest),
    _react2.default.createElement('input', {
      type: 'checkbox',
      className: 'kuiCheckBox',
      onChange: onChange,
      checked: isChecked,
      'aria-label': (isChecked ? 'Deselect' : 'Select') + ' row'
    })
  );
};
exports.KuiTableRowCheckBoxCell = KuiTableRowCheckBoxCell;
KuiTableRowCheckBoxCell.propTypes = {
  isChecked: _propTypes2.default.bool,
  onChange: _propTypes2.default.func,
  className: _propTypes2.default.string
};

/***/ }),
/* 2599 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiTableHeaderCheckBoxCell = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

var _table_header_cell = __webpack_require__(872);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiTableHeaderCheckBoxCell = function KuiTableHeaderCheckBoxCell(_ref) {
  var onChange = _ref.onChange,
      isChecked = _ref.isChecked,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['onChange', 'isChecked', 'className']);

  var classes = (0, _classnames2.default)('kuiTableHeaderCell--checkBox', className);
  return _react2.default.createElement(
    _table_header_cell.KuiTableHeaderCell,
    _extends({
      className: classes
    }, rest),
    _react2.default.createElement('input', {
      type: 'checkbox',
      className: 'kuiCheckBox',
      onChange: onChange,
      checked: isChecked,
      'aria-label': (isChecked ? 'Deselect' : 'Select') + ' all rows'
    })
  );
};
exports.KuiTableHeaderCheckBoxCell = KuiTableHeaderCheckBoxCell;
KuiTableHeaderCheckBoxCell.propTypes = {
  isChecked: _propTypes2.default.bool,
  onChange: _propTypes2.default.func,
  className: _propTypes2.default.string
};

/***/ }),
/* 2600 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiTableBody = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiTableBody = function KuiTableBody(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  return _react2.default.createElement(
    'tbody',
    _extends({ className: className }, rest),
    children
  );
};
exports.KuiTableBody = KuiTableBody;
KuiTableBody.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2601 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiTableHeader = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiTableHeader = function KuiTableHeader(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  return _react2.default.createElement(
    'thead',
    _extends({ className: className }, rest),
    _react2.default.createElement(
      'tr',
      null,
      children
    )
  );
};
exports.KuiTableHeader = KuiTableHeader;
KuiTableHeader.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2602 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _listing_table = __webpack_require__(2603);

Object.defineProperty(exports, 'KuiListingTable', {
  enumerable: true,
  get: function get() {
    return _listing_table.KuiListingTable;
  }
});

var _listing_table_create_button = __webpack_require__(2607);

Object.defineProperty(exports, 'KuiListingTableCreateButton', {
  enumerable: true,
  get: function get() {
    return _listing_table_create_button.KuiListingTableCreateButton;
  }
});

var _listing_table_delete_button = __webpack_require__(2608);

Object.defineProperty(exports, 'KuiListingTableDeleteButton', {
  enumerable: true,
  get: function get() {
    return _listing_table_delete_button.KuiListingTableDeleteButton;
  }
});

var _listing_table_no_matches_prompt = __webpack_require__(2609);

Object.defineProperty(exports, 'KuiListingTableNoMatchesPrompt', {
  enumerable: true,
  get: function get() {
    return _listing_table_no_matches_prompt.KuiListingTableNoMatchesPrompt;
  }
});

var _listing_table_loading_prompt = __webpack_require__(2610);

Object.defineProperty(exports, 'KuiListingTableLoadingPrompt', {
  enumerable: true,
  get: function get() {
    return _listing_table_loading_prompt.KuiListingTableLoadingPrompt;
  }
});

/***/ }),
/* 2603 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.KuiListingTable = KuiListingTable;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _listing_table_tool_bar = __webpack_require__(2604);

var _listing_table_tool_bar_footer = __webpack_require__(2605);

var _listing_table_row = __webpack_require__(2606);

var _index = __webpack_require__(101);

var _services = __webpack_require__(120);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function KuiListingTable(_ref) {
  var rows = _ref.rows,
      header = _ref.header,
      pager = _ref.pager,
      toolBarActions = _ref.toolBarActions,
      onFilter = _ref.onFilter,
      onItemSelectionChanged = _ref.onItemSelectionChanged,
      selectedRowIds = _ref.selectedRowIds,
      filter = _ref.filter,
      prompt = _ref.prompt;


  function areAllRowsSelected() {
    return rows.length > 0 && rows.length === selectedRowIds.length;
  }

  function toggleAll() {
    if (areAllRowsSelected()) {
      onItemSelectionChanged([]);
    } else {
      onItemSelectionChanged(rows.map(function (row) {
        return row.id;
      }));
    }
  }

  function toggleRow(rowId) {
    var selectedRowIndex = selectedRowIds.indexOf(rowId);
    if (selectedRowIndex >= 0) {
      onItemSelectionChanged(selectedRowIds.filter(function (item, index) {
        return index !== selectedRowIndex;
      }));
    } else {
      onItemSelectionChanged([].concat(_toConsumableArray(selectedRowIds), [rowId]));
    }
  }

  function renderTableRows() {
    return rows.map(function (row, rowIndex) {
      return _react2.default.createElement(_listing_table_row.KuiListingTableRow, {
        key: rowIndex,
        isSelected: selectedRowIds.indexOf(row.id) >= 0,
        onSelectionChanged: toggleRow,
        row: row
      });
    });
  }

  function renderHeader() {
    return header.map(function (cell, index) {
      var content = cell.content,
          props = _objectWithoutProperties(cell, ['content']);

      if (_react2.default.isValidElement(cell) || !_lodash2.default.isObject(cell)) {
        props = [];
        content = cell;
      }
      return _react2.default.createElement(
        _index.KuiTableHeaderCell,
        _extends({
          key: index
        }, props),
        content
      );
    });
  }

  function renderInnerTable() {
    return _react2.default.createElement(
      _index.KuiTable,
      null,
      _react2.default.createElement(
        _index.KuiTableHeader,
        null,
        _react2.default.createElement(_index.KuiTableHeaderCheckBoxCell, {
          isChecked: areAllRowsSelected(),
          onChange: toggleAll
        }),
        renderHeader()
      ),
      _react2.default.createElement(
        _index.KuiTableBody,
        null,
        renderTableRows()
      )
    );
  }

  return _react2.default.createElement(
    _index.KuiControlledTable,
    null,
    _react2.default.createElement(_listing_table_tool_bar.KuiListingTableToolBar, {
      actions: toolBarActions,
      pager: pager,
      onFilter: onFilter,
      filter: filter
    }),
    prompt ? prompt : renderInnerTable(),
    _react2.default.createElement(_listing_table_tool_bar_footer.KuiListingTableToolBarFooter, {
      itemsSelectedCount: selectedRowIds.length,
      pager: pager
    })
  );
}

KuiListingTable.PropTypes = {
  header: _propTypes2.default.arrayOf(_propTypes2.default.oneOf([_propTypes2.default.node, _propTypes2.default.shape({
    content: _propTypes2.default.node,
    align: _propTypes2.default.oneOf([_services.LEFT_ALIGNMENT, _services.RIGHT_ALIGNMENT]),
    onSort: _propTypes2.default.func,
    isSortAscending: _propTypes2.default.bool,
    isSorted: _propTypes2.default.bool
  })])),
  rows: _propTypes2.default.arrayOf(_propTypes2.default.shape({
    id: _propTypes2.default.string,
    cells: _propTypes2.default.arrayOf(_propTypes2.default.oneOf([_propTypes2.default.node, _propTypes2.default.shape({
      content: _propTypes2.default.node,
      align: _propTypes2.default.oneOf([_services.LEFT_ALIGNMENT, _services.RIGHT_ALIGNMENT])
    })]))
  })),
  pager: _propTypes2.default.node,
  onItemSelectionChanged: _propTypes2.default.func.isRequired,
  selectedRowIds: _propTypes2.default.array,
  prompt: _propTypes2.default.node, // If given, will be shown instead of a table with rows.
  onFilter: _propTypes2.default.func,
  toolBarActions: _propTypes2.default.node,
  filter: _propTypes2.default.string
};

KuiListingTable.defaultProps = {
  rows: [],
  selectedRowIds: []
};

/***/ }),
/* 2604 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiListingTableToolBar = KuiListingTableToolBar;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _ = __webpack_require__(101);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function KuiListingTableToolBar(_ref) {
  var pager = _ref.pager,
      actions = _ref.actions,
      onFilter = _ref.onFilter,
      filter = _ref.filter;

  var actionsSection = void 0;

  if (actions) {
    actionsSection = _react2.default.createElement(
      _.KuiToolBarSection,
      null,
      actions
    );
  }

  var pagerSection = void 0;

  if (pager) {
    pagerSection = _react2.default.createElement(
      _.KuiToolBarSection,
      null,
      pager
    );
  }

  return _react2.default.createElement(
    _.KuiToolBar,
    null,
    _react2.default.createElement(_.KuiToolBarSearchBox, { onFilter: onFilter, filter: filter }),
    actionsSection,
    pagerSection
  );
}

KuiListingTableToolBar.propTypes = {
  filter: _propTypes2.default.string,
  onFilter: _propTypes2.default.func.isRequired,
  pager: _propTypes2.default.node,
  actions: _propTypes2.default.node
};

/***/ }),
/* 2605 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiListingTableToolBarFooter = KuiListingTableToolBarFooter;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _ = __webpack_require__(101);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function KuiListingTableToolBarFooter(_ref) {
  var pager = _ref.pager,
      itemsSelectedCount = _ref.itemsSelectedCount;

  var renderText = function renderText() {
    if (itemsSelectedCount === 1) {
      return '1 item selected';
    }

    return itemsSelectedCount + ' items selected';
  };

  var pagerSection = void 0;

  if (pager) {
    pagerSection = _react2.default.createElement(
      _.KuiToolBarFooterSection,
      null,
      pager
    );
  }

  return _react2.default.createElement(
    _.KuiToolBarFooter,
    null,
    _react2.default.createElement(
      _.KuiToolBarFooterSection,
      null,
      _react2.default.createElement(
        _.KuiToolBarText,
        null,
        renderText()
      )
    ),
    pagerSection
  );
}

KuiListingTableToolBarFooter.PropTypes = {
  pager: _propTypes2.default.node,
  itemsSelectedCount: _propTypes2.default.number
};

/***/ }),
/* 2606 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiListingTableRow = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _2 = __webpack_require__(871);

var _services = __webpack_require__(120);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var KuiListingTableRow = exports.KuiListingTableRow = function (_React$PureComponent) {
  _inherits(KuiListingTableRow, _React$PureComponent);

  function KuiListingTableRow() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, KuiListingTableRow);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = KuiListingTableRow.__proto__ || Object.getPrototypeOf(KuiListingTableRow)).call.apply(_ref, [this].concat(args))), _this), _this.onSelectionChanged = function () {
      _this.props.onSelectionChanged(_this.props.row.id);
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(KuiListingTableRow, [{
    key: 'renderCells',
    value: function renderCells() {
      return this.props.row.cells.map(function (cell, index) {
        var content = cell.content,
            props = _objectWithoutProperties(cell, ['content']);

        if (_react2.default.isValidElement(cell) || !_lodash2.default.isObject(cell)) {
          props = [];
          content = cell;
        }
        return _react2.default.createElement(
          _2.KuiTableRowCell,
          _extends({
            key: index
          }, props),
          content
        );
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var isSelected = this.props.isSelected;

      return _react2.default.createElement(
        _2.KuiTableRow,
        null,
        _react2.default.createElement(_2.KuiTableRowCheckBoxCell, {
          isChecked: isSelected,
          onChange: this.onSelectionChanged
        }),
        this.renderCells()
      );
    }
  }]);

  return KuiListingTableRow;
}(_react2.default.PureComponent);

KuiListingTableRow.PropTypes = {
  row: _propTypes2.default.shape({
    id: _propTypes2.default.string,
    cells: _propTypes2.default.arrayOf(_propTypes2.default.oneOf([_propTypes2.default.node, _propTypes2.default.shape({
      content: _propTypes2.default.node,
      align: _propTypes2.default.oneOf([_services.LEFT_ALIGNMENT, _services.RIGHT_ALIGNMENT])
    })]))
  }).isRequired,
  onSelectionChanged: _propTypes2.default.func.isRequired,
  isSelected: _propTypes2.default.bool
};

/***/ }),
/* 2607 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.KuiListingTableCreateButton = KuiListingTableCreateButton;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _ = __webpack_require__(101);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function KuiListingTableCreateButton(_ref) {
  var onCreate = _ref.onCreate,
      props = _objectWithoutProperties(_ref, ['onCreate']);

  return _react2.default.createElement(_.KuiButton, _extends({}, props, {
    buttonType: 'primary',
    onClick: onCreate,
    icon: _react2.default.createElement(_.KuiButtonIcon, { type: 'create' })
  }));
}

KuiListingTableCreateButton.propTypes = {
  onCreate: _propTypes2.default.func
};

/***/ }),
/* 2608 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.KuiListingTableDeleteButton = KuiListingTableDeleteButton;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _ = __webpack_require__(101);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function KuiListingTableDeleteButton(_ref) {
  var onDelete = _ref.onDelete,
      props = _objectWithoutProperties(_ref, ['onDelete']);

  return _react2.default.createElement(_.KuiButton, _extends({}, props, {
    buttonType: 'danger',
    onClick: onDelete,
    icon: _react2.default.createElement(_.KuiButtonIcon, { type: 'delete' })
  }));
}

KuiListingTableDeleteButton.propTypes = {
  onDelete: _propTypes2.default.func
};

/***/ }),
/* 2609 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiListingTableNoMatchesPrompt = KuiListingTableNoMatchesPrompt;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _ = __webpack_require__(101);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function KuiListingTableNoMatchesPrompt() {
  return _react2.default.createElement(
    _.KuiEmptyTablePromptPanel,
    null,
    _react2.default.createElement(
      _.KuiTableInfo,
      null,
      'No items matched your search.'
    )
  );
}

/***/ }),
/* 2610 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiListingTableLoadingPrompt = KuiListingTableLoadingPrompt;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _ = __webpack_require__(101);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function KuiListingTableLoadingPrompt() {
  return _react2.default.createElement(
    _.KuiEmptyTablePromptPanel,
    null,
    _react2.default.createElement(
      _.KuiTableInfo,
      null,
      'Loading...'
    )
  );
}

/***/ }),
/* 2611 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _tool_bar_search_box = __webpack_require__(2612);

Object.defineProperty(exports, 'KuiToolBarSearchBox', {
  enumerable: true,
  get: function get() {
    return _tool_bar_search_box.KuiToolBarSearchBox;
  }
});

var _tool_bar = __webpack_require__(2613);

Object.defineProperty(exports, 'KuiToolBar', {
  enumerable: true,
  get: function get() {
    return _tool_bar.KuiToolBar;
  }
});

var _tool_bar_footer = __webpack_require__(2614);

Object.defineProperty(exports, 'KuiToolBarFooter', {
  enumerable: true,
  get: function get() {
    return _tool_bar_footer.KuiToolBarFooter;
  }
});

var _tool_bar_section = __webpack_require__(2615);

Object.defineProperty(exports, 'KuiToolBarSection', {
  enumerable: true,
  get: function get() {
    return _tool_bar_section.KuiToolBarSection;
  }
});

var _tool_bar_footer_section = __webpack_require__(2616);

Object.defineProperty(exports, 'KuiToolBarFooterSection', {
  enumerable: true,
  get: function get() {
    return _tool_bar_footer_section.KuiToolBarFooterSection;
  }
});

var _tool_bar_text = __webpack_require__(2617);

Object.defineProperty(exports, 'KuiToolBarText', {
  enumerable: true,
  get: function get() {
    return _tool_bar_text.KuiToolBarText;
  }
});

/***/ }),
/* 2612 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.KuiToolBarSearchBox = KuiToolBarSearchBox;

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function KuiToolBarSearchBox(_ref) {
  var defaultValue = _ref.defaultValue,
      filter = _ref.filter,
      onFilter = _ref.onFilter,
      placeholder = _ref.placeholder,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['defaultValue', 'filter', 'onFilter', 'placeholder', 'className']);

  function onChange(event) {
    onFilter(event.target.value);
  }
  var classes = (0, _classnames2.default)('kuiToolBarSearch', className);
  return _react2.default.createElement(
    'div',
    _extends({
      className: classes
    }, rest),
    _react2.default.createElement(
      'div',
      { className: 'kuiToolBarSearchBox' },
      _react2.default.createElement('div', { className: 'kuiToolBarSearchBox__icon kuiIcon fa-search' }),
      _react2.default.createElement('input', {
        defaultValue: defaultValue,
        className: 'kuiToolBarSearchBox__input',
        type: 'text',
        placeholder: placeholder,
        'aria-label': 'Filter',
        value: filter,
        onChange: onChange
      })
    )
  );
}

KuiToolBarSearchBox.propTypes = {
  defaultValue: _propTypes2.default.string,
  filter: _propTypes2.default.string,
  onFilter: _propTypes2.default.func.isRequired
};

KuiToolBarSearchBox.defaultProps = {
  placeholder: 'Search...'
};

/***/ }),
/* 2613 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiToolBar = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiToolBar = function KuiToolBar(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiToolBar', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
};
exports.KuiToolBar = KuiToolBar;
KuiToolBar.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2614 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiToolBarFooter = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiToolBarFooter = function KuiToolBarFooter(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiToolBarFooter', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
};
exports.KuiToolBarFooter = KuiToolBarFooter;
KuiToolBarFooter.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2615 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiToolBarSection = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiToolBarSection = function KuiToolBarSection(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiToolBarSection', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
};
exports.KuiToolBarSection = KuiToolBarSection;
KuiToolBarSection.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2616 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiToolBarFooterSection = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiToolBarFooterSection = function KuiToolBarFooterSection(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiToolBarFooterSection', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
};
exports.KuiToolBarFooterSection = KuiToolBarFooterSection;
KuiToolBarFooterSection.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2617 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KuiToolBarText = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(4);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var KuiToolBarText = function KuiToolBarText(_ref) {
  var children = _ref.children,
      className = _ref.className,
      rest = _objectWithoutProperties(_ref, ['children', 'className']);

  var classes = (0, _classnames2.default)('kuiToolBarText', className);
  return _react2.default.createElement(
    'div',
    _extends({ className: classes }, rest),
    children
  );
};
exports.KuiToolBarText = KuiToolBarText;
KuiToolBarText.propTypes = {
  children: _propTypes2.default.node,
  className: _propTypes2.default.string
};

/***/ }),
/* 2618 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var context = __webpack_require__(2619);
context.keys().forEach(function (key) {
  return context(key);
});

/***/ }),
/* 2619 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./auto_select_if_only_one.js": 874,
	"./click_focus.js": 2620,
	"./confirm_click.js": 875,
	"./css_truncate.js": 513,
	"./documentation_href.js": 118,
	"./field_name.js": 514,
	"./file_upload.js": 876,
	"./focus_on.js": 481,
	"./inequality.js": 487,
	"./infinite_scroll.js": 877,
	"./info.js": 2631,
	"./input_base64.js": 2633,
	"./input_datetime.js": 794,
	"./input_focus.js": 465,
	"./input_number.js": 2914,
	"./json_input.js": 779,
	"./kbn_href.js": 694,
	"./kbn_src.js": 693,
	"./paginate.js": 2915,
	"./paginated_selectable_list.js": 908,
	"./pretty_duration.js": 2918,
	"./rows.js": 2919,
	"./saved_object_finder.js": 909,
	"./scroll_bottom.js": 910,
	"./string_to_number.js": 784,
	"./truncated.js": 443,
	"./ui_select_focus_on.js": 254,
	"./validate_agg.js": 911,
	"./validate_cidr_mask.js": 912,
	"./validate_date_math.js": 479,
	"./validate_index_pattern.js": 914,
	"./validate_ip.js": 480,
	"./validate_json.js": 915,
	"./validate_lowercase.js": 2924
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 2619;

/***/ }),
/* 2620 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');

_module.directive('clickFocus', function () {
  return {
    scope: {
      clickFocus: '='
    },
    restrict: 'A',
    link: function link($scope, $elem) {
      function handler() {
        var focusElem = _jquery2.default.find('input[name=' + $scope.clickFocus + ']');
        if (focusElem[0]) focusElem[0].focus();
      }

      $elem.bind('click', handler);
      $scope.$on('$destroy', _lodash2.default.bindKey($elem, 'unbind', 'click', handler));
    }
  };
});

/***/ }),
/* 2621 */
/***/ (function(module, exports) {

module.exports = "<span\n  aria-label=\"Boolean field\"\n  class=\"field-name-icon kuiIcon fa-adjust\"\n></span>\n"

/***/ }),
/* 2622 */
/***/ (function(module, exports) {

module.exports = "<span\n  aria-label=\"Conflicting field\"\n  class=\"field-name-icon kuiIcon fa-warning\"\n></span>\n"

/***/ }),
/* 2623 */
/***/ (function(module, exports) {

module.exports = "<span\n  aria-label=\"Date field\"\n  class=\"field-name-icon kuiIcon fa-clock-o\"\n></span>\n"

/***/ }),
/* 2624 */
/***/ (function(module, exports) {

module.exports = "<span\n  aria-label=\"Geo-point field\"\n  class=\"field-name-icon kuiIcon fa-globe\"\n></span>\n"

/***/ }),
/* 2625 */
/***/ (function(module, exports) {

module.exports = "<span\n  aria-label=\"IP address field\"\n  class=\"field-name-icon kuiIcon fa-laptop\"\n></span>\n"

/***/ }),
/* 2626 */
/***/ (function(module, exports) {

module.exports = "<span\n  aria-label=\"Murmur3 field\"\n  class=\"field-name-icon\"\n>\n  <strong aria-hidden=\"true\">h</strong>\n</span>\n"

/***/ }),
/* 2627 */
/***/ (function(module, exports) {

module.exports = "<span\n  aria-label=\"Number field\"\n  class=\"field-name-icon\"\n>\n  <strong aria-hidden=\"true\">#</strong>\n</span>\n"

/***/ }),
/* 2628 */
/***/ (function(module, exports) {

module.exports = "<span\n  aria-label=\"Source field\"\n  class=\"field-name-icon kuiIcon fa-file-text-o\"\n></span>\n"

/***/ }),
/* 2629 */
/***/ (function(module, exports) {

module.exports = "<span\n  aria-label=\"String field\"\n  class=\"field-name-icon\"\n>\n  <strong aria-hidden=\"true\">t</strong>\n</span>\n"

/***/ }),
/* 2630 */
/***/ (function(module, exports) {

module.exports = "<span\n  aria-label=\"Unknown field\"\n  class=\"field-name-icon\"\n>\n  <strong aria-hidden=\"true\">?</strong>\n</span>\n"

/***/ }),
/* 2631 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _info = __webpack_require__(2632);

var _info2 = _interopRequireDefault(_info);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_modules.uiModules.get('kibana').directive('kbnInfo', function () {
  return {
    restrict: 'E',
    scope: {
      info: '@',
      placement: '@'
    },
    template: _info2.default,
    link: function link($scope) {
      $scope.placement = $scope.placement || 'top';
    }
  };
});

/***/ }),
/* 2632 */
/***/ (function(module, exports) {

module.exports = "<button\n  aria-label=\"{{info}}\"\n  class=\"kuiInfoButton\"\n  tooltip=\"{{info}}\"\n  tooltip-placement=\"{{placement}}\"\n  tooltip-popup-delay=\"250\"\n  tooltip-trigger=\"focus\"\n>\n  <span class=\"kuiIcon fa-info-circle\"></span>\n</button>\n"

/***/ }),
/* 2633 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _modules = __webpack_require__(2);

var _Rx = __webpack_require__(515);

var _module = _modules.uiModules.get('kibana');

var multipleUsageErrorMessage = 'Cannot use input-base-sixty-four directive on input with `multiple` attribute';

var createFileContent$ = function createFileContent$(file) {
  return _Rx.Observable.create(function (observer) {
    var reader = new FileReader();
    reader.onerror = function (err) {
      observer.error(err);
    };

    reader.onload = function () {
      observer.next(reader.result);
      observer.complete();
    };

    reader.readAsDataURL(file);

    return function () {
      reader.abort();
    };
  });
};

_module.directive('inputBaseSixtyFour', function () {
  return {
    restrict: 'A',
    require: 'ngModel',
    scope: 'isolate',
    link: function link($scope, $elem, attrs, ngModel) {
      if ($elem.prop('multiple')) {
        throw new Error(multipleUsageErrorMessage);
      }

      var maxSizeValidator = function maxSizeValidator(dataUrl) {
        return {
          errorKey: 'maxSize',
          isValid: attrs.max === '' || dataUrl.length <= parseInt(attrs.max)
        };
      };

      var validators = [maxSizeValidator];

      // produce fileContent$ whenever the $element 'change' event is triggered.
      var fileContent$ = _Rx.Observable.fromEvent($elem, 'change').map(function (e) {
        return e.target.files;
      }).switchMap(function (files) {
        if (files.length === 0) {
          return [];
        }

        if (files.length > 1) {
          throw new Error(multipleUsageErrorMessage);
        }

        return createFileContent$(files[0]);
      }).share();

      // validate the content of the files after it is loaded
      var validations$ = fileContent$.map(function (fileContent) {
        return validators.map(function (validator) {
          return validator(fileContent);
        });
      });

      // push results from input/validation to the ngModel
      var unsubscribe = _Rx.Observable.combineLatest(fileContent$, validations$).subscribe(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            fileContent = _ref2[0],
            validations = _ref2[1];

        $scope.$evalAsync(function () {
          validations.forEach(function (validation) {
            ngModel.$setValidity(validation.errorKey, validation.isValid);
          });

          if (validations.every(function (validation) {
            return validation.isValid;
          })) {
            ngModel.$setViewValue(fileContent);
          }
        });
      }, function (err) {
        throw err;
      });

      $scope.$on('destroy', unsubscribe);
    }
  };
});

/***/ }),
/* 2634 */,
/* 2635 */,
/* 2636 */,
/* 2637 */,
/* 2638 */,
/* 2639 */,
/* 2640 */,
/* 2641 */,
/* 2642 */,
/* 2643 */,
/* 2644 */,
/* 2645 */,
/* 2646 */,
/* 2647 */,
/* 2648 */,
/* 2649 */,
/* 2650 */,
/* 2651 */,
/* 2652 */,
/* 2653 */,
/* 2654 */,
/* 2655 */,
/* 2656 */,
/* 2657 */,
/* 2658 */,
/* 2659 */,
/* 2660 */,
/* 2661 */,
/* 2662 */,
/* 2663 */,
/* 2664 */,
/* 2665 */,
/* 2666 */,
/* 2667 */,
/* 2668 */,
/* 2669 */,
/* 2670 */,
/* 2671 */,
/* 2672 */,
/* 2673 */,
/* 2674 */,
/* 2675 */,
/* 2676 */,
/* 2677 */,
/* 2678 */,
/* 2679 */,
/* 2680 */,
/* 2681 */,
/* 2682 */,
/* 2683 */,
/* 2684 */,
/* 2685 */,
/* 2686 */,
/* 2687 */,
/* 2688 */,
/* 2689 */,
/* 2690 */,
/* 2691 */,
/* 2692 */,
/* 2693 */,
/* 2694 */,
/* 2695 */,
/* 2696 */,
/* 2697 */,
/* 2698 */,
/* 2699 */,
/* 2700 */,
/* 2701 */,
/* 2702 */,
/* 2703 */,
/* 2704 */,
/* 2705 */,
/* 2706 */,
/* 2707 */,
/* 2708 */,
/* 2709 */,
/* 2710 */,
/* 2711 */,
/* 2712 */,
/* 2713 */,
/* 2714 */,
/* 2715 */,
/* 2716 */,
/* 2717 */,
/* 2718 */,
/* 2719 */,
/* 2720 */,
/* 2721 */,
/* 2722 */,
/* 2723 */,
/* 2724 */,
/* 2725 */,
/* 2726 */,
/* 2727 */,
/* 2728 */,
/* 2729 */,
/* 2730 */,
/* 2731 */,
/* 2732 */,
/* 2733 */,
/* 2734 */,
/* 2735 */,
/* 2736 */,
/* 2737 */,
/* 2738 */,
/* 2739 */,
/* 2740 */,
/* 2741 */,
/* 2742 */,
/* 2743 */,
/* 2744 */,
/* 2745 */,
/* 2746 */,
/* 2747 */,
/* 2748 */,
/* 2749 */,
/* 2750 */,
/* 2751 */,
/* 2752 */,
/* 2753 */,
/* 2754 */,
/* 2755 */,
/* 2756 */,
/* 2757 */,
/* 2758 */,
/* 2759 */,
/* 2760 */,
/* 2761 */,
/* 2762 */,
/* 2763 */,
/* 2764 */,
/* 2765 */,
/* 2766 */,
/* 2767 */,
/* 2768 */,
/* 2769 */,
/* 2770 */,
/* 2771 */,
/* 2772 */,
/* 2773 */,
/* 2774 */,
/* 2775 */,
/* 2776 */,
/* 2777 */,
/* 2778 */,
/* 2779 */,
/* 2780 */,
/* 2781 */,
/* 2782 */,
/* 2783 */,
/* 2784 */,
/* 2785 */,
/* 2786 */,
/* 2787 */,
/* 2788 */,
/* 2789 */,
/* 2790 */,
/* 2791 */,
/* 2792 */,
/* 2793 */,
/* 2794 */,
/* 2795 */,
/* 2796 */,
/* 2797 */,
/* 2798 */,
/* 2799 */,
/* 2800 */,
/* 2801 */,
/* 2802 */,
/* 2803 */,
/* 2804 */,
/* 2805 */,
/* 2806 */,
/* 2807 */,
/* 2808 */,
/* 2809 */,
/* 2810 */,
/* 2811 */,
/* 2812 */,
/* 2813 */,
/* 2814 */,
/* 2815 */,
/* 2816 */,
/* 2817 */,
/* 2818 */,
/* 2819 */,
/* 2820 */,
/* 2821 */,
/* 2822 */,
/* 2823 */,
/* 2824 */,
/* 2825 */,
/* 2826 */,
/* 2827 */,
/* 2828 */,
/* 2829 */,
/* 2830 */,
/* 2831 */,
/* 2832 */,
/* 2833 */,
/* 2834 */,
/* 2835 */,
/* 2836 */,
/* 2837 */,
/* 2838 */,
/* 2839 */,
/* 2840 */,
/* 2841 */,
/* 2842 */,
/* 2843 */,
/* 2844 */,
/* 2845 */,
/* 2846 */,
/* 2847 */,
/* 2848 */,
/* 2849 */,
/* 2850 */,
/* 2851 */,
/* 2852 */,
/* 2853 */,
/* 2854 */,
/* 2855 */,
/* 2856 */,
/* 2857 */,
/* 2858 */,
/* 2859 */,
/* 2860 */,
/* 2861 */,
/* 2862 */,
/* 2863 */,
/* 2864 */,
/* 2865 */,
/* 2866 */,
/* 2867 */,
/* 2868 */,
/* 2869 */,
/* 2870 */,
/* 2871 */,
/* 2872 */,
/* 2873 */,
/* 2874 */,
/* 2875 */,
/* 2876 */,
/* 2877 */,
/* 2878 */,
/* 2879 */,
/* 2880 */,
/* 2881 */,
/* 2882 */,
/* 2883 */,
/* 2884 */,
/* 2885 */,
/* 2886 */,
/* 2887 */,
/* 2888 */,
/* 2889 */,
/* 2890 */,
/* 2891 */,
/* 2892 */,
/* 2893 */,
/* 2894 */,
/* 2895 */,
/* 2896 */,
/* 2897 */,
/* 2898 */,
/* 2899 */,
/* 2900 */,
/* 2901 */,
/* 2902 */,
/* 2903 */,
/* 2904 */,
/* 2905 */,
/* 2906 */,
/* 2907 */,
/* 2908 */,
/* 2909 */,
/* 2910 */,
/* 2911 */,
/* 2912 */,
/* 2913 */,
/* 2914 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _module = _modules.uiModules.get('kibana');

_module.directive('inputNumber', function () {
  return {
    restrict: 'A',
    require: 'ngModel',
    link: function link($scope, $elem, attrs, ngModel) {
      ngModel.$parsers.push(checkNumber);
      ngModel.$formatters.push(checkNumber);

      function checkNumber(value) {
        ngModel.$setValidity('number', !isNaN(parseFloat(value)));
        return value;
      }
    }
  };
});

/***/ }),
/* 2915 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _modules = __webpack_require__(2);

var _paginate_controls = __webpack_require__(2916);

var _paginate_controls2 = _interopRequireDefault(_paginate_controls);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_modules.uiModules.get('kibana').directive('paginate', function ($parse, $compile) {
  return {
    restrict: 'E',
    scope: true,
    link: {
      pre: function pre($scope, $el, attrs) {
        if (_lodash2.default.isUndefined(attrs.bottomControls)) attrs.bottomControls = true;
        if ($el.find('paginate-controls.paginate-bottom').length === 0 && attrs.bottomControls) {
          $el.append($compile('<paginate-controls class="paginate-bottom">')($scope));
        }
      },
      post: function post($scope, $el, attrs) {
        if (_lodash2.default.isUndefined(attrs.topControls)) attrs.topControls = false;
        if ($el.find('paginate-controls.paginate-top').length === 0 && attrs.topControls) {
          $el.prepend($compile('<paginate-controls class="paginate-top">')($scope));
        }

        var paginate = $scope.paginate;

        // add some getters to the controller powered by attributes
        paginate.getList = $parse(attrs.list);
        paginate.perPageProp = attrs.perPageProp;

        if (attrs.perPage) {
          paginate.perPage = attrs.perPage;
          $scope.showSelector = false;
        } else {
          $scope.showSelector = true;
        }

        paginate.otherWidthGetter = $parse(attrs.otherWidth);

        paginate.init();
      }
    },
    controllerAs: 'paginate',
    controller: function controller($scope, $document) {
      var self = this;
      var ALL = 0;

      self.sizeOptions = [{ title: '10', value: 10 }, { title: '25', value: 25 }, { title: '100', value: 100 }, { title: 'All', value: ALL }];

      // setup the watchers, called in the post-link function
      self.init = function () {

        self.perPage = _lodash2.default.parseInt(self.perPage) || $scope[self.perPageProp];

        $scope.$watchMulti(['paginate.perPage', self.perPageProp, self.otherWidthGetter], function (vals, oldVals) {
          var intChanges = vals[0] !== oldVals[0];

          if (intChanges) {
            if (!setPerPage(self.perPage)) {
              // if we are not able to set the external value,
              // render now, otherwise wait for the external value
              // to trigger the watcher again
              self.renderList();
            }
            return;
          }

          self.perPage = _lodash2.default.parseInt(self.perPage) || $scope[self.perPageProp];
          if (self.perPage == null) {
            self.perPage = ALL;
            return;
          }

          self.renderList();
        });

        $scope.$watch('page', self.changePage);
        $scope.$watchCollection(self.getList, function (list) {
          $scope.list = list;
          self.renderList();
        });
      };

      self.goToPage = function (number) {
        if (number) {
          if (number.hasOwnProperty('number')) number = number.number;
          $scope.page = $scope.pages[number - 1] || $scope.pages[0];
        }
      };

      self.goToTop = function goToTop() {
        $document.scrollTop(0);
      };

      self.renderList = function () {
        $scope.pages = [];
        if (!$scope.list) return;

        var perPage = _lodash2.default.parseInt(self.perPage);
        var count = perPage ? Math.ceil($scope.list.length / perPage) : 1;

        _lodash2.default.times(count, function (i) {
          var page = void 0;

          if (perPage) {
            var start = perPage * i;
            page = $scope.list.slice(start, start + perPage);
          } else {
            page = $scope.list.slice(0);
          }

          page.number = i + 1;
          page.i = i;

          page.count = count;
          page.first = page.number === 1;
          page.last = page.number === count;
          page.firstItem = (page.number - 1) * perPage + 1;
          page.lastItem = Math.min(page.number * perPage, $scope.list.length);

          page.prev = $scope.pages[i - 1];
          if (page.prev) page.prev.next = page;

          $scope.pages.push(page);
        });

        // set the new page, or restore the previous page number
        if ($scope.page && $scope.page.i < $scope.pages.length) {
          $scope.page = $scope.pages[$scope.page.i];
        } else {
          $scope.page = $scope.pages[0];
        }

        if ($scope.page && $scope.onPageChanged) {
          $scope.onPageChanged($scope.page);
        }
      };

      self.changePage = function (page) {
        if (!page) {
          $scope.otherPages = null;
          return;
        }

        // setup the list of the other pages to link to
        $scope.otherPages = [];
        var width = +self.otherWidthGetter($scope) || 5;
        var left = page.i - Math.round((width - 1) / 2);
        var right = left + width - 1;

        // shift neg count from left to right
        if (left < 0) {
          right += 0 - left;
          left = 0;
        }

        // shift extra right nums to left
        var lastI = page.count - 1;
        if (right > lastI) {
          right = lastI;
          left = right - width + 1;
        }

        for (var i = left; i <= right; i++) {
          var other = $scope.pages[i];

          if (!other) continue;

          $scope.otherPages.push(other);
          if (other.last) $scope.otherPages.containsLast = true;
          if (other.first) $scope.otherPages.containsFirst = true;
        }

        if ($scope.onPageChanged) {
          $scope.onPageChanged($scope.page);
        }
      };

      function setPerPage(val) {
        var $ppParent = $scope;

        while ($ppParent && !_lodash2.default.has($ppParent, self.perPageProp)) {
          $ppParent = $ppParent.$parent;
        }

        if ($ppParent) {
          $ppParent[self.perPageProp] = val;
          return true;
        }
      }
    }
  };
}).directive('paginateControls', function () {
  // this directive is automatically added by paginate if not found within it's $el
  return {
    restrict: 'E',
    template: _paginate_controls2.default
  };
});

/***/ }),
/* 2916 */
/***/ (function(module, exports) {

module.exports = "<button\n  class=\"kuiLink\"\n  ng-if=\"linkToTop\"\n  ng-click=\"paginate.goToTop()\"\n  data-test-subj=\"paginateControlsLinkToTop\"\n>\n  Scroll to top\n</button>\n\n<div\n  class=\"pagination-other-pages\"\n  data-test-subj=\"paginationControls\"\n>\n  <ul class=\"pagination-other-pages-list pagination-sm\" ng-if=\"page.count > 1\">\n    <li ng-style=\"{'visibility':'hidden'}\" ng-if=\"page.first\">\n      <button\n        class=\"euiButtonEmpty euiButtonEmpty--text euiButtonEmpty--small euiPaginationButton\"\n        ng-click=\"paginate.goToPage(page.prev)\"\n      ></button>\n    </li>\n    <li ng-style=\"{'visibility':'visible'}\" ng-if=\"!page.first\">\n      <button\n        class=\"euiButtonEmpty euiButtonEmpty--text euiButtonEmpty--small euiPaginationButton\"\n        ng-click=\"paginate.goToPage(page.prev)\"\n      ></button>\n    </li>\n\n    <li ng-if=\"!otherPages.containsFirst\">\n      <button\n        class=\"euiButtonEmpty euiButtonEmpty--text euiButtonEmpty--small euiPaginationButton\"\n        ng-click=\"paginate.goToPage(1)\"\n      >1</button>\n      ...\n    </li>\n\n    <li\n      ng-repeat=\"other in otherPages\"\n      ng-class=\"{ active: other.number === page.number }\"\n    >\n      <button\n        class=\"euiButtonEmpty euiButtonEmpty--text euiButtonEmpty--small euiPaginationButton\"\n        ng-class=\"{ 'euiPaginationButton-isActive': other.number === page.number }\"\n        ng-click=\"paginate.goToPage(other)\"\n      >\n        {{other.number}}\n      </button>\n    </li>\n\n    <li ng-if=\"!otherPages.containsLast\">\n      ...\n      <button\n        class=\"euiButtonEmpty euiButtonEmpty--text euiButtonEmpty--small euiPaginationButton\"\n        ng-click=\"paginate.goToPage(page.count)\"\n      >{{page.count}}</button>\n    </li>\n\n    <li ng-style=\"{'visibility':'hidden'}\" ng-if=\"page.last\">\n      <button\n        class=\"euiButtonEmpty euiButtonEmpty--text euiButtonEmpty--small euiPaginationButton\"\n        ng-click=\"paginate.goToPage(page.next)\"\n      ></button>\n    </li>\n    <li ng-style=\"{'visibility':'visible'}\" ng-if=\"!page.last\">\n      <button\n        class=\"euiButtonEmpty euiButtonEmpty--text euiButtonEmpty--small euiPaginationButton\"\n        ng-click=\"paginate.goToPage(page.next)\"\n      ></button>\n    </li>\n  </ul>\n</div>\n\n<form class=\"form-inline pagination-size\" ng-if=\"showSelector\">\n  <div class=\"form-group\">\n    <label>Page Size</label>\n    <select\n      ng-model=\"paginate.perPage\"\n      ng-options=\"opt.value as opt.title for opt in paginate.sizeOptions\"\n      data-test-subj=\"paginateControlsPageSizeSelect\"\n    ></select>\n  </div>\n</form>\n"

/***/ }),
/* 2917 */
/***/ (function(module, exports) {

module.exports = "<form\n  role=\"form\"\n  class=\"kuiVerticalRhythm\"\n>\n  <div class=\"kuiBar\">\n    <div class=\"kuiBarSection\">\n      <div class=\"kuiSearchInput fullWidth\">\n        <div class=\"kuiSearchInput__icon kuiIcon fa-search\"></div>\n        <input\n          class=\"kuiSearchInput__input\"\n          input-focus\n          disable-input-focus=\"disableAutoFocus\"\n          ng-model=\"query\"\n          placeholder=\"Filter...\"\n          class=\"form-control\"\n          name=\"query\"\n          type=\"text\"\n          autocomplete=\"off\"\n        >\n      </div>\n    </div>\n\n    <div class=\"kuiBarSection\">\n      <p class=\"kuiText kuiSubduedText\">\n        {{ (hits | filter: query).length }} of {{ hitCount }}\n      </p>\n    </div>\n  </div>\n</form>\n\n<paginate\n  list=\"hits | filter: query\"\n  per-page=\"{{ perPage }}\"\n  class=\"kuiVerticalRhythm\"\n>\n  <button\n    class=\"paginate-heading list-group-item list-sort-button\"\n    ng-click=\"sortHits(hits)\"\n    aria-live=\"assertive\"\n  >\n    <span class=\"kuiScreenReaderOnly\">Sort by</span>\n    Name\n    <span\n      class=\"fa\"\n      ng-class=\"isAscending ? 'fa-caret-up' : 'fa-caret-down'\">\n      <span class=\"kuiScreenReaderOnly\">({{isAscending ? 'ascending' : 'descending'}})</span>\n    </span>\n  </button>\n  <ul class=\"li-striped list-group list-group-menu\">\n    <li class=\"list-group-item list-group-menu-item\" ng-repeat=\"hit in page\">\n      <a\n        data-test-subj=\"paginatedListItem-{{accessor(hit)}}\"\n        ng-show=\"userMakeUrl\"\n        kbn-href=\"{{ makeUrl(hit) }}\">\n        <span>{{ accessor(hit) }}</span>\n      </a>\n\n      <div ng-show=\"userOnSelect\" ng-click=\"onSelect(hit, $event)\">\n        <span>{{ accessor(hit) }}</span>\n      </div>\n    </li>\n\n    <li class=\"list-group-item list-group-no-results\" ng-if=\"(hits | filter: query).length === 0\">\n      <p>No matches found.</p>\n    </li>\n  </ul>\n</paginate>\n"

/***/ }),
/* 2918 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _datemath = __webpack_require__(90);

var _datemath2 = _interopRequireDefault(_datemath);

var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

__webpack_require__(795);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');

_module.directive('prettyDuration', function (config, timeUnits) {
  return {
    restrict: 'E',
    scope: {
      from: '=',
      to: '='
    },
    link: function link($scope, $elem) {
      var quickRanges = config.get('timepicker:quickRanges');
      var dateFormat = config.get('dateFormat');

      var lookupByRange = {};
      _lodash2.default.each(quickRanges, function (frame) {
        lookupByRange[frame.from + ' to ' + frame.to] = frame;
      });

      function setText(text) {
        $elem.text(text);
        $elem.attr('aria-label', 'Current time range is ' + text);
      }

      function stringify() {
        var text = void 0;
        // If both parts are date math, try to look up a reasonable string
        if ($scope.from && $scope.to && !_moment2.default.isMoment($scope.from) && !_moment2.default.isMoment($scope.to)) {
          var tryLookup = lookupByRange[$scope.from.toString() + ' to ' + $scope.to.toString()];
          if (tryLookup) {
            setText(tryLookup.display);
          } else {
            var fromParts = $scope.from.toString().split('-');
            if ($scope.to.toString() === 'now' && fromParts[0] === 'now' && fromParts[1]) {
              var rounded = fromParts[1].split('/');
              text = 'Last ' + rounded[0];
              if (rounded[1]) {
                text = text + ' rounded to the ' + timeUnits[rounded[1]];
              }
              setText(text);
            } else {
              cantLookup();
            }
          }
          // If at least one part is a moment, try to make pretty strings by parsing date math
        } else {
          cantLookup();
        }
      }

      function cantLookup() {
        var display = {};
        _lodash2.default.each(['from', 'to'], function (time) {
          if ((0, _moment2.default)($scope[time]).isValid()) {
            display[time] = (0, _moment2.default)($scope[time]).format(dateFormat);
          } else {
            if ($scope[time] === 'now') {
              display[time] = 'now';
            } else {
              var tryParse = _datemath2.default.parse($scope[time], time === 'to' ? true : false);
              display[time] = _moment2.default.isMoment(tryParse) ? '~ ' + tryParse.fromNow() : $scope[time];
            }
          }
        });
        setText(display.from + ' to ' + display.to);
      }

      $scope.$watch('from', stringify);
      $scope.$watch('to', stringify);
    }
  };
});

/***/ }),
/* 2919 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _agg_config_result = __webpack_require__(209);

var _agg_config_result2 = _interopRequireDefault(_agg_config_result);

var _filter_bar_click_handler = __webpack_require__(354);

var _modules = __webpack_require__(2);

var _table_cell_filter = __webpack_require__(2922);

var _table_cell_filter2 = _interopRequireDefault(_table_cell_filter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');

_module.directive('kbnRows', function ($compile, $rootScope, getAppState, Private) {
  var filterBarClickHandler = Private(_filter_bar_click_handler.FilterBarClickHandlerProvider);
  return {
    restrict: 'A',
    link: function link($scope, $el, attr) {
      function addCell($tr, contents) {
        function createCell() {
          return (0, _jquery2.default)(document.createElement('td'));
        }

        function createFilterableCell(aggConfigResult) {
          var $template = (0, _jquery2.default)(_table_cell_filter2.default);
          $template.addClass('cell-hover');

          var scope = $scope.$new();

          var $state = getAppState();
          var addFilter = filterBarClickHandler($state);
          scope.onFilterClick = function (event, negate) {
            // Don't add filter if a link was clicked.
            if ((0, _jquery2.default)(event.target).is('a')) {
              return;
            }

            addFilter({ point: { aggConfigResult: aggConfigResult }, negate: negate });
          };

          return $compile($template)(scope);
        }

        var $cell = void 0;
        var $cellContent = void 0;

        if (contents instanceof _agg_config_result2.default) {
          var field = contents.aggConfig.getField();
          var isCellContentFilterable = contents.aggConfig.isFilterable() && (!field || field.filterable);

          if (isCellContentFilterable) {
            $cell = createFilterableCell(contents);
            $cellContent = $cell.find('[data-cell-content]');
          } else {
            $cell = $cellContent = createCell();
          }

          // An AggConfigResult can "enrich" cell contents by applying a field formatter,
          // which we want to do if possible.
          contents = contents.toString('html');
        } else {
          $cell = $cellContent = createCell();

          // TODO: It would be better to actually check the type of the field, but we don't have
          // access to it here. This may become a problem with the switch to BigNumber
          if (_lodash2.default.isNumeric(contents)) {
            $cell.addClass('numeric-value');
          }
        }

        if (_lodash2.default.isObject(contents)) {
          if (contents.attr) {
            $cellContent.attr(contents.attr);
          }

          if (contents.class) {
            $cellContent.addClass(contents.class);
          }

          if (contents.scope) {
            $cellContent = $compile($cellContent.prepend(contents.markup))(contents.scope);
          } else {
            $cellContent.prepend(contents.markup);
          }

          if (contents.attr) {
            $cellContent.attr(contents.attr);
          }
        } else {
          if (contents === '') {
            $cellContent.prepend('&nbsp;');
          } else {
            $cellContent.prepend(contents);
          }
        }

        $tr.append($cell);
      }

      function maxRowSize(max, row) {
        return Math.max(max, row.length);
      }

      $scope.$watchMulti([attr.kbnRows, attr.kbnRowsMin], function (vals) {
        var rows = vals[0];
        var min = vals[1];

        $el.empty();

        if (!Array.isArray(rows)) rows = [];
        var width = rows.reduce(maxRowSize, 0);

        if (isFinite(min) && rows.length < min) {
          // clone the rows so that we can add elements to it without upsetting the original
          rows = _lodash2.default.clone(rows);
          // crate the empty row which will be pushed into the row list over and over
          var emptyRow = new Array(width);
          // fill the empty row with values
          _lodash2.default.times(width, function (i) {
            emptyRow[i] = '';
          });
          // push as many empty rows into the row array as needed
          _lodash2.default.times(min - rows.length, function () {
            rows.push(emptyRow);
          });
        }

        rows.forEach(function (row) {
          var $tr = (0, _jquery2.default)(document.createElement('tr')).appendTo($el);
          row.forEach(function (cell) {
            addCell($tr, cell);
          });
        });
      });
    }
  };
});

/***/ }),
/* 2920 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findByParam = findByParam;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// given an object or array of objects, return the value of the passed param
// if the param is missing, return undefined
function findByParam(values, param) {
  if (Array.isArray(values)) {
    // point series chart
    var index = _lodash2.default.findIndex(values, param);
    if (index === -1) return;
    return values[index][param];
  }
  return values[param]; // pie chart
}

/***/ }),
/* 2921 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AddFiltersToKueryProvider = AddFiltersToKueryProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _map_and_flatten_filters = __webpack_require__(327);

var _extract_time_filter = __webpack_require__(787);

var _change_time_filter = __webpack_require__(789);

var _filter_out_time_based_filter = __webpack_require__(788);

var _kuery = __webpack_require__(323);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function AddFiltersToKueryProvider(Private) {
  var mapAndFlattenFilters = Private(_map_and_flatten_filters.FilterBarLibMapAndFlattenFiltersProvider);
  var extractTimeFilter = Private(_extract_time_filter.FilterBarLibExtractTimeFilterProvider);
  var changeTimeFilter = Private(_change_time_filter.FilterBarLibChangeTimeFilterProvider);
  var filterOutTimeBasedFilter = Private(_filter_out_time_based_filter.FilterBarLibFilterOutTimeBasedFilterProvider);

  return function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(state, filters) {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt('return', mapAndFlattenFilters(filters).then(function (results) {
                extractTimeFilter(results).then(function (timeFilter) {
                  if (timeFilter) {
                    changeTimeFilter(timeFilter);
                  }
                });
                return results;
              }).then(filterOutTimeBasedFilter).then(function (results) {
                var newQueries = results.map(_kuery.filterToKueryAST);
                var allQueries = _lodash2.default.isEmpty(state.query.query) ? newQueries : [(0, _kuery.fromKueryExpression)(state.query.query)].concat(_toConsumableArray(newQueries));

                state.query = {
                  query: (0, _kuery.toKueryExpression)(_kuery.nodeTypes.function.buildNode('and', allQueries, 'implicit')),
                  language: 'kuery'
                };
              }));

            case 1:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function addFiltersToKuery(_x, _x2) {
      return _ref.apply(this, arguments);
    }

    return addFiltersToKuery;
  }();
}

/***/ }),
/* 2922 */
/***/ (function(module, exports) {

module.exports = "<td>\n  <div\n    data-cell-content\n    class=\"cell-hover\"\n  >\n    <span class=\"table-cell-filter\">\n      <span\n        ng-click=\"onFilterClick($event, false)\"\n        class=\"fa fa-search-plus\"\n        tooltip=\"Filter for value\"\n        tooltip-append-to-body=\"1\"\n      ></span>\n\n      <span\n        ng-click=\"onFilterClick($event, true)\"\n        class=\"fa fa-search-minus\"\n        tooltip=\"Filter out value\"\n        tooltip-append-to-body=\"1\"\n      ></span>\n    </span>\n  </div>\n</td>\n"

/***/ }),
/* 2923 */
/***/ (function(module, exports) {

module.exports = "<form\n  role=\"form\"\n  class=\"kuiVerticalRhythm\"\n>\n  <div class=\"kuiBar\">\n    <div class=\"kuiBarSection\">\n      <div class=\"kuiSearchInput fullWidth\">\n        <div class=\"kuiSearchInput__icon kuiIcon fa-search\"></div>\n        <input\n          class=\"kuiSearchInput__input\"\n          input-focus\n          disable-input-focus=\"disableAutoFocus\"\n          ng-model=\"filter\"\n          ng-attr-placeholder=\"{{ finder.properties.nouns | label }} Filter...\"\n          ng-keydown=\"finder.filterKeyDown($event)\"\n          name=\"filter\"\n          type=\"text\"\n          autocomplete=\"off\"\n          data-test-subj=\"savedObjectFinderSearchInput\"\n        >\n      </div>\n    </div>\n\n    <div class=\"kuiBarSection\">\n      <p class=\"kuiText kuiSubduedText\">\n        {{ pageFirstItem }}-{{ pageLastItem }} of {{ finder.hitCount }}\n      </p>\n\n      <div class=\"kuiButtonGroup\">\n        <button\n          class=\"kuiButton kuiButton--primary\"\n          ng-if=\"onAddNew\"\n          ng-click=\"onAddNew()\"\n          data-test-subj=\"addNewSavedObjectLink\"\n        >\n          Add new {{ finder.properties.noun }}\n        </button>\n\n        <button\n          class=\"kuiButton kuiButton--secondary\"\n          ng-if=\"!useLocalManagement\"\n          ng-click=\"finder.manageObjects(finder.properties.name)\"\n        >\n          Manage {{ finder.properties.nouns }}\n        </button>\n      </div>\n    </div>\n  </div>\n</form>\n\n<paginate\n  list=\"finder.hits\"\n  per-page=\"20\"\n  class=\"kuiVerticalRhythm\"\n>\n  <button\n    class=\"paginate-heading list-group-item list-sort-button\"\n    ng-click=\"finder.sortHits(finder.hits)\"\n    aria-live=\"assertive\"\n  >\n    <span class=\"kuiScreenReaderOnly\">Sort by</span>\n    Name\n    <span\n      class=\"fa\"\n      ng-class=\"finder.isAscending ? 'fa-caret-up' : 'fa-caret-down'\">\n      <span class=\"kuiScreenReaderOnly\">({{finder.isAscending ? 'ascending' : 'descending'}})</span>\n    </span>\n  </button>\n  <ul class=\"li-striped list-group list-group-menu\" ng-class=\"{'select-mode': finder.selector.enabled}\">\n    <li\n      class=\"list-group-item list-group-menu-item\"\n      ng-class=\"{'active': finder.selector.index === $index && finder.selector.enabled}\"\n      ng-repeat=\"hit in page\"\n      ng-keydown=\"finder.hitKeyDown($event, page, paginate)\"\n      ng-click=\"finder.onChoose(hit, $event)\">\n\n      <a ng-href=\"{{finder.makeUrl(hit)}}\"\n          ng-blur=\"finder.hitBlur($event)\"\n          ng-click=\"finder.preventClick($event)\">\n          <span aria-hidden=\"true\" class=\"finder-type fa\" ng-if=\"hit.icon\" ng-class=\"hit.icon\"></span>\n          <div class=\"kuiIcon fa-flask ng-scope\" ng-if=\"hit.type.shouldMarkAsExperimentalInUI()\"></div>\n          <span>{{hit.title}}</span>\n          <p ng-if=\"hit.description\" ng-bind=\"hit.description\"></p>\n      </a>\n    </li>\n    <li\n      class=\"list-group-item list-group-no-results\"\n      ng-if=\"finder.hits.length === 0\">\n      <p ng-bind=\"'No matching ' + finder.properties.nouns + ' found.'\"></p>\n    </li>\n  </ul>\n</paginate>\n"

/***/ }),
/* 2924 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

_modules.uiModules.get('kibana').directive('validateLowercase', function () {
  return {
    restrict: 'A',
    require: 'ngModel',
    link: function link($scope, elem, attr, ctrl) {
      ctrl.$validators.lowercase = function (modelValue, viewValue) {
        if (ctrl.$isEmpty(modelValue)) {
          // consider empty models to be valid per lowercase rules
          return true;
        }

        return viewValue.toLowerCase() === viewValue;
      };
    }
  };
});

/***/ }),
/* 2925 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var context = __webpack_require__(2926);
context.keys().forEach(function (key) {
  return context(key);
});

/***/ }),
/* 2926 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./comma_list.js": 2927,
	"./field_type.js": 523,
	"./label.js": 917,
	"./markdown.js": 439,
	"./match_any.js": 918,
	"./moment.js": 919,
	"./rison.js": 697,
	"./short_dots.js": 249,
	"./sort_prefix_first.js": 255,
	"./start_from.js": 920,
	"./trust_as_html.js": 921,
	"./unique.js": 922,
	"./uriescape.js": 696
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 2926;

/***/ }),
/* 2927 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _utils = __webpack_require__(199);

_modules.uiModules.get('kibana').filter('commaList', function () {
  /**
   * Angular filter that accepts either an array or a comma-seperated string
   * and outputs a comma-seperated string for presentation.
   *
   * @param {String|Array} input - The comma-seperated list or array
   * @param {Boolean} inclusive - Should the list be joined with an "and"?
   * @return {String}
   */
  return function (input) {
    var inclusive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    return (0, _utils.formatListAsProse)((0, _utils.parseCommaSeparatedList)(input), { inclusive: inclusive });
  };
});

/***/ }),
/* 2928 */,
/* 2929 */,
/* 2930 */,
/* 2931 */,
/* 2932 */,
/* 2933 */
/***/ (function(module, exports) {

module.exports = "/*\n * Timelion syntax parser\n */\n\n{\n function ltoo (literal) {\n  return {type: 'literal', value: literal}\n }\n\n function simpleLocation (location) {\n  // Returns an object representing the position of the function within the expression,\n  // demarcated by the position of its first character and last character. We calculate these values\n  // using the offset because the expression could span multiple lines, and we don't want to deal\n  // with column and line values.\n  return {\n   min: location.start.offset,\n   max: location.end.offset\n  }\n }\n\n var currentFunction;\n var currentArgs = [];\n\n var functions = [];\n var args = [];\n var variables = {};\n\n}\n\nstart\n = space? tree:series {\n  return {\n    tree: tree.filter(function (o) {return o != null}),\n    functions: functions,\n    args: args,\n    variables: variables\n  }\n }\n\narg_list\n = first:argument rest:(space? ',' space? arg:argument {return arg})* space? ','? {\n  return [first].concat(rest);\n }\n\nargument\n = name:argument_name space? '=' space? value:arg_type {\n  var arg = {\n   type: 'namedArg',\n   name: name,\n   value: value,\n   location: simpleLocation(location()),\n   text: text()\n  };\n  currentArgs.push(arg);\n  return arg;\n }\n / space? '=' space? value:arg_type? {\n  var exception = {\n   type: 'incompleteArgument',\n   currentArgs: currentArgs,\n   currentFunction: currentFunction,\n   location: simpleLocation(location()),\n   text: text()\n  }\n  error(JSON.stringify(exception));\n }\n / name:argument_name space? '=' {\n  var exception = {\n   type: 'incompleteArgumentValue',\n   currentArgs: currentArgs,\n   currentFunction: currentFunction,\n   name: name,\n   location: simpleLocation(location()),\n   text: text()\n  }\n  error(JSON.stringify(exception));\n }\n / element:arg_type {return element}\n\narg_type\n = variable_get\n / series_type\n / literal:literal {\n  var result = ltoo(literal);\n  result.location = simpleLocation(location()),\n  result.text = text();\n  return result;\n }\n\nvariable_get\n = '$' name:argument_name {\n  if (variables[name]) {\n   return variables[name];\n  } else {\n   error('$' + name + ' is not defined')\n  }\n }\n\nvariable_set\n = '$' name:argument_name space? '=' space? value:arg_type {\n  variables[name] = value;\n }\n\nseries_type\n = variable_set\n / variable_get\n / group\n / chain\n / reference\n\nseries\n = first:series_type rest:(space? ',' space? series:series_type {return series})* ','? {\n  return [first].concat(rest)\n }\n\nfunction_name\n = first:[a-zA-Z]+ rest:[.a-zA-Z0-9_-]* {\n  currentFunction = first.join('') + rest.join('');\n  currentArgs = [];\n  return currentFunction;\n}\n\nargument_name\n = first:[a-zA-Z]+ rest:[.a-zA-Z0-9_-]* { return first.join('') + rest.join('') }\n\nfunction \"function\"\n = space? '.' name:function_name space? '(' space? arg_list:arg_list? space? ')' space? {\n  var result = {\n    type: 'function',\n    function: name,\n    arguments: arg_list || [],\n    location: simpleLocation(location()),\n    text: text()\n  }\n\n  result.arguments.forEach(function (arg) {\n   arg.function = name;\n   args.push(arg);\n  })\n\n  functions.push(result)\n  return result;\n }\n / '.' func:function_name? {\n  var exception = {\n   type: 'incompleteFunction',\n   function: func,\n   location: simpleLocation(location()),\n   text: text()\n  }\n  error(JSON.stringify(exception));\n }\n\nreference\n = '@' plot:integer ':' series:integer {\n  return {\n   type: 'reference',\n   plot: plot,\n   series: series\n  }\n }\n / '@' plot:integer {\n  return {\n   type: 'reference',\n   plot: plot\n  }\n }\n\n\nchain\n = func:function space? rest:function* {return {type: 'chain', chain: [func].concat(rest)}}\n\ngroup\n = '(' space? grouped:series space? ')' functions:function* {\n  var first = {\n    type: 'chainList',\n    list: grouped\n  }\n  first.label = text();\n\n  return {type: \"chain\", chain: [first].concat(functions)};\n }\n\n /* ----- Core types ----- */\n\nliteral \"literal\"\n  =  '\"' chars:dq_char* '\"' { return chars.join(''); } // double quoted string\n  / \"'\" chars:sq_char* \"'\" { return chars.join(''); } // single quoted string\n  / 'true'  { return true; } // unquoted literals from here down\n  / 'false' { return false; }\n  / 'null'  { return null; }\n  / string:[^()\"',=\\ \\t]+ { // this also matches numbers via Number()\n   var result = string.join('');\n   // Sort of hacky, but PEG doesn't have backtracking so\n   // a number rule is hard to read, and performs worse\n   if (isNaN(Number(result))) return result;\n   return Number(result)\n  }\n\nspace\n = [\\ \\t\\r\\n]+\n\ndq_char\n  = \"\\\\\" sequence:('\"' / \"\\\\\") { return sequence; }\n  / [^\"] // everything except \"\n\nsq_char\n  = \"\\\\\" sequence:(\"'\" / \"\\\\\") { return sequence; }\n  / [^'] // everything except '\n\ninteger\n = digits:[0-9]+ {return parseInt(digits.join(''))}\n"

/***/ }),
/* 2934 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _timelion_expression_suggestions = __webpack_require__(2935);

var _timelion_expression_suggestions2 = _interopRequireDefault(_timelion_expression_suggestions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var app = __webpack_require__(2).get('apps/timelion', []);

app.directive('timelionExpressionSuggestions', function () {
  return {
    restrict: 'E',
    scope: {
      suggestions: '=',
      suggestionsType: '=',
      selectedIndex: '=',
      onClickSuggestion: '&',
      shouldPopover: '='
    },
    replace: true,
    template: _timelion_expression_suggestions2.default,
    link: function link(scope) {
      // This will prevent the expression input from losing focus.
      scope.onMouseDown = function (e) {
        return e.preventDefault();
      };
    }
  };
});

/***/ }),
/* 2935 */
/***/ (function(module, exports) {

module.exports = "<div\n  id=\"timelionSuggestionList\"\n  class=\"suggestions\"\n  role=\"listbox\"\n  ng-class=\"{ 'suggestions-isPopover': shouldPopover === 'true' }\"\n  data-suggestions-list\n>\n  <div\n    class=\"suggestion\"\n    id=\"timelionSuggestion{{$index}}\"\n    role=\"option\"\n    tabindex=\"0\"\n    data-suggestion-list-item\n    ng-class=\"{active: $index === selectedIndex}\"\n    ng-repeat=\"suggestion in suggestions track by suggestion.name\"\n    ng-mousedown=\"onMouseDown($event)\"\n    ng-click=\"onClickSuggestion({ suggestionIndex: $index })\"\n    aria-label=\"{{suggestion.name}}\"\n    aria-describedby=\"timelionSuggestionDescription{{$index}}\"\n    data-test-subj=\"timelionSuggestionListItem\"\n  >\n\n    <div ng-switch on=\"suggestionsType\">\n\n      <div ng-switch-when=\"functions\">\n        <h4>\n          <strong>.{{suggestion.name}}()</strong>\n          <small id=\"timelionSuggestionDescription{{$index}}\">\n            {{suggestion.help}}\n            {{suggestion.chainable ? '(Chainable)' : '(Data Source)'}}\n          </small>\n        </h4>\n\n        <div ng-show=\"suggestion.args.length > (suggestion.chainable ? 1: 0)\">\n          <div ng-show=\"suggestions.length > 1\">\n            <strong>Arguments:</strong>\n            <span ng-repeat=\"arg in suggestion.args\" ng-hide=\"$index < 1 && suggestion.chainable\">\n              <strong>{{arg.name}}</strong>=(<em>{{arg.types.join(' | ')}}</em>)\n              <em ng-show=\"!$last\">,</em>\n            </span>\n          </div>\n\n          <div class=\"suggestion-details\" ng-show=\"suggestions.length === 1\">\n            <table class=\"table table-striped table-condensed table-bordered\">\n            <thead>\n              <th scope=\"col\">Argument Name</th>\n              <th scope=\"col\">Accepted Types</th>\n              <th scope=\"col\">Information</th>\n            </thead>\n            <tr ng-repeat=\"arg in suggestion.args\" ng-hide=\"$index < 1 && suggestion.chainable\">\n              <td>{{arg.name}}</td>\n              <td><em>{{arg.types.join(', ')}}</em></td>\n              <td>{{arg.help}}</td>\n            </tr>\n            </table>\n          </div>\n        </div>\n      </div>\n\n      <div ng-switch-when=\"arguments\">\n        <h4>\n          <strong>{{suggestion.name}}=</strong>\n          <small id=\"timelionSuggestionDescription{{$index}}\">\n            {{suggestion.help}}\n          </small>\n        </h4>\n        <div>\n          <strong>Accepts:</strong>\n          <em>{{suggestion.types.join(', ')}}</em>\n        </div>\n      </div>\n\n      <div ng-switch-when=\"argument_value\">\n        <h4>\n          <strong>{{suggestion.name}}</strong>\n          <small id=\"timelionSuggestionDescription{{$index}}\">\n            {{suggestion.help}}\n          </small>\n        </h4>\n      </div>\n\n    </div>\n  </div>\n</div>\n"

/***/ }),
/* 2936 */
/***/ (function(module, exports) {

module.exports = "<div\n  class=\"timelionExpressionInputContainer\"\n  role=\"combobox\"\n  aria-expanded=\"{{suggestions.isVisible}}\"\n  aria-owns=\"timelionSuggestionList\"\n  aria-haspopup=\"true\"\n>\n  <!-- The `role=textbox` is required by VoiceOver to properly detect the autocompletion.\n       For some reasons it doesn't work without it (even though the default role of\n       the element is textbox anyway). -->\n  <textarea\n    data-expression-input\n    role=\"textbox\"\n    rows=\"{{ rows }}\"\n    class=\"timelionExpressionInput kuiTextArea fullWidth\"\n    placeholder=\"Try a query with .es(*)\"\n    ng-model=\"sheet\"\n    ng-focus=\"onFocusInput()\"\n    ng-keydown=\"onKeyDownInput($event)\"\n    ng-keyup=\"onKeyUpInput($event)\"\n    ng-blur=\"onBlurInput()\"\n    ng-mousedown=\"onMouseDownInput()\"\n    ng-mouseup=\"onMouseUpInput()\"\n    ng-click=\"onClickExpression()\"\n    aria-label=\"Timelion expression\"\n    aria-multiline=\"false\"\n    aria-autocomplete=\"list\"\n    aria-controls=\"timelionSuggestionList\"\n    aria-activedescendant=\"{{ getActiveSuggestionId() }}\"\n    data-test-subj=\"timelionExpressionTextArea\"\n  ></textarea>\n\n  <timelion-expression-suggestions\n    ng-show=\"suggestions.isVisible\"\n    suggestions=\"suggestions.list\"\n    suggestions-type=\"suggestions.type\"\n    selected-index=\"suggestions.index\"\n    on-click-suggestion=\"onClickSuggestion(suggestionIndex)\"\n    should-popover=\"shouldPopoverSuggestions\"\n  ></timelion-expression-suggestions>\n</div>\n"

/***/ }),
/* 2937 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.suggest = exports.Suggestions = exports.SUGGESTION_TYPE = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var extractSuggestionsFromParsedResult = function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(result, cursorPosition, functionList, argValueSuggestions) {
    var activeFunc, functionHelp, openParen, activeArg, functionName, functionArgs, argName, partialInput, valueSuggestions, _functionHelp$args$fi, staticSuggestions, argsHelp, argumentSuggestions, location;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            activeFunc = result.functions.find(function (func) {
              return cursorPosition >= func.location.min && cursorPosition < func.location.max;
            });

            if (activeFunc) {
              _context.next = 3;
              break;
            }

            return _context.abrupt('return');

          case 3:
            functionHelp = functionList.find(function (func) {
              return func.name === activeFunc.function;
            });

            // return function suggestion when cursor is outside of parentheses
            // location range includes '.', function name, and '('.

            openParen = activeFunc.location.min + activeFunc.function.length + 2;

            if (!(cursorPosition < openParen)) {
              _context.next = 7;
              break;
            }

            return _context.abrupt('return', { list: [functionHelp], location: activeFunc.location, type: SUGGESTION_TYPE.FUNCTIONS });

          case 7:

            // return argument value suggestions when cursor is inside agrument value
            activeArg = activeFunc.arguments.find(function (argument) {
              return inLocation(cursorPosition, argument.location);
            });

            if (!(activeArg && activeArg.type === 'namedArg' && inLocation(cursorPosition, activeArg.value.location))) {
              _context.next = 21;
              break;
            }

            functionName = activeFunc.function, functionArgs = activeFunc.arguments;
            argName = activeArg.name, partialInput = activeArg.value.text;
            valueSuggestions = void 0;

            if (!argValueSuggestions.hasDynamicSuggestionsForArgument(functionName, argName)) {
              _context.next = 18;
              break;
            }

            _context.next = 15;
            return argValueSuggestions.getDynamicSuggestionsForArgument(functionName, argName, functionArgs, partialInput);

          case 15:
            valueSuggestions = _context.sent;
            _context.next = 20;
            break;

          case 18:
            _functionHelp$args$fi = functionHelp.args.find(function (arg) {
              return arg.name === activeArg.name;
            }), staticSuggestions = _functionHelp$args$fi.suggestions;

            valueSuggestions = argValueSuggestions.getStaticSuggestionsForInput(partialInput, staticSuggestions);

          case 20:
            return _context.abrupt('return', { list: valueSuggestions, location: activeArg.value.location, type: SUGGESTION_TYPE.ARGUMENT_VALUE });

          case 21:

            // return argument suggestions
            argsHelp = getArgumentsHelp(functionHelp, activeFunc.arguments);
            argumentSuggestions = argsHelp.filter(function (arg) {
              if (_lodash2.default.get(activeArg, 'type') === 'namedArg') {
                return _lodash2.default.startsWith(arg.name, activeArg.name);
              } else if (activeArg) {
                return _lodash2.default.startsWith(arg.name, activeArg.text);
              }
              return true;
            });
            location = activeArg ? activeArg.location : { min: cursorPosition, max: cursorPosition };
            return _context.abrupt('return', { list: argumentSuggestions, location: location, type: SUGGESTION_TYPE.ARGUMENTS });

          case 25:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function extractSuggestionsFromParsedResult(_x2, _x3, _x4, _x5) {
    return _ref.apply(this, arguments);
  };
}();

var suggest = exports.suggest = function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(expression, functionList, Parser, cursorPosition, argValueSuggestions) {
    var result, message, list, _message, functionName, functionArgs, functionHelp, _message2, argName, _functionName, _functionArgs, valueSuggestions, _functionHelp, argHelp;

    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return Parser.parse(expression);

          case 3:
            result = _context2.sent;
            _context2.next = 6;
            return extractSuggestionsFromParsedResult(result, cursorPosition, functionList, argValueSuggestions);

          case 6:
            return _context2.abrupt('return', _context2.sent);

          case 9:
            _context2.prev = 9;
            _context2.t0 = _context2['catch'](0);
            message = void 0;
            _context2.prev = 12;

            // The grammar will throw an error containing a message if the expression is formatted
            // correctly and is prepared to accept suggestions. If the expression is not formmated
            // correctly the grammar will just throw a regular PEG SyntaxError, and this JSON.parse
            // attempt will throw an error.
            message = JSON.parse(_context2.t0.message);
            _context2.next = 19;
            break;

          case 16:
            _context2.prev = 16;
            _context2.t1 = _context2['catch'](12);
            return _context2.abrupt('return');

          case 19:
            _context2.t2 = message.type;
            _context2.next = _context2.t2 === 'incompleteFunction' ? 22 : _context2.t2 === 'incompleteArgument' ? 25 : _context2.t2 === 'incompleteArgumentValue' ? 28 : 39;
            break;

          case 22:
            list = void 0;

            if (message.function) {
              // The user has start typing a function name, so we'll filter the list down to only
              // possible matches.
              list = functionList.filter(function (func) {
                return _lodash2.default.startsWith(func.name, message.function);
              });
            } else {
              // The user hasn't typed anything yet, so we'll just return the entire list.
              list = functionList;
            }
            return _context2.abrupt('return', { list: list, location: message.location, type: SUGGESTION_TYPE.FUNCTIONS });

          case 25:
            _message = message, functionName = _message.currentFunction, functionArgs = _message.currentArgs;
            functionHelp = functionList.find(function (func) {
              return func.name === functionName;
            });
            return _context2.abrupt('return', {
              list: getArgumentsHelp(functionHelp, functionArgs),
              location: message.location,
              type: SUGGESTION_TYPE.ARGUMENTS
            });

          case 28:
            _message2 = message, argName = _message2.name, _functionName = _message2.currentFunction, _functionArgs = _message2.currentArgs;
            valueSuggestions = [];

            if (!argValueSuggestions.hasDynamicSuggestionsForArgument(_functionName, argName)) {
              _context2.next = 36;
              break;
            }

            _context2.next = 33;
            return argValueSuggestions.getDynamicSuggestionsForArgument(_functionName, argName, _functionArgs);

          case 33:
            valueSuggestions = _context2.sent;
            _context2.next = 38;
            break;

          case 36:
            _functionHelp = functionList.find(function (func) {
              return func.name === _functionName;
            });

            if (_functionHelp) {
              argHelp = _functionHelp.args.find(function (arg) {
                return arg.name === argName;
              });

              if (argHelp && argHelp.suggestions) {
                valueSuggestions = argHelp.suggestions;
              }
            }

          case 38:
            return _context2.abrupt('return', {
              list: valueSuggestions,
              location: { min: cursorPosition, max: cursorPosition },
              type: SUGGESTION_TYPE.ARGUMENT_VALUE
            });

          case 39:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, this, [[0, 9], [12, 16]]);
  }));

  return function suggest(_x6, _x7, _x8, _x9, _x10) {
    return _ref2.apply(this, arguments);
  };
}();

exports.insertAtLocation = insertAtLocation;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SUGGESTION_TYPE = exports.SUGGESTION_TYPE = {
  ARGUMENTS: 'arguments',
  ARGUMENT_VALUE: 'argument_value',
  FUNCTIONS: 'functions'
};

var Suggestions = exports.Suggestions = function () {
  function Suggestions() {
    _classCallCheck(this, Suggestions);

    this.reset();
  }

  _createClass(Suggestions, [{
    key: 'reset',
    value: function reset() {
      this.index = -1;
      this.list = [];
      this.type = null;
      this.isVisible = false;
    }
  }, {
    key: 'setList',
    value: function setList(list, type) {
      this.list = list.sort(function (a, b) {
        if (a.name < b.name) {
          return -1;
        }
        if (a.name > b.name) {
          return 1;
        }
        // names must be equal
        return 0;
      });
      this.type = type;

      // Only try to position index inside of list range, when it was already focused
      // beforehand (i.e. not -1)
      if (this.index > -1) {
        // We may get a shorter list than the one we have now, so we need to make sure our index doesn't
        // fall outside of the new list's range.
        this.index = Math.max(0, Math.min(this.index, this.list.length - 1));
      }
    }
  }, {
    key: 'getCount',
    value: function getCount() {
      return this.list.length;
    }
  }, {
    key: 'isEmpty',
    value: function isEmpty() {
      return this.list.length === 0;
    }
  }, {
    key: 'show',
    value: function show() {
      this.isVisible = true;
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.isVisible = false;
    }
  }, {
    key: 'stepForward',
    value: function stepForward() {
      if (this.index > 0) {
        this.index -= 1;
      }
    }
  }, {
    key: 'stepBackward',
    value: function stepBackward() {
      if (this.index < this.list.length - 1) {
        this.index += 1;
      }
    }
  }]);

  return Suggestions;
}();

function inLocation(cursorPosition, location) {
  return cursorPosition >= location.min && cursorPosition <= location.max;
}

function getArgumentsHelp(functionHelp) {
  var functionArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  if (!functionHelp) {
    return [];
  }

  // Do not provide 'inputSeries' as argument suggestion for chainable functions
  var argsHelp = functionHelp.chainable ? functionHelp.args.slice(1) : functionHelp.args.slice(0);

  // ignore arguments that are already provided in function declaration
  var functionArgNames = functionArgs.map(function (arg) {
    return arg.name;
  });
  return argsHelp.filter(function (arg) {
    return !functionArgNames.includes(arg.name);
  });
}

function insertAtLocation(valueToInsert, destination, replacementRangeStart, replacementRangeEnd) {
  // Insert the value at a location caret within the destination.
  var prefix = destination.slice(0, replacementRangeStart);
  var suffix = destination.slice(replacementRangeEnd, destination.length);
  var result = '' + prefix + valueToInsert + suffix;
  return result;
}

/***/ }),
/* 2938 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArgValueSuggestionsProvider = ArgValueSuggestionsProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _saved_objects = __webpack_require__(76);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function ArgValueSuggestionsProvider(Private, indexPatterns) {
  var _this = this;

  var getIndexPattern = function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(functionArgs) {
      var indexPatternArg, indexPatternTitle, resp, indexPatternSavedObject;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              indexPatternArg = functionArgs.find(function (argument) {
                return argument.name === 'index';
              });

              if (indexPatternArg) {
                _context.next = 3;
                break;
              }

              return _context.abrupt('return');

            case 3:
              indexPatternTitle = _lodash2.default.get(indexPatternArg, 'value.text');
              _context.next = 6;
              return savedObjectsClient.find({
                type: 'index-pattern',
                fields: ['title'],
                search: '"' + indexPatternTitle + '"',
                search_fields: ['title'],
                perPage: 10
              });

            case 6:
              resp = _context.sent;
              indexPatternSavedObject = resp.savedObjects.find(function (savedObject) {
                return savedObject.attributes.title === indexPatternTitle;
              });

              if (indexPatternSavedObject) {
                _context.next = 10;
                break;
              }

              return _context.abrupt('return');

            case 10:
              _context.next = 12;
              return indexPatterns.get(indexPatternSavedObject.id);

            case 12:
              return _context.abrupt('return', _context.sent);

            case 13:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    return function getIndexPattern(_x) {
      return _ref.apply(this, arguments);
    };
  }();

  var savedObjectsClient = Private(_saved_objects.SavedObjectsClientProvider);

  function containsFieldName(partial, field) {
    if (!partial) {
      return true;
    }
    return field.name.includes(partial);
  }

  // Argument value suggestion handlers requiring custom client side code
  // Could not put with function definition since functions are defined on server
  var customHandlers = {
    es: {
      index: function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(partial) {
          var search, resp;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  search = partial ? partial + '*' : '*';
                  _context2.next = 3;
                  return savedObjectsClient.find({
                    type: 'index-pattern',
                    fields: ['title'],
                    search: '' + search,
                    search_fields: ['title'],
                    perPage: 25
                  });

                case 3:
                  resp = _context2.sent;
                  return _context2.abrupt('return', resp.savedObjects.map(function (savedObject) {
                    return { name: savedObject.attributes.title };
                  }));

                case 5:
                case 'end':
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function index(_x2) {
          return _ref2.apply(this, arguments);
        }

        return index;
      }(),
      metric: function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(partial, functionArgs) {
          var indexPattern, valueSplit;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  if (!(!partial || !partial.includes(':'))) {
                    _context3.next = 2;
                    break;
                  }

                  return _context3.abrupt('return', [{ name: 'avg:' }, { name: 'cardinality:' }, { name: 'count' }, { name: 'max:' }, { name: 'min:' }, { name: 'percentiles:' }, { name: 'sum:' }]);

                case 2:
                  _context3.next = 4;
                  return getIndexPattern(functionArgs);

                case 4:
                  indexPattern = _context3.sent;

                  if (indexPattern) {
                    _context3.next = 7;
                    break;
                  }

                  return _context3.abrupt('return', []);

                case 7:
                  valueSplit = partial.split(':');
                  return _context3.abrupt('return', indexPattern.fields.filter(function (field) {
                    return field.aggregatable && 'number' === field.type && containsFieldName(valueSplit[1], field);
                  }).map(function (field) {
                    return { name: valueSplit[0] + ':' + field.name, help: field.type };
                  }));

                case 9:
                case 'end':
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function metric(_x3, _x4) {
          return _ref3.apply(this, arguments);
        }

        return metric;
      }(),
      split: function () {
        var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(partial, functionArgs) {
          var indexPattern;
          return regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.next = 2;
                  return getIndexPattern(functionArgs);

                case 2:
                  indexPattern = _context4.sent;

                  if (indexPattern) {
                    _context4.next = 5;
                    break;
                  }

                  return _context4.abrupt('return', []);

                case 5:
                  return _context4.abrupt('return', indexPattern.fields.filter(function (field) {
                    return field.aggregatable && ['number', 'boolean', 'date', 'ip', 'string'].includes(field.type) && containsFieldName(partial, field);
                  }).map(function (field) {
                    return { name: field.name, help: field.type };
                  }));

                case 6:
                case 'end':
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function split(_x5, _x6) {
          return _ref4.apply(this, arguments);
        }

        return split;
      }(),
      timefield: function () {
        var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(partial, functionArgs) {
          var indexPattern;
          return regeneratorRuntime.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.next = 2;
                  return getIndexPattern(functionArgs);

                case 2:
                  indexPattern = _context5.sent;

                  if (indexPattern) {
                    _context5.next = 5;
                    break;
                  }

                  return _context5.abrupt('return', []);

                case 5:
                  return _context5.abrupt('return', indexPattern.fields.filter(function (field) {
                    return 'date' === field.type && containsFieldName(partial, field);
                  }).map(function (field) {
                    return { name: field.name };
                  }));

                case 6:
                case 'end':
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }));

        function timefield(_x7, _x8) {
          return _ref5.apply(this, arguments);
        }

        return timefield;
      }()
    }
  };

  return {
    /**
     * @param {string} functionName - user provided function name containing argument
     * @param {string} argName - user provided argument name
     * @return {boolean} true when dynamic suggestion handler provided for function argument
     */
    hasDynamicSuggestionsForArgument: function hasDynamicSuggestionsForArgument(functionName, argName) {
      return customHandlers[functionName] && customHandlers[functionName][argName];
    },

    /**
     * @param {string} functionName - user provided function name containing argument
     * @param {string} argName - user provided argument name
     * @param {object} functionArgs - user provided function arguments parsed ahead of current argument
     * @param {string} partial - user provided argument value
     * @return {array} array of dynamic suggestions matching partial
     */
    getDynamicSuggestionsForArgument: function () {
      var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(functionName, argName, functionArgs) {
        var partialInput = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return customHandlers[functionName][argName](partialInput, functionArgs);

              case 2:
                return _context6.abrupt('return', _context6.sent);

              case 3:
              case 'end':
                return _context6.stop();
            }
          }
        }, _callee6, _this);
      }));

      function getDynamicSuggestionsForArgument(_x10, _x11, _x12) {
        return _ref6.apply(this, arguments);
      }

      return getDynamicSuggestionsForArgument;
    }(),

    /**
     * @param {string} partial - user provided argument value
     * @param {array} staticSuggestions - arugment value suggestions
     * @return {array} array of static suggestions matching partial
     */
    getStaticSuggestionsForInput: function getStaticSuggestionsForInput() {
      var partialInput = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var staticSuggestions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      if (partialInput) {
        return staticSuggestions.filter(function (suggestion) {
          return suggestion.name.includes(partialInput);
        });
      }

      return staticSuggestions;
    }
  };
}

/***/ }),
/* 2939 */,
/* 2940 */,
/* 2941 */
/***/ (function(module, exports) {

module.exports = "<input\n  input-focus\n  aria-label=\"Custom interval\"\n  class=\"kuiTextInput timelion-interval-custom\"\n  ng-show=\"interval === 'other'\"\n  ng-class=\"{ 'timelion-interval-custom-compact': interval === 'other' }\"\n  ng-model=\"otherInterval\"\n><select\n  id=\"timelionInterval\"\n  aria-label=\"Select interval\"\n  class=\"kuiSelect timelion-interval-presets\"\n  ng-class=\"{ 'timelion-interval-presets-compact': interval === 'other'}\"\n  ng-model=\"interval\"\n>\n  <option\n    ng-repeat=\"intervalOption in intervalOptions\"\n    aria-label=\"{{::intervalLabels[intervalOption]}}\"\n    value=\"{{::intervalOption}}\"\n  >\n      {{::intervalOption}}\n  </option>\n</select>\n"

/***/ }),
/* 2942 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 2943 */,
/* 2944 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Scanner = undefined;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _chrome = __webpack_require__(17);

var _chrome2 = _interopRequireDefault(_chrome);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Scanner = exports.Scanner = function Scanner($http) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      index = _ref.index,
      type = _ref.type;

  if (!index) throw new Error('Expected index');
  if (!type) throw new Error('Expected type');
  if (!$http) throw new Error('Expected $http');

  this.$http = $http;
  this.index = index;
  this.type = type;
};

Scanner.prototype.start = function (searchBody) {
  var addBasePath = _chrome2.default.addBasePath;

  var scrollStartPath = addBasePath('/api/kibana/legacy_scroll_start');
  return this.$http.post(scrollStartPath, searchBody);
};

Scanner.prototype.continue = function (scrollId) {
  var addBasePath = _chrome2.default.addBasePath;

  var scrollContinuePath = addBasePath('/api/kibana/legacy_scroll_continue');
  return this.$http.post(scrollContinuePath, { scrollId: scrollId });
};

Scanner.prototype.scanAndMap = function (searchString, options, mapFn) {
  var _this = this;

  var bool = { must: [], filter: [] };

  var scrollId = void 0;
  var allResults = {
    hits: [],
    total: 0
  };
  var opts = _lodash2.default.defaults(options || {}, {
    pageSize: 100,
    docCount: 1000
  });

  if (this.type) {
    bool.filter.push({
      bool: {
        should: [{
          term: {
            _type: this.type
          }
        }, {
          term: {
            type: this.type
          }
        }]
      }
    });
  }

  if (searchString) {
    bool.must.push({
      simple_query_string: {
        query: searchString + '*',
        fields: ['title^3', 'description'],
        default_operator: 'AND'
      }
    });
  } else {
    bool.must.push({
      match_all: {}
    });
  }

  return new Promise(function (resolve, reject) {
    var getMoreUntilDone = function getMoreUntilDone(error, response) {
      if (error) {
        reject(error);
        return;
      }
      var scanAllResults = opts.docCount === Infinity;
      allResults.total = scanAllResults ? response.hits.total : Math.min(response.hits.total, opts.docCount);
      scrollId = response._scroll_id || scrollId;

      var hits = response.hits.hits.slice(0, allResults.total - allResults.hits.length);

      hits = hits.map(function (hit) {
        if (hit._type === 'doc') {
          return {
            _id: hit._id.replace(_this.type + ':', ''),
            _type: _this.type,
            _source: hit._source[_this.type],
            _meta: {
              savedObjectVersion: 2
            }
          };
        }

        return _lodash2.default.pick(hit, ['_id', '_type', '_source']);
      });

      if (mapFn) hits = hits.map(mapFn);

      allResults.hits = allResults.hits.concat(hits);

      var collectedAllResults = allResults.total === allResults.hits.length;
      if (collectedAllResults) {
        resolve(allResults);
      } else {
        _this.continue(scrollId).then(function (response) {
          return getMoreUntilDone(null, response.data);
        }).catch(function (error) {
          return getMoreUntilDone(error);
        });
      }
    };

    var searchBody = {
      index: _this.index,
      size: opts.pageSize,
      body: { query: { bool: bool } }
    };
    _this.start(searchBody).then(function (response) {
      return getMoreUntilDone(null, response.data);
    }).catch(function (error) {
      return getMoreUntilDone(error);
    });
  });
};

/***/ }),
/* 2945 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var StringUtils = exports.StringUtils = function () {
  function StringUtils() {
    _classCallCheck(this, StringUtils);
  }

  _createClass(StringUtils, null, [{
    key: 'upperFirst',


    /**
     * Returns a version of the string with the first letter capitalized.
     * @param str {string}
     * @returns {string}
     */
    value: function upperFirst(str) {
      return str ? str.charAt(0).toUpperCase() + str.slice(1) : '';
    }
  }]);

  return StringUtils;
}();

/***/ }),
/* 2946 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.AngularVisTypeProvider = AngularVisTypeProvider;

var _vis_types = __webpack_require__(525);

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function AngularVisTypeProvider(Private, $compile, $rootScope) {
  var VisType = Private(_vis_types.VisTypeProvider);

  var AngularVisController = function () {
    function AngularVisController(domeElement, vis) {
      _classCallCheck(this, AngularVisController);

      this.el = (0, _jquery2.default)(domeElement);
      this.vis = vis;
    }

    _createClass(AngularVisController, [{
      key: 'render',
      value: function render(esResponse) {
        var _this = this;

        return new Promise(function (resolve, reject) {
          var updateScope = function updateScope() {
            _this.$scope.vis = _this.vis;
            _this.$scope.esResponse = esResponse;
            _this.$scope.renderComplete = resolve;
            _this.$scope.renderFailed = reject;
            _this.$scope.resize = Date.now();
            _this.$scope.$apply();
          };

          if (!_this.$scope) {
            _this.$scope = $rootScope.$new();
            updateScope();
            _this.$scope.uiState = _this.vis.getUiState();
            _this.el.html($compile(_this.vis.type.visConfig.template)(_this.$scope));
          } else {
            updateScope();
          }
        });
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        if (this.$scope) {
          this.$scope.$destroy();
          this.$scope = null;
        }
      }
    }]);

    return AngularVisController;
  }();

  var AngularVisType = function (_VisType) {
    _inherits(AngularVisType, _VisType);

    function AngularVisType(opts) {
      _classCallCheck(this, AngularVisType);

      opts.visualization = AngularVisController;

      var _this2 = _possibleConstructorReturn(this, (AngularVisType.__proto__ || Object.getPrototypeOf(AngularVisType)).call(this, opts));

      _this2.visConfig.template = opts.visConfig ? opts.visConfig.template : opts.template;
      if (!_this2.visConfig.template) {
        throw new Error('Missing template for AngularVisType');
      }
      return _this2;
    }

    return AngularVisType;
  }(VisType);

  return AngularVisType;
}

/***/ }),
/* 2947 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.VislibVisTypeProvider = VislibVisTypeProvider;

__webpack_require__(526);

__webpack_require__(2949);

__webpack_require__(2951);

__webpack_require__(2953);

__webpack_require__(2955);

__webpack_require__(2957);

var _base_vis_type = __webpack_require__(930);

var _point_series = __webpack_require__(931);

var _vislib = __webpack_require__(529);

var _vislib2 = _interopRequireDefault(_vislib);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function VislibVisTypeProvider(Private) {
  var VisType = Private(_base_vis_type.VisTypeProvider);
  var pointSeries = Private(_point_series.AggResponsePointSeriesProvider);
  var vislib = Private(_vislib2.default);

  var VislibVisController = function () {
    function VislibVisController(el, vis) {
      _classCallCheck(this, VislibVisController);

      this.el = el;
      this.vis = vis;
    }

    _createClass(VislibVisController, [{
      key: 'render',
      value: function render(esResponse) {
        var _this = this;

        this._response = esResponse;
        if (this.vis.vislibVis) {
          this.destroy();
        } else {
          this.vis.refreshLegend = 0;
        }

        return new Promise(function (resolve, reject) {
          if (!_this._response) return reject();
          _this.vis.vislibVis = new vislib.Vis(_this.el, _this.vis.params);
          _this.vis.vislibVis.on('brush', _this.vis.API.events.brush);
          _this.vis.vislibVis.on('click', _this.vis.API.events.filter);
          _this.vis.vislibVis.on('renderComplete', resolve);
          _this.vis.vislibVis.render(esResponse, _this.vis.getUiState());
        });
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        if (this.vis.vislibVis) {
          this.vis.vislibVis.off('brush', this.vis.API.events.brush);
          this.vis.vislibVis.off('click', this.vis.API.events.filter);
          this.vis.vislibVis.destroy();
          delete this.vis.vislibVis;
        }
      }
    }]);

    return VislibVisController;
  }();

  var VislibVisType = function (_VisType) {
    _inherits(VislibVisType, _VisType);

    function VislibVisType(opts) {
      _classCallCheck(this, VislibVisType);

      if (!opts.responseHandler) {
        opts.responseHandler = 'basic';
      }
      if (!opts.responseConverter) {
        opts.responseConverter = pointSeries;
      }
      opts.visualization = VislibVisController;

      var _this2 = _possibleConstructorReturn(this, (VislibVisType.__proto__ || Object.getPrototypeOf(VislibVisType)).call(this, opts));

      _this2.refreshLegend = 0;
      return _this2;
    }

    return VislibVisType;
  }(VisType);

  return VislibVisType;
}

/***/ }),
/* 2948 */
/***/ (function(module, exports) {

module.exports = "<div class=\"form-group\">\n  <div class=\"kuiSideBarFormRow\">\n    <label class=\"kuiSideBarFormRow__label\" for=\"visualizeBasicSettingsLegendPosition\">\n      Legend Position\n    </label>\n    <div class=\"kuiSideBarFormRow__control\">\n      <select\n        id=\"visualizeBasicSettingsLegendPosition\"\n        class=\"form-control\"\n        ng-model=\"vis.params.legendPosition\"\n        ng-options=\"position.value as position.text for position in vis.type.editorConfig.collections.legendPositions\"\n      >\n      </select>\n    </div>\n  </div>\n\n  <div class=\"kuiSideBarFormRow\">\n    <label class=\"kuiSideBarFormRow__label\" for=\"showTooltip\">\n      Show Tooltip\n    </label>\n    <div class=\"kuiSideBarFormRow__control\">\n      <input id=\"showTooltip\" type=\"checkbox\" ng-model=\"vis.params.addTooltip\">\n    </div>\n  </div>\n</div>\n"

/***/ }),
/* 2949 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(487);

var _modules = __webpack_require__(2);

var _point_series_options = __webpack_require__(2950);

var _point_series_options2 = _interopRequireDefault(_point_series_options);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');

_module.directive('pointSeriesOptions', function () {
  return {
    restrict: 'E',
    template: _point_series_options2.default,
    replace: true
  };
});

/***/ }),
/* 2950 */
/***/ (function(module, exports) {

module.exports = "<div>\n  <div class=\"vis-option-item\" ng-show=\"vis.hasSchemaAgg('segment', 'date_histogram')\">\n    <label>\n      <input type=\"checkbox\" ng-model=\"vis.params.addTimeMarker\" ng-checked=\"vis.params.addTimeMarker\">\n      Current time marker\n    </label>\n  </div>\n  <div class=\"vis-option-item\">\n    <label>\n      <input type=\"checkbox\" ng-model=\"vis.params.setYExtents\">\n      Set Y-Axis Extents\n    </label>\n    <div ng-if=\"vis.params.setYExtents\">\n      <label>\n        y-max\n        <input name=\"yMax\"\n               class=\"form-control\"\n               type=\"number\"\n               step=\"0.1\"\n               greater-than=\"{{vis.params.yAxis.min}}\"\n               ng-model=\"vis.params.yAxis.max\"\n               ng-required=\"vis.params.setYExtents\">\n      </label>\n      <div ng-show=\"vis.params.yAxis.min >= vis.params.yAxis.max\">\n        <span class=\"text-danger\">Max must be greater than min</span>\n      </div>\n      <label>\n        y-min\n        <input name=\"yMin\"\n               class=\"form-control\"\n               type=\"number\"\n               step=\"0.1\"\n               less-than=\"{{vis.params.yAxis.max}}\"\n               greater-than=\"{{vis.params.scale === 'log' ? 0 : ''}}\"\n               ng-model=\"vis.params.yAxis.min\"\n               ng-required=\"vis.params.setYExtents\">\n      </label>\n    </div>\n    <div ng-show=\"vis.params.setYExtents && vis.params.scale === 'log' && vis.params.yAxis.min <= 0\">\n      <span class=\"text-danger\">Min must exceed 0 when a log scale is selected</span>\n    </div>\n    <div class=\"vis-option-item\">\n      <label>\n        <input type=\"checkbox\" ng-model=\"vis.params.defaultYExtents\" ng-disabled=\"vis.params.setYExtents\">\n        Scale Y-Axis to Data Bounds\n      </label>\n    </div>\n    <div class=\"vis-option-item\">\n      <label>\n        <input type=\"checkbox\" ng-model=\"vis.params.orderBucketsBySum\">\n        Order buckets by descending sum\n      </label>\n    </div>\n  </div>\n</div>\n"

/***/ }),
/* 2951 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _line_interpolation_option = __webpack_require__(2952);

var _line_interpolation_option2 = _interopRequireDefault(_line_interpolation_option);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');

_module.directive('lineInterpolationOption', function () {
  return {
    restrict: 'E',
    template: _line_interpolation_option2.default,
    replace: true
  };
});

/***/ }),
/* 2952 */
/***/ (function(module, exports) {

module.exports = "<div>\n  <label>\n    Line Mode\n  </label>\n  <select\n    class=\"form-control\"\n    ng-model=\"vis.params.interpolate\"\n    ng-options=\"mode.value as mode.text for mode in vis.type.params.interpolationModes\"\n  >\n  </select>\n</div>\n"

/***/ }),
/* 2953 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _heatmap_options = __webpack_require__(2954);

var _heatmap_options2 = _interopRequireDefault(_heatmap_options);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');

_module.directive('heatmapOptions', function () {
  return {
    restrict: 'E',
    template: _heatmap_options2.default,
    replace: true,
    link: function link($scope) {

      $scope.collections = $scope.vis.type.editorConfig.collections;

      var verticalRotation = 270;
      $scope.showColorRange = false;
      $scope.showLabels = false;
      $scope.customColors = false;
      $scope.valueAxis = $scope.vis.params.valueAxes[0];
      $scope.options = {
        rotateLabels: $scope.valueAxis.labels.rotate === verticalRotation
      };

      $scope.$watch('options.rotateLabels', function (rotate) {
        $scope.vis.params.valueAxes[0].labels.rotate = rotate ? verticalRotation : 0;
      });

      $scope.resetColors = function () {
        $scope.uiState.set('vis.colors', null);
        $scope.customColors = false;
      };

      $scope.toggleColorRangeSection = function () {
        var checkbox = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        $scope.showColorRange = !$scope.showColorRange;
        if (checkbox && !$scope.vis.params.setColorRange) $scope.showColorRange = false;
        if (!checkbox && $scope.showColorRange && !$scope.vis.params.setColorRange) $scope.vis.params.setColorRange = true;
      };

      $scope.toggleLabelSection = function () {
        var checkbox = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        $scope.showLabels = !$scope.showLabels;
        if (checkbox && !$scope.valueAxis.labels.show) $scope.showLabels = false;
        if ($scope.showLabels && !$scope.valueAxis.labels.show) {
          $scope.vis.params.valueAxes[0].labels.show = true;
        }
      };

      $scope.getGreaterThan = function (index) {
        if (index === 0) return;
        return $scope.vis.params.colorsRange[index - 1].to;
      };

      $scope.addRange = function () {
        var previousRange = _lodash2.default.last($scope.vis.params.colorsRange);
        var from = previousRange ? previousRange.to : 0;
        $scope.vis.params.colorsRange.push({ from: from, to: null });
      };

      $scope.removeRange = function (index) {
        $scope.vis.params.colorsRange.splice(index, 1);
      };

      $scope.getColor = function (index) {
        var defaultColors = this.uiState.get('vis.defaultColors');
        var overwriteColors = this.uiState.get('vis.colors');
        var colors = defaultColors ? _lodash2.default.defaults({}, overwriteColors, defaultColors) : overwriteColors;
        return colors ? Object.values(colors)[index] : 'transparent';
      };

      $scope.uiState.on('colorChanged', function () {
        $scope.customColors = true;
      });
    }
  };
});

/***/ }),
/* 2954 */
/***/ (function(module, exports) {

module.exports = "<div>\n  <div class=\"kuiSideBarFormRow\">\n    <label class=\"kuiSideBarFormRow__label\" for=\"colorSchema\">\n      Color Schema\n    </label>\n    <div class=\"kuiSideBarFormRow__control\">\n      <select\n        id=\"colorSchema\"\n        class=\"kuiSelect kuiSideBarSelect\"\n        ng-model=\"vis.params.colorSchema\"\n        ng-options=\"mode for mode in collections.colorSchemas\"\n      ></select>\n    </div>\n    <div\n      class=\"text-info text-center\"\n      ng-show=\"customColors\"\n      ng-click=\"resetColors()\"\n      kbn-accessible-click\n    >\n      reset colors\n    </div>\n  </div>\n\n  <div class=\"kuiSideBarFormRow\">\n    <label class=\"kuiSideBarFormRow__label\" for=\"invertColors\">\n      Reverse Color Schema\n    </label>\n    <div class=\"kuiSideBarFormRow__control\">\n      <input class=\"kuiCheckBox\" id=\"invertColors\" type=\"checkbox\" ng-model=\"vis.params.invertColors\">\n    </div>\n  </div>\n\n  <div class=\"kuiSideBarFormRow\">\n    <label class=\"kuiSideBarFormRow__label\" for=\"axisScale\">\n      Color Scale\n    </label>\n    <div class=\"kuiSideBarFormRow__control\">\n      <select\n        id=\"axisScale\"\n        class=\"kuiSelect kuiSideBarSelect\"\n        ng-model=\"vis.params.valueAxes[0].scale.type\"\n        ng-options=\"mode for mode in collections.scales\"\n      ></select>\n    </div>\n  </div>\n\n  <div class=\"kuiSideBarFormRow\">\n    <label class=\"kuiSideBarFormRow__label\" for=\"defaultYExtents\">\n      Scale to Data Bounds\n    </label>\n    <div class=\"kuiSideBarFormRow__control\">\n      <input class=\"kuiCheckBox\" id=\"defaultYExtents\" type=\"checkbox\" ng-model=\"vis.params.valueAxes[0].scale.defaultYExtents\">\n    </div>\n  </div>\n\n  <div class=\"kuiSideBarFormRow\" ng-if=\"!vis.params.setColorRange\">\n    <label class=\"kuiSideBarFormRow__label\" for=\"percentageMode\">\n      Percentage Mode\n    </label>\n    <div class=\"kuiSideBarFormRow__control\">\n      <input class=\"kuiCheckBox\" id=\"percentageMode\" type=\"checkbox\" ng-model=\"vis.params.percentageMode\">\n    </div>\n  </div>\n\n  <div class=\"kuiSideBarFormRow\" ng-if=\"!vis.params.setColorRange\">\n    <label class=\"kuiSideBarFormRow__label\" for=\"colorsNumber\">\n      Number of colors\n    </label>\n    <div class=\"kuiSideBarFormRow__control\">\n      <input\n        id=\"colorsNumber\"\n        class=\"kuiSideBarInput\"\n        ng-model=\"vis.params.colorsNumber\"\n        type=\"number\"\n        greater-than=\"1\"\n        less-than=\"11\"\n      >\n    </div>\n  </div>\n\n  <div>\n    <div class=\"kuiSideBarCollapsibleTitle\">\n      <div\n        class=\"kuiSideBarCollapsibleTitle__label\"\n        ng-click=\"toggleColorRangeSection()\"\n        kbn-accessible-click\n        aria-expanded=\"{{!!showColorRange}}\"\n        aria-controls=\"heatmapOptionsRanges\"\n        aria-label=\"Toggle custom ranges options\"\n      >\n        <span\n          aria-hidden=\"true\"\n          ng-class=\"{ 'fa-caret-down': showColorRange, 'fa-caret-right': !showColorRange }\"\n          class=\"kuiIcon fa-caret-right kuiSideBarCollapsibleTitle__caret\"\n        ></span>\n        <span class=\"kuiSideBarCollapsibleTitle__text\">\n          Custom Ranges\n        </span>\n      </div>\n      <input\n        aria-label=\"Enable custom ranges\"\n        ng-model=\"vis.params.setColorRange\"\n        type=\"checkbox\"\n        class=\"kuiSideBarSectionTitle__action\"\n        ng-click=\"toggleColorRangeSection(true)\"\n        kbn-accessible-click\n      >\n    </div>\n\n    <div\n      id=\"heatmapOptionsRanges\"\n      ng-if=\"vis.params.setColorRange\"\n      ng-show=\"showColorRange\"\n      class=\"kuiSideBarCollapsibleSection\"\n    >\n      <div class=\"kuiSideBarSection\">\n        <table class=\"vis-editor-agg-editor-ranges form-group\" ng-show=\"vis.params.colorsRange.length\">\n          <tr>\n            <th scope=\"col\">\n              <label id=\"heatmapCustomRangeFrom\">From</label>\n            </th>\n            <th scope=\"col\" colspan=\"2\">\n              <label id=\"heatmapCustomRangeTo\">To</label>\n            </th>\n          </tr>\n\n          <tr ng-repeat=\"range in vis.params.colorsRange track by $index\">\n            <td>\n              <input\n                aria-labelledby=\"heatmapCustomRangeFrom\"\n                ng-model=\"range.from\"\n                type=\"number\"\n                class=\"form-control\"\n                name=\"range.from\"\n                greater-or-equal-than=\"{{getGreaterThan($index)}}\"\n                step=\"any\" />\n            </td>\n            <td>\n              <input\n                aria-labelledby=\"heatmapCustomRangeTo\"\n                ng-model=\"range.to\"\n                type=\"number\"\n                class=\"form-control\"\n                name=\"range.to\"\n                greater-than=\"range.from\"\n                step=\"any\" />\n            </td>\n            <td>\n              <button\n                type=\"button\"\n                ng-click=\"removeRange($index)\"\n                class=\"kuiButton kuiButton--danger kuiButton--small\"\n              >\n                <span class=\"kuiIcon fa-times\"></span>\n              </button>\n            </td>\n          </tr>\n        </table>\n\n        <div class=\"hintbox\" ng-show=\"!vis.params.colorsRange.length\">\n          <p>\n            <span class=\"kuiIcon fa-danger text-danger\"></span>\n            <strong>Required:</strong> You must specify at least one range.\n          </p>\n        </div>\n\n        <button\n          ng-click=\"addRange()\"\n          class=\"kuiButton kuiButton--primary kuiButton--fullWidth\"\n        >\n          Add Range\n        </button>\n        <div class=\"euiSpacer euiSpacer--s\"></div>\n        <div class=\"text text-center text-info\">Note: colors can be changed in the legend</div>\n      </div>\n    </div>\n  </div>\n  <div>\n    <div class=\"kuiSideBarCollapsibleTitle\">\n      <div\n        class=\"kuiSideBarCollapsibleTitle__label\"\n        ng-click=\"toggleLabelSection()\"\n        kbn-accessible-click\n        aria-expanded=\"{{!!showLabels}}\"\n        aria-controls=\"heatmapOptionsLabels\"\n      >\n        <span\n          aria-hidden=\"true\"\n          ng-class=\"{\n          'fa-caret-down': showLabels,\n          'fa-caret-right': !showLabels\n          }\"\n          class=\"kuiIcon fa-caret-right kuiSideBarCollapsibleTitle__caret\"\n        ></span>\n        <span class=\"kuiSideBarCollapsibleTitle__text\">\n          Show Labels\n        </span>\n      </div>\n      <input\n        aria-label=\"Show labels\"\n        ng-model=\"vis.params.valueAxes[0].labels.show\"\n        type=\"checkbox\"\n        class=\"kuiSideBarSectionTitle__action\"\n      >\n    </div>\n    <div\n      id=\"heatmapOptionsLabels\"\n      ng-if=\"vis.params.valueAxes[0].labels.show\"\n      ng-show=\"showLabels\"\n      class=\"kuiSideBarCollapsibleSection\"\n    >\n      <div class=\"kuiSideBarSection\">\n        <div class=\"kuiSideBarFormRow\">\n          <label class=\"kuiSideBarFormRow__label\" for=\"rotateLabels\">\n            Rotate\n          </label>\n          <div class=\"kuiSideBarFormRow__control\">\n            <input class=\"kuiCheckBox\" id=\"rotateLabels\" type=\"checkbox\" ng-model=\"options.rotateLabels\">\n          </div>\n        </div>\n\n        <div class=\"kuiSideBarFormRow\">\n          <label class=\"kuiSideBarFormRow__label\" for=\"labelColor\">\n            Color\n          </label>\n          <div class=\"kuiSideBarFormRow__control\">\n            <input\n              id=\"labelColor\"\n              class=\"kuiSideBarInput\"\n              ng-model=\"vis.params.valueAxes[0].labels.color\"\n            >\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n</div>\n"

/***/ }),
/* 2955 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _gauge_options = __webpack_require__(2956);

var _gauge_options2 = _interopRequireDefault(_gauge_options);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');

_module.directive('gaugeOptions', function () {
  return {
    restrict: 'E',
    template: _gauge_options2.default,
    replace: true,
    link: function link($scope) {
      $scope.collections = $scope.vis.type.editorConfig.collections;
      $scope.showColorRange = true;

      $scope.$watch('vis.params.gauge.gaugeType', function (type) {
        switch (type) {
          case 'Arc':
            $scope.vis.params.gauge.type = 'meter';
            $scope.vis.params.gauge.minAngle = undefined;
            $scope.vis.params.gauge.maxAngle = undefined;
            break;
          case 'Circle':
            $scope.vis.params.gauge.type = 'meter';
            $scope.vis.params.gauge.minAngle = 0;
            $scope.vis.params.gauge.maxAngle = 2 * Math.PI;
            break;
          case 'Metric':
            $scope.vis.params.gauge.type = 'simple';
        }
      });

      var updateLegend = function updateLegend() {
        if (!$scope.vis.params.gauge.style.bgColor && !$scope.vis.params.gauge.style.labelColor) {
          $scope.vis.params.addLegend = false;
        } else {
          $scope.vis.params.addLegend = true;
        }
      };

      $scope.$watch('vis.params.gauge.gaugeColorMode', function (newValue) {
        switch (newValue) {
          case 'Labels':
            $scope.vis.params.gauge.style.labelColor = true;
            $scope.vis.params.gauge.style.bgColor = false;
            break;
          case 'Background':
            $scope.vis.params.gauge.style.labelColor = false;
            $scope.vis.params.gauge.style.bgColor = true;
            break;
          case 'None':
            $scope.vis.params.gauge.style.labelColor = false;
            $scope.vis.params.gauge.style.bgColor = false;
            break;
        }
        updateLegend();
      });

      $scope.resetColors = function () {
        $scope.uiState.set('vis.colors', null);
        $scope.customColors = false;
      };

      $scope.getGreaterThan = function (index) {
        if (index === 0) return 0;
        return $scope.vis.params.gauge.colorsRange[index - 1].to;
      };

      $scope.addRange = function () {
        var previousRange = _lodash2.default.last($scope.vis.params.gauge.colorsRange);
        var from = previousRange ? previousRange.to : 0;
        var to = previousRange ? from + (previousRange.to - previousRange.from) : 100;
        $scope.vis.params.gauge.colorsRange.push({ from: from, to: to });
      };

      $scope.removeRange = function (index) {
        $scope.vis.params.gauge.colorsRange.splice(index, 1);
      };

      $scope.getColor = function (index) {
        var defaultColors = this.uiState.get('vis.defaultColors');
        var overwriteColors = this.uiState.get('vis.colors');
        var colors = defaultColors ? _lodash2.default.defaults({}, overwriteColors, defaultColors) : overwriteColors;
        return colors ? Object.values(colors)[index] : 'transparent';
      };

      $scope.uiState.on('colorChanged', function () {
        $scope.customColors = true;
      });
    }
  };
});

/***/ }),
/* 2956 */
/***/ (function(module, exports) {

module.exports = "<div class=\"kuiSideBarSection\">\n  <div class=\"kuiSideBarFormRow\">\n    <label class=\"kuiSideBarFormRow__label\" for=\"gaugeType\">\n      Gauge Type\n    </label>\n    <div class=\"kuiSideBarFormRow__control\">\n      <select\n        id=\"gaugeType\"\n        class=\"kuiSelect kuiSideBarSelect\"\n        ng-model=\"vis.params.gauge.gaugeType\"\n        ng-options=\"mode for mode in collections.gaugeTypes\"\n      ></select>\n    </div>\n  </div>\n\n  <div class=\"kuiSideBarFormRow\">\n    <label class=\"kuiSideBarFormRow__label\" for=\"percentageMode\">\n      Percentage Mode\n    </label>\n    <div class=\"kuiSideBarFormRow__control\">\n      <input class=\"kuiCheckBox\" id=\"percentageMode\" type=\"checkbox\" ng-model=\"vis.params.gauge.percentageMode\">\n    </div>\n  </div>\n\n  <div class=\"kuiSideBarFormRow\" ng-hide=\"vis.params.gauge.type === 'simple'\">\n    <label class=\"kuiSideBarFormRow__label\" for=\"verticalSplit\">\n      Vertical Split &nbsp;\n      <kbn-info\n        placement=\"right\"\n        info=\"Shows gauges one under another\">\n      </kbn-info>\n    </label>\n    <div class=\"kuiSideBarFormRow__control\">\n      <input class=\"kuiCheckBox\" id=\"verticalSplit\" type=\"checkbox\" ng-model=\"vis.params.gauge.verticalSplit\">\n    </div>\n  </div>\n\n  <div class=\"kuiSideBarFormRow\">\n    <label class=\"kuiSideBarFormRow__label\" for=\"displayWarnings\">\n      Display warnings &nbsp;\n      <kbn-info info=\"Turns on/off warnings. When turned on, a warning will be shown if not all labels could be displayed.\"></kbn-info>\n    </label>\n\n    <div class=\"kuiSideBarFormRow__control\">\n      <input class=\"kuiCheckBox\" id=\"displayWarnings\" type=\"checkbox\" ng-model=\"vis.params.isDisplayWarning\">\n    </div>\n  </div>\n\n  <div class=\"kuiSideBarFormRow\">\n    <label class=\"kuiSideBarFormRow__label\" for=\"addLegend\">\n      Show Legend\n    </label>\n    <div class=\"kuiSideBarFormRow__control\">\n      <input class=\"kuiCheckBox\" id=\"addLegend\" type=\"checkbox\" ng-model=\"vis.params.addLegend\">\n    </div>\n  </div>\n\n  <div class=\"kuiSideBarFormRow\">\n    <label class=\"kuiSideBarFormRow__label\" for=\"showLabels\">\n      Show Labels\n    </label>\n    <div class=\"kuiSideBarFormRow__control\">\n      <input class=\"kuiCheckBox\" id=\"showLabels\" type=\"checkbox\" ng-model=\"vis.params.gauge.labels.show\">\n    </div>\n  </div>\n\n  <div class=\"kuiSideBarFormRow\" ng-show=\"vis.params.gauge.labels.show\">\n    <label class=\"kuiSideBarFormRow__label\" for=\"subText\">\n      Sub Text\n    </label>\n    <div class=\"kuiSideBarFormRow__control\">\n      <input\n        id=\"subText\"\n        class=\"kuiInput kuiSideBarInput\"\n        ng-model=\"vis.params.gauge.style.subText\"\n        type=\"text\"\n      >\n    </div>\n  </div>\n\n  <div\n    class=\"kuiSideBarFormRow\"\n    ng-hide=\"vis.params.gauge.type === 'simple'\"\n    ng-show=\"vis.params.gauge.colorsRange.length > 1\"\n  >\n    <label class=\"kuiSideBarFormRow__label\" for=\"extendRange\">\n      Auto Extend Range &nbsp;\n      <kbn-info\n        placement=\"right\"\n        info=\"Extends range to the maximum value in your data\">\n      </kbn-info>\n    </label>\n    <div class=\"kuiSideBarFormRow__control\">\n      <input class=\"kuiCheckBox\" id=\"extendRange\" type=\"checkbox\" ng-model=\"vis.params.gauge.extendRange\">\n    </div>\n  </div>\n\n  <div>\n    <div class=\"kuiSideBarCollapsibleTitle\">\n      <div\n        kbn-accessible-click\n        aria-expanded=\"{{!!showColorRange}}\"\n        aria-controls=\"gaugeOptionsRanges\"\n        aria-label=\"Toggle range options\"\n        class=\"kuiSideBarCollapsibleTitle__label\"\n        ng-click=\"showColorRange = !showColorRange\"\n      >\n      <span\n        aria-hidden=\"true\"\n        ng-class=\"{ 'fa-caret-down': showColorRange, 'fa-caret-right': !showColorRange }\"\n        class=\"fa fa-caret-right kuiSideBarCollapsibleTitle__caret\"\n      ></span>\n        <span class=\"kuiSideBarCollapsibleTitle__text\">\n        Ranges\n      </span>\n      </div>\n    </div>\n\n    <div id=\"gaugeOptionsRanges\" ng-show=\"showColorRange\" class=\"kuiSideBarCollapsibleSection\">\n      <div class=\"kuiSideBarSection\">\n        <table class=\"vis-editor-agg-editor-ranges form-group\" ng-show=\"vis.params.gauge.colorsRange.length\">\n          <tr>\n            <th scope=\"col\">\n              <label id=\"gaugeOptionsCustomRangeFrom\">From</label>\n            </th>\n            <th scope=\"col\" colspan=\"2\">\n              <label id=\"gaugeOptionsCustomRangeTo\">To</label>\n            </th>\n          </tr>\n\n          <tr ng-repeat=\"range in vis.params.gauge.colorsRange track by $index\">\n            <td>\n              <input\n                aria-labelledby=\"gaugeOptionsCustomRangeFrom\"\n                ng-model=\"range.from\"\n                type=\"number\"\n                class=\"form-control\"\n                name=\"range.from\"\n                greater-or-equal-than=\"{{getGreaterThan($index)}}\"\n                required\n                step=\"any\" />\n            </td>\n            <td>\n              <input\n                aria-labelledby=\"gaugeOptionsCustomRangeTo\"\n                ng-model=\"range.to\"\n                type=\"number\"\n                class=\"form-control\"\n                name=\"range.to\"\n                greater-or-equal-than=\"{{range.from}}\"\n                required\n                step=\"any\" />\n            </td>\n            <td>\n              <button\n                type=\"button\"\n                ng-click=\"removeRange($index)\"\n                ng-show=\"vis.params.gauge.colorsRange.length > 1\"\n                class=\"kuiButton kuiButton--danger kuiButton--small\">\n                <i class=\"fa fa-times\"></i>\n              </button>\n            </td>\n          </tr>\n        </table>\n\n        <div class=\"hintbox\" ng-show=\"!vis.params.gauge.colorsRange.length\">\n          <p>\n            <i class=\"fa fa-danger text-danger\"></i>\n            <strong>Required:</strong> You must specify at least one range.\n          </p>\n        </div>\n\n        <div\n          ng-click=\"addRange()\"\n          class=\"kuiButton kuiButton--primary kuiButton--fullWidth\">\n          Add Range\n        </div>\n        <div class=\"euiSpacer euiSpacer--s\"></div>\n        <div class=\"text text-center text-info\">Note: colors can be changed in the legend</div>\n      </div>\n    </div>\n  </div>\n  <div ng-show=\"vis.params.gauge.colorsRange.length > 1\">\n    <div class=\"kuiSideBarCollapsibleTitle\">\n      <div\n        kbn-accessible-click\n        aria-expanded=\"{{!!showColorOptions}}\"\n        aria-controls=\"gaugeOptionsColors\"\n        aria-label=\"Toggle color options\"\n        class=\"kuiSideBarCollapsibleTitle__label\"\n        ng-click=\"showColorOptions = !showColorOptions\"\n      >\n      <span\n        aria-hidden=\"true\"\n        ng-class=\"{\n        'fa-caret-down': showColorOptions,\n        'fa-caret-right': !showColorOptions\n        }\"\n        class=\"fa fa-caret-right kuiSideBarCollapsibleTitle__caret\"\n      ></span>\n        <span class=\"kuiSideBarCollapsibleTitle__text\">\n        Color Options\n      </span>\n      </div>\n    </div>\n    <div id=\"gaugeOptionsColors\" ng-if=\"showColorOptions\" class=\"kuiSideBarCollapsibleSection\">\n      <div class=\"kuiSideBarSection\">\n        <div class=\"kuiSideBarFormRow\">\n          <label class=\"kuiSideBarFormRow__label\" for=\"colorSchema\">\n            Color Schema\n          </label>\n          <div class=\"kuiSideBarFormRow__control\">\n            <select\n              id=\"colorSchema\"\n              class=\"kuiSelect kuiSideBarSelect\"\n              ng-model=\"vis.params.gauge.colorSchema\"\n              ng-options=\"mode for mode in collections.colorSchemas\"\n            ></select>\n          </div>\n          <div class=\"text-info text-center\" ng-show=\"customColors\" ng-click=\"resetColors()\">reset colors</div>\n        </div>\n\n        <div class=\"kuiSideBarFormRow\">\n          <label class=\"kuiSideBarFormRow__label\" for=\"invertColors\">\n            Reverse Color Schema\n          </label>\n          <div class=\"kuiSideBarFormRow__control\">\n            <input class=\"kuiCheckBox\" id=\"invertColors\" type=\"checkbox\" ng-model=\"vis.params.gauge.invertColors\">\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <div>\n    <div class=\"kuiSideBarCollapsibleTitle\">\n      <div\n        kbn-accessible-click\n        aria-expanded=\"{{!!showStyle}}\"\n        aria-controls=\"gaugeOptionsStyle\"\n        aria-label=\"Toggle style options\"\n        class=\"kuiSideBarCollapsibleTitle__label\"\n        ng-click=\"showStyle = !showStyle\"\n      >\n        <span\n          aria-hidden=\"true\"\n          ng-class=\"{\n          'fa-caret-down': showStyle,\n          'fa-caret-right': !showStyle\n          }\"\n          class=\"fa fa-caret-right kuiSideBarCollapsibleTitle__caret\"\n        ></span>\n        <span class=\"kuiSideBarCollapsibleTitle__text\">\n          Style\n        </span>\n      </div>\n    </div>\n    <div id=\"gaugeOptionsStyle\" ng-if=\"showStyle\" class=\"kuiSideBarCollapsibleSection\">\n\n      <div class=\"kuiSideBarSection\">\n        <div ng-hide=\"vis.params.gauge.type === 'simple'\">\n          <div class=\"kuiSideBarFormRow\" ng-show=\"vis.params.gauge.colorsRange.length > 1\">\n            <label class=\"kuiSideBarFormRow__label\" for=\"labelColor\">\n              Color Labels\n            </label>\n            <div class=\"kuiSideBarFormRow__control\">\n              <input class=\"kuiCheckBox\" id=\"labelColor\" type=\"checkbox\" ng-model=\"vis.params.gauge.style.labelColor\">\n            </div>\n          </div>\n          <div class=\"kuiSideBarFormRow\">\n            <label class=\"kuiSideBarFormRow__label\" for=\"showScale\">\n              Show Scale\n            </label>\n            <div class=\"kuiSideBarFormRow__control\">\n              <input class=\"kuiCheckBox\" id=\"showScale\" type=\"checkbox\" ng-model=\"vis.params.gauge.scale.show\">\n            </div>\n          </div>\n        </div>\n        <div ng-show=\"vis.params.gauge.type === 'simple'\">\n          <div class=\"kuiSideBarFormRow\">\n            <label class=\"kuiSideBarFormRow__label\" for=\"gaugeColorMode\">\n              Color\n            </label>\n            <div class=\"kuiSideBarFormRow__control\">\n              <select\n                id=\"gaugeColorMode\"\n                class=\"kuiSelect kuiSideBarSelect\"\n                ng-model=\"vis.params.gauge.gaugeColorMode\"\n                ng-options=\"mode for mode in collections.gaugeColorMode\"\n              ></select>\n            </div>\n          </div>\n          <div class=\"kuiSideBarFormRow\">\n            <label class=\"kuiSideBarFormRow__label\" for=\"backColor\">\n              Back/Text Color\n            </label>\n            <div class=\"kuiSideBarFormRow__control\">\n              <input\n                id=\"backTextColor\"\n                class=\"kuiInput kuiSideBarInput\"\n                ng-model=\"vis.params.gauge.style.bgFill\"\n              >\n            </div>\n          </div>\n          <div class=\"kuiSideBarFormRow\">\n            <label class=\"kuiSideBarFormRow__label\" for=\"showScale\">\n              Font Size (<span ng-bind=\"vis.params.gauge.style.fontSize\"></span>pt)\n            </label>\n            <div class=\"kuiSideBarFormRow__control\">\n              <input type=\"range\" ng-model=\"vis.params.gauge.style.fontSize\" class=\"form-control\" min=\"12\" max=\"120\" />\n            </div>\n          </div>\n        </div>\n\n      </div>\n    </div>\n  </div>\n</div>\n"

/***/ }),
/* 2957 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(2958);

__webpack_require__(2960);

__webpack_require__(2962);

__webpack_require__(2964);

/***/ }),
/* 2958 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _modules = __webpack_require__(2);

var _value_axes = __webpack_require__(2959);

var _value_axes2 = _interopRequireDefault(_value_axes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');

_module.directive('vislibValueAxes', function () {
  return {
    restrict: 'E',
    template: _value_axes2.default,
    replace: true,
    link: function link($scope) {
      var isCategoryAxisHorizontal = true;

      function mapPosition(position) {
        switch (position) {
          case 'bottom':
            return 'left';
          case 'top':
            return 'right';
          case 'left':
            return 'bottom';
          case 'right':
            return 'top';
        }
      }

      function mapPositionOposite(position) {
        switch (position) {
          case 'bottom':
            return 'top';
          case 'top':
            return 'bottom';
          case 'left':
            return 'right';
          case 'right':
            return 'left';
        }
      }

      $scope.rotateOptions = [{ name: 'horizontal', value: 0 }, { name: 'vertical', value: 90 }, { name: 'angled', value: 75 }];

      $scope.$watch('vis.params.categoryAxes[0].position', function (position) {
        isCategoryAxisHorizontal = ['top', 'bottom'].includes(position);
        $scope.vis.params.valueAxes.forEach(function (axis) {
          var axisIsHorizontal = ['top', 'bottom'].includes(axis.position);
          if (axisIsHorizontal === isCategoryAxisHorizontal) {
            axis.position = mapPosition(axis.position);
            $scope.updateAxisName(axis);
          }
        });
      });

      $scope.getSeries = function (axis) {
        var isFirst = $scope.vis.params.valueAxes[0] === axis;
        var series = $scope.vis.params.seriesParams.filter(function (series) {
          return series.valueAxis === axis.id || isFirst && !series.valueAxis;
        });
        return series.map(function (series) {
          return series.data.label;
        }).join(', ');
      };

      $scope.getSeriesShort = function (axis) {
        var maxStringLength = 30;
        return $scope.getSeries(axis).substring(0, maxStringLength);
      };

      $scope.isPositionDisabled = function (position) {
        if (isCategoryAxisHorizontal) {
          return ['top', 'bottom'].includes(position);
        }
        return ['left', 'right'].includes(position);
      };

      $scope.addValueAxis = function () {
        var firstAxis = $scope.vis.params.valueAxes[0];
        var newAxis = _lodash2.default.cloneDeep(firstAxis);
        newAxis.id = 'ValueAxis-' + $scope.vis.params.valueAxes.reduce(function (value, axis) {
          if (axis.id.substr(0, 10) === 'ValueAxis-') {
            var num = parseInt(axis.id.substr(10));
            if (num >= value) value = num + 1;
          }
          return value;
        }, 1);

        newAxis.position = mapPositionOposite(firstAxis.position);
        var axisName = _lodash2.default.capitalize(newAxis.position) + 'Axis-';
        newAxis.name = axisName + $scope.vis.params.valueAxes.reduce(function (value, axis) {
          if (axis.name.substr(0, axisName.length) === axisName) {
            var num = parseInt(axis.name.substr(axisName.length));
            if (num >= value) value = num + 1;
          }
          return value;
        }, 1);

        $scope.vis.params.valueAxes.push(newAxis);
        return newAxis;
      };

      $scope.removeValueAxis = function (axis) {
        if ($scope.vis.params.valueAxes.length > 1) {
          _lodash2.default.remove($scope.vis.params.valueAxes, function (valAxis) {
            return valAxis.id === axis.id;
          });
        }
      };

      $scope.updateExtents = function (axis) {
        if (!axis.scale.setYExtents) {
          delete axis.scale.min;
          delete axis.scale.max;
        }
      };

      $scope.updateAxisName = function (axis) {
        var axisName = _lodash2.default.capitalize(axis.position) + 'Axis-';
        axis.name = axisName + $scope.vis.params.valueAxes.reduce(function (value, axis) {
          if (axis.name.substr(0, axisName.length) === axisName) {
            var num = parseInt(axis.name.substr(axisName.length));
            if (num >= value) value = num + 1;
          }
          return value;
        }, 1);
      };

      var lastAxisTitles = {};
      $scope.updateAxisTitle = function () {
        $scope.vis.params.valueAxes.forEach(function (axis, axisNumber) {
          var label = '';
          var isFirst = axisNumber === 0;
          var matchingSeries = [];
          $scope.vis.params.seriesParams.forEach(function (series, i) {
            var isMatchingSeries = isFirst && !series.valueAxis || series.valueAxis === axis.id;
            if (isMatchingSeries) {
              var seriesNumber = 0;
              $scope.vis.getAggConfig().forEach(function (agg) {
                if (agg.schema.name === 'metric') {
                  if (seriesNumber === i) matchingSeries.push(agg);
                  seriesNumber++;
                }
              });
            }
          });
          if (matchingSeries.length === 1) {
            label = matchingSeries[0].makeLabel();
          }
          if (lastAxisTitles[axis.id] !== label && label !== '') {
            lastAxisTitles[axis.id] = label;
            axis.title.text = label;
          }
        });
      };

      $scope.$watch(function () {
        return $scope.vis.getAggConfig().map(function (agg) {
          return agg.makeLabel();
        }).join();
      }, function () {
        $scope.updateAxisTitle();
      });
    }
  };
});

/***/ }),
/* 2959 */
/***/ (function(module, exports) {

module.exports = "<div class=\"kuiSideBarSection kuiSideBarSection__main\">\n  <div class=\"kuiSideBarSectionTitle\">\n    <div class=\"kuiSideBarSectionTitle__text\">\n      Y-Axes\n    </div>\n\n    <button\n      data-test-subj=\"visualizeAddYAxisButton\"\n      aria-label=\"Add Y axis\"\n      ng-click=\"addValueAxis()\"\n      tooltip=\"Add Y axis\"\n      tooltip-append-to-body=\"true\"\n      type=\"button\"\n      class=\"kuiIcon fa-plus kuiSideBarSectionTitle__action\"\n    ></button>\n  </div>\n\n  <div\n    ng-repeat=\"axis in vis.params.valueAxes track by axis.id\"\n    class=\"kuiSideBarSection\"\n  >\n    <div class=\"kuiSideBarCollapsibleTitle\">\n      <div\n        class=\"kuiSideBarCollapsibleTitle__label\"\n        ng-click=\"isValueAxisOpen = !isValueAxisOpen\"\n        kbn-accessible-click\n        aria-expanded=\"{{!!isValueAxisOpen}}\"\n        aria-controls=\"axisOptions{{axis.id}}\"\n        aria-label=\"Toggle {{axis.name}} options\"\n      >\n        <span\n          aria-hidden=\"true\"\n          ng-class=\"{ 'fa-caret-down': isValueAxisOpen, 'fa-caret-right': !isValueAxisOpen }\"\n          class=\"kuiIcon fa-caret-right kuiSideBarCollapsibleTitle__caret\"\n        ></span>\n        <span class=\"kuiSideBarCollapsibleTitle__text\">\n          {{axis.name}}\n        </span>\n      </div>\n\n      <div tooltip=\"{{getSeries(axis)}}\">{{getSeriesShort(axis)}}</div>\n\n      <button\n        ng-hide=\"vis.params.valueAxes.length === 1\"\n        aria-label=\"Remove Y axis\"\n        ng-click=\"removeValueAxis(axis)\"\n        tooltip=\"Remove Y axis\"\n        tooltip-append-to-body=\"true\"\n        type=\"button\"\n        class=\"kuiIcon fa-remove kuiSideBarCollapsibleTitle__action\"\n      ></button>\n    </div>\n\n    <div id=\"axisOptions{{axis.id}}\" ng-show=\"isValueAxisOpen\" class=\"kuiSideBarCollapsibleSection\">\n      <!-- General -->\n      <div class=\"kuiSideBarSection\">\n        <div class=\"kuiSideBarFormRow\">\n          <label class=\"kuiSideBarFormRow__label\" for=\"{ 'valueAxisShow' + $index }\">\n            Show\n          </label>\n          <div class=\"kuiSideBarFormRow__control\">\n            <input class=\"kuiCheckBox\" id=\"{ 'valueAxisShow' + $index }\" type=\"checkbox\" ng-model=\"axis.show\">\n          </div>\n        </div>\n\n        <div class=\"kuiSideBarFormRow\">\n          <label class=\"kuiSideBarFormRow__label\" for=\"{{ 'valueAxisTitle' + $index }}\">\n            Title\n          </label>\n          <div class=\"kuiSideBarFormRow__control\">\n            <input\n              id=\"{{ 'valueAxisTitle' + $index }}\"\n              class=\"kuiInput kuiSideBarInput\"\n              type=\"text\"\n              ng-model=\"axis.title.text\"\n            >\n          </div>\n        </div>\n\n        <div class=\"kuiSideBarFormRow\">\n          <label class=\"kuiSideBarFormRow__label\" for=\"{{ 'valueAxisPosition' + $index }}\">\n            Position\n          </label>\n          <div class=\"kuiSideBarFormRow__control\">\n            <select\n              id=\"{{ 'valueAxisPosition' + $index }}\"\n              class=\"kuiSelect kuiSideBarSelect\"\n              ng-change=\"updateAxisName(axis)\"\n              ng-model=\"axis.position\"\n              ng-options=\"mode disable when isPositionDisabled(mode) for mode in vis.type.editorConfig.collections.positions\"\n            ></select>\n          </div>\n        </div>\n\n        <div class=\"kuiSideBarFormRow\">\n          <label class=\"kuiSideBarFormRow__label\" for=\"{{ 'valueAxisMode' + $index }}\">\n            Mode\n          </label>\n          <div class=\"kuiSideBarFormRow__control\">\n            <select\n              id=\"{{ 'valueAxisMode' + $index }}\"\n              class=\"kuiSelect kuiSideBarSelect\"\n              ng-model=\"axis.scale.mode\"\n              ng-options=\"mode for mode in vis.type.editorConfig.collections.axisModes\"\n            ></select>\n          </div>\n        </div>\n\n        <div class=\"kuiSideBarFormRow\">\n          <label class=\"kuiSideBarFormRow__label\" for=\"{{ 'valueAxisScaleType' + $index }}\">\n            Scale Type\n          </label>\n          <div class=\"kuiSideBarFormRow__control\">\n            <select\n              id=\"{{ 'valueAxisScaleType' + $index }}\"\n              class=\"kuiSelect kuiSideBarSelect\"\n              ng-model=\"axis.scale.type\"\n              ng-options=\"type for type in vis.type.editorConfig.collections.scaleTypes\"\n            ></select>\n          </div>\n        </div>\n      </div>\n\n      <!-- Advanced options -->\n      <div class=\"kuiSideBarSection\">\n        <a\n          class=\"kuiSideBarOptionsLink\"\n          ng-click=\"isValueAxisAdvancedOptionsOpen = !isValueAxisAdvancedOptionsOpen\"\n          kbn-accessible-click\n        >\n          <span\n            aria-hidden=\"true\"\n            ng-class=\"{ 'fa-caret-down': isValueAxisAdvancedOptionsOpen, 'fa-caret-right': !isValueAxisAdvancedOptionsOpen }\"\n            class=\"kuiIcon fa-caret-right kuiSideBarOptionsLink__caret\"\n          ></span>\n          <span class=\"kuiSideBarOptionsLink__text\">\n            <span ng-show=\"!isValueAxisAdvancedOptionsOpen\">\n              Show\n            </span>\n            <span ng-show=\"isValueAxisAdvancedOptionsOpen\">\n              Hide\n            </span>\n            Advanced Options\n          </span>\n        </a>\n\n        <div ng-show=\"isValueAxisAdvancedOptionsOpen\">\n\n          <!-- Labels -->\n          <div class=\"kuiSideBarSection\">\n            <h6 class=\"kuiSideBarFormSectionTitle\">\n              Labels\n            </h6>\n\n            <div class=\"kuiSideBarFormRow\">\n              <label class=\"kuiSideBarFormRow__label\" for=\"{{ 'valueAxisShowLabels' + $index }}\">\n                Show Labels\n              </label>\n              <div class=\"kuiSideBarFormRow__control\">\n                <input class=\"kuiCheckBox\" id=\"{{ 'valueAxisShowLabels' + $index }}\" type=\"checkbox\" ng-model=\"axis.labels.show\">\n              </div>\n            </div>\n\n            <div class=\"kuiSideBarFormRow\">\n              <label class=\"kuiSideBarFormRow__label\" for=\"{{ 'valueAxisFilterLabels' + $index }}\">\n                Filter Labels\n              </label>\n              <div class=\"kuiSideBarFormRow__control\">\n                <input class=\"kuiCheckBox\" id=\"{{ 'valueAxisFilterLabels' + $index }}\" type=\"checkbox\" ng-model=\"axis.labels.filter\">\n              </div>\n            </div>\n\n            <div class=\"kuiSideBarFormRow\">\n              <label class=\"kuiSideBarFormRow__label\" for=\"{{ 'valueAxisRotateLabels' + $index }}\">\n                Rotate\n              </label>\n              <div class=\"kuiSideBarFormRow__control\">\n                <select\n                  id=\"{{ 'valueAxisRotateLabels' + $index }}\"\n                  class=\"kuiSelect kuiSideBarSelect\"\n                  ng-model=\"axis.labels.rotate\"\n                  ng-options=\"mode.value as mode.name for mode in rotateOptions\"\n                ></select>\n              </div>\n            </div>\n\n            <div class=\"kuiSideBarFormRow\">\n              <label class=\"kuiSideBarFormRow__label\" for=\"{{ 'valueAxisTruncateLabels' + $index }}\">\n                Truncate\n              </label>\n              <div class=\"kuiSideBarFormRow__control\">\n                <input\n                  id=\"{{ 'valueAxisTruncateLabels' + $index }}\"\n                  class=\"kuiInput kuiSideBarInput\"\n                  type=\"number\"\n                  ng-model=\"axis.labels.truncate\"\n                >\n              </div>\n            </div>\n          </div>\n\n          <!-- Custom Extents -->\n          <div class=\"kuiSideBarSection\">\n            <h6 class=\"kuiSideBarFormSectionTitle\">\n              Custom Extents\n            </h6>\n\n            <div class=\"kuiSideBarFormRow\">\n              <label class=\"kuiSideBarFormRow__label\" for=\"{ 'defaultYExtents' + $index }\">\n                Scale to Data Bounds\n              </label>\n              <div class=\"kuiSideBarFormRow__control\">\n                <input class=\"kuiCheckBox\" id=\"{ 'defaultYExtents' + $index }\" type=\"checkbox\" ng-model=\"axis.scale.defaultYExtents\">\n              </div>\n            </div>\n\n            <div class=\"kuiSideBarFormRow\">\n              <label class=\"kuiSideBarFormRow__label\" for=\"{ 'setYExtents' + $index }\">\n                Set Axis Extents\n              </label>\n              <div class=\"kuiSideBarFormRow__control\">\n                <input class=\"kuiCheckBox\" id=\"{ 'setYExtents' + $index }\" type=\"checkbox\" ng-model=\"axis.scale.setYExtents\" ng-change=\"updateExtents(axis)\">\n              </div>\n            </div>\n\n            <div ng-if=\"axis.scale.setYExtents\">\n              <div class=\"kuiSideBarFormRow\">\n                <label class=\"kuiSideBarFormRow__label\">\n                  Max\n                </label>\n                <div class=\"kuiSideBarFormRow__control\">\n                  <input\n                    name=\"yMax\"\n                    class=\"kuiInput kuiSideBarInput\"\n                    type=\"number\"\n                    step=\"0.1\"\n                    ng-model=\"axis.scale.max\"\n                  >\n                </div>\n              </div>\n\n              <div class=\"kuiSideBarFormRow\">\n                <label class=\"kuiSideBarFormRow__label\">\n                  Min\n                </label>\n                <div class=\"kuiSideBarFormRow__control\">\n                  <input\n                    name=\"yMin\"\n                    class=\"kuiInput kuiSideBarInput\"\n                    type=\"number\"\n                    step=\"0.1\"\n                    greater-than=\"{{axis.scale.type === 'log' ? 0 : ''}}\"\n                    ng-model=\"axis.scale.min\"\n                  >\n                </div>\n              </div>\n              <div ng-show=\"axis.scale.type === 'log' && axis.scale.min <= 0\">\n                <span class=\"text-danger\">Min must exceed 0 when a log scale is selected</span>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <div style=\"height: 10px\"></div>\n</div>\n"

/***/ }),
/* 2960 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _category_axis = __webpack_require__(2961);

var _category_axis2 = _interopRequireDefault(_category_axis);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');

_module.directive('vislibCategoryAxis', function () {
  return {
    restrict: 'E',
    template: _category_axis2.default,
    replace: true,
    link: function link($scope) {
      $scope.rotateOptions = [{ name: 'horizontal', value: 0 }, { name: 'vertical', value: 90 }, { name: 'angled', value: 75 }];
    }
  };
});

/***/ }),
/* 2961 */
/***/ (function(module, exports) {

module.exports = "<div class=\"kuiSideBarSection kuiSideBarSection__main\">\n  <div class=\"kuiSideBarSectionTitle\">\n    <div class=\"kuiSideBarSectionTitle__text\">\n      X-Axis\n    </div>\n  </div>\n\n  <!-- General -->\n  <div class=\"kuiSideBarSection\">\n    <div class=\"kuiSideBarFormRow\">\n      <label class=\"kuiSideBarFormRow__label\" for=\"categoryAxisShow\">\n        Show\n      </label>\n      <div class=\"kuiSideBarFormRow__control\">\n        <input class=\"kuiCheckBox\" id=\"categoryAxisShow\" type=\"checkbox\" ng-model=\"vis.params.categoryAxes[0].show\">\n      </div>\n    </div>\n\n    <div class=\"kuiSideBarFormRow\">\n      <label class=\"kuiSideBarFormRow__label\" for=\"categoryAxisPosition\">\n        Position\n      </label>\n      <div class=\"kuiSideBarFormRow__control\">\n        <select\n          id=\"categoryAxisPosition\"\n          class=\"kuiSelect kuiSideBarSelect\"\n          ng-model=\"vis.params.categoryAxes[0].position\"\n          ng-options=\"mode for mode in vis.type.editorConfig.collections.positions\"\n        ></select>\n      </div>\n    </div>\n  </div>\n\n  <!-- Advanced options -->\n  <div class=\"kuiSideBarSection\">\n    <a\n      class=\"kuiSideBarOptionsLink\"\n      ng-click=\"isCategoryAxisAdvancedOptionsOpen = !isCategoryAxisAdvancedOptionsOpen\"\n      kbn-accessible-click\n    >\n      <span\n        aria-hidden=\"true\"\n        ng-class=\"{ 'fa-caret-down': isCategoryAxisAdvancedOptionsOpen, 'fa-caret-right': !isCategoryAxisAdvancedOptionsOpen }\"\n        class=\"kuiIcon fa-caret-right kuiSideBarOptionsLink__caret\"\n      ></span>\n      <span class=\"kuiSideBarOptionsLink__text\">\n        <span ng-show=\"!isCategoryAxisAdvancedOptionsOpen\">\n          Show\n        </span>\n        <span ng-show=\"isCategoryAxisAdvancedOptionsOpen\">\n          Hide\n        </span>\n        Advanced Options\n      </span>\n    </a>\n\n    <div ng-show=\"isCategoryAxisAdvancedOptionsOpen\">\n      <!-- Labels -->\n      <div class=\"kuiSideBarSection\">\n        <h6 class=\"kuiSideBarFormSectionTitle\">\n          Labels\n        </h6>\n\n        <div class=\"kuiSideBarFormRow\">\n          <label class=\"kuiSideBarFormRow__label\" for=\"categoryAxisShowLabels\">\n            Show Labels\n          </label>\n          <div class=\"kuiSideBarFormRow__control\">\n            <input class=\"kuiCheckBox\" id=\"categoryAxisShowLabels\" type=\"checkbox\" ng-model=\"vis.params.categoryAxes[0].labels.show\">\n          </div>\n        </div>\n\n        <div class=\"kuiSideBarFormRow\">\n          <label class=\"kuiSideBarFormRow__label\" for=\"categoryAxisShowFilter\">\n            Filter Labels\n          </label>\n          <div class=\"kuiSideBarFormRow__control\">\n            <input class=\"kuiCheckBox\" id=\"categoryAxisShowFilter\" type=\"checkbox\" ng-model=\"vis.params.categoryAxes[0].labels.filter\">\n          </div>\n        </div>\n\n        <div class=\"kuiSideBarFormRow\">\n          <label class=\"kuiSideBarFormRow__label\" for=\"categoryAxisSotateLabels\">\n            Rotate\n          </label>\n          <div class=\"kuiSideBarFormRow__control\">\n            <select\n              id=\"categoryAxisSotateLabels\"\n              class=\"kuiSelect kuiSideBarSelect\"\n              ng-model=\"vis.params.categoryAxes[0].labels.rotate\"\n              ng-options=\"mode.value as mode.name for mode in rotateOptions\"\n            ></select>\n          </div>\n        </div>\n\n        <div class=\"kuiSideBarFormRow\">\n          <label class=\"kuiSideBarFormRow__label\" for=\"categoryAxisSruncateLabels\">\n            Truncate\n          </label>\n          <div class=\"kuiSideBarFormRow__control\">\n            <input\n              id=\"categoryAxisSruncateLabels\"\n              class=\"kuiInput kuiSideBarInput\"\n              type=\"number\"\n              ng-model=\"vis.params.categoryAxes[0].labels.truncate\"\n            >\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n</div>\n"

/***/ }),
/* 2962 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _modules = __webpack_require__(2);

var _series = __webpack_require__(2963);

var _series2 = _interopRequireDefault(_series);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');

_module.directive('vislibSeries', function () {
  return {
    restrict: 'E',
    template: _series2.default,
    replace: true,
    link: function link($scope) {
      function makeSerie(id, label) {
        var last = $scope.series[$scope.series.length - 1];
        return {
          show: true,
          mode: last ? last.mode : 'normal',
          type: last ? last.type : 'line',
          drawLinesBetweenPoints: last ? last.drawLinesBetweenPoints : true,
          showCircles: last ? last.showCircles : true,
          interpolate: last ? last.interpolate : 'linear',
          lineWidth: last ? last.lineWidth : 2,
          data: {
            id: id,
            label: label
          },
          valueAxis: last ? last.valueAxis : $scope.vis.params.valueAxes[0].id
        };
      }

      $scope.series = $scope.vis.params.seriesParams;
      $scope.$watch(function () {
        return $scope.vis.aggs.map(function (agg) {
          return agg.makeLabel();
        }).join();
      }, function () {
        var schemaTitle = $scope.vis.type.schemas.metrics[0].title;

        var metrics = $scope.vis.aggs.filter(function (agg) {
          var isMetric = agg.type && agg.type.type === 'metrics';
          return isMetric && agg.schema.title === schemaTitle;
        });

        // update labels for existing params or create new one
        $scope.vis.params.seriesParams = metrics.map(function (agg) {
          var params = $scope.vis.params.seriesParams.find(function (param) {
            return param.data.id === agg.id;
          });
          if (params) {
            params.data.label = agg.makeLabel();
            return params;
          } else {
            var series = makeSerie(agg.id, agg.makeLabel());
            return series;
          }
        });
      });

      $scope.$watch(function () {
        return $scope.vis.params.seriesParams.map(function (series) {
          return series.type;
        }).join();
      }, function () {
        var types = _lodash2.default.uniq(_lodash2.default.map($scope.vis.params.seriesParams, 'type'));
        $scope.vis.type.type = types.length === 1 ? types[0] : 'histogram';
      });

      $scope.$watch('vis.params.valueAxes.length', function () {
        $scope.vis.params.seriesParams.forEach(function (series) {
          if (!$scope.vis.params.valueAxes.find(function (axis) {
            return axis.id === series.valueAxis;
          })) {
            series.valueAxis = $scope.vis.params.valueAxes[0].id;
          }
        });
      });

      $scope.changeValueAxis = function (index) {
        var series = $scope.vis.params.seriesParams[index];
        if (series.valueAxis === 'new') {
          var axis = $scope.addValueAxis();
          series.valueAxis = axis.id;
        }
        $scope.updateAxisTitle();
      };
    }
  };
});

/***/ }),
/* 2963 */
/***/ (function(module, exports) {

module.exports = "<div class=\"kuiSideBarSection kuiSideBarSection__main\">\n  <div class=\"kuiSideBarSectionTitle\">\n    <div class=\"kuiSideBarSectionTitle__text\">\n      Metrics\n    </div>\n  </div>\n\n  <div\n    ng-repeat=\"chart in vis.params.seriesParams track by $index\"\n    class=\"kuiSideBarSection\"\n  >\n    <div class=\"kuiSideBarCollapsibleTitle\">\n      <div\n        ng-init=\"isSeriesOpen = ($index === 0)\"\n        class=\"kuiSideBarCollapsibleTitle__label\"\n        ng-click=\"isSeriesOpen = !isSeriesOpen\"\n        kbn-accessible-click\n        aria-expanded=\"{{!!isSeriesOpen}}\"\n        aria-controls=\"visSeriesOptions{{$index}}\"\n        aria-label=\"Toggle {{chart.data.label}} options\"\n      >\n        <span\n          aria-hidden=\"true\"\n          ng-class=\"{ 'fa-caret-down': isSeriesOpen, 'fa-caret-right': !isSeriesOpen }\"\n          class=\"kuiIcon fa-caret-right kuiSideBarCollapsibleTitle__caret\"\n        ></span>\n        <span class=\"kuiSideBarCollapsibleTitle__text\">\n          {{chart.data.label}}\n        </span>\n      </div>\n    </div>\n\n    <div id=\"visSeriesOptions{{$index}}\" ng-show=\"isSeriesOpen\" class=\"kuiSideBarCollapsibleSection\">\n      <!-- General -->\n      <div class=\"kuiSideBarSection\">\n\n        <div class=\"kuiSideBarFormRow\">\n          <label class=\"kuiSideBarFormRow__label\" for=\"{{ 'seriesType' + $index }}\">\n            Chart Type\n          </label>\n          <div class=\"kuiSideBarFormRow__control\">\n            <select\n              id=\"{{ 'seriesType' + $index }}\"\n              class=\"kuiSelect kuiSideBarSelect\"\n              ng-model=\"chart.type\"\n              ng-options=\"mode.value as mode.text for mode in vis.type.editorConfig.collections.chartTypes\"\n            ></select>\n          </div>\n        </div>\n\n        <div class=\"kuiSideBarFormRow\">\n          <label class=\"kuiSideBarFormRow__label\" for=\"{{ 'seriesMode' + $index }}\">\n            Mode\n          </label>\n          <div class=\"kuiSideBarFormRow__control\">\n            <select\n              id=\"{{ 'seriesMode' + $index }}\"\n              class=\"kuiSelect kuiSideBarSelect\"\n              ng-model=\"chart.mode\"\n              ng-options=\"mode for mode in vis.type.editorConfig.collections.chartModes\"\n            ></select>\n          </div>\n        </div>\n\n        <div class=\"kuiSideBarFormRow\">\n          <label class=\"kuiSideBarFormRow__label\" for=\"{{ 'seriesValueAxis' + $index }}\">\n            Value Axis\n          </label>\n          <div class=\"kuiSideBarFormRow__control\">\n            <select\n              id=\"{{ 'seriesValueAxis' + $index }}\"\n              class=\"kuiSelect kuiSideBarSelect\"\n              ng-model=\"chart.valueAxis\"\n              ng-change=\"changeValueAxis($index)\"\n            >\n              <option ng-repeat=\"axis in vis.params.valueAxes track by axis.id\" value=\"{{axis.id}}\">{{axis.name}}</option>\n              <option value=\"new\">New Axis ...</option>\n            </select>\n          </div>\n        </div>\n\n        <div ng-show=\"chart.type == 'line' || chart.type == 'area'\">\n          <div class=\"kuiSideBarFormRow\">\n            <label class=\"kuiSideBarFormRow__label\" for=\"{{ 'lineMode' + $index }}\">\n              Line Mode\n            </label>\n            <div class=\"kuiSideBarFormRow__control\">\n              <select\n                id=\"{{ 'lineMode' + $index }}\"\n                class=\"kuiSelect kuiSideBarSelect\"\n                ng-model=\"chart.interpolate\"\n                ng-options=\"mode.value as mode.text for mode in vis.type.editorConfig.collections.interpolationModes\"\n              >\n              </select>\n            </div>\n          </div>\n        </div>\n        <div ng-show=\"chart.type == 'line'\">\n          <div class=\"kuiSideBarFormRow\">\n            <label class=\"kuiSideBarFormRow__label\" for=\"{{ 'drawLines' + $index }}\">\n              Show Line\n            </label>\n            <div class=\"kuiSideBarFormRow__control\">\n              <input class=\"kuiCheckBox\" id=\"{{ 'drawLines' + $index }}\" type=\"checkbox\" ng-model=\"chart.drawLinesBetweenPoints\">\n            </div>\n          </div>\n\n          <div class=\"kuiSideBarFormRow\">\n            <label class=\"kuiSideBarFormRow__label\" for=\"{{ 'showCircles' + $index }}\">\n              Show Circles\n            </label>\n            <div class=\"kuiSideBarFormRow__control\">\n              <input class=\"kuiCheckBox\" id=\"{{ 'showCircles' + $index }}\" type=\"checkbox\" ng-model=\"chart.showCircles\">\n            </div>\n          </div>\n\n          <div class=\"kuiSideBarFormRow\">\n            <label class=\"kuiSideBarFormRow__label\">\n              Line Width\n            </label>\n            <div class=\"kuiSideBarFormRow__control\">\n              <input name=\"lineWidth\"\n                     class=\"kuiInput kuiSideBarInput\"\n                     type=\"number\"\n                     step=\"0.5\"\n                     ng-model=\"chart.lineWidth\"\n              >\n            </div>\n          </div>\n\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <div style=\"height: 10px\"></div>\n</div>\n"

/***/ }),
/* 2964 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var _grid = __webpack_require__(2965);

var _grid2 = _interopRequireDefault(_grid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('kibana');

_module.directive('vislibGrid', function () {
  return {
    restrict: 'E',
    template: _grid2.default,
    replace: true,
    link: function link($scope) {

      $scope.isGridOpen = true;
    }
  };
});

/***/ }),
/* 2965 */
/***/ (function(module, exports) {

module.exports = "<div>\n  <div class=\"kuiSideBarCollapsibleTitle\">\n    <div\n      class=\"kuiSideBarCollapsibleTitle__label\"\n      ng-click=\"isGridOpen = !isGridOpen\"\n      kbn-accessible-click\n      aria-expanded=\"{{!!isGridOpen}}\"\n      aria-controls=\"visGridOptions\"\n      aria-label=\"Toggle grid options\"\n    >\n      <span\n        aria-hidden=\"true\"\n        ng-class=\"{ 'fa-caret-down': isGridOpen, 'fa-caret-right': !isGridOpen }\"\n        class=\"kuiIcon fa-caret-right kuiSideBarCollapsibleTitle__caret\"\n      ></span>\n      <span class=\"kuiSideBarCollapsibleTitle__text\">\n        Grid\n      </span>\n    </div>\n  </div>\n\n  <div id=\"visGridOptions\" ng-show=\"isGridOpen\" class=\"kuiSideBarCollapsibleSection\">\n    <!-- General -->\n    <div class=\"kuiSideBarSection\">\n      <div class=\"kuiSideBarFormRow\">\n        <label class=\"kuiSideBarFormRow__label\" for=\"showCategoryLines\">\n          X-Axis Lines\n        </label>\n        <div class=\"kuiSideBarFormRow__control\">\n          <input class=\"kuiCheckBox\" id=\"showCategoryLines\" type=\"checkbox\" ng-model=\"vis.params.grid.categoryLines\">\n        </div>\n      </div>\n\n      <div class=\"kuiSideBarFormRow\">\n        <label class=\"kuiSideBarFormRow__label\" for=\"gridAxis\">\n          Y-Axis Lines\n        </label>\n        <div class=\"kuiSideBarFormRow__control\">\n          <select\n            id=\"gridAxis\"\n            class=\"kuiSelect kuiSideBarSelect\"\n            ng-model=\"vis.params.grid.valueAxis\"\n            ng-options=\"axis.id as axis.name for axis in vis.params.valueAxes track by axis.id\"\n          >\n            <option value=\"\">Don't show</option>\n          </select>\n        </div>\n      </div>\n\n    </div>\n\n  </div>\n"

/***/ }),
/* 2966 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PointSeriesGetSeriesProvider = PointSeriesGetSeriesProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _get_point = __webpack_require__(2967);

var _add_to_siri = __webpack_require__(2968);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function PointSeriesGetSeriesProvider(Private) {
  var getPoint = Private(_get_point.PointSeriesGetPointProvider);
  var addToSiri = Private(_add_to_siri.PointSeriesAddToSiriProvider);

  return function getSeries(rows, chart) {
    var aspects = chart.aspects;
    var multiY = Array.isArray(aspects.y);
    var yScale = chart.yScale;
    var partGetPoint = _lodash2.default.partial(getPoint, aspects.x, aspects.series, yScale);

    var series = (0, _lodash2.default)(rows).transform(function (series, row) {
      if (!multiY) {
        var point = partGetPoint(row, aspects.y, aspects.z);
        if (point) addToSiri(series, point, point.series, point.series, aspects.y.agg);
        return;
      }

      aspects.y.forEach(function (y) {
        var point = partGetPoint(row, y, aspects.z);
        if (!point) return;

        // use the point's y-axis as it's series by default,
        // but augment that with series aspect if it's actually
        // available
        var seriesId = y.agg.id;
        var seriesLabel = y.col.title;

        if (aspects.series) {
          var prefix = point.series ? point.series + ': ' : '';
          seriesId = prefix + seriesId;
          seriesLabel = prefix + seriesLabel;
        }

        addToSiri(series, point, seriesId, seriesLabel, y.agg);
      });
    }, new Map()).thru(function (series) {
      return [].concat(_toConsumableArray(series.values()));
    }).value();

    if (multiY) {
      series = _lodash2.default.sortBy(series, function (siri) {
        var firstVal = siri.values[0];
        var y = void 0;

        if (firstVal) {
          var agg = firstVal.aggConfigResult.aggConfig;
          y = _lodash2.default.find(aspects.y, function (y) {
            return y.agg === agg;
          });
        }

        return y ? y.i : series.length;
      });
    }

    return series;
  };
}

/***/ }),
/* 2967 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PointSeriesGetPointProvider = PointSeriesGetPointProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function PointSeriesGetPointProvider() {
  function unwrap(aggConfigResult, def) {
    return aggConfigResult ? aggConfigResult.value : def;
  }

  return function getPoint(x, series, yScale, row, y, z) {
    var zRow = z && row[z.i];
    var xRow = row[x.i];

    var point = {
      x: unwrap(xRow, '_all'),
      y: unwrap(row[y.i]),
      z: zRow && unwrap(zRow),
      aggConfigResult: row[y.i],
      extraMetrics: _lodash2.default.compact([zRow]),
      yScale: yScale
    };

    if (point.y === 'NaN') {
      // filter out NaN from stats
      // from metrics that are not based at zero
      return;
    }

    if (series) {
      point.aggConfig = series.agg;
      point.series = series.agg.fieldFormatter()(unwrap(row[series.i]));
    } else if (y) {
      // If the data is not split up with a series aspect, then
      // each point's "series" becomes the y-agg that produced it
      point.aggConfig = y.col.aggConfig;
      point.series = y.col.title;
    }

    if (yScale) {
      point.y *= yScale;
    }

    return point;
  };
}

/***/ }),
/* 2968 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PointSeriesAddToSiriProvider = PointSeriesAddToSiriProvider;
function PointSeriesAddToSiriProvider() {
  return function addToSiri(series, point, id, label, agg) {
    id = id == null ? '' : id + '';

    if (series.has(id)) {
      series.get(id).values.push(point);
      return;
    }

    series.set(id, {
      label: label == null ? id : label,
      aggLabel: agg.type ? agg.type.makeLabel(agg) : label,
      aggId: agg.parentId ? agg.parentId : agg.id,
      count: 0,
      values: [point]
    });
  };
}

/***/ }),
/* 2969 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PointSeriesGetAspectsProvider = PointSeriesGetAspectsProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _fake_x_aspect = __webpack_require__(2970);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function PointSeriesGetAspectsProvider(Private) {
  var fakeXAspect = Private(_fake_x_aspect.PointSeriesFakeXAxisProvider);

  var map = {
    segment: 'x',
    metric: 'y',
    radius: 'z',
    width: 'width',
    group: 'series'
  };

  function columnToAspect(aspects, col, i) {
    var schema = col.aggConfig.schema.name;

    var name = map[schema];
    if (!name) throw new TypeError('unknown schema name "' + schema + '"');

    var aspect = {
      i: i,
      col: col,
      agg: col.aggConfig
    };

    if (!aspects[name]) aspects[name] = [];
    aspects[name].push(aspect);
  }

  /**
   * Identify and group the columns based on the aspect of the pointSeries
   * they represent.
   *
   * @param  {array} columns - the list of columns
   * @return {object} - an object with a key for each aspect (see map). The values
   *                    may be undefined, a single aspect, or an array of aspects.
   */
  return function getAspects(vis, table) {
    var aspects = (0, _lodash2.default)(table.columns)
    // write each column into the aspects under it's group
    .transform(columnToAspect, {})
    // unwrap groups that only have one value, and validate groups that have more
    .transform(function (aspects, group, name) {
      if (name !== 'y' && group.length > 1) {
        throw new TypeError('Only multiple metrics are supported in point series');
      }

      aspects[name] = group.length > 1 ? group : group[0];
    }).value();

    if (!aspects.x) {
      aspects.x = fakeXAspect(vis);
    }

    return aspects;
  };
}

/***/ }),
/* 2970 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PointSeriesFakeXAxisProvider = PointSeriesFakeXAxisProvider;

var _agg_config = __webpack_require__(105);

var _agg_type = __webpack_require__(527);

function PointSeriesFakeXAxisProvider(Private) {
  var AggConfig = Private(_agg_config.VisAggConfigProvider);
  var AggType = Private(_agg_type.AggTypesAggTypeProvider);

  var allAgg = new AggType({
    name: 'all',
    title: 'All docs',
    ordered: false,
    hasNoDsl: true
  });

  return function makeFakeXAxis(vis) {
    var fake = new AggConfig(vis, {
      type: allAgg,
      schema: vis.type.schemas.all.byName.segment
    });

    return {
      i: -1,
      agg: fake,
      col: {
        aggConfig: fake,
        label: fake.makeLabel()
      }
    };
  };
}

/***/ }),
/* 2971 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FieldParamTypeProvider = FieldParamTypeProvider;

var _errors = __webpack_require__(37);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _field = __webpack_require__(2972);

var _field2 = _interopRequireDefault(_field);

var _base = __webpack_require__(211);

__webpack_require__(523);

var _indexed_array = __webpack_require__(99);

var _notifier = __webpack_require__(43);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function FieldParamTypeProvider(Private, $filter) {
  var BaseParamType = Private(_base.BaseParamTypeProvider);
  var notifier = new _notifier.Notifier();

  _lodash2.default.class(FieldParamType).inherits(BaseParamType);
  function FieldParamType(config) {
    FieldParamType.Super.call(this, config);
  }

  FieldParamType.prototype.editor = _field2.default;
  FieldParamType.prototype.scriptable = true;
  FieldParamType.prototype.filterFieldTypes = '*';
  // retain only the fields with the aggregatable property if the onlyAggregatable option is true
  FieldParamType.prototype.onlyAggregatable = true;

  /**
   * Called to serialize values for saving an aggConfig object
   *
   * @param  {field} field - the field that was selected
   * @return {string}
   */
  FieldParamType.prototype.serialize = function (field) {
    return field.name;
  };

  /**
   * Get the options for this field from the indexPattern
   */
  FieldParamType.prototype.getFieldOptions = function (aggConfig) {
    var indexPattern = aggConfig.getIndexPattern();
    var fields = indexPattern.fields.raw;

    if (this.onlyAggregatable) {
      fields = fields.filter(function (f) {
        return f.aggregatable;
      });
    }

    if (!this.scriptable) {
      fields = fields.filter(function (field) {
        return !field.scripted;
      });
    }

    if (this.filterFieldTypes) {
      var filters = this.filterFieldTypes;
      if (_lodash2.default.isFunction(this.filterFieldTypes)) {
        filters = this.filterFieldTypes.bind(this, aggConfig.vis);
      }
      fields = $filter('fieldType')(fields, filters);
      fields = $filter('orderBy')(fields, ['type', 'name']);
    }

    return new _indexed_array.IndexedArray({
      index: ['name'],
      group: ['type'],
      initialSet: fields
    });
  };

  /**
   * Called to read values from a database record into the
   * aggConfig object
   *
   * @param  {string} fieldName
   * @return {field}
   */
  FieldParamType.prototype.deserialize = function (fieldName, aggConfig) {
    var field = aggConfig.getIndexPattern().fields.byName[fieldName];

    if (!field) {
      throw new _errors.SavedObjectNotFound('index-pattern-field', fieldName);
    }

    var validField = this.getFieldOptions(aggConfig).byName[fieldName];
    if (!validField) {
      notifier.error('Saved "field" parameter is now invalid. Please select a new field.');
    }

    return validField;
  };

  /**
   * Write the aggregation parameter.
   *
   * @param  {AggConfig} aggConfig - the entire configuration for this agg
   * @param  {object} output - the result of calling write on all of the aggregations
   *                         parameters.
   * @param  {object} output.params - the final object that will be included as the params
   *                               for the agg
   * @return {undefined}
   */
  FieldParamType.prototype.write = function (aggConfig, output) {
    var field = aggConfig.getField();

    if (!field) {
      throw new TypeError('"field" is a required parameter');
    }

    if (field.scripted) {
      output.params.script = {
        inline: field.script,
        lang: field.lang
      };
    } else {
      output.params.field = field.name;
    }
  };

  return FieldParamType;
}

/***/ }),
/* 2972 */
/***/ (function(module, exports) {

module.exports = "<div class=\"form-group\">\n  <label>\n    Field\n  </label>\n\n  <ui-select\n    title=\"Aggregation Field\"\n    name=\"field\"\n    required\n    class=\"vis-editor-field-ui-select field-select\"\n    ng-show=\"indexedFields.length\"\n    ng-model=\"agg.params.field\"\n    on-select=\"aggParam.onChange(agg)\"\n    uis-open-close=\"limit = 100\"\n  >\n    <ui-select-match placeholder=\"Select a field\">\n      {{$select.selected.displayName}}\n    </ui-select-match>\n    <ui-select-choices\n      group-by=\"'type'\"\n      kbn-scroll-bottom=\"limit = limit + 100\"\n      repeat=\"field in indexedFields | filter: { displayName: $select.search } | sortPrefixFirst:$select.search:'name' | limitTo: limit\"\n    >\n      <div ng-bind-html=\"field.displayName | highlight: $select.search\"></div>\n    </ui-select-choices>\n  </ui-select>\n\n  <div class=\"hintbox\" ng-if=\"!indexedFields.length\">\n    <p>\n      <i class=\"fa fa-danger text-danger\"></i>\n      <strong>No Compatible Fields:</strong> The \"{{ vis.indexPattern.title }}\" index pattern does not contain any of the following field types: {{ agg.type.params.byName.field.filterFieldTypes | commaList:false }}\n    </p>\n  </div>\n\n</div>\n"

/***/ }),
/* 2973 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OptionedParamTypeProvider = OptionedParamTypeProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _indexed_array = __webpack_require__(99);

var _base = __webpack_require__(211);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function OptionedParamTypeProvider(Private) {

  var BaseParamType = Private(_base.BaseParamTypeProvider);

  _lodash2.default.class(OptionedParamType).inherits(BaseParamType);
  function OptionedParamType(config) {
    OptionedParamType.Super.call(this, config);

    this.options = new _indexed_array.IndexedArray({
      index: ['val'],
      immutable: true,
      initialSet: this.options
    });
  }

  /**
   * Serialize a selection to be stored in the database
   * @param  {object} selected - the option that was selected
   * @return {any}
   */
  OptionedParamType.prototype.serialize = function (selected) {
    return selected.val;
  };

  /**
   * Take a value that was serialized to the database and
   * return the option that is represents
   *
   * @param  {any} val - the value that was saved
   * @return {object}
   */
  OptionedParamType.prototype.deserialize = function (val) {
    return this.options.byVal[val];
  };

  /**
   * Write the aggregation parameter.
   *
   * @param  {AggConfig} aggConfig - the entire configuration for this agg
   * @param  {object} output - the result of calling write on all of the aggregations
   *                         parameters.
   * @param  {object} output.params - the final object that will be included as the params
   *                               for the agg
   * @return {undefined}
   */
  OptionedParamType.prototype.write = function (aggConfig, output) {
    output.params[this.name] = aggConfig.params[this.name].val;
  };

  return OptionedParamType;
}

/***/ }),
/* 2974 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RegexParamTypeProvider = RegexParamTypeProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _regular_expression = __webpack_require__(2975);

var _regular_expression2 = _interopRequireDefault(_regular_expression);

var _base = __webpack_require__(211);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function RegexParamTypeProvider(Private) {

  var BaseParamType = Private(_base.BaseParamTypeProvider);

  _lodash2.default.class(RegexParamType).inherits(BaseParamType);
  function RegexParamType(config) {
    _lodash2.default.defaults(config, { pattern: '' });
    RegexParamType.Super.call(this, config);
  }

  RegexParamType.prototype.editor = _regular_expression2.default;

  /**
   * Disabled state of the agg param
   *
   * @return {bool}
   */
  RegexParamType.prototype.disabled = function () {
    return false;
  };

  /**
   * Write the aggregation parameter.
   *
   * @param  {AggConfig} aggConfig - the entire configuration for this agg
   * @param  {object} output - the result of calling write on all of the aggregations
   *                         parameters.
   * @param  {object} output.params - the final object that will be included as the params
   *                               for the agg
   * @return {undefined}
   */
  RegexParamType.prototype.write = function (aggConfig, output) {
    var param = aggConfig.params[this.name];
    var paramType = aggConfig.type.params.byName[this.name];

    // clear aggParam if pattern is not set or is disabled
    if (!param || !param.pattern || !param.pattern.length || paramType.disabled(aggConfig)) {
      return;
    }

    var obj = {
      pattern: param.pattern
    };

    output.params[this.name] = obj;
  };

  return RegexParamType;
}

/***/ }),
/* 2975 */
/***/ (function(module, exports) {

module.exports = "<div ng-if=\"!aggParam.disabled(agg)\">\n  <div class=\"form-group regex\">\n    <label for=\"visEditorRegexInput{{agg.id}}{{aggParam.name}}\">{{ aggParam.name | label }} Pattern</label>\n    <input\n      id=\"visEditorRegexInput{{agg.id}}{{aggParam.name}}\"\n      type=\"text\"\n      class=\"form-control\"\n      ng-model=\"agg.params[aggParam.name].pattern\"\n    >\n  </div>\n</div>\n"

/***/ }),
/* 2976 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StringParamTypeProvider = StringParamTypeProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _string = __webpack_require__(2977);

var _string2 = _interopRequireDefault(_string);

var _base = __webpack_require__(211);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function StringParamTypeProvider(Private) {

  var BaseParamType = Private(_base.BaseParamTypeProvider);

  _lodash2.default.class(StringParamType).inherits(BaseParamType);
  function StringParamType(config) {
    StringParamType.Super.call(this, config);
  }

  StringParamType.prototype.editor = _string2.default;

  /**
   * Write the aggregation parameter.
   *
   * @param  {AggConfig} aggConfig - the entire configuration for this agg
   * @param  {object} output - the result of calling write on all of the aggregations
   *                         parameters.
   * @param  {object} output.params - the final object that will be included as the params
   *                               for the agg
   * @return {undefined}
   */
  StringParamType.prototype.write = function (aggConfig, output) {
    if (aggConfig.params[this.name] && aggConfig.params[this.name].length) {
      output.params[this.name] = aggConfig.params[this.name];
    }
  };

  return StringParamType;
}

/***/ }),
/* 2977 */
/***/ (function(module, exports) {

module.exports = "<div class=\"form-group\">\n  <div class=\"euiSpacer euiSpacer--m\"></div>\n\n  <label for=\"visEditorStringInput{{agg.id}}{{aggParam.name}}\">{{ aggParam.name | label }}</label>\n  <div>\n    <input\n      type=\"text\"\n      id=\"visEditorStringInput{{agg.id}}{{aggParam.name}}\"\n      ng-model=\"agg.params[aggParam.name]\"\n      class=\"form-control\"\n    >\n  </div>\n</div>\n"

/***/ }),
/* 2978 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.JsonParamTypeProvider = JsonParamTypeProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _raw_json = __webpack_require__(2979);

var _raw_json2 = _interopRequireDefault(_raw_json);

var _base = __webpack_require__(211);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function JsonParamTypeProvider(Private) {

  var BaseParamType = Private(_base.BaseParamTypeProvider);

  _lodash2.default.class(JsonParamType).inherits(BaseParamType);
  function JsonParamType(config) {
    // force name override
    config = _lodash2.default.defaults(config, { name: 'json' });
    JsonParamType.Super.call(this, config);
  }

  JsonParamType.prototype.editor = _raw_json2.default;

  /**
   * Write the aggregation parameter.
   *
   * @param  {AggConfig} aggConfig - the entire configuration for this agg
   * @param  {object} output - the result of calling write on all of the aggregations
   *                         parameters.
   * @param  {object} output.params - the final object that will be included as the params
   *                               for the agg
   * @return {undefined}
   */
  JsonParamType.prototype.write = function (aggConfig, output) {
    var paramJson = void 0;
    var param = aggConfig.params[this.name];

    if (!param) {
      return;
    }

    // handle invalid Json input
    try {
      paramJson = JSON.parse(param);
    } catch (err) {
      return;
    }

    function filteredCombine(srcA, srcB) {
      function mergeObjs(a, b) {
        return (0, _lodash2.default)(a).keys().union(_lodash2.default.keys(b)).transform(function (dest, key) {
          var val = compare(a[key], b[key]);
          if (val !== undefined) dest[key] = val;
        }, {}).value();
      }

      function mergeArrays(a, b) {
        // attempt to merge each value
        return _lodash2.default.times(Math.max(a.length, b.length), function (i) {
          return compare(a[i], b[i]);
        });
      }

      function compare(a, b) {
        if (_lodash2.default.isPlainObject(a) && _lodash2.default.isPlainObject(b)) return mergeObjs(a, b);
        if (Array.isArray(a) && Array.isArray(b)) return mergeArrays(a, b);
        if (b === null) return undefined;
        if (b !== undefined) return b;
        return a;
      }

      return compare(srcA, srcB);
    }

    output.params = filteredCombine(output.params, paramJson);
    return;
  };

  return JsonParamType;
}

/***/ }),
/* 2979 */
/***/ (function(module, exports) {

module.exports = "<div class=\"form-group regex\">\n    <span class=\"hintbox-label\">\n      <label for=\"visEditorRawJson{{agg.id}}\">\n        JSON Input\n        <kbn-info\n          placement=\"right\"\n          info='Any JSON formatted properties you add here will be merged with the elasticsearch aggregation definition for this section. For example \"shard_size\" on a terms aggregation.'>\n        </kbn-info>\n      </label>\n    </span>\n  <p>\n    <textarea\n      type=\"text\"\n      id=\"visEditorRawJson{{agg.id}}\"\n      class=\"form-control\"\n      ng-model=\"agg.params.json\"\n      validate-json\n      ></textarea>\n  </p>\n</div>\n"

/***/ }),
/* 2980 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PointSeriesInitYAxisProvider = PointSeriesInitYAxisProvider;
function PointSeriesInitYAxisProvider() {

  return function initYAxis(chart) {
    var y = chart.aspects.y;

    if (Array.isArray(y)) {
      // TODO: vis option should allow choosing this format
      chart.yAxisFormatter = y[0].agg.fieldFormatter();
      chart.yAxisLabel = ''; // use the legend
    } else {
      chart.yAxisFormatter = y.agg.fieldFormatter();
      chart.yAxisLabel = y.col.title;
    }

    var z = chart.aspects.series;
    if (z) {
      if (Array.isArray(z)) {
        chart.zAxisFormatter = z[0].agg.fieldFormatter();
        chart.zAxisLabel = ''; // use the legend
      } else {
        chart.zAxisFormatter = z.agg.fieldFormatter();
        chart.zAxisLabel = z.col.title;
      }
    }
  };
}

/***/ }),
/* 2981 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PointSeriesInitXAxisProvider = PointSeriesInitXAxisProvider;
function PointSeriesInitXAxisProvider() {
  return function initXAxis(chart) {
    var x = chart.aspects.x;
    chart.xAxisFormatter = x.agg ? x.agg.fieldFormatter() : String;
    chart.xAxisLabel = x.col.title;

    if (!x.agg || !x.agg.type.ordered) return;

    chart.indexPattern = x.agg.vis.indexPattern;
    chart.xAxisField = x.agg.params.field;

    chart.ordered = {};
    var xAggOutput = x.agg.write();
    if (xAggOutput.params.interval) {
      chart.ordered.interval = xAggOutput.params.interval;
    }
  };
}

/***/ }),
/* 2982 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PointSeriesOrderedDateAxisProvider = PointSeriesOrderedDateAxisProvider;

var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function PointSeriesOrderedDateAxisProvider() {

  return function orderedDateAxis(vis, chart) {
    var xAgg = chart.aspects.x.agg;
    var buckets = xAgg.buckets;
    var format = buckets.getScaledDateFormat();

    chart.xAxisFormatter = function (val) {
      return (0, _moment2.default)(val).format(format);
    };

    chart.ordered = {
      date: true,
      interval: buckets.getInterval()
    };

    var axisOnTimeField = xAgg.fieldIsTimeField();
    var bounds = buckets.getBounds();
    if (bounds && axisOnTimeField) {
      chart.ordered.min = bounds.min;
      chart.ordered.max = bounds.max;
    } else {
      chart.ordered.endzones = false;
    }
  };
}

/***/ }),
/* 2983 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PointSeriesTooltipFormatter = PointSeriesTooltipFormatter;

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function PointSeriesTooltipFormatter($compile, $rootScope) {

  var $tooltipScope = $rootScope.$new();
  var $tooltip = (0, _jquery2.default)(__webpack_require__(2984));
  $compile($tooltip)($tooltipScope);

  return function tooltipFormatter(event) {
    var datum = event.datum;
    if (!datum || !datum.aggConfigResult) return '';

    var details = $tooltipScope.details = [];
    var result = { $parent: datum.aggConfigResult };

    function addDetail(result) {
      var agg = result.aggConfig;
      var value = result.value;

      var detail = {
        value: agg.fieldFormatter()(value),
        label: agg.makeLabel()
      };

      if (agg === datum.aggConfigResult.aggConfig) {
        detail.percent = event.percent;
        if (datum.yScale != null) {
          detail.value = agg.fieldFormatter()(value * datum.yScale);
        }
      }

      details.push(detail);
    }

    datum.extraMetrics.forEach(addDetail);
    while ((result = result.$parent) && result.aggConfig) {
      addDetail(result);
    }

    $tooltipScope.$apply();
    return $tooltip[0].outerHTML;
  };
}

/***/ }),
/* 2984 */
/***/ (function(module, exports) {

module.exports = "<table>\n  <tbody>\n    <tr ng-repeat=\"detail in details\" >\n      <td class=\"tooltip-label\">{{detail.label}}</td>\n      <td class=\"tooltip-value\">\n          {{detail.value}}\n          <span ng-if=\"detail.percent\"> ({{detail.percent}})</span>\n      </td>\n    </tr>\n  </tbody>\n</table>\n"

/***/ }),
/* 2985 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VislibProvider = VislibProvider;

__webpack_require__(932);

__webpack_require__(933);

__webpack_require__(934);

__webpack_require__(935);

__webpack_require__(530);

__webpack_require__(939);

__webpack_require__(942);

var _vis = __webpack_require__(3025);

// prefetched for faster optimization runs
// end prefetching

/**
 * Provides the Kibana4 Visualization Library
 *
 * @module vislib
 * @main vislib
 * @return {Object} Contains the version number and the Vis Class for creating visualizations
 */
function VislibProvider(Private) {
  return {
    version: '0.0.0',
    Vis: Private(_vis.VislibVisProvider)
  };
}

/***/ }),
/* 2986 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vislibGaugeProvider = vislibGaugeProvider;
function vislibGaugeProvider() {

  return function (config) {
    return config;
  };
}

/***/ }),
/* 2987 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VislibLibLayoutTypesColumnLayoutProvider = VislibLibLayoutTypesColumnLayoutProvider;

var _chart_split = __webpack_require__(2988);

var _y_axis_split = __webpack_require__(2989);

var _x_axis_split = __webpack_require__(2990);

var _chart_title_split = __webpack_require__(2991);

function VislibLibLayoutTypesColumnLayoutProvider(Private) {
  var chartSplit = Private(_chart_split.VislibLibLayoutSplitsColumnChartChartSplitProvider);
  var yAxisSplit = Private(_y_axis_split.VislibLibLayoutSplitsColumnChartYAxisSplitProvider);
  var xAxisSplit = Private(_x_axis_split.VislibLibLayoutSplitsColumnChartXAxisSplitProvider);
  var chartTitleSplit = Private(_chart_title_split.VislibLibLayoutSplitsColumnChartChartTitleSplitProvider);

  /**
   * Specifies the visualization layout for column charts.
   *
   * This is done using an array of objects. The first object has
   * a `parent` DOM element,  a DOM `type` (e.g. div, svg, etc),
   * and a `class` (required). Each child can omit the parent object,
   * but must include a type and class.
   *
   * Optionally, you can specify `datum` to be bound to the DOM
   * element, a `splits` function that divides the selected element
   * into more DOM elements based on a callback function provided, or
   * a children array which nests other layout objects.
   *
   * Objects in children arrays are children of the current object and return
   * DOM elements which are children of their respective parent element.
   */

  return function (el, data) {
    if (!el || !data) {
      throw new Error('Both an el and data need to be specified');
    }

    return [{
      parent: el,
      type: 'div',
      class: 'vis-wrapper',
      datum: data,
      children: [{
        type: 'div',
        class: 'y-axis-col-wrapper',
        children: [{
          type: 'div',
          class: 'y-axis-spacer-block y-axis-spacer-block-top'
        }, {
          type: 'div',
          class: 'y-axis-col axis-wrapper-left',
          children: [{
            type: 'div',
            class: 'y-axis-chart-title',
            splits: chartTitleSplit
          }, {
            type: 'div',
            class: 'y-axis-div-wrapper',
            splits: yAxisSplit
          }]
        }, {
          type: 'div',
          class: 'y-axis-spacer-block y-axis-spacer-block-bottom'
        }]
      }, {
        type: 'div',
        class: 'vis-col-wrapper',
        children: [{
          type: 'div',
          class: 'x-axis-wrapper axis-wrapper-top',
          children: [{
            type: 'div',
            class: 'x-axis-div-wrapper',
            splits: xAxisSplit
          }]
        }, {
          type: 'div',
          class: 'chart-wrapper',
          splits: chartSplit
        }, {
          type: 'div',
          class: 'vis-alerts'
        }, {
          type: 'div',
          class: 'x-axis-wrapper axis-wrapper-bottom',
          children: [{
            type: 'div',
            class: 'x-axis-div-wrapper',
            splits: xAxisSplit
          }, {
            type: 'div',
            class: 'x-axis-chart-title',
            splits: chartTitleSplit
          }]
        }]
      }, {
        type: 'div',
        class: 'y-axis-col-wrapper',
        children: [{
          type: 'div',
          class: 'y-axis-spacer-block y-axis-spacer-block-top'
        }, {
          type: 'div',
          class: 'y-axis-col axis-wrapper-right',
          children: [{
            type: 'div',
            class: 'y-axis-div-wrapper',
            splits: yAxisSplit
          }]
        }, {
          type: 'div',
          class: 'y-axis-spacer-block y-axis-spacer-block-bottom'
        }]
      }]
    }];
  };
}

/***/ }),
/* 2988 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VislibLibLayoutSplitsColumnChartChartSplitProvider = VislibLibLayoutSplitsColumnChartChartSplitProvider;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function VislibLibLayoutSplitsColumnChartChartSplitProvider() {
  /*
   * Adds div DOM elements to the `.chart-wrapper` element based on the data layout.
   * For example, if the data has rows, it returns the same number of
   * `.chart` elements as row objects.
   */
  return function split(selection, parent) {
    selection.each(function (data) {
      var div = _d2.default.select(this).attr('class', function () {
        if (data.rows) {
          return 'chart-wrapper-row';
        } else if (data.columns) {
          return 'chart-wrapper-column';
        } else {
          if (parent) {
            return 'chart-first chart-last chart-wrapper';
          }
          return this.className + ' chart-wrapper';
        }
      });
      var divClass = '';
      var chartsNumber = void 0;

      var charts = div.selectAll('charts').append('div').data(function (d) {
        if (d.rows) {
          chartsNumber = d.rows.length;
          return d.rows;
        } else if (d.columns) {
          chartsNumber = d.columns.length;
          return d.columns;
        } else {
          divClass = 'chart';
          chartsNumber = 1;
          return [d];
        }
      }).enter().append('div').attr('class', function (d, i) {
        var fullDivClass = divClass;
        if (fullDivClass !== 'chart') {
          if (chartsNumber > 1) {
            if (i === 0) {
              fullDivClass += ' chart-first';
            } else if (i === chartsNumber - 1) {
              fullDivClass += ' chart-last';
            }
          } else {
            fullDivClass += ' chart-first chart-last';
          }
        }
        return fullDivClass;
      });

      if (!data.series) {
        charts.call(split);
      }
    });
  };
}

/***/ }),
/* 2989 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VislibLibLayoutSplitsColumnChartYAxisSplitProvider = VislibLibLayoutSplitsColumnChartYAxisSplitProvider;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function VislibLibLayoutSplitsColumnChartYAxisSplitProvider() {
  /*
   * Adds div DOM elements to the `.y-axis-div-wrapper` element based on the data layout.
   * For example, if the data has rows, it returns the same number of
   * `.y-axis-div` elements as row objects.
   */

  // render and get bounding box width
  return function (selection) {

    selection.each(function () {
      var div = _d2.default.select(this);
      var rows = void 0;

      div.selectAll('.y-axis-div').append('div').data(function (d) {
        rows = d.rows ? d.rows.length : 1;
        return d.rows ? d.rows : [d];
      }).enter().append('div').attr('class', function (d, i) {
        var divClass = '';
        if (i === 0) {
          divClass += ' chart-first';
        }
        if (i === rows - 1) {
          divClass += ' chart-last';
        }
        return 'y-axis-div axis-div' + divClass;
      });
    });
  };
}

/***/ }),
/* 2990 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VislibLibLayoutSplitsColumnChartXAxisSplitProvider = VislibLibLayoutSplitsColumnChartXAxisSplitProvider;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function VislibLibLayoutSplitsColumnChartXAxisSplitProvider() {
  /*
   * Adds div DOM elements to the `.x-axis-div-wrapper` element based on the data layout.
   * For example, if the data has rows, it returns the same number of
   * `.x-axis-div` elements as row objects.
   */

  return function (selection) {
    selection.each(function () {
      var div = _d2.default.select(this);
      var columns = void 0;
      div.selectAll('.x-axis-div').append('div').data(function (d) {
        columns = d.columns ? d.columns.length : 1;
        return d.columns ? d.columns : [d];
      }).enter().append('div').attr('class', function (d, i) {
        var divClass = '';
        if (i === 0) {
          divClass += ' chart-first';
        }
        if (i === columns - 1) {
          divClass += ' chart-last';
        }
        return 'x-axis-div axis-div' + divClass;
      });
    });
  };
}

/***/ }),
/* 2991 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VislibLibLayoutSplitsColumnChartChartTitleSplitProvider = VislibLibLayoutSplitsColumnChartChartTitleSplitProvider;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function VislibLibLayoutSplitsColumnChartChartTitleSplitProvider() {
  /*
   * Adds div DOM elements to either the `.y-axis-chart-title` element or the
   * `.x-axis-chart-title` element based on the data layout.
   * For example, if the data has rows, it returns the same number of
   * `.chart-title` elements as row objects.
   * if not data.rows or data.columns, return no chart titles
   */
  return function (selection) {
    selection.each(function (data) {
      var div = _d2.default.select(this);
      var parent = (0, _jquery2.default)(this).parents('.vis-wrapper');

      if (!data.series) {
        div.selectAll('.chart-title').data(function (d) {
          return d.rows ? d.rows : d.columns;
        }).enter().append('div').attr('class', 'chart-title');

        if (data.rows) {
          parent.find('.x-axis-chart-title').remove();
        } else {
          parent.find('.y-axis-chart-title').remove();
        }

        return div;
      }

      return _d2.default.select(this).remove();
    });
  };
}

/***/ }),
/* 2992 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VislibLibLayoutTypesPieLayoutProvider = VislibLibLayoutTypesPieLayoutProvider;

var _chart_split = __webpack_require__(2993);

var _chart_title_split = __webpack_require__(2994);

function VislibLibLayoutTypesPieLayoutProvider(Private) {
  var chartSplit = Private(_chart_split.VislibLibLayoutSplitsPieChartChartSplitProvider);
  var chartTitleSplit = Private(_chart_title_split.VislibLibLayoutSplitsPieChartChartTitleSplitProvider);

  /**
   * Specifies the visualization layout for column charts.
   *
   * This is done using an array of objects. The first object has
   * a `parent` DOM element,  a DOM `type` (e.g. div, svg, etc),
   * and a `class` (required). Each child can omit the parent object,
   * but must include a type and class.
   *
   * Optionally, you can specify `datum` to be bound to the DOM
   * element, a `splits` function that divides the selected element
   * into more DOM elements based on a callback function provided, or
   * a children array which nests other layout objects.
   *
   * Objects in children arrays are children of the current object and return
   * DOM elements which are children of their respective parent element.
   */

  return function (el, data) {
    if (!el || !data) {
      throw new Error('Both an el and data need to be specified');
    }

    return [{
      parent: el,
      type: 'div',
      class: 'vis-wrapper',
      datum: data,
      children: [{
        type: 'div',
        class: 'y-axis-chart-title',
        splits: chartTitleSplit
      }, {
        type: 'div',
        class: 'vis-col-wrapper',
        children: [{
          type: 'div',
          class: 'chart-wrapper',
          splits: chartSplit
        }, {
          type: 'div',
          class: 'x-axis-chart-title',
          splits: chartTitleSplit
        }]
      }]
    }];
  };
}

/***/ }),
/* 2993 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VislibLibLayoutSplitsPieChartChartSplitProvider = VislibLibLayoutSplitsPieChartChartSplitProvider;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function VislibLibLayoutSplitsPieChartChartSplitProvider() {
  /*
   * Adds div DOM elements to the `.chart-wrapper` element based on the data layout.
   * For example, if the data has rows, it returns the same number of
   * `.chart` elements as row objects.
   */

  return function split(selection) {
    selection.each(function (data) {
      var div = _d2.default.select(this).attr('class', function () {
        if (data.rows) {
          return 'chart-wrapper-row';
        } else if (data.columns) {
          return 'chart-wrapper-column';
        } else {
          return 'chart-wrapper';
        }
      });
      var divClass = void 0;

      var charts = div.selectAll('charts').append('div').data(function (d) {
        if (d.rows) {
          divClass = 'chart-row';
          return d.rows;
        } else if (d.columns) {
          divClass = 'chart-column';
          return d.columns;
        } else {
          divClass = 'chart';
          return [d];
        }
      }).enter().append('div').attr('class', function () {
        return divClass;
      });

      if (!data.slices) {
        charts.call(split);
      }
    });
  };
}

/***/ }),
/* 2994 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VislibLibLayoutSplitsPieChartChartTitleSplitProvider = VislibLibLayoutSplitsPieChartChartTitleSplitProvider;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function VislibLibLayoutSplitsPieChartChartTitleSplitProvider() {
  /*
   * Adds div DOM elements to either the `.y-axis-chart-title` element or the
   * `.x-axis-chart-title` element based on the data layout.
   * For example, if the data has rows, it returns the same number of
   * `.chart-title` elements as row objects.
   * if not data.rows or data.columns, return no chart titles
   */

  return function (selection, parent) {
    selection.each(function (data) {
      var div = _d2.default.select(this);

      if (!data.slices) {
        div.selectAll('.chart-title').append('div').data(function (d) {
          return d.rows ? d.rows : d.columns;
        }).enter().append('div').attr('class', 'chart-title');

        if (data.rows) {
          _d2.default.select(parent).select('.x-axis-chart-title').remove();
        } else {
          _d2.default.select(parent).select('.y-axis-chart-title').remove();
        }

        return div;
      }

      return _d2.default.select(this).remove();
    });
  };
}

/***/ }),
/* 2995 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GaugeLayoutProvider = GaugeLayoutProvider;

var _chart_split = __webpack_require__(2996);

var _chart_split2 = _interopRequireDefault(_chart_split);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//import VislibLibLayoutSplitsPieChartChartTitleSplitProvider from '../splits/gauge_chart/chart_title_split';
function GaugeLayoutProvider(Private) {
  var chartSplit = Private(_chart_split2.default);
  //const chartTitleSplit = Private(VislibLibLayoutSplitsPieChartChartTitleSplitProvider);

  /**
   * Specifies the visualization layout for column charts.
   *
   * This is done using an array of objects. The first object has
   * a `parent` DOM element,  a DOM `type` (e.g. div, svg, etc),
   * and a `class` (required). Each child can omit the parent object,
   * but must include a type and class.
   *
   * Optionally, you can specify `datum` to be bound to the DOM
   * element, a `splits` function that divides the selected element
   * into more DOM elements based on a callback function provided, or
   * a children array which nests other layout objects.
   *
   * Objects in children arrays are children of the current object and return
   * DOM elements which are children of their respective parent element.
   */

  return function (el, data) {
    if (!el || !data) {
      throw new Error('Both an el and data need to be specified');
    }

    return [{
      parent: el,
      type: 'div',
      class: 'vis-wrapper',
      datum: data,
      children: [{
        type: 'div',
        class: 'y-axis-chart-title'
        //splits: chartTitleSplit
      }, {
        type: 'div',
        class: 'vis-col-wrapper',
        children: [{
          type: 'div',
          class: 'chart-wrapper',
          splits: chartSplit
        }, {
          type: 'div',
          class: 'vis-alerts'
        }, {
          type: 'div',
          class: 'x-axis-chart-title'
          //splits: chartTitleSplit
        }]
      }]
    }];
  };
}

/***/ }),
/* 2996 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ChartSplitFactory;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line @elastic/kibana-custom/no-default-export
function ChartSplitFactory() {

  /*
   * Adds div DOM elements to the `.chart-wrapper` element based on the data layout.
   * For example, if the data has rows, it returns the same number of
   * `.chart` elements as row objects.
   */

  return function split(selection) {
    selection.each(function (data) {
      var div = _d2.default.select(this).attr('class', function () {
        if (data.rows) {
          return 'chart-wrapper-row';
        } else if (data.columns) {
          return 'chart-wrapper-column';
        } else {
          return 'chart-wrapper';
        }
      });
      var divClass = void 0;

      var charts = div.selectAll('charts').append('div').data(function (d) {
        if (d.rows) {
          divClass = 'chart-row';
          return d.rows;
        } else if (d.columns) {
          divClass = 'chart-column';
          return d.columns;
        } else {
          divClass = 'chart';
          return [d];
        }
      }).enter().append('div').attr('class', function () {
        return divClass;
      });

      if (!data.series) {
        charts.call(split);
      }
    });
  };
}
module.exports = exports['default'];

/***/ }),
/* 2997 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VislibComponentsZeroInjectionInjectZerosProvider = VislibComponentsZeroInjectionInjectZerosProvider;

var _ordered_x_keys = __webpack_require__(936);

var _zero_filled_array = __webpack_require__(3000);

var _zero_fill_data_array = __webpack_require__(3001);

function VislibComponentsZeroInjectionInjectZerosProvider(Private) {

  var orderXValues = Private(_ordered_x_keys.VislibComponentsZeroInjectionOrderedXKeysProvider);
  var createZeroFilledArray = Private(_zero_filled_array.VislibComponentsZeroInjectionZeroFilledArrayProvider);
  var zeroFillDataArray = Private(_zero_fill_data_array.VislibComponentsZeroInjectionZeroFillDataArrayProvider);

  /*
   * A Kibana data object may have multiple series with different array lengths.
   * This proves an impediment to stacking in the visualization library.
   * Therefore, zero values must be injected wherever these arrays do not line up.
   * That is, each array must have the same x values with zeros filled in where the
   * x values were added.
   *
   * This function and its helper functions accepts a Kibana data object
   * and injects zeros where needed.
   */

  return function (obj, data) {
    var orderBucketsBySum = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    var keys = orderXValues(data, orderBucketsBySum);

    obj.forEach(function (series) {
      var zeroArray = createZeroFilledArray(keys, series.label);
      series.values = zeroFillDataArray(zeroArray, series.values);
    });

    return obj;
  };
}

/***/ }),
/* 2998 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VislibComponentsZeroInjectionUniqKeysProvider = VislibComponentsZeroInjectionUniqKeysProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _flatten_data = __webpack_require__(2999);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function VislibComponentsZeroInjectionUniqKeysProvider(Private) {

  var flattenDataArray = Private(_flatten_data.VislibComponentsZeroInjectionFlattenDataProvider);

  /*
   * Accepts a Kibana data object.
   * Returns an object with unique x axis values as keys with an object of
   * their index numbers and an isNumber boolean as their values.
   * e.g. { 'xAxisValue': { index: 1, isNumber: false }}, ...
   */

  return function (obj) {
    if (!_lodash2.default.isObject(obj)) {
      throw new TypeError('UniqueXValuesUtilService expects an object');
    }

    var flattenedData = flattenDataArray(obj);
    var uniqueXValues = new Map();

    var charts = void 0;
    if (!obj.series) {
      charts = obj.rows ? obj.rows : obj.columns;
    } else {
      charts = [obj];
    }

    var isDate = charts.every(function (chart) {
      return chart.ordered && chart.ordered.date;
    });

    var isOrdered = charts.every(function (chart) {
      return chart.ordered;
    });

    flattenedData.forEach(function (d, i) {
      var key = d.x;
      var prev = uniqueXValues.get(key);
      var sum = d.y;

      if (prev) {
        i = Math.min(i, prev.index);
        sum += prev.sum;
      }

      uniqueXValues.set(key, {
        index: i,
        isDate: isDate,
        isOrdered: isOrdered,
        isNumber: _lodash2.default.isNumber(key),
        sum: sum
      });
    });

    return uniqueXValues;
  };
}

/***/ }),
/* 2999 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VislibComponentsZeroInjectionFlattenDataProvider = VislibComponentsZeroInjectionFlattenDataProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function VislibComponentsZeroInjectionFlattenDataProvider() {

  /*
   * Accepts a Kibana data object, flattens the data.series values array,
   * and returns an array of values objects.
   */

  return function (obj) {
    var charts = void 0;

    if (!_lodash2.default.isObject(obj) || !obj.rows && !obj.columns && !obj.series) {
      throw new TypeError('FlattenDataObjUtilService expects an object with a series, rows, or columns key');
    }

    if (!obj.series) {
      charts = obj.rows ? obj.rows : obj.columns;
    }

    return (0, _lodash2.default)(charts ? charts : [obj]).pluck('series').flattenDeep().pluck('values').flattenDeep().filter(Boolean).value();
  };
}

/***/ }),
/* 3000 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VislibComponentsZeroInjectionZeroFilledArrayProvider = VislibComponentsZeroInjectionZeroFilledArrayProvider;
function VislibComponentsZeroInjectionZeroFilledArrayProvider() {
  /*
   * Accepts an array of x axis values (strings or numbers).
   * Returns a zero filled array.
  */

  return function (arr, label) {
    if (!Array.isArray(arr)) {
      throw new Error('ZeroFilledArrayUtilService expects an array of strings or numbers');
    }

    var zeroFilledArray = [];

    arr.forEach(function (val) {
      zeroFilledArray.push({
        x: val,
        xi: Infinity,
        y: 0,
        series: label
      });
    });

    return zeroFilledArray;
  };
}

/***/ }),
/* 3001 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VislibComponentsZeroInjectionZeroFillDataArrayProvider = VislibComponentsZeroInjectionZeroFillDataArrayProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function VislibComponentsZeroInjectionZeroFillDataArrayProvider() {

  /*
   * Accepts an array of zero-filled y value objects (arr1)
   * and a kibana data.series[i].values array of objects (arr2).
   * Return a zero-filled array of objects (arr1).
   */

  return function (arr1, arr2) {
    if (!Array.isArray(arr1) || !Array.isArray(arr2)) {
      throw new TypeError('ZeroFillDataArrayUtilService expects 2 arrays');
    }

    var i = void 0;
    var val = void 0;
    var index = void 0;
    var max = arr2.length;

    var getX = function getX(d) {
      return d.x === val.x;
    };

    for (i = 0; i < max; i++) {
      val = arr2[i];
      index = _lodash2.default.findIndex(arr1, getX);
      arr1.splice(index, 1, val);
    }

    return arr1;
  };
}

/***/ }),
/* 3002 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VislibComponentsLabelsLabelsProvider = VislibComponentsLabelsLabelsProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _data_array = __webpack_require__(3003);

var _uniq_labels = __webpack_require__(3005);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function VislibComponentsLabelsLabelsProvider(Private) {

  var createArr = Private(_data_array.VislibComponentsLabelsDataArrayProvider);
  var getArrOfUniqLabels = Private(_uniq_labels.VislibComponentsLabelsUniqLabelsProvider);

  /*
   * Accepts a Kibana data object and returns an array of unique labels (strings).
   * Extracts the field formatter from the raw object and passes it to the
   * getArrOfUniqLabels function.
   *
   * Currently, this service is only used for vertical bar charts and line charts.
   */
  return function (obj) {
    if (!_lodash2.default.isObject(obj)) {
      throw new TypeError('LabelUtil expects an object');
    }
    return getArrOfUniqLabels(createArr(obj));
  };
}

/***/ }),
/* 3003 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VislibComponentsLabelsDataArrayProvider = VislibComponentsLabelsDataArrayProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _flatten_series = __webpack_require__(3004);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function VislibComponentsLabelsDataArrayProvider(Private) {
  var flattenSeries = Private(_flatten_series.VislibComponentsLabelsFlattenSeriesProvider);

  /*
   * Accepts a Kibana data object and returns an array of values objects.
  */
  return function (obj) {
    if (!_lodash2.default.isObject(obj) || !obj.rows && !obj.columns && !obj.series) {
      throw new TypeError('GetArrayUtilService expects an object with a series, rows, or columns key');
    }

    if (!obj.series) return flattenSeries(obj);
    return obj.series;
  };
}

/***/ }),
/* 3004 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VislibComponentsLabelsFlattenSeriesProvider = VislibComponentsLabelsFlattenSeriesProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function VislibComponentsLabelsFlattenSeriesProvider() {

  /*
   * Accepts a Kibana data object with a rows or columns key
   * and returns an array of flattened series values.
   */
  return function (obj) {
    if (!_lodash2.default.isObject(obj) || !obj.rows && !obj.columns) {
      throw new TypeError('GetSeriesUtilService expects an object with either a rows or columns key');
    }

    obj = obj.rows ? obj.rows : obj.columns;

    return _lodash2.default.chain(obj).pluck('series').flattenDeep().value();
  };
}

/***/ }),
/* 3005 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VislibComponentsLabelsUniqLabelsProvider = VislibComponentsLabelsUniqLabelsProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function VislibComponentsLabelsUniqLabelsProvider() {

  /*
   * Accepts an array of data objects and a formatter function.
   * Returns a unique list of formatted labels (strings).
   */
  return function (arr) {
    if (!Array.isArray(arr)) {
      throw new TypeError('UniqLabelUtil expects an array of objects');
    }

    return (0, _lodash2.default)(arr).pluck('label').unique().value();
  };
}

/***/ }),
/* 3006 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VislibComponentsColorColorProvider = VislibComponentsColorColorProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _mapped_colors = __webpack_require__(3007);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function VislibComponentsColorColorProvider(Private) {
  var mappedColors = Private(_mapped_colors.VisColorMappedColorsProvider);

  /*
   * Accepts an array of strings or numbers that are used to create a
   * a lookup table that associates the values (key) with a hex color (value).
   * Returns a function that accepts a value (i.e. a string or number)
   * and returns a hex color associated with that value.
   */

  return function (arrayOfStringsOrNumbers, colorMapping) {
    colorMapping = colorMapping || {};
    if (!Array.isArray(arrayOfStringsOrNumbers)) {
      throw new Error('ColorUtil expects an array');
    }

    arrayOfStringsOrNumbers.forEach(function (val) {
      if (!_lodash2.default.isString(val) && !_lodash2.default.isNumber(val) && !_lodash2.default.isUndefined(val)) {
        throw new TypeError('ColorUtil expects an array of strings, numbers, or undefined values');
      }
    });

    mappedColors.mapKeys(arrayOfStringsOrNumbers);

    return function (value) {
      return colorMapping[value] || mappedColors.get(value);
    };
  };
}

/***/ }),
/* 3007 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.VisColorMappedColorsProvider = VisColorMappedColorsProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

var _color_palette = __webpack_require__(937);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function VisColorMappedColorsProvider(config, $rootScope) {
  var standardizeColor = function standardizeColor(color) {
    return _d2.default.rgb(color).toString();
  };
  function getConfigColorMapping() {
    return _lodash2.default.mapValues(config.get('visualization:colorMapping'), standardizeColor);
  }

  /*
   * Maintains a lookup table that associates the value (key) with a hex color (value)
   * across the visualizations.
   * Provides functions to interact with the lookup table
   */

  var MappedColors = function () {
    function MappedColors() {
      var _this = this;

      _classCallCheck(this, MappedColors);

      $rootScope.$on('$routeChangeStart', function () {
        return _this.purge();
      });
      this.oldMap = {};
      this.mapping = {};
    }

    _createClass(MappedColors, [{
      key: 'get',
      value: function get(key) {
        return getConfigColorMapping()[key] || this.mapping[key];
      }
    }, {
      key: 'flush',
      value: function flush() {
        this.oldMap = _lodash2.default.clone(this.mapping);
        this.mapping = {};
      }
    }, {
      key: 'purge',
      value: function purge() {
        this.oldMap = {};
        this.mapping = {};
      }
    }, {
      key: 'mapKeys',
      value: function mapKeys(keys) {
        var _this2 = this;

        var configMapping = getConfigColorMapping();
        var configColors = _lodash2.default.values(configMapping);
        var oldColors = _lodash2.default.values(this.oldMap);

        var keysToMap = [];
        _lodash2.default.each(keys, function (key) {
          // If this key is mapped in the config, it's unnecessary to have it mapped here
          if (configMapping[key]) delete _this2.mapping[key];

          // If this key is mapped to a color used by the config color mapping, we need to remap it
          if (_lodash2.default.contains(configColors, _this2.mapping[key])) keysToMap.push(key);

          // if key exist in oldMap, move it to mapping
          if (_this2.oldMap[key]) _this2.mapping[key] = _this2.oldMap[key];

          // If this key isn't mapped, we need to map it
          if (_this2.get(key) == null) keysToMap.push(key);
        });

        // Generate a color palette big enough that all new keys can have unique color values
        var allColors = (0, _lodash2.default)(this.mapping).values().union(configColors).union(oldColors).value();
        var colorPalette = (0, _color_palette.createColorPalette)(allColors.length + keysToMap.length);
        var newColors = _lodash2.default.difference(colorPalette, allColors);

        while (keysToMap.length > newColors.length) {
          newColors = newColors.concat(_lodash2.default.sample(allColors, keysToMap.length - newColors.length));
        }

        _lodash2.default.merge(this.mapping, _lodash2.default.zipObject(keysToMap, newColors));
      }
    }]);

    return MappedColors;
  }();

  return new MappedColors();
}

/***/ }),
/* 3008 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.VislibVisualizationsPointSeriesProvider = VislibVisualizationsPointSeriesProvider;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

var _tooltip = __webpack_require__(531);

var _chart = __webpack_require__(532);

var _time_marker = __webpack_require__(3014);

var _series_types = __webpack_require__(3015);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function VislibVisualizationsPointSeriesProvider(Private) {

  var Chart = Private(_chart.VislibVisualizationsChartProvider);
  var Tooltip = Private(_tooltip.TooltipProvider);
  var TimeMarker = Private(_time_marker.VislibVisualizationsTimeMarkerProvider);
  var seriTypes = Private(_series_types.VislibVisualizationsSeriesTypesProvider);
  var touchdownTmpl = _lodash2.default.template(__webpack_require__(3020));
  /**
   * Line Chart Visualization
   *
   * @class PointSeries
   * @constructor
   * @extends Chart
   * @param handler {Object} Reference to the Handler Class Constructor
   * @param el {HTMLElement} HTML element to which the chart will be appended
   * @param chartData {Object} Elasticsearch query results for this specific chart
   */

  var PointSeries = function (_Chart) {
    _inherits(PointSeries, _Chart);

    function PointSeries(handler, chartEl, chartData) {
      _classCallCheck(this, PointSeries);

      var _this = _possibleConstructorReturn(this, (PointSeries.__proto__ || Object.getPrototypeOf(PointSeries)).call(this, handler, chartEl, chartData));

      _this.handler = handler;
      _this.chartData = chartData;
      _this.chartEl = chartEl;
      _this.chartConfig = _this.findChartConfig();
      _this.handler.pointSeries = _this;
      return _this;
    }

    _createClass(PointSeries, [{
      key: 'findChartConfig',
      value: function findChartConfig() {
        var charts = this.handler.visConfig.get('charts');
        var chartIndex = this.handler.data.chartData().indexOf(this.chartData);
        return charts[chartIndex];
      }
    }, {
      key: 'getSeries',
      value: function getSeries(seriesId) {
        return this.series.find(function (series) {
          return series.chartData.aggId === seriesId;
        });
      }
    }, {
      key: 'addBackground',
      value: function addBackground(svg, width, height) {
        var startX = 0;
        var startY = 0;

        return svg.append('rect').attr('x', startX).attr('y', startY).attr('width', width).attr('height', height).attr('fill', 'transparent').attr('class', 'background');
      }
    }, {
      key: 'addGrid',
      value: function addGrid(svg) {
        var _svg$node$getBBox = svg.node().getBBox(),
            width = _svg$node$getBBox.width,
            height = _svg$node$getBBox.height;

        return svg.append('g').attr('class', 'grid').call(this.handler.grid.draw(width, height));
      }
    }, {
      key: 'addClipPath',
      value: function addClipPath(svg) {
        var _svg$node$getBBox2 = svg.node().getBBox(),
            width = _svg$node$getBBox2.width,
            height = _svg$node$getBBox2.height;

        var startX = 0;
        var startY = 0;
        this.clipPathId = 'chart-area' + _lodash2.default.uniqueId();

        // Creating clipPath
        return svg.append('clipPath').attr('id', this.clipPathId).append('rect').attr('x', startX).attr('y', startY).attr('width', width).attr('height', height);
      }
    }, {
      key: 'addEvents',
      value: function addEvents(svg) {
        var isBrushable = this.events.isBrushable();
        if (isBrushable) {
          var brush = this.events.addBrushEvent(svg);
          return svg.call(brush);
        }
      }
    }, {
      key: 'createEndZones',
      value: function createEndZones(svg) {
        var self = this;
        var xAxis = this.handler.categoryAxes[0];
        var xScale = xAxis.getScale();
        var ordered = xAxis.ordered;
        var isHorizontal = xAxis.axisConfig.isHorizontal();
        var missingMinMax = !ordered || _lodash2.default.isUndefined(ordered.min) || _lodash2.default.isUndefined(ordered.max);

        if (missingMinMax || ordered.endzones === false) return;

        var _svg$node$getBBox3 = svg.node().getBBox(),
            width = _svg$node$getBBox3.width,
            height = _svg$node$getBBox3.height;

        // we don't want to draw endzones over our min and max values, they
        // are still a part of the dataset. We want to start the endzones just
        // outside of them so we will use these values rather than ordered.min/max


        var oneUnit = (ordered.units || _lodash2.default.identity)(1);

        var drawInverted = isHorizontal || xAxis.axisConfig.get('scale.inverted', false);
        var size = isHorizontal ? width : height;
        // points on this axis represent the amount of time they cover,
        // so draw the endzones at the actual time bounds
        var leftEndzone = {
          x: drawInverted ? 0 : Math.max(xScale(ordered.min), 0),
          w: drawInverted ? Math.max(xScale(ordered.min), 0) : height - Math.max(xScale(ordered.min), 0)
        };

        var expandLastBucket = xAxis.axisConfig.get('scale.expandLastBucket');
        var rightLastVal = expandLastBucket ? ordered.max : Math.min(ordered.max, _lodash2.default.last(xAxis.values));
        var rightStart = rightLastVal + oneUnit;
        var rightEndzone = {
          x: drawInverted ? xScale(rightStart) : 0,
          w: drawInverted ? Math.max(size - xScale(rightStart), 0) : xScale(rightStart)
        };

        this.endzones = svg.selectAll('.layer').data([leftEndzone, rightEndzone]).enter().insert('g', '.brush').attr('class', 'endzone').append('rect').attr('class', 'zone').attr('x', function (d) {
          return isHorizontal ? d.x : 0;
        }).attr('y', function (d) {
          return isHorizontal ? 0 : d.x;
        }).attr('height', function (d) {
          return isHorizontal ? height : d.w;
        }).attr('width', function (d) {
          return isHorizontal ? d.w : width;
        });

        function callPlay(event) {
          var boundData = event.target.__data__;
          var mouseChartXCoord = event.clientX - self.chartEl.getBoundingClientRect().left;
          var mouseChartYCoord = event.clientY - self.chartEl.getBoundingClientRect().top;
          var wholeBucket = boundData && boundData.x != null;

          // the min and max that the endzones start in
          var min = drawInverted ? leftEndzone.w : rightEndzone.w;
          var max = drawInverted ? rightEndzone.x : leftEndzone.x;

          // bounds of the cursor to consider
          var xLeft = isHorizontal ? mouseChartXCoord : mouseChartYCoord;
          var xRight = isHorizontal ? mouseChartXCoord : mouseChartYCoord;
          if (wholeBucket) {
            xLeft = xScale(boundData.x);
            xRight = xScale(xAxis.addInterval(boundData.x));
          }

          return {
            wholeBucket: wholeBucket,
            touchdown: min > xLeft || max < xRight
          };
        }

        function textFormatter() {
          return touchdownTmpl(callPlay(_d2.default.event));
        }

        var endzoneTT = new Tooltip('endzones', this.handler.el, textFormatter, null);
        this.tooltips.push(endzoneTT);
        endzoneTT.order = 0;
        endzoneTT.showCondition = function inEndzone() {
          return callPlay(_d2.default.event).touchdown;
        };
        endzoneTT.render()(svg);
      }
    }, {
      key: 'calculateRadiusLimits',
      value: function calculateRadiusLimits(data) {
        this.radii = (0, _lodash2.default)(data.series).map(function (series) {
          return _lodash2.default.map(series.values, 'z');
        }).flattenDeep().reduce(function (result, val) {
          if (result.min > val) result.min = val;
          if (result.max < val) result.max = val;
          return result;
        }, {
          min: Infinity,
          max: -Infinity
        });
      }
    }, {
      key: 'draw',
      value: function draw() {
        var self = this;
        var $elem = (0, _jquery2.default)(this.chartEl);
        var width = this.chartConfig.width = $elem.width();
        var height = this.chartConfig.height = $elem.height();
        var xScale = this.handler.categoryAxes[0].getScale();
        var addTimeMarker = this.chartConfig.addTimeMarker;
        var times = this.chartConfig.times || [];
        var div = void 0;
        var svg = void 0;

        return function (selection) {
          selection.each(function (data) {
            var el = this;

            div = _d2.default.select(el);

            svg = div.append('svg').attr('width', width).attr('height', height);

            self.addBackground(svg, width, height);
            self.addGrid(svg);
            self.addClipPath(svg);
            self.addEvents(svg);
            self.createEndZones(svg);
            self.calculateRadiusLimits(data);

            self.series = [];
            _lodash2.default.each(self.chartConfig.series, function (seriArgs, i) {
              if (!seriArgs.show) return;
              var SeriClass = seriTypes[seriArgs.type || self.handler.visConfig.get('chart.type')] || seriTypes.line;
              var series = new SeriClass(self.handler, svg, data.series[i], seriArgs);
              series.events = self.events;
              svg.call(series.draw());
              self.series.push(series);
            });

            if (addTimeMarker) {
              //Domain end of 'now' will be milliseconds behind current time
              //Extend toTime by 1 minute to ensure those cases have a TimeMarker
              var toTime = new Date(xScale.domain()[1].getTime() + 60000);
              var currentTime = new Date();
              if (toTime > currentTime) {
                new TimeMarker(times, xScale, height).render(svg);
              }
            }

            return svg;
          });
        };
      }
    }]);

    return PointSeries;
  }(Chart);

  return PointSeries;
}

/***/ }),
/* 3009 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tooltip = Tooltip;
exports.TooltipProvider = TooltipProvider;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _binder = __webpack_require__(940);

var _position_tooltip = __webpack_require__(3011);

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var allContents = [];

/**
 * Add tooltip and listeners to visualization elements
 *
 * @class Tooltip
 * @constructor
 * @param el {HTMLElement} Reference to DOM element
 * @param formatter {Function} Tooltip formatter
 * @param events {Constructor} Allows tooltip to return event response data
 */
function Tooltip(id, el, formatter, events) {
  if (!(this instanceof Tooltip)) {
    return new Tooltip(id, el, formatter, events);
  }

  this.id = id; // unique id for this tooltip type
  this.el = el;
  this.order = 100; // higher ordered contents are rendered below the others
  this.formatter = formatter;
  this.events = events;
  this.containerClass = 'vis-wrapper';
  this.tooltipClass = 'vis-tooltip';
  this.tooltipSizerClass = 'vis-tooltip-sizing-clone';
  this.showCondition = _lodash2.default.constant(true);

  this.binder = new _binder.Binder();
}

/**
 * Get jquery reference to the tooltip node
 *
 * @return {Object} jQuery node object
 */
Tooltip.prototype.$get = _lodash2.default.once(function () {
  return (0, _jquery2.default)('<div>').addClass(this.tooltipClass).appendTo(document.body);
});

/**
 * Get jquery reference to the tooltip sizer node
 *
 * @return {Object} jQuery node object
 */
Tooltip.prototype.$getSizer = _lodash2.default.once(function () {
  return this.$get().clone().removeClass(this.tooltipClass).addClass(this.tooltipSizerClass).appendTo(document.body);
});

/**
 * Show the tooltip, positioning it based on the content and chart container
 */
Tooltip.prototype.show = function () {
  var $tooltip = this.$get();
  var $chart = this.$getChart();
  var html = $tooltip.html();

  if (!$chart) return;

  var placement = (0, _position_tooltip.positionTooltip)({
    $window: (0, _jquery2.default)(window),
    $chart: $chart,
    $el: $tooltip,
    $sizer: this.$getSizer(),
    event: _d2.default.event
  }, html);

  $tooltip.css({
    visibility: 'visible',
    left: placement.left,
    top: placement.top
  });
};

/**
 * Hide the tooltip, clearing its contents
 */
Tooltip.prototype.hide = function () {
  var $tooltip = this.$get();
  allContents = [];
  $tooltip.css({
    visibility: 'hidden',
    left: '-500px',
    top: '-500px'
  });
};

/**
 * Get the jQuery chart node, based on the container object
 * NOTE: the container is a d3 selection
 *
 * @return {Object} jQuery node for the chart
 */
Tooltip.prototype.$getChart = function () {
  var chart = (0, _jquery2.default)(this.container && this.container.node());
  return chart.length ? chart : false;
};

/**
 * Renders tooltip
 *
 * @method render
 * @return {Function} Renders tooltip on a D3 selection
 */
Tooltip.prototype.render = function () {
  var self = this;

  /**
   * Calculates values for the tooltip placement
   *
   * @param {Object} selection D3 selection object
   */
  return function (selection) {
    var $tooltip = self.$get();
    var id = self.id;
    var order = self.order;

    if (self.container === undefined || self.container !== _d2.default.select(self.el).select('.' + self.containerClass)) {
      self.container = _d2.default.select(self.el).select('.' + self.containerClass);
    }

    var $chart = self.$getChart();
    if ($chart) {
      self.binder.jqOn($chart, 'mouseleave', function () {
        // only clear when we leave the chart, so that
        // moving between points doesn't make it reposition
        $chart.removeData('previousPlacement');
      });
    }

    selection.each(function (d, i) {
      var element = _d2.default.select(this);

      function render(html) {
        allContents = _lodash2.default.filter(allContents, function (content) {
          return content.id !== id;
        });

        if (html) allContents.push({ id: id, html: html, order: order });

        var allHtml = (0, _lodash2.default)(allContents).sortBy('order').pluck('html').compact().join('\n');

        if (allHtml) {
          $tooltip.html(allHtml);
          self.show();
        } else {
          self.hide();
        }
      }

      self.binder.fakeD3Bind(this, 'mousemove', function () {
        if (!self.showCondition.call(element, d, i)) {
          return render();
        }

        var events = self.events ? self.events.eventResponse(d, i) : d;
        return render(self.formatter(events));
      });

      self.binder.fakeD3Bind(this, 'mouseleave', function () {
        render();
      });
    });
  };
};

Tooltip.prototype.destroy = function () {
  this.hide();
  this.binder.destroy();
};

function TooltipProvider() {
  return Tooltip;
}

/***/ }),
/* 3010 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Binder = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

var _binder = __webpack_require__(432);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Binder = exports.Binder = function (_BinderBase) {
  _inherits(Binder, _BinderBase);

  function Binder($scope) {
    _classCallCheck(this, Binder);

    // support auto-binding to $scope objects
    var _this = _possibleConstructorReturn(this, (Binder.__proto__ || Object.getPrototypeOf(Binder)).call(this));

    if ($scope) {
      $scope.$on('$destroy', function () {
        return _this.destroy();
      });
    }
    return _this;
  }

  _createClass(Binder, [{
    key: 'jqOn',
    value: function jqOn(el) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var $el = (0, _jquery2.default)(el);
      $el.on.apply($el, args);
      this.disposal.push(function () {
        return $el.off.apply($el, args);
      });
    }
  }, {
    key: 'fakeD3Bind',
    value: function fakeD3Bind(el, event, handler) {
      var _this2 = this;

      this.jqOn(el, event, function (e) {
        // mimick https://github.com/mbostock/d3/blob/3abb00113662463e5c19eb87cd33f6d0ddc23bc0/src/selection/on.js#L87-L94
        var o = _d2.default.event; // Events can be reentrant (e.g., focus).
        _d2.default.event = e;
        try {
          handler.apply(_this2, [_this2.__data__]);
        } finally {
          _d2.default.event = o;
        }
      });
    }
  }]);

  return Binder;
}(_binder.BinderBase);

/***/ }),
/* 3011 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.positionTooltip = positionTooltip;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OFFSET = 10;
var $clone = void 0;

// translate css properties into their basic direction
var propDirs = {
  top: 'north',
  left: 'west'
};

function positionTooltip(opts, html) {
  if (!opts) return;
  var $chart = (0, _jquery2.default)(opts.$chart);
  var $el = (0, _jquery2.default)(opts.$el);
  var $window = (0, _jquery2.default)(opts.$window || window);
  var $sizer = (0, _jquery2.default)(opts.$sizer);
  var prev = $chart.data('previousPlacement') || {};
  var event = opts.event;

  if (!$chart.length || !$el.length) return;

  var size = getTtSize(html || $el.html(), $sizer);
  var pos = getBasePosition(size, event);
  var overflow = getOverflow(size, pos, [$chart, $window]);

  var placement = placeToAvoidOverflow(pos, prev, overflow);
  $chart.data('previousPlacement', placement);
  return placement;
}

function getTtSize(ttHtml, $sizer) {
  if ($sizer.html() !== ttHtml) {
    $sizer.html(ttHtml);
  }

  var size = {
    width: $sizer.outerWidth(),
    height: $sizer.outerHeight()
  };

  return size;
}

function getBasePosition(size, event) {
  return {
    east: event.clientX + OFFSET,
    west: event.clientX - size.width - OFFSET,
    south: event.clientY + OFFSET,
    north: event.clientY - size.height - OFFSET
  };
}

function getBounds($el) {
  // in testing, $window is not actually a window, so we need to add
  // the offsets to make it work right.
  // Sometimes $el is a $(window), which doesn't have getBoundingClientRect()
  // which breaks in jQuery 3
  var bounds = _jquery2.default.isWindow($el[0]) ? { top: 0, left: 0 } : $el.offset();
  bounds.top += $el.scrollTop();
  bounds.left += $el.scrollLeft();
  bounds.bottom = bounds.top + $el.outerHeight();
  bounds.right = bounds.left + $el.outerWidth();
  bounds.area = (bounds.bottom - bounds.top) * (bounds.right - bounds.left);
  return bounds;
}

function getOverflow(size, pos, containers) {
  var overflow = {};

  containers.map(getBounds).sort(function (a, b) {
    // ensure smallest containers are merged first
    return a.area - b.area;
  }).forEach(function (bounds) {
    // number of pixels that the toolip would overflow it's far
    // side, if we placed it that way. (negative === no overflow)
    mergeOverflows(overflow, {
      north: bounds.top - pos.north,
      east: pos.east + size.width - bounds.right,
      south: pos.south + size.height - bounds.bottom,
      west: bounds.left - pos.west
    });
  });

  (window.overflows || (window.overflows = [])).push(overflow);
  return overflow;
}

function mergeOverflows(dest, src) {
  _lodash2.default.merge(dest, src, function (a, b) {
    if (a == null || b == null) return a || b;
    if (a < 0 && b < 0) return Math.min(a, b);
    return Math.max(a, b);
  });

  // When tooltip overflows both sides of smaller container,
  // remove overflow on one side if the outer container can contain tooltip.
  if (dest.east && dest.west && dest.east > 0 && dest.west > 0 && (src.east < 0 || src.west < 0)) {
    if (src.east < src.west) {
      dest.east = src.east;
    } else {
      dest.west = src.west;
    }
  }
}

function pickPlacement(prop, pos, overflow, prev, pref, fallback, placement) {
  var stash = '_' + prop;

  // list of directions in order of preference
  var dirs = _lodash2.default.unique([prev[stash], pref, fallback].filter(Boolean));

  var dir = void 0;
  var value = void 0;

  // find the first direction that doesn't overflow
  for (var i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (overflow[dir] > 0) continue;
    value = pos[dir];
    break;
  }

  // if we don't find one that doesn't overflow, use
  // the first choice and offset based on overflo
  if (value == null) {
    dir = dirs[0];

    var offset = overflow[dir];
    if (propDirs[prop] === dir) {
      // when the property represents the same direction
      // as dir, we flip the overflow
      offset = offset * -1;
    }

    value = pos[dir] - offset;
  }

  placement[prop] = value;
  placement[stash] = dir;
}

function placeToAvoidOverflow(pos, prev, overflow) {
  var placement = {};
  pickPlacement('top', pos, overflow, prev, 'south', 'north', placement);
  pickPlacement('left', pos, overflow, prev, 'east', 'west', placement);
  return placement;
}

// expose units/helpers for testing
positionTooltip.getTtSize = getTtSize;
positionTooltip.getBasePosition = getBasePosition;
positionTooltip.getOverflow = getOverflow;
positionTooltip.getBounds = getBounds;
positionTooltip.placeToAvoidOverflow = placeToAvoidOverflow;
positionTooltip.removeClone = function () {
  $clone && $clone.remove();
  $clone = null;
};

/***/ }),
/* 3012 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dataLabel = dataLabel;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Creates a string based on the hex color passed in
 *
 * @method dataLabel
 * @param d {Object} object to wrap in d3.select
 * @returns {string} label value
 */
function dataLabel(selection, label) {
  _d2.default.select(selection).attr('data-label', label);
}

/***/ }),
/* 3013 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.VislibLibDispatchProvider = VislibLibDispatchProvider;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

var _simple_emitter = __webpack_require__(437);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function VislibLibDispatchProvider(Private, config) {

  /**
   * Handles event responses
   *
   * @class Dispatch
   * @constructor
   * @param handler {Object} Reference to Handler Class Object
   */

  var Dispatch = function (_SimpleEmitter) {
    _inherits(Dispatch, _SimpleEmitter);

    function Dispatch(handler) {
      _classCallCheck(this, Dispatch);

      var _this = _possibleConstructorReturn(this, (Dispatch.__proto__ || Object.getPrototypeOf(Dispatch)).call(this));

      _this.handler = handler;
      _this._listeners = {};
      return _this;
    }

    /**
     * Response to click and hover events
     *
     * @param d {Object} Data point
     * @param i {Number} Index number of data point
     * @returns {{value: *, point: *, label: *, color: *, pointIndex: *,
     * series: *, config: *, data: (Object|*),
     * e: (d3.event|*), handler: (Object|*)}} Event response object
     */


    _createClass(Dispatch, [{
      key: 'eventResponse',
      value: function eventResponse(d, i) {
        var datum = d._input || d;
        var data = _d2.default.event.target.nearestViewportElement ? _d2.default.event.target.nearestViewportElement.__data__ : _d2.default.event.target.__data__;
        var label = d.label ? d.label : d.series || 'Count';
        var isSeries = !!(data && data.series);
        var isSlices = !!(data && data.slices);
        var series = isSeries ? data.series : undefined;
        var slices = isSlices ? data.slices : undefined;
        var handler = this.handler;
        var color = _lodash2.default.get(handler, 'data.color');

        var eventData = {
          value: d.y,
          point: datum,
          datum: datum,
          label: label,
          color: color ? color(label) : undefined,
          pointIndex: i,
          series: series,
          slices: slices,
          config: handler && handler.visConfig,
          data: data,
          e: _d2.default.event,
          handler: handler
        };

        if (isSeries) {
          var percentageMode = false;
          //only series charts work in percentage mode.
          var isSeriesChart = handler.charts && handler.charts[0] && handler.charts[0].getSeries;
          var parentNode = _d2.default.event.target.parentNode;
          var parentData = parentNode ? parentNode.__data__ : null;
          if (isSeriesChart && parentData) {
            var aggId = parentData.aggId;
            var seriesFromAggId = handler.charts[0].getSeries(aggId);
            if (seriesFromAggId && seriesFromAggId.getValueAxis) {
              percentageMode = seriesFromAggId.getValueAxis().axisConfig.isPercentage();
            }
          }

          var object = _lodash2.default.find(series, { 'label': label });
          if (object) {
            eventData.value = +object.values[i].y;

            if (percentageMode) {
              // Add the formatted percentage to the point object
              eventData.percent = (100 * d.y).toFixed(1) + '%';
            }
          }
        }

        return eventData;
      }

      /**
       * Returns a function that adds events and listeners to a D3 selection
       *
       * @method addEvent
       * @param event {String}
       * @param callback {Function}
       * @returns {Function}
       */

    }, {
      key: 'addEvent',
      value: function addEvent(event, callback) {
        return function (selection) {
          selection.each(function () {
            var element = _d2.default.select(this);

            if (typeof callback === 'function') {
              return element.on(event, callback);
            }
          });
        };
      }

      /**
       *
       * @method addHoverEvent
       * @returns {Function}
       */

    }, {
      key: 'addHoverEvent',
      value: function addHoverEvent() {
        var self = this;
        var isClickable = this.listenerCount('click') > 0;
        var addEvent = this.addEvent;
        var $el = this.handler.el;
        if (!this.handler.highlight) {
          this.handler.highlight = self.highlight;
        }

        function hover(d, i) {
          // Add pointer if item is clickable
          if (isClickable) {
            self.addMousePointer.call(this, arguments);
          }

          self.handler.highlight.call(this, $el);
          self.emit('hover', self.eventResponse(d, i));
        }

        return addEvent('mouseover', hover);
      }

      /**
       *
       * @method addMouseoutEvent
       * @returns {Function}
       */

    }, {
      key: 'addMouseoutEvent',
      value: function addMouseoutEvent() {
        var self = this;
        var addEvent = this.addEvent;
        var $el = this.handler.el;
        if (!this.handler.unHighlight) {
          this.handler.unHighlight = self.unHighlight;
        }

        function mouseout() {
          self.handler.unHighlight.call(this, $el);
        }

        return addEvent('mouseout', mouseout);
      }

      /**
       *
       * @method addClickEvent
       * @returns {Function}
       */

    }, {
      key: 'addClickEvent',
      value: function addClickEvent() {
        var self = this;
        var addEvent = this.addEvent;

        function click(d, i) {
          self.emit('click', self.eventResponse(d, i));
        }

        return addEvent('click', click);
      }

      /**
       * Determine if we will allow brushing
       *
       * @method allowBrushing
       * @returns {Boolean}
       */

    }, {
      key: 'allowBrushing',
      value: function allowBrushing() {
        var xAxis = this.handler.categoryAxes[0];

        //Allow brushing for ordered axis - date histogram and histogram
        return Boolean(xAxis.ordered);
      }

      /**
       * Determine if brushing is currently enabled
       *
       * @method isBrushable
       * @returns {Boolean}
       */

    }, {
      key: 'isBrushable',
      value: function isBrushable() {
        return this.allowBrushing() && this.listenerCount('brush') > 0;
      }

      /**
       *
       * @param svg
       * @returns {Function}
       */

    }, {
      key: 'addBrushEvent',
      value: function addBrushEvent(svg) {
        if (!this.isBrushable()) return;

        var self = this;
        var xScale = this.handler.categoryAxes[0].getScale();
        var brush = this.createBrush(xScale, svg);

        function simulateClickWithBrushEnabled(d, i) {
          if (!validBrushClick(_d2.default.event)) return;

          if (isQuantitativeScale(xScale)) {
            var bar = _d2.default.select(this);
            var startX = _d2.default.mouse(svg.node());
            var startXInv = xScale.invert(startX[0]);

            // Reset the brush value
            brush.extent([startXInv, startXInv]);

            // Magic!
            // Need to call brush on svg to see brush when brushing
            // while on top of bars.
            // Need to call brush on bar to allow the click event to be registered
            svg.call(brush);
            bar.call(brush);
          } else {
            self.emit('click', self.eventResponse(d, i));
          }
        }

        return this.addEvent('mousedown', simulateClickWithBrushEnabled);
      }

      /**
       * Mouseover Behavior
       *
       * @method addMousePointer
       * @returns {d3.Selection}
       */

    }, {
      key: 'addMousePointer',
      value: function addMousePointer() {
        return _d2.default.select(this).style('cursor', 'pointer');
      }

      /**
       * Highlight the element that is under the cursor
       * by reducing the opacity of all the elements on the graph.
       * @param element {d3.Selection}
       * @method highlight
       */

    }, {
      key: 'highlight',
      value: function highlight(element) {
        var label = this.getAttribute('data-label');
        if (!label) return;

        var dimming = config.get('visualization:dimmingOpacity');
        (0, _jquery2.default)(element).parent().find('[data-label]').css('opacity', 1) //Opacity 1 is needed to avoid the css application
        .not(function (els, el) {
          return String((0, _jquery2.default)(el).data('label')) === label;
        }).css('opacity', justifyOpacity(dimming));
      }

      /**
       * Mouseout Behavior
       *
       * @param element {d3.Selection}
       * @method unHighlight
       */

    }, {
      key: 'unHighlight',
      value: function unHighlight(element) {
        (0, _jquery2.default)('[data-label]', element.parentNode).css('opacity', 1);
      }

      /**
       * Adds D3 brush to SVG and returns the brush function
       *
       * @param xScale {Function} D3 xScale function
       * @param svg {HTMLElement} Reference to SVG
       * @returns {*} Returns a D3 brush function and a SVG with a brush group attached
       */

    }, {
      key: 'createBrush',
      value: function createBrush(xScale, svg) {
        var self = this;
        var visConfig = self.handler.visConfig;

        var _svg$node$getBBox = svg.node().getBBox(),
            width = _svg$node$getBBox.width,
            height = _svg$node$getBBox.height;

        var isHorizontal = self.handler.categoryAxes[0].axisConfig.isHorizontal();

        // Brush scale
        var brush = _d2.default.svg.brush();
        if (isHorizontal) {
          brush.x(xScale);
        } else {
          brush.y(xScale);
        }

        brush.on('brushend', function brushEnd() {

          // Assumes data is selected at the chart level
          // In this case, the number of data objects should always be 1
          var data = _d2.default.select(this).data()[0];
          var isTimeSeries = data.ordered && data.ordered.date;

          // Allows for brushing on d3.scale.ordinal()
          var selected = xScale.domain().filter(function (d) {
            return brush.extent()[0] <= xScale(d) && xScale(d) <= brush.extent()[1];
          });
          var range = isTimeSeries ? brush.extent() : selected;

          return self.emit('brush', {
            range: range,
            config: visConfig,
            e: _d2.default.event,
            data: data
          });
        });

        // if `addBrushing` is true, add brush canvas
        if (self.listenerCount('brush')) {
          var rect = svg.insert('g', 'g').attr('class', 'brush').call(brush).call(function (brushG) {
            // hijack the brush start event to filter out right/middle clicks
            var brushHandler = brushG.on('mousedown.brush');
            if (!brushHandler) return; // touch events in use
            brushG.on('mousedown.brush', function () {
              if (validBrushClick(_d2.default.event)) brushHandler.apply(this, arguments);
            });
          }).selectAll('rect');

          if (isHorizontal) {
            rect.attr('height', height);
          } else {
            rect.attr('width', width);
          }

          return brush;
        }
      }
    }]);

    return Dispatch;
  }(_simple_emitter.SimpleEmitter);

  /**
   * Determine if d3.Scale is quantitative
   *
   * @param element {d3.Scale}
   * @method isQuantitativeScale
   * @returns {boolean}
   */


  function isQuantitativeScale(scale) {
    //Invert is a method that only exists on quantitative scales
    if (scale.invert) {
      return true;
    } else {
      return false;
    }
  }

  function validBrushClick(event) {
    return event.button === 0;
  }

  function justifyOpacity(opacity) {
    var decimalNumber = parseFloat(opacity, 10);
    var fallbackOpacity = 0.5;
    return 0 <= decimalNumber && decimalNumber <= 1 ? decimalNumber : fallbackOpacity;
  }

  return Dispatch;
}

/***/ }),
/* 3014 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.VislibVisualizationsTimeMarkerProvider = VislibVisualizationsTimeMarkerProvider;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

var _datemath = __webpack_require__(90);

var _datemath2 = _interopRequireDefault(_datemath);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function VislibVisualizationsTimeMarkerProvider() {
  var TimeMarker = function () {
    function TimeMarker(times, xScale, height) {
      _classCallCheck(this, TimeMarker);

      var currentTimeArr = [{
        'time': new Date().getTime(),
        'class': 'time-marker',
        'color': '#c80000',
        'opacity': 0.3,
        'width': 2
      }];

      this.xScale = xScale;
      this.height = height;
      this.times = times.length ? times.map(function (d) {
        return {
          'time': _datemath2.default.parse(d.time),
          'class': d.class || 'time-marker',
          'color': d.color || '#c80000',
          'opacity': d.opacity || 0.3,
          'width': d.width || 2
        };
      }) : currentTimeArr;
    }

    _createClass(TimeMarker, [{
      key: '_isTimeBasedChart',
      value: function _isTimeBasedChart(selection) {
        var data = selection.data();
        return data.every(function (datum) {
          return datum.ordered && datum.ordered.date;
        });
      }
    }, {
      key: 'render',
      value: function render(selection) {
        var self = this;

        // return if not time based chart
        if (!self._isTimeBasedChart(selection)) return;

        selection.each(function () {
          _d2.default.select(this).selectAll('time-marker').data(self.times).enter().append('line').attr('class', function (d) {
            return d.class;
          }).attr('pointer-events', 'none').attr('stroke', function (d) {
            return d.color;
          }).attr('stroke-width', function (d) {
            return d.width;
          }).attr('stroke-opacity', function (d) {
            return d.opacity;
          }).attr('x1', function (d) {
            return self.xScale(d.time);
          }).attr('x2', function (d) {
            return self.xScale(d.time);
          }).attr('y1', self.height).attr('y2', self.xScale.range()[0]);
        });
      }
    }]);

    return TimeMarker;
  }();

  return TimeMarker;
}

/***/ }),
/* 3015 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VislibVisualizationsSeriesTypesProvider = VislibVisualizationsSeriesTypesProvider;

var _column_chart = __webpack_require__(3016);

var _line_chart = __webpack_require__(3017);

var _area_chart = __webpack_require__(3018);

var _heatmap_chart = __webpack_require__(3019);

function VislibVisualizationsSeriesTypesProvider(Private) {

  return {
    histogram: Private(_column_chart.VislibVisualizationsColumnChartProvider),
    line: Private(_line_chart.VislibVisualizationsLineChartProvider),
    area: Private(_area_chart.VislibVisualizationsAreaChartProvider),
    heatmap: Private(_heatmap_chart.VislibVisualizationsHeatmapChartProvider)
  };
}

/***/ }),
/* 3016 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.VislibVisualizationsColumnChartProvider = VislibVisualizationsColumnChartProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _point_series = __webpack_require__(356);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function VislibVisualizationsColumnChartProvider(Private) {

  var PointSeries = Private(_point_series.VislibVisualizationsPointSeriesProvider);

  var defaults = {
    mode: 'normal',
    showTooltip: true,
    color: undefined,
    fillColor: undefined
  };

  /**
   * Histogram intervals are not always equal widths, e.g, monthly time intervals.
   * It is more visually appealing to vary bar width so that gutter width is constant.
   */
  function datumWidth(defaultWidth, datum, nextDatum, scale, gutterWidth) {
    var groupCount = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;

    var datumWidth = defaultWidth;
    if (nextDatum) {
      datumWidth = (scale(nextDatum.x) - scale(datum.x) - gutterWidth) / groupCount;
      // To handle data-sets with holes, do not let width be larger than default.
      if (datumWidth > defaultWidth) {
        datumWidth = defaultWidth;
      }
    }
    return datumWidth;
  }

  /**
   * Vertical Bar Chart Visualization: renders vertical and/or stacked bars
   *
   * @class ColumnChart
   * @constructor
   * @extends Chart
   * @param handler {Object} Reference to the Handler Class Constructor
   * @param el {HTMLElement} HTML element to which the chart will be appended
   * @param chartData {Object} Elasticsearch query results for this specific chart
   */

  var ColumnChart = function (_PointSeries) {
    _inherits(ColumnChart, _PointSeries);

    function ColumnChart(handler, chartEl, chartData, seriesConfigArgs) {
      _classCallCheck(this, ColumnChart);

      var _this = _possibleConstructorReturn(this, (ColumnChart.__proto__ || Object.getPrototypeOf(ColumnChart)).call(this, handler, chartEl, chartData, seriesConfigArgs));

      _this.seriesConfig = _lodash2.default.defaults(seriesConfigArgs || {}, defaults);
      return _this;
    }

    _createClass(ColumnChart, [{
      key: 'addBars',
      value: function addBars(svg, data) {
        var self = this;
        var color = this.handler.data.getColorFunc();
        var tooltip = this.baseChart.tooltip;
        var isTooltip = this.handler.visConfig.get('tooltip.show');

        var layer = svg.append('g').attr('class', 'series histogram').attr('clip-path', 'url(#' + this.baseChart.clipPathId + ')');

        var bars = layer.selectAll('rect').data(data.values.filter(function (d) {
          return !_lodash2.default.isNull(d.y);
        }));

        bars.exit().remove();

        bars.enter().append('rect').attr('data-label', data.label).attr('fill', function () {
          return color(data.label);
        }).attr('stroke', function () {
          return color(data.label);
        });

        self.updateBars(bars);

        // Add tooltip
        if (isTooltip) {
          bars.call(tooltip.render());
        }

        return bars;
      }

      /**
       * Determines whether bars are grouped or stacked and updates the D3
       * selection
       *
       * @method updateBars
       * @param bars {D3.UpdateSelection} SVG with rect added
       * @returns {D3.UpdateSelection}
       */

    }, {
      key: 'updateBars',
      value: function updateBars(bars) {
        if (this.seriesConfig.mode === 'stacked') {
          return this.addStackedBars(bars);
        }
        return this.addGroupedBars(bars);
      }

      /**
       * Adds stacked bars to column chart visualization
       *
       * @method addStackedBars
       * @param bars {D3.UpdateSelection} SVG with rect added
       * @returns {D3.UpdateSelection}
       */

    }, {
      key: 'addStackedBars',
      value: function addStackedBars(bars) {
        var xScale = this.getCategoryAxis().getScale();
        var yScale = this.getValueAxis().getScale();
        var isHorizontal = this.getCategoryAxis().axisConfig.isHorizontal();
        var isTimeScale = this.getCategoryAxis().axisConfig.isTimeDomain();
        var yMin = yScale.domain()[0];
        var gutterSpacingPercentage = 0.15;
        var groupCount = this.getGroupedCount();
        var groupNum = this.getGroupedNum(this.chartData);
        var barWidth = void 0;
        var gutterWidth = void 0;

        if (isTimeScale) {
          var _handler$data$get = this.handler.data.get('ordered'),
              min = _handler$data$get.min,
              interval = _handler$data$get.interval;

          var intervalWidth = xScale(min + interval) - xScale(min);
          intervalWidth = Math.abs(intervalWidth);

          gutterWidth = intervalWidth * gutterSpacingPercentage;
          barWidth = (intervalWidth - gutterWidth) / groupCount;
        }

        function x(d, i) {
          if (isTimeScale) {
            return xScale(d.x) + datumWidth(barWidth, d, bars.data()[i + 1], xScale, gutterWidth, groupCount) * groupNum;
          }
          return xScale(d.x) + xScale.rangeBand() / groupCount * groupNum;
        }

        function y(d) {
          if (isHorizontal && d.y < 0 || !isHorizontal && d.y > 0) {
            return yScale(d.y0);
          }
          return yScale(d.y0 + d.y);
        }

        function widthFunc(d, i) {
          if (isTimeScale) {
            return datumWidth(barWidth, d, bars.data()[i + 1], xScale, gutterWidth, groupCount);
          }
          return xScale.rangeBand() / groupCount;
        }

        function heightFunc(d) {
          // for split bars or for one series,
          // last series will have d.y0 = 0
          if (d.y0 === 0 && yMin > 0) {
            return yScale(yMin) - yScale(d.y);
          }

          return Math.abs(yScale(d.y0) - yScale(d.y0 + d.y));
        }

        // update
        bars.attr('x', isHorizontal ? x : y).attr('width', isHorizontal ? widthFunc : heightFunc).attr('y', isHorizontal ? y : x).attr('height', isHorizontal ? heightFunc : widthFunc);

        return bars;
      }

      /**
       * Adds grouped bars to column chart visualization
       *
       * @method addGroupedBars
       * @param bars {D3.UpdateSelection} SVG with rect added
       * @returns {D3.UpdateSelection}
       */

    }, {
      key: 'addGroupedBars',
      value: function addGroupedBars(bars) {
        var xScale = this.getCategoryAxis().getScale();
        var yScale = this.getValueAxis().getScale();
        var groupCount = this.getGroupedCount();
        var groupNum = this.getGroupedNum(this.chartData);
        var gutterSpacingPercentage = 0.15;
        var isTimeScale = this.getCategoryAxis().axisConfig.isTimeDomain();
        var isHorizontal = this.getCategoryAxis().axisConfig.isHorizontal();
        var isLogScale = this.getValueAxis().axisConfig.isLogScale();
        var barWidth = void 0;
        var gutterWidth = void 0;

        if (isTimeScale) {
          var _handler$data$get2 = this.handler.data.get('ordered'),
              min = _handler$data$get2.min,
              interval = _handler$data$get2.interval;

          var intervalWidth = xScale(min + interval) - xScale(min);
          intervalWidth = Math.abs(intervalWidth);

          gutterWidth = intervalWidth * gutterSpacingPercentage;
          barWidth = (intervalWidth - gutterWidth) / groupCount;
        }

        function x(d, i) {
          if (isTimeScale) {
            return xScale(d.x) + datumWidth(barWidth, d, bars.data()[i + 1], xScale, gutterWidth, groupCount) * groupNum;
          }
          return xScale(d.x) + xScale.rangeBand() / groupCount * groupNum;
        }

        function y(d) {
          if (isHorizontal && d.y < 0 || !isHorizontal && d.y > 0) {
            return yScale(0);
          }

          return yScale(d.y);
        }

        function widthFunc(d, i) {
          if (isTimeScale) {
            return datumWidth(barWidth, d, bars.data()[i + 1], xScale, gutterWidth, groupCount);
          }
          return xScale.rangeBand() / groupCount;
        }

        function heightFunc(d) {
          var baseValue = isLogScale ? 1 : 0;
          return Math.abs(yScale(baseValue) - yScale(d.y));
        }

        // update
        bars.attr('x', isHorizontal ? x : y).attr('width', isHorizontal ? widthFunc : heightFunc).attr('y', isHorizontal ? y : x).attr('height', isHorizontal ? heightFunc : widthFunc);

        return bars;
      }

      /**
       * Renders d3 visualization
       *
       * @method draw
       * @returns {Function} Creates the vertical bar chart
       */

    }, {
      key: 'draw',
      value: function draw() {
        var self = this;

        return function (selection) {
          selection.each(function () {
            var svg = self.chartEl.append('g');
            svg.data([self.chartData]);

            var bars = self.addBars(svg, self.chartData);
            self.addCircleEvents(bars);

            self.events.emit('rendered', {
              chart: self.chartData
            });

            return svg;
          });
        };
      }
    }]);

    return ColumnChart;
  }(PointSeries);

  return ColumnChart;
}

/***/ }),
/* 3017 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.VislibVisualizationsLineChartProvider = VislibVisualizationsLineChartProvider;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _point_series = __webpack_require__(356);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function VislibVisualizationsLineChartProvider(Private) {

  var PointSeries = Private(_point_series.VislibVisualizationsPointSeriesProvider);

  var defaults = {
    mode: 'normal',
    showCircles: true,
    radiusRatio: 9,
    showLines: true,
    interpolate: 'linear',
    lineWidth: 2,
    color: undefined,
    fillColor: undefined
  };
  /**
   * Line Chart Visualization
   *
   * @class LineChart
   * @constructor
   * @extends Chart
   * @param handler {Object} Reference to the Handler Class Constructor
   * @param el {HTMLElement} HTML element to which the chart will be appended
   * @param chartData {Object} Elasticsearch query results for this specific chart
   */

  var LineChart = function (_PointSeries) {
    _inherits(LineChart, _PointSeries);

    function LineChart(handler, chartEl, chartData, seriesConfigArgs) {
      _classCallCheck(this, LineChart);

      var _this = _possibleConstructorReturn(this, (LineChart.__proto__ || Object.getPrototypeOf(LineChart)).call(this, handler, chartEl, chartData, seriesConfigArgs));

      _this.seriesConfig = _lodash2.default.defaults(seriesConfigArgs || {}, defaults);
      return _this;
    }

    _createClass(LineChart, [{
      key: 'addCircles',
      value: function addCircles(svg, data) {
        var self = this;
        var showCircles = this.seriesConfig.showCircles;
        var color = this.handler.data.getColorFunc();
        var xScale = this.getCategoryAxis().getScale();
        var yScale = this.getValueAxis().getScale();
        var ordered = this.handler.data.get('ordered');
        var tooltip = this.baseChart.tooltip;
        var isTooltip = this.handler.visConfig.get('tooltip.show');
        var isHorizontal = this.getCategoryAxis().axisConfig.isHorizontal();
        var lineWidth = this.seriesConfig.lineWidth;

        var radii = this.baseChart.radii;

        var radiusStep = (radii.max - radii.min || radii.max * 100) / Math.pow(this.seriesConfig.radiusRatio, 2);

        var layer = svg.append('g').attr('class', 'points line').attr('clip-path', 'url(#' + this.baseChart.clipPathId + ')');

        var circles = layer.selectAll('circle').data(function appendData() {
          return data.values.filter(function (d) {
            return !_lodash2.default.isNull(d.y);
          });
        });

        circles.exit().remove();

        function cx(d) {
          if (ordered && ordered.date) {
            return xScale(d.x);
          }
          return xScale(d.x) + xScale.rangeBand() / 2;
        }

        function cy(d) {
          var y0 = d.y0 || 0;
          var y = d.y || 0;
          return yScale(y0 + y);
        }

        function cColor(d) {
          return color(d.series);
        }

        function colorCircle(d) {
          var parent = _d2.default.select(this).node().parentNode;
          var lengthOfParent = _d2.default.select(parent).data()[0].length;
          var isVisible = lengthOfParent === 1;

          // If only 1 point exists, show circle
          if (!showCircles && !isVisible) return 'none';
          return cColor(d);
        }

        function getCircleRadiusFn(modifier) {
          return function getCircleRadius(d) {
            var width = self.baseChart.chartConfig.width;
            var height = self.baseChart.chartConfig.height;
            var circleRadius = (d.z - radii.min) / radiusStep;
            var baseMagicNumber = 2;

            var base = circleRadius ? Math.sqrt(circleRadius + baseMagicNumber) + lineWidth : lineWidth;
            return _lodash2.default.min([base, width, height]) + (modifier || 0);
          };
        }

        circles.enter().append('circle').attr('r', getCircleRadiusFn()).attr('fill-opacity', this.seriesConfig.drawLinesBetweenPoints ? 1 : 0.7).attr('cx', isHorizontal ? cx : cy).attr('cy', isHorizontal ? cy : cx).attr('class', 'circle-decoration').attr('data-label', data.label).attr('fill', colorCircle);

        circles.enter().append('circle').attr('r', getCircleRadiusFn(10)).attr('cx', isHorizontal ? cx : cy).attr('cy', isHorizontal ? cy : cx).attr('fill', 'transparent').attr('class', 'circle').attr('data-label', data.label).attr('stroke', cColor).attr('stroke-width', 0);

        if (isTooltip) {
          circles.call(tooltip.render());
        }

        return circles;
      }

      /**
       * Adds path to SVG
       *
       * @method addLines
       * @param svg {HTMLElement} SVG to which path are appended
       * @param data {Array} Array of object data points
       * @returns {D3.UpdateSelection} SVG with paths added
       */

    }, {
      key: 'addLine',
      value: function addLine(svg, data) {
        var xScale = this.getCategoryAxis().getScale();
        var yScale = this.getValueAxis().getScale();
        var color = this.handler.data.getColorFunc();
        var ordered = this.handler.data.get('ordered');
        var lineWidth = this.seriesConfig.lineWidth;
        var interpolate = this.seriesConfig.interpolate;
        var isHorizontal = this.getCategoryAxis().axisConfig.isHorizontal();

        var line = svg.append('g').attr('class', 'pathgroup lines').attr('clip-path', 'url(#' + this.baseChart.clipPathId + ')');

        function cx(d) {
          if (ordered && ordered.date) {
            return xScale(d.x);
          }
          return xScale(d.x) + xScale.rangeBand() / 2;
        }

        function cy(d) {
          var y = d.y || 0;
          var y0 = d.y0 || 0;
          return yScale(y0 + y);
        }

        line.append('path').attr('data-label', data.label).attr('d', function () {
          var d3Line = _d2.default.svg.line().defined(function (d) {
            return !_lodash2.default.isNull(d.y);
          }).interpolate(interpolate).x(isHorizontal ? cx : cy).y(isHorizontal ? cy : cx);
          return d3Line(data.values.filter(function (d) {
            return !_lodash2.default.isNull(d.y);
          }));
        }).attr('fill', 'none').attr('stroke', function () {
          return color(data.label);
        }).attr('stroke-width', lineWidth);

        return line;
      }

      /**
       * Renders d3 visualization
       *
       * @method draw
       * @returns {Function} Creates the line chart
       */

    }, {
      key: 'draw',
      value: function draw() {
        var self = this;

        return function (selection) {
          selection.each(function () {

            var svg = self.chartEl.append('g');
            svg.data([self.chartData]);

            if (self.seriesConfig.drawLinesBetweenPoints) {
              self.addLine(svg, self.chartData);
            }
            var circles = self.addCircles(svg, self.chartData);
            self.addCircleEvents(circles);

            self.events.emit('rendered', {
              chart: self.chartData
            });

            return svg;
          });
        };
      }
    }]);

    return LineChart;
  }(PointSeries);

  return LineChart;
}

/***/ }),
/* 3018 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.VislibVisualizationsAreaChartProvider = VislibVisualizationsAreaChartProvider;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

var _point_series = __webpack_require__(356);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function VislibVisualizationsAreaChartProvider(Private) {

  var PointSeries = Private(_point_series.VislibVisualizationsPointSeriesProvider);

  var defaults = {
    mode: 'normal',
    showCircles: true,
    radiusRatio: 9,
    showLines: true,
    interpolate: 'linear',
    color: undefined,
    fillColor: undefined
  };
  /**
   * Area chart visualization
   *
   * @class AreaChart
   * @constructor
   * @extends Chart
   * @param handler {Object} Reference to the Handler Class Constructor
   * @param el {HTMLElement} HTML element to which the chart will be appended
   * @param chartData {Object} Elasticsearch query results for this specific
   * chart
   */

  var AreaChart = function (_PointSeries) {
    _inherits(AreaChart, _PointSeries);

    function AreaChart(handler, chartEl, chartData, seriesConfigArgs) {
      _classCallCheck(this, AreaChart);

      var _this = _possibleConstructorReturn(this, (AreaChart.__proto__ || Object.getPrototypeOf(AreaChart)).call(this, handler, chartEl, chartData, seriesConfigArgs));

      _this.seriesConfig = _lodash2.default.defaults(seriesConfigArgs || {}, defaults);
      _this.isOverlapping = _this.seriesConfig.mode !== 'stacked';
      if (_this.isOverlapping) {

        // Default opacity should return to 0.6 on mouseout
        var defaultOpacity = 0.6;
        _this.seriesConfig.defaultOpacity = defaultOpacity;
        handler.highlight = function (element) {
          var label = this.getAttribute('data-label');
          if (!label) return;

          var highlightOpacity = 0.8;
          var highlightElements = (0, _jquery2.default)('[data-label]', element.parentNode).filter(function (els, el) {
            return '' + (0, _jquery2.default)(el).data('label') === label;
          });
          (0, _jquery2.default)('[data-label]', element.parentNode).not(highlightElements).css('opacity', defaultOpacity / 2); // half of the default opacity
          highlightElements.css('opacity', highlightOpacity);
        };
        handler.unHighlight = function (element) {
          (0, _jquery2.default)('[data-label]', element).css('opacity', defaultOpacity);

          //The legend should keep max opacity
          (0, _jquery2.default)('[data-label]', (0, _jquery2.default)(element).siblings()).css('opacity', 1);
        };
      }

      return _this;
    }

    _createClass(AreaChart, [{
      key: 'addPath',
      value: function addPath(svg, data) {
        var ordered = this.handler.data.get('ordered');
        var isTimeSeries = ordered && ordered.date;
        var isOverlapping = this.isOverlapping;
        var color = this.handler.data.getColorFunc();
        var xScale = this.getCategoryAxis().getScale();
        var yScale = this.getValueAxis().getScale();
        var interpolate = this.seriesConfig.interpolate;
        var isHorizontal = this.getCategoryAxis().axisConfig.isHorizontal();

        // Data layers
        var layer = svg.append('g').attr('class', function (d, i) {
          return 'series series-' + i;
        });

        // Append path
        var path = layer.append('path').attr('data-label', data.label).style('fill', function () {
          return color(data.label);
        }).style('stroke', function () {
          return color(data.label);
        }).classed('overlap_area', function () {
          return isOverlapping;
        }).attr('clip-path', 'url(#' + this.baseChart.clipPathId + ')');

        function x(d) {
          if (isTimeSeries) {
            return xScale(d.x);
          }
          return xScale(d.x) + xScale.rangeBand() / 2;
        }

        function y1(d) {
          var y0 = d.y0 || 0;
          var y = d.y || 0;
          return yScale(y0 + y);
        }

        function y0(d) {
          var y0 = d.y0 || 0;
          return yScale(y0);
        }

        function getArea() {
          if (isHorizontal) {
            return _d2.default.svg.area().x(x).y0(y0).y1(y1);
          } else {
            return _d2.default.svg.area().y(x).x0(y0).x1(y1);
          }
        }

        // update
        path.attr('d', function () {
          var area = getArea().defined(function (d) {
            return !_lodash2.default.isNull(d.y);
          }).interpolate(interpolate);
          return area(data.values.filter(function (d) {
            return !_lodash2.default.isNull(d.y);
          }));
        }).style('stroke-width', '1px');

        return path;
      }

      /**
       * Adds SVG circles to area chart
       *
       * @method addCircles
       * @param svg {HTMLElement} SVG to which circles are appended
       * @param data {Array} Chart data array
       * @returns {D3.UpdateSelection} SVG with circles added
       */

    }, {
      key: 'addCircles',
      value: function addCircles(svg, data) {
        var color = this.handler.data.getColorFunc();
        var xScale = this.getCategoryAxis().getScale();
        var yScale = this.getValueAxis().getScale();
        var ordered = this.handler.data.get('ordered');
        var circleRadius = 12;
        var circleStrokeWidth = 0;
        var tooltip = this.baseChart.tooltip;
        var isTooltip = this.handler.visConfig.get('tooltip.show');
        var isOverlapping = this.isOverlapping;
        var isHorizontal = this.getCategoryAxis().axisConfig.isHorizontal();

        var layer = svg.append('g').attr('class', 'points area').attr('clip-path', 'url(#' + this.baseChart.clipPathId + ')');

        // append the circles
        var circles = layer.selectAll('circles').data(function appendData() {
          return data.values.filter(function isZeroOrNull(d) {
            return d.y !== 0 && !_lodash2.default.isNull(d.y);
          });
        });

        // exit
        circles.exit().remove();

        // enter
        circles.enter().append('circle').attr('data-label', data.label).attr('stroke', function () {
          return color(data.label);
        }).attr('fill', 'transparent').attr('stroke-width', circleStrokeWidth);

        function cx(d) {
          if (ordered && ordered.date) {
            return xScale(d.x);
          }
          return xScale(d.x) + xScale.rangeBand() / 2;
        }

        function cy(d) {
          var y = d.y || 0;
          if (isOverlapping) {
            return yScale(y);
          }
          return yScale(d.y0 + y);
        }

        // update
        circles.attr('cx', isHorizontal ? cx : cy).attr('cy', isHorizontal ? cy : cx).attr('r', circleRadius);

        // Add tooltip
        if (isTooltip) {
          circles.call(tooltip.render());
        }

        return circles;
      }
    }, {
      key: 'addPathEvents',
      value: function addPathEvents(path) {
        var events = this.events;
        if (this.handler.visConfig.get('enableHover')) {
          var hover = events.addHoverEvent();
          var mouseout = events.addMouseoutEvent();
          path.call(hover).call(mouseout);
        }
      }

      /**
       * Renders d3 visualization
       *
       * @method draw
       * @returns {Function} Creates the area chart
       */

    }, {
      key: 'draw',
      value: function draw() {
        var self = this;

        return function (selection) {
          selection.each(function () {
            var svg = self.chartEl.append('g');
            svg.data([self.chartData]);

            var path = self.addPath(svg, self.chartData);
            self.addPathEvents(path);
            var circles = self.addCircles(svg, self.chartData);
            self.addCircleEvents(circles);

            self.events.emit('rendered', {
              chart: self.chartData
            });

            return svg;
          });
        };
      }
    }]);

    return AreaChart;
  }(PointSeries);

  return AreaChart;
}

/***/ }),
/* 3019 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.VislibVisualizationsHeatmapChartProvider = VislibVisualizationsHeatmapChartProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

var _point_series = __webpack_require__(356);

var _heatmap_color = __webpack_require__(533);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function VislibVisualizationsHeatmapChartProvider(Private) {

  var PointSeries = Private(_point_series.VislibVisualizationsPointSeriesProvider);

  var defaults = {
    color: undefined, // todo
    fillColor: undefined // todo
  };
  /**
   * Line Chart Visualization
   *
   * @class HeatmapChart
   * @constructor
   * @extends Chart
   * @param handler {Object} Reference to the Handler Class Constructor
   * @param el {HTMLElement} HTML element to which the chart will be appended
   * @param chartData {Object} Elasticsearch query results for this specific chart
   */

  var HeatmapChart = function (_PointSeries) {
    _inherits(HeatmapChart, _PointSeries);

    function HeatmapChart(handler, chartEl, chartData, seriesConfigArgs) {
      _classCallCheck(this, HeatmapChart);

      var _this = _possibleConstructorReturn(this, (HeatmapChart.__proto__ || Object.getPrototypeOf(HeatmapChart)).call(this, handler, chartEl, chartData, seriesConfigArgs));

      _this.seriesConfig = _lodash2.default.defaults(seriesConfigArgs || {}, defaults);

      _this.handler.visConfig.set('legend', {
        labels: _this.getHeatmapLabels(_this.handler.visConfig),
        colors: _this.getHeatmapColors(_this.handler.visConfig)
      });

      var colors = _this.handler.visConfig.get('legend.colors', null);
      if (colors) {
        _this.handler.vis.uiState.setSilent('vis.defaultColors', null);
        _this.handler.vis.uiState.setSilent('vis.defaultColors', colors);
      }
      return _this;
    }

    _createClass(HeatmapChart, [{
      key: 'getHeatmapLabels',
      value: function getHeatmapLabels(cfg) {
        var percentageMode = cfg.get('percentageMode');
        var colorsNumber = cfg.get('colorsNumber');
        var colorsRange = cfg.get('colorsRange');
        var zAxisConfig = this.getValueAxis().axisConfig;
        var zAxisFormatter = zAxisConfig.get('labels.axisFormatter');
        var zScale = this.getValueAxis().getScale();

        var _zScale$domain = zScale.domain(),
            _zScale$domain2 = _slicedToArray(_zScale$domain, 2),
            min = _zScale$domain2[0],
            max = _zScale$domain2[1];

        var labels = [];
        if (cfg.get('setColorRange')) {
          colorsRange.forEach(function (range) {
            var from = isFinite(range.from) ? zAxisFormatter(range.from) : range.from;
            var to = isFinite(range.to) ? zAxisFormatter(range.to) : range.to;
            labels.push(from + ' - ' + to);
          });
        } else {
          if (max === min) {
            return [min.toString()];
          }
          for (var i = 0; i < colorsNumber; i++) {
            var label = void 0;
            var val = i / colorsNumber;
            var nextVal = (i + 1) / colorsNumber;
            if (percentageMode) {
              val = Math.ceil(val * 100);
              nextVal = Math.ceil(nextVal * 100);
              label = val + '% - ' + nextVal + '%';
            } else {
              val = val * (max - min) + min;
              nextVal = nextVal * (max - min) + min;
              if (max > 1) {
                val = Math.ceil(val);
                nextVal = Math.ceil(nextVal);
              }
              if (isFinite(val)) val = zAxisFormatter(val);
              if (isFinite(nextVal)) nextVal = zAxisFormatter(nextVal);
              label = val + ' - ' + nextVal;
            }

            labels.push(label);
          }
        }

        return labels;
      }
    }, {
      key: 'getHeatmapColors',
      value: function getHeatmapColors(cfg) {
        var colorsNumber = cfg.get('colorsNumber');
        var invertColors = cfg.get('invertColors');
        var colorSchema = cfg.get('colorSchema');
        var labels = this.getHeatmapLabels(cfg);
        var colors = {};
        for (var i in labels) {
          if (labels[i]) {
            var val = invertColors ? 1 - i / colorsNumber : i / colorsNumber;
            colors[labels[i]] = (0, _heatmap_color.getHeatmapColors)(val, colorSchema);
          }
        }
        return colors;
      }
    }, {
      key: 'addSquares',
      value: function addSquares(svg, data) {
        var xScale = this.getCategoryAxis().getScale();
        var yScale = this.handler.categoryAxes[1].getScale();
        var zScale = this.getValueAxis().getScale();
        var tooltip = this.baseChart.tooltip;
        var isTooltip = this.handler.visConfig.get('tooltip.show');
        var isHorizontal = this.getCategoryAxis().axisConfig.isHorizontal();
        var colorsNumber = this.handler.visConfig.get('colorsNumber');
        var setColorRange = this.handler.visConfig.get('setColorRange');
        var colorsRange = this.handler.visConfig.get('colorsRange');
        var color = this.handler.data.getColorFunc();
        var labels = this.handler.visConfig.get('legend.labels');
        var zAxisConfig = this.getValueAxis().axisConfig;
        var zAxisFormatter = zAxisConfig.get('labels.axisFormatter');
        var showLabels = zAxisConfig.get('labels.show');

        var layer = svg.append('g').attr('class', 'series');

        var squares = layer.selectAll('g.square').data(data.values);

        squares.exit().remove();

        var barWidth = void 0;
        if (this.getCategoryAxis().axisConfig.isTimeDomain()) {
          var _handler$data$get = this.handler.data.get('ordered'),
              _min = _handler$data$get.min,
              interval = _handler$data$get.interval;

          var start = _min;
          var end = (0, _moment2.default)(_min).add(interval).valueOf();

          barWidth = xScale(end) - xScale(start);
          if (!isHorizontal) barWidth *= -1;
        }

        function x(d) {
          return xScale(d.x);
        }

        function y(d) {
          return yScale(d.series);
        }

        var _zScale$domain3 = zScale.domain(),
            _zScale$domain4 = _slicedToArray(_zScale$domain3, 2),
            min = _zScale$domain4[0],
            max = _zScale$domain4[1];

        function getColorBucket(d) {
          var val = 0;
          if (setColorRange && colorsRange.length) {
            var bucket = _lodash2.default.find(colorsRange, function (range) {
              return range.from <= d.y && range.to > d.y;
            });
            return bucket ? colorsRange.indexOf(bucket) : -1;
          } else {
            if (isNaN(min) || isNaN(max)) {
              val = colorsNumber - 1;
            } else if (min === max) {
              val = 0;
            } else {
              val = (d.y - min) / (max - min); /* get val from 0 - 1 */
              val = Math.min(colorsNumber - 1, Math.floor(val * colorsNumber));
            }
          }
          return !isNaN(val) ? val : -1;
        }

        function label(d) {
          var colorBucket = getColorBucket(d);
          if (colorBucket === -1) d.hide = true;
          return labels[colorBucket];
        }

        function z(d) {
          if (label(d) === '') return 'transparent';
          return color(label(d));
        }

        var squareWidth = barWidth || xScale.rangeBand();
        var squareHeight = yScale.rangeBand();

        squares.enter().append('g').attr('class', 'square');

        squares.append('rect').attr('x', x).attr('width', squareWidth).attr('y', y).attr('height', squareHeight).attr('data-label', label).attr('fill', z).attr('style', 'cursor: pointer; stroke: black; stroke-width: 0.1px').style('display', function (d) {
          return d.hide ? 'none' : 'initial';
        });

        // todo: verify that longest label is not longer than the barwidth
        // or barwidth is not smaller than textheight (and vice versa)
        //
        if (showLabels) {
          var rotate = zAxisConfig.get('labels.rotate');
          var rotateRad = rotate * Math.PI / 180;
          var cellPadding = 5;
          var maxLength = Math.min(Math.abs(squareWidth / Math.cos(rotateRad)), Math.abs(squareHeight / Math.sin(rotateRad))) - cellPadding;
          var maxHeight = Math.min(Math.abs(squareWidth / Math.sin(rotateRad)), Math.abs(squareHeight / Math.cos(rotateRad))) - cellPadding;

          var hiddenLabels = false;
          squares.append('text').text(function (d) {
            return zAxisFormatter(d.y);
          }).style('display', function (d) {
            var textLength = this.getBBox().width;
            var textHeight = this.getBBox().height;
            var textTooLong = textLength > maxLength;
            var textTooWide = textHeight > maxHeight;
            if (!d.hide && (textTooLong || textTooWide)) {
              hiddenLabels = true;
            }
            return d.hide || textTooLong || textTooWide ? 'none' : 'initial';
          }).style('dominant-baseline', 'central').style('text-anchor', 'middle').style('fill', zAxisConfig.get('labels.color')).attr('x', function (d) {
            var center = x(d) + squareWidth / 2;
            return center;
          }).attr('y', function (d) {
            var center = y(d) + squareHeight / 2;
            return center;
          }).attr('transform', function (d) {
            var horizontalCenter = x(d) + squareWidth / 2;
            var verticalCenter = y(d) + squareHeight / 2;
            return 'rotate(' + rotate + ',' + horizontalCenter + ',' + verticalCenter + ')';
          });
          if (hiddenLabels) {
            this.baseChart.handler.alerts.show('Some labels were hidden due to size constraints');
          }
        }

        if (isTooltip) {
          squares.call(tooltip.render());
        }

        return squares.selectAll('rect');
      }

      /**
       * Renders d3 visualization
       *
       * @method draw
       * @returns {Function} Creates the line chart
       */

    }, {
      key: 'draw',
      value: function draw() {
        var self = this;

        return function (selection) {
          selection.each(function () {
            var svg = self.chartEl.append('g');
            svg.data([self.chartData]);

            var squares = self.addSquares(svg, self.chartData);
            self.addCircleEvents(squares);

            self.events.emit('rendered', {
              chart: self.chartData
            });

            return svg;
          });
        };
      }
    }]);

    return HeatmapChart;
  }(PointSeries);

  return HeatmapChart;
}

/***/ }),
/* 3020 */
/***/ (function(module, exports) {

module.exports = "<p class=\"vis-tooltip-header bg-info\">\n  <i class=\"fa fa-info-circle vis-tooltip-header-icon\"></i>\n  <span class=\"vis-tooltip-header-text\">\n    <%= wholeBucket ? 'Part of this bucket' : 'This area' %>\n    may contain partial data. <br> The selected time range does not fully cover it.\n  </span>\n</p>"

/***/ }),
/* 3021 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.VislibVisualizationsPieChartProvider = VislibVisualizationsPieChartProvider;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

var _numeral = __webpack_require__(448);

var _numeral2 = _interopRequireDefault(_numeral);

var _errors = __webpack_require__(37);

var _chart = __webpack_require__(532);

var _truncate_labels = __webpack_require__(941);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function VislibVisualizationsPieChartProvider(Private) {

  var Chart = Private(_chart.VislibVisualizationsChartProvider);

  var defaults = {
    isDonut: false,
    showTooltip: true,
    color: undefined,
    fillColor: undefined
  };
  /**
   * Pie Chart Visualization
   *
   * @class PieChart
   * @constructor
   * @extends Chart
   * @param handler {Object} Reference to the Handler Class Constructor
   * @param el {HTMLElement} HTML element to which the chart will be appended
   * @param chartData {Object} Elasticsearch query results for this specific chart
   */

  var PieChart = function (_Chart) {
    _inherits(PieChart, _Chart);

    function PieChart(handler, chartEl, chartData) {
      _classCallCheck(this, PieChart);

      var _this = _possibleConstructorReturn(this, (PieChart.__proto__ || Object.getPrototypeOf(PieChart)).call(this, handler, chartEl, chartData));

      var charts = _this.handler.data.getVisData();
      _this._validatePieData(charts);

      _this._attr = _lodash2.default.defaults(handler.visConfig.get('chart', {}), defaults);
      return _this;
    }

    /**
     * Checks whether pie slices have all zero values.
     * If so, an error is thrown.
     */


    _createClass(PieChart, [{
      key: '_validatePieData',
      value: function _validatePieData(charts) {
        var isAllZeros = charts.every(function (chart) {
          return chart.slices.children.length === 0;
        });

        if (isAllZeros) {
          throw new _errors.PieContainsAllZeros();
        }
      }

      /**
       * Adds Events to SVG paths
       *
       * @method addPathEvents
       * @param element {D3.Selection} Reference to SVG path
       * @returns {D3.Selection} SVG path with event listeners attached
       */

    }, {
      key: 'addPathEvents',
      value: function addPathEvents(element) {
        var events = this.events;

        return element.call(events.addHoverEvent()).call(events.addMouseoutEvent()).call(events.addClickEvent());
      }
    }, {
      key: 'convertToPercentage',
      value: function convertToPercentage(slices) {
        (function assignPercentages(slices) {
          if (slices.sumOfChildren != null) return;

          var parent = slices;
          var children = parent.children;
          var parentPercent = parent.percentOfParent;

          var sum = parent.sumOfChildren = Math.abs(children.reduce(function (sum, child) {
            return sum + Math.abs(child.size);
          }, 0));

          children.forEach(function (child) {
            child.percentOfGroup = Math.abs(child.size) / sum;
            child.percentOfParent = child.percentOfGroup;

            if (parentPercent != null) {
              child.percentOfParent *= parentPercent;
            }

            if (child.children) {
              assignPercentages(child);
            }
          });
        })(slices);
      }

      /**
       * Adds pie paths to SVG
       *
       * @method addPath
       * @param width {Number} Width of SVG
       * @param height {Number} Height of SVG
       * @param svg {HTMLElement} Chart SVG
       * @param slices {Object} Chart data
       * @returns {D3.Selection} SVG with paths attached
       */

    }, {
      key: 'addPath',
      value: function addPath(width, height, svg, slices) {
        var self = this;
        var marginFactor = 0.95;
        var isDonut = self._attr.isDonut;
        var radius = Math.min(width, height) / 2 * marginFactor;
        var color = self.handler.data.getPieColorFunc();
        var tooltip = self.tooltip;
        var isTooltip = self._attr.addTooltip;

        var arcs = svg.append('g').attr('class', 'arcs');
        var labels = svg.append('g').attr('class', 'labels');

        var showLabels = self._attr.labels.show;
        var showValues = self._attr.labels.values;
        var truncateLabelLength = self._attr.labels.truncate;
        var showOnlyOnLastLevel = self._attr.labels.last_level;

        var partition = _d2.default.layout.partition().sort(null).value(function (d) {
          return d.percentOfParent * 100;
        });

        var x = _d2.default.scale.linear().range([0, 2 * Math.PI]);
        var y = _d2.default.scale.sqrt().range([0, showLabels ? radius * 0.7 : radius]);

        var startAngle = function startAngle(d) {
          return Math.max(0, Math.min(2 * Math.PI, x(d.x)));
        };

        var endAngle = function endAngle(d) {
          if (d.dx < 1e-8) return x(d.x);
          return Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx)));
        };

        var arc = _d2.default.svg.arc().startAngle(startAngle).endAngle(endAngle).innerRadius(function (d) {
          // option for a single layer, i.e pie chart
          if (d.depth === 1 && !isDonut) {
            // return no inner radius
            return 0;
          }

          return Math.max(0, y(d.y));
        }).outerRadius(function (d) {
          return Math.max(0, y(d.y + d.dy));
        });

        var outerArc = _d2.default.svg.arc().startAngle(startAngle).endAngle(endAngle).innerRadius(radius * 0.8).outerRadius(radius * 0.8);

        var maxDepth = 0;
        var path = arcs.datum(slices).selectAll('path').data(partition.nodes).enter().append('path').attr('d', arc).attr('class', function (d) {
          if (d.depth === 0) {
            return;
          }
          if (d.depth > maxDepth) maxDepth = d.depth;
          return 'slice';
        }).call(self._addIdentifier, 'name').style('fill', function (d) {
          if (d.depth === 0) {
            return 'none';
          }
          return color(d.name);
        });

        // add labels
        if (showLabels) {
          var labelGroups = labels.datum(slices).selectAll('.label').data(partition.nodes);

          // create an empty quadtree to hold label positions
          var svgParentNode = svg.node().parentNode.parentNode;
          var svgBBox = {
            width: svgParentNode.clientWidth,
            height: svgParentNode.clientHeight
          };

          var labelLayout = _d2.default.geom.quadtree().extent([[-svgBBox.width, -svgBBox.height], [svgBBox.width, svgBBox.height]]).x(function (d) {
            return d.position.x;
          }).y(function (d) {
            return d.position.y;
          })([]);

          labelGroups.enter().append('g').attr('class', 'label').append('text').text(function (d) {
            if (d.depth === 0) {
              _d2.default.select(this.parentNode).remove();
              return;
            }
            if (showValues) {
              var value = (0, _numeral2.default)(d.value / 100).format('0.[00]%');
              return d.name + ' (' + value + ')';
            }
            return d.name;
          }).text(function () {
            return (0, _truncate_labels.truncateLabel)(this, truncateLabelLength);
          }).attr('text-anchor', function (d) {
            var midAngle = startAngle(d) + (endAngle(d) - startAngle(d)) / 2;
            return midAngle < Math.PI ? 'start' : 'end';
          }).attr('class', 'label-text').each(function resolveConflicts(d) {
            if (d.depth === 0) return;

            var parentNode = this.parentNode;
            if (showOnlyOnLastLevel && maxDepth !== d.depth) {
              _d2.default.select(parentNode).remove();
              return;
            }

            var bbox = this.getBBox();
            var pos = outerArc.centroid(d);
            var midAngle = startAngle(d) + (endAngle(d) - startAngle(d)) / 2;
            pos[1] += 4;
            pos[0] = (0.7 + d.depth / 10) * radius * (midAngle < Math.PI ? 1 : -1);
            d.position = {
              x: pos[0],
              y: pos[1],
              left: midAngle < Math.PI ? pos[0] : pos[0] - bbox.width,
              right: midAngle > Math.PI ? pos[0] + bbox.width : pos[0],
              bottom: pos[1] + 5,
              top: pos[1] - bbox.height - 5
            };

            var conflicts = [];
            labelLayout.visit(function (node) {
              if (!node.point) return;
              if (conflicts.length) return true;

              var point = node.point.position;
              var current = d.position;
              if (point) {
                var horizontalConflict = point.left < 0 && current.left < 0 || point.left > 0 && current.left > 0;
                var verticalConflict = point.top >= current.top && point.top <= current.bottom || point.top <= current.top && point.bottom >= current.top;

                if (horizontalConflict && verticalConflict) {
                  point.point = node.point;
                  conflicts.push(point);
                }

                return true;
              }
            });

            if (conflicts.length) {
              _d2.default.select(parentNode).remove();
              return;
            }

            labelLayout.add(d);
          }).attr('x', function (d) {
            if (d.depth === 0 || !d.position) {
              return;
            }
            return d.position.x;
          }).attr('y', function (d) {
            if (d.depth === 0 || !d.position) {
              return;
            }
            return d.position.y;
          });

          labelGroups.append('polyline').attr('points', function (d) {
            if (d.depth === 0 || !d.position) {
              return;
            }
            var pos1 = outerArc.centroid(d);
            var x2 = d.position.x > 0 ? d.position.x - 10 : d.position.x + 10;
            var pos2 = [x2, d.position.y - 4];
            pos1[1] = pos2[1];
            return [arc.centroid(d), pos1, pos2];
          }).attr('class', 'label-line');
        }

        if (isTooltip) {
          path.call(tooltip.render());
        }

        return path;
      }
    }, {
      key: '_validateContainerSize',
      value: function _validateContainerSize(width, height) {
        var minWidth = 20;
        var minHeight = 20;

        if (width <= minWidth || height <= minHeight) {
          throw new _errors.ContainerTooSmall();
        }
      }

      /**
       * Renders d3 visualization
       *
       * @method draw
       * @returns {Function} Creates the pie chart
       */

    }, {
      key: 'draw',
      value: function draw() {
        var self = this;

        return function (selection) {
          selection.each(function (data) {
            var slices = data.slices;
            var div = _d2.default.select(this);
            var width = (0, _jquery2.default)(this).width();
            var height = (0, _jquery2.default)(this).height();

            if (!slices.children.length) return;

            self.convertToPercentage(slices);
            self._validateContainerSize(width, height);

            var svg = div.append('svg').attr('width', width).attr('height', height).append('g').attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');

            var path = self.addPath(width, height, svg, slices);
            self.addPathEvents(path);

            self.events.emit('rendered', {
              chart: data
            });

            return svg;
          });
        };
      }
    }]);

    return PieChart;
  }(Chart);

  return PieChart;
}

/***/ }),
/* 3022 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.GaugeChartProvider = GaugeChartProvider;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

var _chart = __webpack_require__(532);

var _gauge_types = __webpack_require__(3023);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function GaugeChartProvider(Private) {

  var Chart = Private(_chart.VislibVisualizationsChartProvider);
  var gaugeTypes = Private(_gauge_types.GaugeTypesProvider);

  var GaugeChart = function (_Chart) {
    _inherits(GaugeChart, _Chart);

    function GaugeChart(handler, chartEl, chartData) {
      _classCallCheck(this, GaugeChart);

      var _this = _possibleConstructorReturn(this, (GaugeChart.__proto__ || Object.getPrototypeOf(GaugeChart)).call(this, handler, chartEl, chartData));

      _this.gaugeConfig = handler.visConfig.get('gauge', {});
      _this.gauge = new gaugeTypes[_this.gaugeConfig.type](_this);
      return _this;
    }

    _createClass(GaugeChart, [{
      key: 'addEvents',
      value: function addEvents(element) {
        var events = this.events;

        return element.call(events.addHoverEvent()).call(events.addMouseoutEvent()).call(events.addClickEvent());
      }
    }, {
      key: 'draw',
      value: function draw() {
        var self = this;
        var verticalSplit = this.gaugeConfig.verticalSplit;

        return function (selection) {
          selection.each(function (data) {
            var div = _d2.default.select(this);
            var containerMargin = 20;
            var containerWidth = (0, _jquery2.default)(this).width() - containerMargin;
            var containerHeight = (0, _jquery2.default)(this).height() - containerMargin;
            var width = Math.floor(verticalSplit ? (0, _jquery2.default)(this).width() : containerWidth / data.series.length);
            var height = Math.floor((verticalSplit ? containerHeight / data.series.length : (0, _jquery2.default)(this).height()) - 25);

            if (height < 0 || width < 0) return;

            div.style('text-align', 'center').style('overflow-y', 'auto');

            data.series.forEach(function (series) {
              var svg = div.append('svg').style('display', 'inline-block').style('overflow', 'hidden').attr('width', width);

              var g = svg.append('g');

              var gauges = self.gauge.drawGauge(g, series, width, height);

              svg.attr('height', height);
              var transformX = width / 2;
              var transformY = self.gaugeConfig.gaugeType === 'Arc' ? height / (2 * 0.75) : height / 2;
              g.attr('transform', 'translate(' + transformX + ', ' + transformY + ')');

              self.addEvents(gauges);
            });

            div.append('div').attr('class', 'chart-title').style('text-align', 'center').text(data.label || data.yAxisLabel);

            self.events.emit('rendered', {
              chart: data
            });

            return div;
          });
        };
      }
    }]);

    return GaugeChart;
  }(Chart);

  return GaugeChart;
}

/***/ }),
/* 3023 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GaugeTypesProvider = GaugeTypesProvider;

var _meter = __webpack_require__(3024);

function GaugeTypesProvider(Private) {

  return {
    meter: Private(_meter.MeterGaugeProvider)
  };
}

/***/ }),
/* 3024 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.MeterGaugeProvider = MeterGaugeProvider;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _heatmap_color = __webpack_require__(533);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function MeterGaugeProvider() {

  var defaultConfig = {
    showTooltip: true,
    percentageMode: true,
    maxAngle: 2 * Math.PI * 1.3,
    minAngle: 2 * Math.PI * 0.7,
    innerSpace: 5,
    extents: [0, 10000],
    scale: {
      show: true,
      color: '#666',
      width: 2,
      ticks: 10,
      tickLength: 8
    },
    labels: {
      show: true,
      color: '#666'
    },
    style: {
      bgWidth: 0.5,
      width: 0.9
    }
  };

  var MeterGauge = function () {
    function MeterGauge(gaugeChart) {
      _classCallCheck(this, MeterGauge);

      this.gaugeChart = gaugeChart;
      this.gaugeConfig = gaugeChart.gaugeConfig;
      this.gaugeConfig = _lodash2.default.defaultsDeep(this.gaugeConfig, defaultConfig);

      this.gaugeChart.handler.visConfig.set('legend', {
        labels: this.getLabels(),
        colors: this.getColors()
      });

      var colors = this.gaugeChart.handler.visConfig.get('legend.colors', null);
      if (colors) {
        this.gaugeChart.handler.vis.uiState.setSilent('vis.defaultColors', null);
        this.gaugeChart.handler.vis.uiState.setSilent('vis.defaultColors', colors);
      }

      this.colorFunc = this.gaugeChart.handler.data.getColorFunc();
    }

    _createClass(MeterGauge, [{
      key: 'getLabels',
      value: function getLabels() {
        var isPercentageMode = this.gaugeConfig.percentageMode;
        var colorsRange = this.gaugeConfig.colorsRange;
        var max = _lodash2.default.last(colorsRange).to;
        var labels = [];
        colorsRange.forEach(function (range) {
          var from = isPercentageMode ? Math.round(100 * range.from / max) : range.from;
          var to = isPercentageMode ? Math.round(100 * range.to / max) : range.to;
          labels.push(from + ' - ' + to);
        });

        return labels;
      }
    }, {
      key: 'getColors',
      value: function getColors() {
        var invertColors = this.gaugeConfig.invertColors;
        var colorSchema = this.gaugeConfig.colorSchema;
        var colorsRange = this.gaugeConfig.colorsRange;
        var labels = this.getLabels();
        var colors = {};
        for (var i = 0; i < labels.length; i += 1) {
          var divider = Math.max(colorsRange.length - 1, 1);
          var val = invertColors ? 1 - i / divider : i / divider;
          colors[labels[i]] = (0, _heatmap_color.getHeatmapColors)(val, colorSchema);
        }
        return colors;
      }
    }, {
      key: 'getBucket',
      value: function getBucket(val) {
        var bucket = _lodash2.default.findIndex(this.gaugeConfig.colorsRange, function (range) {
          return range.from <= val && range.to > val;
        });

        if (bucket === -1) {
          if (val < this.gaugeConfig.colorsRange[0].from) bucket = 0;else bucket = this.gaugeConfig.colorsRange.length - 1;
        }

        return bucket;
      }
    }, {
      key: 'getLabel',
      value: function getLabel(val) {
        var bucket = this.getBucket(val);
        var labels = this.gaugeChart.handler.visConfig.get('legend.labels');
        return labels[bucket];
      }
    }, {
      key: 'getColorBucket',
      value: function getColorBucket(val) {
        var bucket = this.getBucket(val);
        var labels = this.gaugeChart.handler.visConfig.get('legend.labels');
        return this.colorFunc(labels[bucket]);
      }
    }, {
      key: 'drawScale',
      value: function drawScale(svg, radius, angle) {
        var _this = this;

        var scaleWidth = this.gaugeConfig.scale.width;
        var tickLength = this.gaugeConfig.scale.tickLength;
        var scaleTicks = this.gaugeConfig.scale.ticks;

        var scale = svg.append('g');

        this.gaugeConfig.colorsRange.forEach(function (range) {
          var color = _this.getColorBucket(range.from);

          var scaleArc = _d2.default.svg.arc().startAngle(angle(range.from)).endAngle(angle(range.to)).innerRadius(radius).outerRadius(radius + scaleWidth);

          scale.append('path').attr('d', scaleArc).style('stroke', color).style('fill', color);
        });

        var extents = angle.domain();
        for (var i = 0; i <= scaleTicks; i++) {
          var val = i * (extents[1] - extents[0]) / scaleTicks;
          var tickAngle = angle(val) - Math.PI / 2;
          var x0 = Math.cos(tickAngle) * radius;
          var x1 = Math.cos(tickAngle) * (radius - tickLength);
          var y0 = Math.sin(tickAngle) * radius;
          var y1 = Math.sin(tickAngle) * (radius - tickLength);
          var color = this.getColorBucket(val);
          scale.append('line').attr('x1', x0).attr('x2', x1).attr('y1', y0).attr('y2', y1).style('stroke-width', scaleWidth).style('stroke', color);
        }

        return scale;
      }
    }, {
      key: 'drawGauge',
      value: function drawGauge(svg, data, width, height) {
        var _this2 = this;

        var self = this;
        var marginFactor = 0.95;
        var tooltip = this.gaugeChart.tooltip;
        var isTooltip = this.gaugeChart.handler.visConfig.get('addTooltip');
        var isDisplayWarning = this.gaugeChart.handler.visConfig.get('isDisplayWarning', false);
        var maxAngle = this.gaugeConfig.maxAngle;
        var minAngle = this.gaugeConfig.minAngle;
        var angleFactor = this.gaugeConfig.gaugeType === 'Arc' ? 0.75 : 1;
        var maxRadius = Math.min(width, height / angleFactor) / 2 * marginFactor;

        var extendRange = this.gaugeConfig.extendRange;
        var maxY = _lodash2.default.max(data.values, 'y').y;
        var min = this.gaugeConfig.colorsRange[0].from;
        var max = _lodash2.default.last(this.gaugeConfig.colorsRange).to;
        var angle = _d2.default.scale.linear().range([minAngle, maxAngle]).domain([min, extendRange && max < maxY ? maxY : max]);
        var radius = _d2.default.scale.linear().range([0, maxRadius]).domain([this.gaugeConfig.innerSpace + 1, 0]);

        var totalWidth = Math.abs(radius(0) - radius(1));
        var bgPadding = totalWidth * (1 - this.gaugeConfig.style.bgWidth) / 2;
        var gaugePadding = totalWidth * (1 - this.gaugeConfig.style.width) / 2;
        var arc = _d2.default.svg.arc().startAngle(minAngle).endAngle(function (d) {
          return Math.max(0, Math.min(maxAngle, angle(Math.max(min, d.y))));
        }).innerRadius(function (d, i, j) {
          return Math.max(0, radius(j + 1) + gaugePadding);
        }).outerRadius(function (d, i, j) {
          return Math.max(0, radius(j) - gaugePadding);
        });

        var bgArc = _d2.default.svg.arc().startAngle(minAngle).endAngle(maxAngle).innerRadius(function (d, i, j) {
          return Math.max(0, radius(j + 1) + bgPadding);
        }).outerRadius(function (d, i, j) {
          return Math.max(0, radius(j) - bgPadding);
        });

        var gaugeHolders = svg.selectAll('path').data([data]).enter().append('g').attr('data-label', function (d) {
          return _this2.getLabel(d.values[0].y);
        });

        var gauges = gaugeHolders.selectAll('g').data(function (d) {
          return d.values;
        }).enter();

        gauges.append('path').attr('d', bgArc).style('fill', this.gaugeConfig.style.bgFill);

        var series = gauges.append('path').attr('d', arc).style('fill', function (d) {
          return self.getColorBucket(Math.max(min, d.y));
        });

        var smallContainer = svg.node().getBBox().height < 70;
        var hiddenLabels = smallContainer;

        if (this.gaugeConfig.labels.show) {
          svg.append('text').attr('class', 'chart-label').text(data.label).attr('y', -30).attr('style', 'dominant-baseline: central; text-anchor: middle;').style('display', function () {
            var textLength = this.getBBox().width;
            var textTooLong = textLength > maxRadius;
            if (textTooLong) {
              hiddenLabels = true;
            }
            return smallContainer || textTooLong ? 'none' : 'initial';
          });

          svg.append('text').attr('class', 'chart-label').text(this.gaugeConfig.style.subText).attr('y', 20).attr('style', 'dominant-baseline: central; text-anchor: middle;').style('display', function () {
            var textLength = this.getBBox().width;
            var textTooLong = textLength > maxRadius;
            if (textTooLong) {
              hiddenLabels = true;
            }
            return smallContainer || textTooLong ? 'none' : 'initial';
          });
        }

        gauges.append('text').attr('class', 'chart-label').attr('y', -5).text(function (d) {
          if (_this2.gaugeConfig.percentageMode) {
            var percentage = Math.round(100 * (d.y - min) / (max - min));
            return percentage + '%';
          }
          if (_lodash2.default.has(d, 'aggConfigResult.aggConfig')) {
            var fieldFormatter = d.aggConfigResult.aggConfig.fieldFormatter('text');
            return fieldFormatter(d.y);
          }
          return d.y;
        }).attr('style', 'dominant-baseline: central;').style('text-anchor', 'middle').style('font-size', '2em').style('display', function () {
          var textLength = this.getBBox().width;
          var textTooLong = textLength > maxRadius;
          if (textTooLong) {
            hiddenLabels = true;
          }
          return textTooLong ? 'none' : 'initial';
        });

        if (this.gaugeConfig.scale.show) {
          this.drawScale(svg, radius(1), angle);
        }

        if (isTooltip) {
          series.each(function () {
            var gauge = _d2.default.select(this);
            gauge.call(tooltip.render());
          });
        }

        if (hiddenLabels && isDisplayWarning) {
          this.gaugeChart.handler.alerts.show('Some labels were hidden due to size constraints');
        }

        return series;
      }
    }]);

    return MeterGauge;
  }();

  return MeterGauge;
}

/***/ }),
/* 3025 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.VislibVisProvider = VislibVisProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

var _errors = __webpack_require__(37);

var _events = __webpack_require__(133);

__webpack_require__(942);

var _vis_config = __webpack_require__(3026);

var _handler = __webpack_require__(3027);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function VislibVisProvider(Private) {
  var Events = Private(_events.EventsProvider);
  var VisConfig = Private(_vis_config.VislibVisConfigProvider);
  var Handler = Private(_handler.VisHandlerProvider);

  /**
   * Creates the visualizations.
   *
   * @class Vis
   * @constructor
   * @param $el {HTMLElement} jQuery selected HTML element
   * @param config {Object} Parameters that define the chart type and chart options
   */

  var Vis = function (_Events) {
    _inherits(Vis, _Events);

    function Vis($el, visConfigArgs) {
      _classCallCheck(this, Vis);

      var _this = _possibleConstructorReturn(this, (Vis.__proto__ || Object.getPrototypeOf(Vis)).call(this, arguments));

      _this.el = $el.get ? $el.get(0) : $el;
      _this.visConfigArgs = _lodash2.default.cloneDeep(visConfigArgs);
      return _this;
    }

    _createClass(Vis, [{
      key: 'hasLegend',
      value: function hasLegend() {
        return this.visConfigArgs.addLegend;
      }
      /**
       * Renders the visualization
       *
       * @method render
       * @param data {Object} Elasticsearch query results
       */

    }, {
      key: 'render',
      value: function render(data, uiState) {
        if (!data) {
          throw new Error('No valid data!');
        }

        if (this.handler) {
          this.data = null;
          this._runOnHandler('destroy');
        }

        this.data = data;

        this.uiState = uiState;

        this.visConfig = new VisConfig(this.visConfigArgs, this.data, this.uiState, this.el);

        this.handler = new Handler(this, this.visConfig);
        this._runOnHandler('render');
      }
    }, {
      key: 'getLegendLabels',
      value: function getLegendLabels() {
        return this.visConfig ? this.visConfig.get('legend.labels', null) : null;
      }
    }, {
      key: 'getLegendColors',
      value: function getLegendColors() {
        return this.visConfig ? this.visConfig.get('legend.colors', null) : null;
      }
    }, {
      key: '_runOnHandler',
      value: function _runOnHandler(method) {
        try {
          this.handler[method]();
        } catch (error) {

          if (error instanceof _errors.KbnError) {
            error.displayToScreen(this.handler);
          } else {
            throw error;
          }
        }
      }

      /**
       * Destroys the visualization
       * Removes chart and all elements associated with it.
       * Removes chart and all elements associated with it.
       * Remove event listeners and pass destroy call down to owned objects.
       *
       * @method destroy
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        var selection = _d2.default.select(this.el).select('.vis-wrapper');

        if (this.handler) this._runOnHandler('destroy');

        selection.remove();
      }

      /**
       * Sets attributes on the visualization
       *
       * @method set
       * @param name {String} An attribute name
       * @param val {*} Value to which the attribute name is set
       */

    }, {
      key: 'set',
      value: function set(name, val) {
        this.visConfigArgs[name] = val;
        this.render(this.data, this.uiState);
      }

      /**
       * Gets attributes from the visualization
       *
       * @method get
       * @param name {String} An attribute name
       * @returns {*} The value of the attribute name
       */

    }, {
      key: 'get',
      value: function get(name) {
        return this.visConfig.get(name);
      }

      /**
       * Turns on event listeners.
       *
       * @param event {String}
       * @param listener{Function}
       * @returns {*}
       */

    }, {
      key: 'on',
      value: function on(event, listener) {
        var first = this.listenerCount(event) === 0;
        var ret = Events.prototype.on.call(this, event, listener);
        var added = this.listenerCount(event) > 0;

        // if this is the first listener added for the event
        // enable the event in the handler
        if (first && added && this.handler) this.handler.enable(event);

        return ret;
      }

      /**
       * Turns off event listeners.
       *
       * @param event {String}
       * @param listener{Function}
       * @returns {*}
       */

    }, {
      key: 'off',
      value: function off(event, listener) {
        var last = this.listenerCount(event) === 1;
        var ret = Events.prototype.off.call(this, event, listener);
        var removed = this.listenerCount(event) === 0;

        // Once all listeners are removed, disable the events in the handler
        if (last && removed && this.handler) this.handler.disable(event);
        return ret;
      }
    }]);

    return Vis;
  }(Events);

  return Vis;
}

/***/ }),
/* 3026 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Provides vislib configuration, throws error if invalid property is accessed without providing defaults
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


exports.VislibVisConfigProvider = VislibVisConfigProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _types = __webpack_require__(934);

var _data = __webpack_require__(530);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function VislibVisConfigProvider(Private) {

  var Data = Private(_data.VislibLibDataProvider);
  var visTypes = Private(_types.VislibTypesProvider);
  var DEFAULT_VIS_CONFIG = {
    style: {
      margin: { top: 10, right: 3, bottom: 5, left: 3 }
    },
    alerts: [],
    categoryAxes: [],
    valueAxes: [],
    grid: {}
  };

  var VisConfig = function () {
    function VisConfig(visConfigArgs, data, uiState, el) {
      _classCallCheck(this, VisConfig);

      this.data = new Data(data, uiState);

      var visType = visTypes[visConfigArgs.type];
      var typeDefaults = visType(visConfigArgs, this.data);
      this._values = _lodash2.default.defaultsDeep({}, typeDefaults, DEFAULT_VIS_CONFIG);
      this._values.el = el;
    }

    _createClass(VisConfig, [{
      key: 'get',
      value: function get(property, defaults) {
        if (_lodash2.default.has(this._values, property) || typeof defaults !== 'undefined') {
          return _lodash2.default.get(this._values, property, defaults);
        } else {
          throw new Error('Accessing invalid config property: ' + property);
          return defaults;
        }
      }
    }, {
      key: 'set',
      value: function set(property, value) {
        return _lodash2.default.set(this._values, property, value);
      }
    }]);

    return VisConfig;
  }();

  return VisConfig;
}

/***/ }),
/* 3027 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.VisHandlerProvider = VisHandlerProvider;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _markdownIt = __webpack_require__(235);

var _markdownIt2 = _interopRequireDefault(_markdownIt);

var _errors = __webpack_require__(37);

var _binder = __webpack_require__(940);

var _layout = __webpack_require__(3028);

var _chart_title = __webpack_require__(945);

var _alerts = __webpack_require__(3035);

var _axis = __webpack_require__(943);

var _chart_grid = __webpack_require__(3036);

var _vis_types = __webpack_require__(939);

var _render_complete = __webpack_require__(264);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var markdownIt = new _markdownIt2.default({
  html: false,
  linkify: true
});

function VisHandlerProvider(Private) {
  var chartTypes = Private(_vis_types.VislibVisualizationsVisTypesProvider);
  var Layout = Private(_layout.VislibLibLayoutLayoutProvider);
  var ChartTitle = Private(_chart_title.VislibLibChartTitleProvider);
  var Alerts = Private(_alerts.VislibLibAlertsProvider);
  var Axis = Private(_axis.VislibLibAxisProvider);
  var Grid = Private(_chart_grid.VislibGridProvider);

  /**
   * Handles building all the components of the visualization
   *
   * @class Handler
   * @constructor
   * @param vis {Object} Reference to the Vis Class Constructor
   * @param opts {Object} Reference to Visualization constructors needed to
   * create the visualization
   */

  var Handler = function () {
    function Handler(vis, visConfig) {
      _classCallCheck(this, Handler);

      this.el = visConfig.get('el');
      this.ChartClass = chartTypes[visConfig.get('type')];
      this.charts = [];

      this.vis = vis;
      this.visConfig = visConfig;
      this.data = visConfig.data;

      this.categoryAxes = visConfig.get('categoryAxes').map(function (axisArgs) {
        return new Axis(visConfig, axisArgs);
      });
      this.valueAxes = visConfig.get('valueAxes').map(function (axisArgs) {
        return new Axis(visConfig, axisArgs);
      });
      this.chartTitle = new ChartTitle(visConfig);
      this.alerts = new Alerts(this, visConfig.get('alerts'));
      this.grid = new Grid(this, visConfig.get('grid'));

      if (visConfig.get('type') === 'point_series') {
        this.data.stackData(this);
      }

      if (visConfig.get('resize', false)) {
        this.resize = visConfig.get('resize');
      }

      this.layout = new Layout(visConfig);
      this.binder = new _binder.Binder();
      this.renderArray = _lodash2.default.filter([this.layout, this.chartTitle, this.alerts], Boolean);

      this.renderArray = this.renderArray.concat(this.valueAxes)
      // category axes need to render in reverse order https://github.com/elastic/kibana/issues/13551
      .concat(this.categoryAxes.slice().reverse());

      // memoize so that the same function is returned every time,
      // allowing us to remove/re-add the same function
      this.getProxyHandler = _lodash2.default.memoize(function (event) {
        var self = this;
        return function (e) {
          self.vis.emit(event, e);
        };
      });

      /**
       * Enables events, i.e. binds specific events to the chart
       * object(s) `on` method. For example, `click` or `mousedown` events.
       *
       * @method enable
       * @param event {String} Event type
       * @param chart {Object} Chart
       * @returns {*}
       */
      this.enable = this.chartEventProxyToggle('on');

      /**
       * Disables events for all charts
       *
       * @method disable
       * @param event {String} Event type
       * @param chart {Object} Chart
       * @returns {*}
       */
      this.disable = this.chartEventProxyToggle('off');
    }
    /**
     * Validates whether data is actually present in the data object
     * used to render the Vis. Throws a no results error if data is not
     * present.
     *
     * @private
     */


    _createClass(Handler, [{
      key: '_validateData',
      value: function _validateData() {
        var dataType = this.data.type;

        if (!dataType) {
          throw new _errors.NoResults();
        }
      }

      /**
       * Renders the constructors that create the visualization,
       * including the chart constructor
       *
       * @method render
       * @returns {HTMLElement} With the visualization child element
       */

    }, {
      key: 'render',
      value: function render() {
        if (this.visConfig.get('error', null)) return this.error(this.visConfig.get('error'));

        var self = this;
        var binder = this.binder,
            _charts = this.charts,
            charts = _charts === undefined ? [] : _charts;

        var selection = _d2.default.select(this.el);

        selection.selectAll('*').remove();

        this._validateData();
        this.renderArray.forEach(function (property) {
          if (typeof property.render === 'function') {
            property.render();
          }
        });

        // render the chart(s)
        var loadedCount = 0;
        var chartSelection = selection.selectAll('.chart');
        chartSelection.each(function (chartData) {
          var chart = new self.ChartClass(self, this, chartData);

          self.vis.activeEvents().forEach(function (event) {
            self.enable(event, chart);
          });

          binder.on(chart.events, 'rendered', function () {
            loadedCount++;
            if (loadedCount === chartSelection.length) {
              // events from all charts are propagated to vis, we only need to fire renderComplete once they all finish
              self.vis.emit('renderComplete');
            }
          });

          charts.push(chart);
          chart.render();
        });
      }
    }, {
      key: 'chartEventProxyToggle',
      value: function chartEventProxyToggle(method) {
        return function (event, chart) {
          var proxyHandler = this.getProxyHandler(event);

          _lodash2.default.each(chart ? [chart] : this.charts, function (chart) {
            chart.events[method](event, proxyHandler);
          });
        };
      }

      /**
       * Removes all DOM elements from the HTML element provided
       *
       * @method removeAll
       * @param el {HTMLElement} Reference to the HTML Element that
       * contains the chart
       * @returns {D3.Selection|D3.Transition.Transition} With the chart
       * child element removed
       */

    }, {
      key: 'removeAll',
      value: function removeAll(el) {
        return _d2.default.select(el).selectAll('*').remove();
      }

      /**
       * Displays an error message in the DOM
       *
       * @method error
       * @param message {String} Error message to display
       * @returns {HTMLElement} Displays the input message
       */

    }, {
      key: 'error',
      value: function error(message) {
        this.removeAll(this.el);

        var div = _d2.default.select(this.el).append('div')
        // class name needs `chart` in it for the polling checkSize function
        // to continuously call render on resize
        .attr('class', 'visualize-error chart error');

        if (message === 'No results found') {
          div.append('div').attr('class', 'text-center visualize-error visualize-chart').append('div').attr('class', 'item top').append('div').attr('class', 'item').append('h2').html('<i class="fa fa-meh-o"></i>').append('h4').text(message);

          div.append('div').attr('class', 'item bottom');
        } else {
          div.append('h4').text(markdownIt.renderInline(message));
        }

        (0, _render_complete.dispatchRenderComplete)(this.el);
        return div;
      }

      /**
       * Destroys all the charts in the visualization
       *
       * @method destroy
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.binder.destroy();

        this.renderArray.forEach(function (renderable) {
          if (_lodash2.default.isFunction(renderable.destroy)) {
            renderable.destroy();
          }
        });

        this.charts.splice(0).forEach(function (chart) {
          if (_lodash2.default.isFunction(chart.destroy)) {
            chart.destroy();
          }
        });
      }
    }]);

    return Handler;
  }();

  return Handler;
}

/***/ }),
/* 3028 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.VislibLibLayoutLayoutProvider = VislibLibLayoutLayoutProvider;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

var _layout_types = __webpack_require__(935);

var _axis = __webpack_require__(3029);

var _chart_title = __webpack_require__(945);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function VislibLibLayoutLayoutProvider(Private) {

  var layoutType = Private(_layout_types.VislibLibLayoutLayoutTypesProvider);
  var Axis = Private(_axis.VislibLibAxisProvider);
  var ChartTitle = Private(_chart_title.VislibLibChartTitleProvider);
  /**
   * Builds the visualization DOM layout
   *
   * The Layout Constructor is responsible for rendering the visualization
   * layout, which includes all the DOM div elements.
   * Input:
   *   1. DOM div - parent element for which the layout is attached
   *   2. data - data is bound to the div element
   *   3. chartType (e.g. 'histogram') - specifies the layout type to grab
   *
   * @class Layout
   * @constructor
   * @param el {HTMLElement} HTML element to which the chart will be appended
   * @param data {Object} Elasticsearch query results for this specific chart
   * @param chartType {Object} Reference to chart functions, i.e. Pie
   */

  var Layout = function () {
    function Layout(config) {
      _classCallCheck(this, Layout);

      this.el = config.get('el');
      this.data = config.data.data;
      this.opts = config;
      this.layoutType = layoutType[config.get('type')](this.el, this.data);
    }

    // Render the layout
    /**
     * Renders visualization HTML layout
     * Remove all elements from the current visualization and creates the layout
     *
     * @method render
     */


    _createClass(Layout, [{
      key: 'render',
      value: function render() {
        this.removeAll(this.el);
        this.createLayout(this.layoutType);
        // update y-axis-spacer height based on precalculated horizontal axis heights
        if (this.opts.get('type') === 'point_series') {
          this.updateCategoryAxisSize();
        }
      }

      /**
       * Create the layout based on the json array provided
       * for each object in the layout array, call the layout function
       *
       * @method createLayout
       * @param arr {Array} Json array
       * @returns {*} Creates the visualization layout
       */

    }, {
      key: 'createLayout',
      value: function createLayout(arr) {
        var _this = this;

        return _lodash2.default.each(arr, function (obj) {
          _this.layout(obj);
        });
      }
    }, {
      key: 'updateCategoryAxisSize',
      value: function updateCategoryAxisSize() {
        var visConfig = this.opts;
        var axisConfig = visConfig.get('categoryAxes[0]');
        var axis = new Axis(visConfig, axisConfig);
        var position = axis.axisConfig.get('position');
        var chartTitle = new ChartTitle(visConfig);

        var axisWrapperElement = (0, _jquery2.default)(this.el).find('.axis-wrapper-' + position);

        axisWrapperElement.css('visibility', 'hidden');
        axis.render();
        chartTitle.render();
        var width = axisWrapperElement.width();
        var height = axisWrapperElement.height();
        axis.destroy();
        (0, _jquery2.default)(this.el).find('.chart-title svg').remove();
        axisWrapperElement.css('visibility', '');

        if (axis.axisConfig.isHorizontal()) {
          var spacerNodes = (0, _jquery2.default)(this.el).find('.y-axis-spacer-block-' + position);
          spacerNodes.height(height + 'px');
        } else {
          axisWrapperElement.find('.y-axis-div-wrapper').width(width + 'px');
        }
      }

      /**
       * Appends a DOM element based on the object keys
       * check to see if reference to DOM element is string but not class selector
       * Create a class selector
       *
       * @method layout
       * @param obj {Object} Instructions for creating the layout of a DOM Element
       * @returns {*} DOM Element
       */

    }, {
      key: 'layout',
      value: function layout(obj) {
        if (!obj.parent) {
          throw new Error('No parent element provided');
        }

        if (!obj.type) {
          throw new Error('No element type provided');
        }

        if (typeof obj.type !== 'string') {
          throw new Error(obj.type + ' must be a string');
        }

        if (typeof obj.parent === 'string' && obj.parent.charAt(0) !== '.') {
          obj.parent = '.' + obj.parent;
        }

        var childEl = this.appendElem(obj.parent, obj.type, obj.class);

        if (obj.datum) {
          childEl.datum(obj.datum);
        }

        if (obj.splits) {
          childEl.call(obj.splits, obj.parent, this.opts);
        }

        if (obj.children) {
          var newParent = childEl[0][0];

          _lodash2.default.forEach(obj.children, function (obj) {
            if (!obj.parent) {
              obj.parent = newParent;
            }
          });

          this.createLayout(obj.children);
        }

        return childEl;
      }

      /**
       * Appends a `type` of DOM element to `el` and gives it a class name attribute `className`
       *
       * @method appendElem
       * @param el {HTMLElement} Reference to a DOM Element
       * @param type {String} DOM element type
       * @param className {String} CSS class name
       * @returns {*} Reference to D3 Selection
       */

    }, {
      key: 'appendElem',
      value: function appendElem(el, type, className) {
        if (!el || !type || !className) {
          throw new Error('Function requires that an el, type, and class be provided');
        }

        if (typeof el === 'string') {
          // Create a DOM reference with a d3 selection
          // Need to make sure that the `el` is bound to this object
          // to prevent it from being appended to another Layout
          el = _d2.default.select(this.el).select(el)[0][0];
        }

        return _d2.default.select(el).append(type).attr('class', className);
      }

      /**
       * Removes all DOM elements from DOM element
       *
       * @method removeAll
       * @param el {HTMLElement} Reference to DOM element
       * @returns {D3.Selection|D3.Transition.Transition} Reference to an empty DOM element
       */

    }, {
      key: 'removeAll',
      value: function removeAll(el) {
        return _d2.default.select(el).selectAll('*').remove();
      }
    }]);

    return Layout;
  }();

  return Layout;
}

/***/ }),
/* 3029 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _axis = __webpack_require__(943);

Object.defineProperty(exports, 'VislibLibAxisProvider', {
  enumerable: true,
  get: function get() {
    return _axis.VislibLibAxisProvider;
  }
});

/***/ }),
/* 3030 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.VislibLibAxisTitleProvider = VislibLibAxisTitleProvider;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function VislibLibAxisTitleProvider() {
  var AxisTitle = function () {
    function AxisTitle(axisConfig) {
      _classCallCheck(this, AxisTitle);

      this.axisConfig = axisConfig;
      this.elSelector = this.axisConfig.get('title.elSelector').replace('{pos}', this.axisConfig.get('position'));
    }

    _createClass(AxisTitle, [{
      key: 'render',
      value: function render() {
        _d2.default.select(this.axisConfig.get('rootEl')).selectAll(this.elSelector).call(this.draw());
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        (0, _jquery2.default)(this.axisConfig.get('rootEl')).find(this.elSelector).find('svg').remove();
      }
    }, {
      key: 'draw',
      value: function draw() {
        var config = this.axisConfig;

        return function (selection) {
          selection.each(function () {
            if (!config.get('show') && !config.get('title.show', false)) return;

            var el = this;
            var div = _d2.default.select(el);
            var width = (0, _jquery2.default)(el).width();
            var height = (0, _jquery2.default)(el).height();
            var axisPrefix = config.isHorizontal() ? 'x' : 'y';

            var svg = div.append('svg').attr('width', width).attr('height', height).attr('class', 'axis-title ' + axisPrefix + '-axis-title');

            var bbox = svg.append('text').attr('transform', function () {
              if (config.isHorizontal()) {
                return 'translate(' + width / 2 + ',0)';
              }
              return 'translate(0,' + height / 2 + ') rotate(270)';
            }).attr('text-anchor', 'middle').attr('alignment-baseline', 'hanging').text(config.get('title.text')).node().getBBox();

            if (config.isHorizontal()) {
              svg.attr('height', Math.ceil(bbox.height));
            } else {
              svg.attr('width', Math.ceil(bbox.height));
            }
          });
        };
      }
    }]);

    return AxisTitle;
  }();

  return AxisTitle;
}

/***/ }),
/* 3031 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.VislibAxisLabelsProvider = VislibAxisLabelsProvider;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

var _truncate_labels = __webpack_require__(941);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function VislibAxisLabelsProvider() {
  var AxisLabels = function () {
    function AxisLabels(axisConfig, scale) {
      _classCallCheck(this, AxisLabels);

      this.axisConfig = axisConfig;
      this.axisScale = scale;
    }

    _createClass(AxisLabels, [{
      key: 'render',
      value: function render(selection) {
        selection.call(this.draw());
      }
    }, {
      key: 'rotateAxisLabels',
      value: function rotateAxisLabels() {
        var config = this.axisConfig;
        return function (selection) {
          var text = selection.selectAll('.tick text');

          if (config.get('labels.rotate')) {
            text.style('text-anchor', function () {
              var currentValue = (0, _jquery2.default)(this).css('text-anchor');
              var rotateDeg = config.get('labels.rotate');
              if (!rotateDeg) return currentValue;else {
                var position = config.get('position');
                switch (position) {
                  case 'top':
                    return 'end';
                  case 'bottom':
                    return 'end';
                  default:
                    if (rotateDeg === 90 || rotateDeg === -90) return 'middle';
                    return currentValue;
                }
              }
            }).attr('dy', function () {
              return config.isHorizontal() ? '0.3em' : '0';
            }).attr('transform', function rotate(d, j) {
              var position = config.get('position');
              var rotateDeg = position === 'top' ? config.get('labels.rotate') : -config.get('labels.rotate');

              if ((0, _jquery2.default)(this).css('text-anchor') === 'middle') {
                var coord = text[0][j].getBBox();
                var transX = coord.x + coord.width / 2;
                var transY = coord.y + coord.height / 2;
                return 'rotate(' + rotateDeg + ', ' + transX + ', ' + transY + ')';
              } else {
                var _transX = this.attributes.x.nodeValue;
                var _transY = this.attributes.y.nodeValue;
                return 'rotate(' + rotateDeg + ', ' + _transX + ', ' + _transY + ')';
              }
            });
          }
        };
      }
    }, {
      key: 'truncateLabels',
      value: function truncateLabels() {
        var config = this.axisConfig;
        return function (selection) {
          if (!config.get('labels.truncate')) return;

          selection.selectAll('.tick text').text(function () {
            return (0, _truncate_labels.truncateLabel)(this, config.get('labels.truncate'));
          });
        };
      }
    }, {
      key: 'filterAxisLabels',
      value: function filterAxisLabels() {
        var self = this;
        var config = this.axisConfig;
        var startPos = 0;
        var padding = 1.1;

        return function (selection) {
          if (!config.get('labels.filter')) return;
          selection.selectAll('.tick text').text(function (d) {
            var par = _d2.default.select(this.parentNode).node();
            var el = (0, _jquery2.default)(config.get('rootEl')).find(config.get('elSelector'));
            var maxSize = config.isHorizontal() ? el.width() : el.height();
            var myPos = config.isHorizontal() ? self.axisScale.scale(d) : maxSize - self.axisScale.scale(d);
            var mySize = (config.isHorizontal() ? par.getBBox().width : par.getBBox().height) * padding;
            var halfSize = mySize / 2;

            if (startPos + halfSize < myPos && maxSize > myPos + halfSize) {
              startPos = myPos + halfSize;
              return this.textContent;
            } else {
              _d2.default.select(this.parentNode).remove();
            }
          });
        };
      }
    }, {
      key: 'draw',
      value: function draw() {
        var self = this;
        var config = this.axisConfig;

        return function (selection) {
          selection.each(function () {
            selection.selectAll('text').attr('style', function () {
              var currentStyle = _d2.default.select(this).attr('style');
              return currentStyle + ' font-size: ' + config.get('labels.fontSize') + ';';
            });
            if (!config.get('labels.show')) selection.selectAll('text').attr('style', 'display: none;');

            selection.call(self.truncateLabels());
            selection.call(self.rotateAxisLabels());
            selection.call(self.filterAxisLabels());
          });
        };
      }
    }]);

    return AxisLabels;
  }();

  return AxisLabels;
}

/***/ }),
/* 3032 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.VislibAxisScaleProvider = VislibAxisScaleProvider;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

var _errors = __webpack_require__(37);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function VislibAxisScaleProvider() {
  var AxisScale = function () {
    function AxisScale(axisConfig, visConfig) {
      _classCallCheck(this, AxisScale);

      this.axisConfig = axisConfig;
      this.visConfig = visConfig;

      if (this.axisConfig.get('type') === 'category') {
        this.values = this.axisConfig.values;
        this.ordered = this.axisConfig.ordered;
      }
    }

    _createClass(AxisScale, [{
      key: 'getScaleType',
      value: function getScaleType() {
        return this.axisConfig.getScaleType();
      }
    }, {
      key: 'validateUserExtents',
      value: function validateUserExtents(domain) {
        var config = this.axisConfig;
        return domain.map(function (val) {
          val = parseFloat(val);
          if (isNaN(val)) throw new Error(val + ' is not a valid number');
          if (config.isPercentage() && config.isUserDefined()) return val / 100;
          return val;
        });
      }
    }, {
      key: 'getTimeDomain',
      value: function getTimeDomain(data) {
        return [this.minExtent(data), this.maxExtent(data)];
      }
    }, {
      key: 'minExtent',
      value: function minExtent(data) {
        return this.calculateExtent(data || this.values, 'min');
      }
    }, {
      key: 'maxExtent',
      value: function maxExtent(data) {
        return this.calculateExtent(data || this.values, 'max');
      }
    }, {
      key: 'calculateExtent',
      value: function calculateExtent(data, extent) {
        var ordered = this.ordered;
        var opts = [ordered[extent]];

        var point = _d2.default[extent](data);
        if (this.axisConfig.get('scale.expandLastBucket') && extent === 'max') {
          point = this.addInterval(point);
        }
        opts.push(point);

        return _d2.default[extent](opts.reduce(function (opts, v) {
          if (!_lodash2.default.isNumber(v)) v = +v;
          if (!isNaN(v)) opts.push(v);
          return opts;
        }, []));
      }
    }, {
      key: 'addInterval',
      value: function addInterval(x) {
        return this.modByInterval(x, +1);
      }
    }, {
      key: 'subtractInterval',
      value: function subtractInterval(x) {
        return this.modByInterval(x, -1);
      }
    }, {
      key: 'modByInterval',
      value: function modByInterval(x, n) {
        var ordered = this.ordered;
        if (!ordered) return x;
        var interval = ordered.interval;
        if (!interval) return x;

        if (!ordered.date) {
          return x += ordered.interval * n;
        }

        var y = (0, _moment2.default)(x);
        var method = n > 0 ? 'add' : 'subtract';

        _lodash2.default.times(Math.abs(n), function () {
          y[method](interval);
        });

        return y.valueOf();
      }
    }, {
      key: 'getAllPoints',
      value: function getAllPoints() {
        var _this = this;

        var config = this.axisConfig;
        var data = this.visConfig.data.chartData();
        var chartPoints = _lodash2.default.reduce(data, function (chartPoints, chart, chartIndex) {
          var points = chart.series.reduce(function (points, seri, seriIndex) {
            var seriConfig = _this.visConfig.get('charts[' + chartIndex + '].series[' + seriIndex + ']');
            var matchingValueAxis = !!seriConfig.valueAxis && seriConfig.valueAxis === config.get('id');
            var isFirstAxis = config.get('id') === _this.visConfig.get('valueAxes[0].id');

            if (matchingValueAxis || !seriConfig.valueAxis && isFirstAxis) {
              var axisPoints = seri.values.map(function (val) {
                if (val.y0) {
                  return val.y0 + val.y;
                }
                return val.y;
              });
              return points.concat(axisPoints);
            }
            return points;
          }, []);
          return chartPoints.concat(points);
        }, []);

        return chartPoints;
      }
    }, {
      key: 'getYMin',
      value: function getYMin() {
        return _d2.default.min(this.getAllPoints());
      }
    }, {
      key: 'getYMax',
      value: function getYMax() {
        return _d2.default.max(this.getAllPoints());
      }
    }, {
      key: 'getExtents',
      value: function getExtents() {
        if (this.axisConfig.get('type') === 'category') {
          if (this.axisConfig.isTimeDomain()) return this.getTimeDomain(this.values);
          if (this.axisConfig.isOrdinal()) return this.values;
        }

        var min = this.axisConfig.get('scale.min', this.getYMin());
        var max = this.axisConfig.get('scale.max', this.getYMax());
        var domain = [min, max];
        if (this.axisConfig.isUserDefined()) return this.validateUserExtents(domain);
        if (this.axisConfig.isLogScale()) return this.logDomain(min, max);
        if (this.axisConfig.isYExtents()) return domain;
        return [Math.min(0, min), Math.max(0, max)];
      }
    }, {
      key: 'getRange',
      value: function getRange(length) {
        if (this.axisConfig.isHorizontal()) {
          return !this.axisConfig.get('scale.inverted') ? [0, length] : [length, 0];
        } else {
          return this.axisConfig.get('scale.inverted') ? [0, length] : [length, 0];
        }
      }
    }, {
      key: 'throwCustomError',
      value: function throwCustomError(message) {
        throw new Error(message);
      }
    }, {
      key: 'throwLogScaleValuesError',
      value: function throwLogScaleValuesError() {
        throw new _errors.InvalidLogScaleValues();
      }
    }, {
      key: 'logDomain',
      value: function logDomain(min, max) {
        if (min < 0 || max < 0) return this.throwLogScaleValuesError();
        return [1, max];
      }
    }, {
      key: 'getD3Scale',
      value: function getD3Scale(scaleTypeArg) {
        var scaleType = scaleTypeArg || 'linear';
        if (scaleType === 'square root') scaleType = 'sqrt';

        if (this.axisConfig.isTimeDomain()) return _d2.default.time.scale.utc(); // allow time scale
        if (this.axisConfig.isOrdinal()) return _d2.default.scale.ordinal();
        if (typeof _d2.default.scale[scaleType] !== 'function') {
          return this.throwCustomError('Axis.getScaleType: ' + scaleType + ' is not a function');
        }

        return _d2.default.scale[scaleType]();
      }
    }, {
      key: 'canApplyNice',
      value: function canApplyNice() {
        var config = this.axisConfig;
        return !config.isUserDefined() && !config.isYExtents() && !config.isOrdinal() && !config.isTimeDomain();
      }
    }, {
      key: 'getScale',
      value: function getScale(length) {
        var config = this.axisConfig;
        var scale = this.getD3Scale(config.getScaleType());
        var domain = this.getExtents();
        var range = this.getRange(length);
        var padding = config.get('style.rangePadding');
        var outerPadding = config.get('style.rangeOuterPadding');
        this.scale = scale.domain(domain);
        if (config.isOrdinal()) {
          this.scale.rangeBands(range, padding, outerPadding);
        } else {
          this.scale.range(range);
        }

        if (this.canApplyNice()) this.scale.nice();
        // Prevents bars from going off the chart when the y extents are within the domain range
        if (this.scale.clamp) this.scale.clamp(true);

        this.validateScale(this.scale);

        return this.scale;
      }
    }, {
      key: 'validateScale',
      value: function validateScale(scale) {
        if (!scale || _lodash2.default.isNaN(scale)) throw new Error('scale is ' + scale);
      }
    }]);

    return AxisScale;
  }();

  return AxisScale;
}

/***/ }),
/* 3033 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.VislibLibAxisConfigProvider = VislibLibAxisConfigProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

var _scale_modes = __webpack_require__(3034);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function VislibLibAxisConfigProvider() {

  var defaults = {
    show: true,
    type: 'value',
    elSelector: '.axis-wrapper-{pos} .axis-div',
    position: 'left',
    scale: {
      type: 'linear',
      expandLastBucket: true,
      inverted: false,
      setYExtents: null,
      defaultYExtents: null,
      min: null,
      max: null,
      mode: _scale_modes.SCALE_MODES.NORMAL
    },
    style: {
      color: '#ddd',
      lineWidth: '1px',
      opacity: 1,
      tickColor: '#ddd',
      tickWidth: '1px',
      tickLength: '6px',
      rangePadding: 0.1,
      rangeOuterPadding: 0
    },
    labels: {
      axisFormatter: null,
      show: true,
      rotate: 0,
      rotateAnchor: 'center',
      filter: false,
      color: '#ddd',
      font: '"Open Sans", "Lato", "Helvetica Neue", Helvetica, Arial, sans-serif',
      fontSize: '8pt',
      truncate: 100
    },
    title: {
      text: '',
      elSelector: '.axis-wrapper-{pos} .axis-div'
    }
  };

  var categoryDefaults = {
    type: 'category',
    position: 'bottom'
  };

  var valueDefaults = {
    labels: {
      axisFormatter: _d2.default.format('n')
    }
  };

  var horizontalDefaults = {
    labels: {
      rotate: 0,
      rotateAnchor: 'end',
      filter: true,
      truncate: 0
    }
  };

  var verticalDefaults = {
    labels: {
      rotateAnchor: 'middle'
    }
  };

  var AxisConfig = function () {
    function AxisConfig(chartConfig, axisConfigArgs) {
      _classCallCheck(this, AxisConfig);

      var typeDefaults = axisConfigArgs.type === 'category' ? categoryDefaults : valueDefaults;
      // _.defaultsDeep mutates axisConfigArgs nested values so we clone it first
      var axisConfigArgsClone = _lodash2.default.cloneDeep(axisConfigArgs);
      var isCategoryAxis = axisConfigArgsClone.type === 'category';
      var isHorizontal = axisConfigArgsClone.position && ['top', 'bottom'].includes(axisConfigArgsClone.position);

      _lodash2.default.merge(typeDefaults, isHorizontal || isCategoryAxis ? horizontalDefaults : verticalDefaults);
      this._values = _lodash2.default.defaultsDeep({}, axisConfigArgsClone, typeDefaults, defaults);

      this._values.elSelector = this._values.elSelector.replace('{pos}', this._values.position);
      this._values.rootEl = chartConfig.get('el');

      this.data = chartConfig.data;
      if (isCategoryAxis) {
        if (!this._values.values) {
          this.values = this.data.xValues(chartConfig.get('orderBucketsBySum', false));
          this.ordered = this.data.get('ordered');
        } else {
          this.values = this._values.values;
        }
        if (!this._values.labels.axisFormatter) {
          this._values.labels.axisFormatter = this.data.data.xAxisFormatter || this.data.get('xAxisFormatter');
        }
      }

      if (this.get('type') === 'value') {
        var isWiggleOrSilhouette = this.get('scale.mode') === _scale_modes.SCALE_MODES.WIGGLE || this.get('scale.mode') === _scale_modes.SCALE_MODES.SILHOUETTE;
        // if show was not explicitly set and wiggle or silhouette option was checked
        if (isWiggleOrSilhouette) {
          this._values.scale.defaultYExtents = false;

          if (!axisConfigArgs.show) {
            this._values.show = false;
            this._values.title.show = true;
          }
        }

        // override axisFormatter (to replicate current behaviour)
        if (this.isPercentage()) {
          this._values.labels.axisFormatter = _d2.default.format('%');
        }

        if (this.isLogScale()) {
          this._values.labels.filter = true;
        }
      }

      if (axisConfigArgs.title == null || axisConfigArgs.title.text == null) {
        var label = isCategoryAxis ? 'xAxisLabel' : 'yAxisLabel';
        this.set('title.text', this.data.get(label));
      }

      // horizontal axis with ordinal scale should have labels rotated (so we can fit more)
      // unless explicitly overriden by user
      if (this.isHorizontal() && this.isOrdinal()) {
        this._values.labels.filter = _lodash2.default.get(axisConfigArgs, 'labels.filter', false);
        this._values.labels.rotate = _lodash2.default.get(axisConfigArgs, 'labels.rotate', 90);
        this._values.labels.truncate = _lodash2.default.get(axisConfigArgs, 'labels.truncate', 100);
      }

      if (this.get('type') === 'category' && !this.isHorizontal()) {
        this._values.scale.inverted = _lodash2.default.get(axisConfigArgs, 'scale.inverted', true);
      }

      var offset = void 0;
      var stacked = true;
      switch (this.get('scale.mode')) {
        case _scale_modes.SCALE_MODES.NORMAL:
          offset = 'zero';
          stacked = false;
          break;
        case _scale_modes.SCALE_MODES.GROUPED:
          offset = 'group';
          stacked = false;
          break;
        case _scale_modes.SCALE_MODES.PERCENTAGE:
          offset = 'expand';
          break;
        default:
          offset = this.get('scale.mode');
      }
      this.set('scale.offset', _lodash2.default.get(axisConfigArgs, 'scale.offset', offset));
      /* axis.scale.stacked means that axis stacking function should be run */
      this.set('scale.stacked', stacked);
    }

    _createClass(AxisConfig, [{
      key: 'get',
      value: function get(property, defaults) {
        if (typeof defaults === 'undefined' && !_lodash2.default.has(this._values, property)) {
          throw new Error('Accessing invalid config property: ' + property);
        }
        var val = _lodash2.default.get(this._values, property, defaults);
        if (val == null && defaults != null) return defaults;
        return val;
      }
    }, {
      key: 'set',
      value: function set(property, value) {
        return _lodash2.default.set(this._values, property, value);
      }
    }, {
      key: 'isHorizontal',
      value: function isHorizontal() {
        return this._values.position === 'top' || this._values.position === 'bottom';
      }
    }, {
      key: 'isOrdinal',
      value: function isOrdinal() {
        return !!this.values && !this.isTimeDomain();
      }
    }, {
      key: 'isTimeDomain',
      value: function isTimeDomain() {
        return this.ordered && this.ordered.date;
      }
    }, {
      key: 'isPercentage',
      value: function isPercentage() {
        return this._values.scale.mode === _scale_modes.SCALE_MODES.PERCENTAGE;
      }
    }, {
      key: 'isUserDefined',
      value: function isUserDefined() {
        return this._values.scale.setYExtents;
      }
    }, {
      key: 'isYExtents',
      value: function isYExtents() {
        return this._values.scale.defaultYExtents;
      }
    }, {
      key: 'isLogScale',
      value: function isLogScale() {
        return this.getScaleType() === 'log';
      }
    }, {
      key: 'getScaleType',
      value: function getScaleType() {
        return this._values.scale.type;
      }
    }]);

    return AxisConfig;
  }();

  return AxisConfig;
}

/***/ }),
/* 3034 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCALE_MODES = exports.SCALE_MODES = {
  NORMAL: 'normal',
  PERCENTAGE: 'percentage',
  WIGGLE: 'wiggle',
  SILHOUETTE: 'silhouette',
  GROUPED: 'grouped', // this should not be a scale mode but it is at this point to make it compatible with old charts
  ALL: ['normal', 'percentage', 'wiggle', 'silhouette']
};

/***/ }),
/* 3035 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.VislibLibAlertsProvider = VislibLibAlertsProvider;

var _jquery = __webpack_require__(7);

var _jquery2 = _interopRequireDefault(_jquery);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function VislibLibAlertsProvider() {

  /**
   * Adds allerts that float in front of a visualization
   *
   * @class Alerts
   * @constructor
   * @param el {HTMLElement} Reference to DOM element
   */
  var Alerts = function () {
    function Alerts(vis, alertDefs) {
      var _this = this;

      _classCallCheck(this, Alerts);

      this.vis = vis;
      this.data = vis.data;
      this.alertDefs = _lodash2.default.cloneDeep(alertDefs);

      this.alerts = (0, _lodash2.default)(alertDefs).map(function (alertDef) {
        if (!alertDef) return;
        if (alertDef.test && !alertDef.test(vis, _this.data)) return;
        return _this._addAlert(alertDef);
      }).compact();
    }

    _createClass(Alerts, [{
      key: '_addAlert',
      value: function _addAlert(alertDef) {
        var type = alertDef.type || 'info';
        var icon = alertDef.icon || type;
        var msg = alertDef.msg;
        // alert container
        var $icon = (0, _jquery2.default)('<i>').addClass('vis-alerts-icon fa fa-' + icon);
        var $text = (0, _jquery2.default)('<p>').addClass('vis-alerts-text').text(msg);
        var $closeIcon = (0, _jquery2.default)('<i>').addClass('fa fa-close');
        var $closeDiv = (0, _jquery2.default)('<div>').addClass('vis-alerts-close').append($closeIcon);

        var $alert = (0, _jquery2.default)('<div>').addClass('vis-alert vis-alert-' + type).append([$icon, $text, $closeDiv]);
        $closeDiv.on('click', function () {
          $alert.remove();
        });

        return $alert;
      }

      // renders initial alerts

    }, {
      key: 'render',
      value: function render() {
        var alerts = this.alerts;
        var vis = this.vis;

        (0, _jquery2.default)(vis.el).find('.vis-alerts').append((0, _jquery2.default)('<div>').addClass('vis-alerts-tray'));
        if (!alerts.size()) return;
        (0, _jquery2.default)(vis.el).find('.vis-alerts-tray').append(alerts.value());
      }

      // shows new alert

    }, {
      key: 'show',
      value: function show(msg, type) {
        var vis = this.vis;
        var alert = {
          msg: msg,
          type: type
        };
        if (this.alertDefs.find(function (alertDef) {
          return alertDef.msg === alert.msg;
        })) return;
        this.alertDefs.push(alert);
        (0, _jquery2.default)(vis.el).find('.vis-alerts-tray').append(this._addAlert(alert));
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        (0, _jquery2.default)(this.vis.el).find('.vis-alerts').remove();
      }
    }]);

    return Alerts;
  }();

  return Alerts;
}

/***/ }),
/* 3036 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.VislibGridProvider = VislibGridProvider;

var _d = __webpack_require__(21);

var _d2 = _interopRequireDefault(_d);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function VislibGridProvider() {

  var defaults = {
    style: {
      color: '#eee'
    },
    categoryLines: false,
    valueAxis: undefined
  };

  var ChartGrid = function () {
    function ChartGrid(handler, gridConfig) {
      _classCallCheck(this, ChartGrid);

      if (!gridConfig) return;
      this._handler = handler;
      this._values = _lodash2.default.defaultsDeep({}, gridConfig, defaults);
    }

    _createClass(ChartGrid, [{
      key: 'drawLine',
      value: function drawLine(svg, tick, axis, width, height) {
        var isHorizontal = axis.axisConfig.isHorizontal();
        var scale = axis.getScale();
        svg.append('path').attr('d', function () {
          var x0 = isHorizontal ? tick : 0;
          var x1 = isHorizontal ? tick : width;
          var y0 = !isHorizontal ? tick : 0;
          var y1 = !isHorizontal ? tick : height;
          var d3Line = _d2.default.svg.line().x(function (d) {
            return isHorizontal ? scale(d[0]) : d[0];
          }).y(function (d) {
            return !isHorizontal ? scale(d[1]) : d[1];
          });
          return d3Line([[x0, y0], [x1, y1]]);
        }).attr('fill', 'none').attr('stroke', this.get('style.color')).attr('stroke-width', 1);
      }
    }, {
      key: 'drawCategoryLines',
      value: function drawCategoryLines(svg, width, height) {
        var _this = this;

        var axis = this._handler.categoryAxes[0];
        if (!axis) return;
        var ticks = axis.getScale().ticks;
        if (!ticks) return;
        ticks().forEach(function (tick) {
          _this.drawLine(svg, tick, axis, width, height);
        });
      }
    }, {
      key: 'drawValueLines',
      value: function drawValueLines(svg, width, height) {
        var _this2 = this;

        var axis = this._handler.valueAxes.find(function (axis) {
          return axis.axisConfig.get('id') === _this2.get('valueAxis');
        });
        if (!axis) return;
        var ticks = axis.getScale().ticks;
        if (!ticks) return;
        ticks().forEach(function (tick) {
          _this2.drawLine(svg, tick, axis, width, height);
        });
      }
    }, {
      key: 'draw',
      value: function draw(width, height) {
        var self = this;
        return function (selection) {
          if (!self._values) return;
          selection.each(function () {
            if (self.get('categoryLines')) self.drawCategoryLines(_d2.default.select(this), width, height);
            if (self.get('valueAxis', false)) self.drawValueLines(_d2.default.select(this), width, height);
          });
        };
      }
    }, {
      key: 'get',
      value: function get(property, defaults) {
        if (_lodash2.default.has(this._values, property) || typeof defaults !== 'undefined') {
          return _lodash2.default.get(this._values, property, defaults);
        } else {
          throw new Error('Accessing invalid config property: ' + property);
          return defaults;
        }
      }
    }, {
      key: 'set',
      value: function set(property, value) {
        return _lodash2.default.set(this._values, property, value);
      }
    }]);

    return ChartGrid;
  }();

  return ChartGrid;
}

/***/ }),
/* 3037 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _modules = __webpack_require__(2);

var attributeName = 'data-render-complete';

_modules.uiModules.get('kibana').directive('renderComplete', function () {
  return {
    controller: function controller($scope, $element) {
      var el = $element[0];

      var start = function start() {
        $element.attr(attributeName, false);
        return true;
      };

      var complete = function complete() {
        $element.attr(attributeName, true);
        return true;
      };

      var teardown = function teardown() {
        el.removeEventListener('renderStart', start);
        el.removeEventListener('renderComplete', complete);
      };

      var setup = function setup() {
        $element.attr(attributeName, false);
        el.addEventListener('renderStart', start);
        el.addEventListener('renderComplete', complete);
        $scope.$on('$destroy', teardown);
      };

      this.disable = function () {
        $element.attr(attributeName, 'disabled');
        teardown();
      };

      setup();
    }
  };
});

/***/ }),
/* 3038 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.ReactVisTypeProvider = ReactVisTypeProvider;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(45);

var _vis_types = __webpack_require__(525);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ReactVisTypeProvider(Private, getAppState, config) {
  var VisType = Private(_vis_types.VisTypeProvider);

  var ReactVisController = function () {
    function ReactVisController(el, vis) {
      _classCallCheck(this, ReactVisController);

      this.el = el;
      this.vis = vis;
    }

    _createClass(ReactVisController, [{
      key: 'render',
      value: function render(visData) {
        var _this = this;

        this.visData = visData;

        return new Promise(function (resolve, reject) {
          if (!_this.visData) return reject();
          var Component = _this.vis.type.visConfig.component;
          (0, _reactDom.render)(_react2.default.createElement(Component, { config: config, vis: _this.vis, appState: getAppState(), visData: visData, renderComplete: resolve }), _this.el);
        });
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        (0, _reactDom.unmountComponentAtNode)(this.el);
      }
    }]);

    return ReactVisController;
  }();

  var ReactVisType = function (_VisType) {
    _inherits(ReactVisType, _VisType);

    function ReactVisType(opts) {
      _classCallCheck(this, ReactVisType);

      opts.visualization = ReactVisController;

      var _this2 = _possibleConstructorReturn(this, (ReactVisType.__proto__ || Object.getPrototypeOf(ReactVisType)).call(this, opts));

      if (!_this2.visConfig.component) {
        throw new Error('Missing component for ReactVisType');
      }
      return _this2;
    }

    return ReactVisType;
  }(VisType);

  return ReactVisType;
}

/***/ }),
/* 3039 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "3c9862715546cd524edf3b9fa7516994.svg";

/***/ }),
/* 3040 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TimelionRequestHandlerProvider = undefined;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _dashboard_context = __webpack_require__(534);

var _timezone = __webpack_require__(450);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TimelionRequestHandlerProvider = function TimelionRequestHandlerProvider(Private, Notifier, $http, $rootScope, timefilter) {
  var timezone = Private(_timezone.timezoneProvider)();
  var dashboardContext = Private(_dashboard_context.dashboardContextProvider);

  var notify = new Notifier({
    location: 'Timelion'
  });

  return {
    name: 'timelion',
    handler: function handler(vis /*, appState, uiState, queryFilter*/) {

      return new Promise(function (resolve, reject) {
        var expression = vis.params.expression;
        if (!expression) return;

        var timeFilter = timefilter.time;
        if (vis.params.timeRange) {
          timeFilter = {
            mode: 'absolute',
            from: vis.params.timeRange.min.toJSON(),
            to: vis.params.timeRange.max.toJSON()
          };
        }
        var httpResult = $http.post('../api/timelion/run', {
          sheet: [expression],
          extended: {
            es: {
              filter: dashboardContext()
            }
          },
          time: _lodash2.default.extend(timeFilter, {
            interval: vis.params.interval,
            timezone: timezone
          })
        }).then(function (resp) {
          return resp.data;
        }).catch(function (resp) {
          throw resp.data;
        });

        httpResult.then(function (resp) {
          resolve(resp);
        }).catch(function (resp) {
          var err = new Error(resp.message);
          err.stack = resp.stack;
          notify.error(err);
          reject(err);
        });
      });
    }
  };
};

exports.TimelionRequestHandlerProvider = TimelionRequestHandlerProvider;

/***/ }),
/* 3041 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(524);

__webpack_require__(926);

__webpack_require__(237);

var _modules = __webpack_require__(2);

_modules.uiModules.get('kibana/timelion_vis', ['kibana']).controller('TimelionVisController', function ($scope) {
  $scope.$on('timelionChartRendered', function (event) {
    event.stopPropagation();
    $scope.renderComplete();
  });
});

/***/ }),
/* 3042 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 3043 */
/***/ (function(module, exports) {

module.exports = "<div ng-controller=\"TimelionVisController\" class=\"timelion-vis\">\n    <div chart=\"esResponse.sheet[0]\" interval=\"vis.params.interval\"></div>\n</div>\n"

/***/ }),
/* 3044 */
/***/ (function(module, exports) {

module.exports = "<div class=\"kuiSideBarSection\">\n  <div class=\"form-group\">\n    <label for=\"timelionInterval\">Interval</label>\n    <div class=\"form-group\">\n      <timelion-interval model=\"vis.params.interval\"></timelion-interval>\n    </div>\n  </div>\n\n  <div class=\"form-group\">\n    <div>\n      <label>Timelion Expression</label>\n    </div>\n\n    <timelion-expression-input\n      sheet=\"vis.params.expression\"\n      rows=\"9\"\n    ></timelion-expression-input>\n  </div>\n\n</div>\n"

/***/ }),
/* 3045 */,
/* 3046 */,
/* 3047 */,
/* 3048 */,
/* 3049 */,
/* 3050 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _angular = __webpack_require__(16);

var _angular2 = _interopRequireDefault(_angular);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('app/dashboard');

// Used only by the savedDashboards service, usually no reason to change this
_module.factory('SavedDashboard', function (courier, config) {
  // SavedDashboard constructor. Usually you'd interact with an instance of this.
  // ID is option, without it one will be generated on save.
  _lodash2.default.class(SavedDashboard).inherits(courier.SavedObject);
  function SavedDashboard(id) {
    // Gives our SavedDashboard the properties of a SavedObject
    SavedDashboard.Super.call(this, {
      type: SavedDashboard.type,
      mapping: SavedDashboard.mapping,
      searchSource: SavedDashboard.searchsource,

      // if this is null/undefined then the SavedObject will be assigned the defaults
      id: id,

      // default values that will get assigned if the doc is new
      defaults: {
        title: 'New Dashboard',
        hits: 0,
        description: '',
        panelsJSON: '[]',
        optionsJSON: _angular2.default.toJson({
          darkTheme: config.get('dashboard:defaultDarkTheme'),
          // for BWC reasons we can't default dashboards that already exist without this setting to true.
          useMargins: id ? false : true,
          hidePanelTitles: false
        }),
        version: 1,
        timeRestore: false,
        timeTo: undefined,
        timeFrom: undefined,
        refreshInterval: undefined
      },

      // if an indexPattern was saved with the searchsource of a SavedDashboard
      // object, clear it. It was a mistake
      clearSavedIndexPattern: true
    });
  }

  // save these objects with the 'dashboard' type
  SavedDashboard.type = 'dashboard';

  // if type:dashboard has no mapping, we push this mapping into ES
  SavedDashboard.mapping = {
    title: 'text',
    hits: 'integer',
    description: 'text',
    panelsJSON: 'text',
    optionsJSON: 'text',
    // Note: this field is no longer used for dashboards created or saved in version 6.2 onward.  We keep it around
    // due to BWC, until we can ensure a migration step for all old dashboards saved in an index, as well as
    // migration steps for importing.  See https://github.com/elastic/kibana/issues/15204 for more info.
    uiStateJSON: 'text',
    version: 'integer',
    timeRestore: 'boolean',
    timeTo: 'keyword',
    timeFrom: 'keyword',
    refreshInterval: {
      type: 'object',
      properties: {
        display: { type: 'keyword' },
        pause: { type: 'boolean' },
        section: { type: 'integer' },
        value: { type: 'integer' }
      }
    }
  };

  // Order these fields to the top, the rest are alphabetical
  SavedDashboard.fieldOrder = ['title', 'description'];

  SavedDashboard.searchsource = true;

  return SavedDashboard;
});

/***/ }),
/* 3051 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

__webpack_require__(62);

var _modules = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _module = _modules.uiModules.get('discover/saved_searches', ['kibana/notify', 'kibana/courier']);

_module.factory('SavedSearch', function (courier) {
  _lodash2.default.class(SavedSearch).inherits(courier.SavedObject);
  function SavedSearch(id) {
    courier.SavedObject.call(this, {
      type: SavedSearch.type,
      mapping: SavedSearch.mapping,
      searchSource: SavedSearch.searchSource,

      id: id,
      defaults: {
        title: 'New Saved Search',
        description: '',
        columns: [],
        hits: 0,
        sort: [],
        version: 1
      }
    });
  }

  SavedSearch.type = 'search';

  SavedSearch.mapping = {
    title: 'text',
    description: 'text',
    hits: 'integer',
    columns: 'keyword',
    sort: 'keyword',
    version: 'integer'
  };

  // Order these fields to the top, the rest are alphabetical
  SavedSearch.fieldOrder = ['title', 'description'];

  SavedSearch.searchSource = true;

  return SavedSearch;
});

/***/ }),
/* 3052 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.createUrlFormat = createUrlFormat;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _highlight_html = __webpack_require__(468);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var templateMatchRE = /{{([\s\S]+?)}}/g;
var whitelistUrlSchemes = ['http://', 'https://'];

function createUrlFormat(FieldFormat) {
  var UrlFormat = function (_FieldFormat) {
    _inherits(UrlFormat, _FieldFormat);

    function UrlFormat(params) {
      _classCallCheck(this, UrlFormat);

      var _this = _possibleConstructorReturn(this, (UrlFormat.__proto__ || Object.getPrototypeOf(UrlFormat)).call(this, params));

      _this._compileTemplate = _lodash2.default.memoize(_this._compileTemplate);
      return _this;
    }

    _createClass(UrlFormat, [{
      key: 'getParamDefaults',
      value: function getParamDefaults() {
        return {
          type: 'a',
          urlTemplate: null,
          labelTemplate: null
        };
      }
    }, {
      key: '_formatLabel',
      value: function _formatLabel(value, url) {
        var template = this.param('labelTemplate');
        if (url == null) url = this._formatUrl(value);
        if (!template) return url;

        return this._compileTemplate(template)({
          value: value,
          url: url
        });
      }
    }, {
      key: '_formatUrl',
      value: function _formatUrl(value) {
        var template = this.param('urlTemplate');
        if (!template) return value;

        return this._compileTemplate(template)({
          value: encodeURIComponent(value),
          rawValue: value
        });
      }
    }, {
      key: '_compileTemplate',
      value: function _compileTemplate(template) {
        var parts = template.split(templateMatchRE).map(function (part, i) {
          // trim all the odd bits, the variable names
          return i % 2 ? part.trim() : part;
        });

        return function (locals) {
          // replace all the odd bits with their local var
          var output = '';
          var i = -1;
          while (++i < parts.length) {
            if (i % 2) {
              if (locals.hasOwnProperty(parts[i])) {
                var local = locals[parts[i]];
                output += local == null ? '' : local;
              }
            } else {
              output += parts[i];
            }
          }

          return output;
        };
      }
    }]);

    return UrlFormat;
  }(FieldFormat);

  UrlFormat.id = 'url';
  UrlFormat.title = 'Url';
  UrlFormat.fieldType = ['number', 'boolean', 'date', 'ip', 'string', 'murmur3', 'unknown', 'conflict'];


  UrlFormat.prototype._convert = {
    text: function text(value) {
      return this._formatLabel(value);
    },

    html: function html(rawValue, field, hit, parsedUrl) {
      var url = _lodash2.default.escape(this._formatUrl(rawValue));
      var label = _lodash2.default.escape(this._formatLabel(rawValue, url));

      switch (this.param('type')) {
        case 'img':
          // If the URL hasn't been formatted to become a meaningful label then the best we can do
          // is tell screen readers where the image comes from.
          var imageLabel = label === url ? 'A dynamically-specified image located at ' + url : label;

          return '<img src="' + url + '" alt="' + imageLabel + '">';
        default:
          var inWhitelist = whitelistUrlSchemes.some(function (scheme) {
            return url.indexOf(scheme) === 0;
          });
          if (!inWhitelist && !parsedUrl) {
            return url;
          }

          var prefix = '';
          /**
           * This code attempts to convert a relative url into a kibana absolute url
           *
           * SUPPORTED:
           *  - /app/kibana/
           *  - ../app/kibana
           *  - #/discover
           *
           * UNSUPPORTED
           *  - app/kibana
           */
          if (!inWhitelist) {
            // Handles urls like: `#/discover`
            if (url[0] === '#') {
              prefix = '' + parsedUrl.origin + parsedUrl.pathname;
            }
            // Handle urls like: `/app/kibana` or `/xyz/app/kibana`
            else if (url.indexOf(parsedUrl.basePath || '/') === 0) {
                prefix = '' + parsedUrl.origin;
              }
              // Handle urls like: `../app/kibana`
              else {
                  prefix = '' + parsedUrl.origin + parsedUrl.basePath + '/app/';
                }
          }

          var linkLabel = void 0;

          if (hit && hit.highlight && hit.highlight[field.name]) {
            linkLabel = (0, _highlight_html.getHighlightHtml)(label, hit.highlight[field.name]);
          } else {
            linkLabel = label;
          }

          var linkTarget = this.param('openLinkInCurrentTab') ? '_self' : '_blank';

          return '<a href="' + prefix + url + '" target="' + linkTarget + '" rel="noopener noreferrer">' + linkLabel + '</a>';
      }
    }
  };

  return UrlFormat;
}

/***/ }),
/* 3053 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createBytesFormat = createBytesFormat;

var _numeral = __webpack_require__(536);

function createBytesFormat(FieldFormat) {
  return (0, _numeral.createNumeralFormat)(FieldFormat, {
    id: 'bytes',
    title: 'Bytes'
  });
}

/***/ }),
/* 3054 */,
/* 3055 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.createDateFormat = createDateFormat;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function createDateFormat(FieldFormat) {
  var _class, _temp;

  return _temp = _class = function (_FieldFormat) {
    _inherits(DateFormat, _FieldFormat);

    function DateFormat(params, getConfig) {
      _classCallCheck(this, DateFormat);

      var _this = _possibleConstructorReturn(this, (DateFormat.__proto__ || Object.getPrototypeOf(DateFormat)).call(this, params));

      _this.getConfig = getConfig;
      return _this;
    }

    _createClass(DateFormat, [{
      key: 'getParamDefaults',
      value: function getParamDefaults() {
        return {
          pattern: this.getConfig('dateFormat'),
          timezone: this.getConfig('dateFormat:tz')
        };
      }
    }, {
      key: '_convert',
      value: function _convert(val) {
        // don't give away our ref to converter so
        // we can hot-swap when config changes
        var pattern = this.param('pattern');
        var timezone = this.param('timezone');

        var timezoneChanged = this._timeZone !== timezone;
        var datePatternChanged = this._memoizedPattern !== pattern;
        if (timezoneChanged || datePatternChanged) {
          this._timeZone = timezone;
          this._memoizedPattern = pattern;

          this._memoizedConverter = _lodash2.default.memoize(function converter(val) {
            if (val === null || val === undefined) {
              return '-';
            }

            var date = (0, _moment2.default)(val);
            if (date.isValid()) {
              return date.format(pattern);
            } else {
              return val;
            }
          });
        }

        return this._memoizedConverter(val);
      }
    }]);

    return DateFormat;
  }(FieldFormat), _class.id = 'date', _class.title = 'Date', _class.fieldType = 'date', _temp;
}

/***/ }),
/* 3056 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.createRelativeDateFormat = createRelativeDateFormat;

var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function createRelativeDateFormat(FieldFormat) {
  var _class, _temp;

  return _temp = _class = function (_FieldFormat) {
    _inherits(RelativeDateFormat, _FieldFormat);

    function RelativeDateFormat(params) {
      _classCallCheck(this, RelativeDateFormat);

      return _possibleConstructorReturn(this, (RelativeDateFormat.__proto__ || Object.getPrototypeOf(RelativeDateFormat)).call(this, params));
    }

    _createClass(RelativeDateFormat, [{
      key: '_convert',
      value: function _convert(val) {
        if (val === null || val === undefined) {
          return '-';
        }

        var date = (0, _moment2.default)(val);
        if (date.isValid()) {
          return date.fromNow();
        } else {
          return val;
        }
      }
    }]);

    return RelativeDateFormat;
  }(FieldFormat), _class.id = 'relative_date', _class.title = 'Relative Date', _class.fieldType = 'date', _temp;
}

/***/ }),
/* 3057 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.createIpFormat = createIpFormat;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function createIpFormat(FieldFormat) {
  var _class, _temp;

  return _temp = _class = function (_FieldFormat) {
    _inherits(IpFormat, _FieldFormat);

    function IpFormat() {
      _classCallCheck(this, IpFormat);

      return _possibleConstructorReturn(this, (IpFormat.__proto__ || Object.getPrototypeOf(IpFormat)).apply(this, arguments));
    }

    _createClass(IpFormat, [{
      key: '_convert',
      value: function _convert(val) {
        if (val === undefined || val === null) return '-';
        if (!isFinite(val)) return val;

        // shazzam!
        return [val >>> 24, val >>> 16 & 0xFF, val >>> 8 & 0xFF, val & 0xFF].join('.');
      }
    }]);

    return IpFormat;
  }(FieldFormat), _class.id = 'ip', _class.title = 'IP Address', _class.fieldType = 'ip', _temp;
}

/***/ }),
/* 3058 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNumberFormat = createNumberFormat;

var _numeral = __webpack_require__(536);

function createNumberFormat(FieldFormat) {
  return (0, _numeral.createNumeralFormat)(FieldFormat, {
    id: 'number',
    title: 'Number'
  });
}

/***/ }),
/* 3059 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPercentFormat = createPercentFormat;

var _numeral = __webpack_require__(536);

function createPercentFormat(FieldFormat) {
  return (0, _numeral.createNumeralFormat)(FieldFormat, {
    id: 'percent',
    title: 'Percentage',
    getParamDefaults: function getParamDefaults(getConfig) {
      return {
        pattern: getConfig('format:percent:defaultPattern'),
        fractional: true
      };
    },
    afterConvert: function afterConvert(val) {
      return this.param('fractional') ? val : val / 100;
    }
  });
}

/***/ }),
/* 3060 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.createStringFormat = createStringFormat;

var _as_pretty_string = __webpack_require__(322);

var _shorten_dotted_string = __webpack_require__(467);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function createStringFormat(FieldFormat) {
  var _class, _temp;

  return _temp = _class = function (_FieldFormat) {
    _inherits(StringFormat, _FieldFormat);

    function StringFormat() {
      _classCallCheck(this, StringFormat);

      return _possibleConstructorReturn(this, (StringFormat.__proto__ || Object.getPrototypeOf(StringFormat)).apply(this, arguments));
    }

    _createClass(StringFormat, [{
      key: 'getParamDefaults',
      value: function getParamDefaults() {
        return {
          transform: false
        };
      }
    }, {
      key: '_base64Decode',
      value: function _base64Decode(val) {
        try {
          return Buffer.from(val, 'base64').toString('utf8');
        } catch (e) {
          return (0, _as_pretty_string.asPrettyString)(val);
        }
      }
    }, {
      key: '_toTitleCase',
      value: function _toTitleCase(val) {
        return val.replace(/\w\S*/g, function (txt) {
          return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
        });
      }
    }, {
      key: '_convert',
      value: function _convert(val) {
        switch (this.param('transform')) {
          case 'lower':
            return String(val).toLowerCase();
          case 'upper':
            return String(val).toUpperCase();
          case 'title':
            return this._toTitleCase(val);
          case 'short':
            return (0, _shorten_dotted_string.shortenDottedString)(val);
          case 'base64':
            return this._base64Decode(val);
          default:
            return (0, _as_pretty_string.asPrettyString)(val);
        }
      }
    }]);

    return StringFormat;
  }(FieldFormat), _class.id = 'string', _class.title = 'String', _class.fieldType = ['number', 'boolean', 'date', 'ip', 'attachment', 'geo_point', 'geo_shape', 'string', 'murmur3', 'unknown', 'conflict'], _temp;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(114).Buffer))

/***/ }),
/* 3061 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createSourceFormat = createSourceFormat;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _no_white_space = __webpack_require__(951);

var _aggressive_parse = __webpack_require__(768);

var _shorten_dotted_string = __webpack_require__(467);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var templateHtml = '\n  <dl class="source truncate-by-height">\n    <% defPairs.forEach(function (def) { %>\n      <dt><%- def[0] %>:</dt>\n      <dd><%= def[1] %></dd>\n      <%= \' \' %>\n    <% }); %>\n  </dl>';
var template = _lodash2.default.template((0, _no_white_space.noWhiteSpace)(templateHtml));

function createSourceFormat(FieldFormat) {
  var SourceFormat = function (_FieldFormat) {
    _inherits(SourceFormat, _FieldFormat);

    function SourceFormat(params, getConfig) {
      _classCallCheck(this, SourceFormat);

      var _this = _possibleConstructorReturn(this, (SourceFormat.__proto__ || Object.getPrototypeOf(SourceFormat)).call(this, params));

      _this.getConfig = getConfig;
      return _this;
    }

    return SourceFormat;
  }(FieldFormat);

  SourceFormat.id = '_source';
  SourceFormat.title = '_source';
  SourceFormat.fieldType = '_source';


  SourceFormat.prototype._convert = {
    text: function text(value) {
      return (0, _aggressive_parse.toJson)(value);
    },
    html: function sourceToHtml(source, field, hit) {
      if (!field) return this.getConverterFor('text')(source, field, hit);

      var highlights = hit && hit.highlight || {};
      var formatted = field.indexPattern.formatHit(hit);
      var highlightPairs = [];
      var sourcePairs = [];

      var isShortDots = this.getConfig('shortDots:enable');
      _lodash2.default.keys(formatted).forEach(function (key) {
        var pairs = highlights[key] ? highlightPairs : sourcePairs;
        var field = isShortDots ? (0, _shorten_dotted_string.shortenDottedString)(key) : key;
        var val = formatted[key];
        pairs.push([field, val]);
      }, []);

      return template({ defPairs: highlightPairs.concat(sourcePairs) });
    }
  };

  return SourceFormat;
}

/***/ }),
/* 3062 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.createColorFormat = createColorFormat;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _as_pretty_string = __webpack_require__(322);

var _color_default = __webpack_require__(952);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var convertTemplate = _lodash2.default.template('<span style="<%- style %>"><%- val %></span>');

function createColorFormat(FieldFormat) {
  var ColorFormat = function (_FieldFormat) {
    _inherits(ColorFormat, _FieldFormat);

    function ColorFormat() {
      _classCallCheck(this, ColorFormat);

      return _possibleConstructorReturn(this, (ColorFormat.__proto__ || Object.getPrototypeOf(ColorFormat)).apply(this, arguments));
    }

    _createClass(ColorFormat, [{
      key: 'getParamDefaults',
      value: function getParamDefaults() {
        return {
          fieldType: null, // populated by editor, see controller below
          colors: [_lodash2.default.cloneDeep(_color_default.DEFAULT_COLOR)]
        };
      }
    }, {
      key: 'findColorRuleForVal',
      value: function findColorRuleForVal(val) {
        switch (this.param('fieldType')) {
          case 'string':
            return _lodash2.default.findLast(this.param('colors'), function (colorParam) {
              return new RegExp(colorParam.regex).test(val);
            });

          case 'number':
            return _lodash2.default.findLast(this.param('colors'), function (_ref) {
              var range = _ref.range;

              if (!range) return;

              var _range$split = range.split(':'),
                  _range$split2 = _slicedToArray(_range$split, 2),
                  start = _range$split2[0],
                  end = _range$split2[1];

              return val >= Number(start) && val <= Number(end);
            });

          default:
            return null;
        }
      }
    }]);

    return ColorFormat;
  }(FieldFormat);

  ColorFormat.id = 'color';
  ColorFormat.title = 'Color';
  ColorFormat.fieldType = ['number', 'string'];


  ColorFormat.prototype._convert = {
    html: function html(val) {
      var color = this.findColorRuleForVal(val);
      if (!color) return _lodash2.default.escape((0, _as_pretty_string.asPrettyString)(val));

      var style = '';
      if (color.text) style += 'color: ' + color.text + ';';
      if (color.background) style += 'background-color: ' + color.background + ';';
      return convertTemplate({ val: val, style: style });
    }
  };

  return ColorFormat;
}

/***/ }),
/* 3063 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.createTruncateFormat = createTruncateFormat;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var omission = '...';

function createTruncateFormat(FieldFormat) {
  var _class, _temp;

  return _temp = _class = function (_FieldFormat) {
    _inherits(TruncateFormat, _FieldFormat);

    function TruncateFormat() {
      _classCallCheck(this, TruncateFormat);

      return _possibleConstructorReturn(this, (TruncateFormat.__proto__ || Object.getPrototypeOf(TruncateFormat)).apply(this, arguments));
    }

    _createClass(TruncateFormat, [{
      key: '_convert',
      value: function _convert(val) {
        var length = this.param('fieldLength');
        if (length > 0) {
          return _lodash2.default.trunc(val, {
            'length': length + omission.length,
            'omission': omission
          });
        }

        return val;
      }
    }]);

    return TruncateFormat;
  }(FieldFormat), _class.id = 'truncate', _class.title = 'Truncated String', _class.fieldType = ['string'], _temp;
}

/***/ }),
/* 3064 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.createBoolFormat = createBoolFormat;

var _as_pretty_string = __webpack_require__(322);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function createBoolFormat(FieldFormat) {
  var _class, _temp;

  return _temp = _class = function (_FieldFormat) {
    _inherits(BoolFormat, _FieldFormat);

    function BoolFormat() {
      _classCallCheck(this, BoolFormat);

      return _possibleConstructorReturn(this, (BoolFormat.__proto__ || Object.getPrototypeOf(BoolFormat)).apply(this, arguments));
    }

    _createClass(BoolFormat, [{
      key: '_convert',
      value: function _convert(value) {
        if (typeof value === 'string') {
          value = value.trim().toLowerCase();
        }

        switch (value) {
          case false:
          case 0:
          case 'false':
          case 'no':
            return 'false';
          case true:
          case 1:
          case 'true':
          case 'yes':
            return 'true';
          default:
            return (0, _as_pretty_string.asPrettyString)(value);
        }
      }
    }]);

    return BoolFormat;
  }(FieldFormat), _class.id = 'boolean', _class.title = 'Boolean', _class.fieldType = ['boolean', 'number', 'string'], _temp;
}

/***/ }),
/* 3065 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.VisProvider = VisProvider;

var _events = __webpack_require__(98);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _vis_types = __webpack_require__(66);

var _agg_configs = __webpack_require__(3066);

var _persisted_state = __webpack_require__(238);

var _brush_event = __webpack_require__(964);

var _query_filter = __webpack_require__(119);

var _filter_bar_click_handler = __webpack_require__(354);

var _vis_update = __webpack_require__(3138);

var _query_manager = __webpack_require__(3139);

var _kuery = __webpack_require__(323);

var kueryAPI = _interopRequireWildcard(_kuery);

var _search_source = __webpack_require__(135);

var _saved_objects = __webpack_require__(76);

var _filter_manager = __webpack_require__(256);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @name Vis
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @description This class consists of aggs, params, listeners, title, and type.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - Aggs: Instances of AggConfig.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - Params: The settings in the Options tab.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Not to be confused with vislib/vis.js.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

function VisProvider(Private, Promise, indexPatterns, timefilter, getAppState) {
  var visTypes = Private(_vis_types.VisTypesRegistryProvider);
  var AggConfigs = Private(_agg_configs.VisAggConfigsProvider);
  var brushEvent = Private(_brush_event.UtilsBrushEventProvider);
  var queryFilter = Private(_query_filter.FilterBarQueryFilterProvider);
  var filterBarClickHandler = Private(_filter_bar_click_handler.FilterBarClickHandlerProvider);
  var SearchSource = Private(_search_source.SearchSourceProvider);
  var savedObjectsClient = Private(_saved_objects.SavedObjectsClientProvider);
  var filterManager = Private(_filter_manager.FilterManagerProvider);

  var Vis = function (_EventEmitter) {
    _inherits(Vis, _EventEmitter);

    function Vis(indexPattern, visState) {
      _classCallCheck(this, Vis);

      var _this = _possibleConstructorReturn(this, (Vis.__proto__ || Object.getPrototypeOf(Vis)).call(this));

      visState = visState || {};

      if (_lodash2.default.isString(visState)) {
        visState = {
          type: visState
        };
      }
      _this.indexPattern = indexPattern;
      _this._setUiState(new _persisted_state.PersistedState());
      _this.setCurrentState(visState);
      _this.setState(_this.getCurrentState(), false);

      // Session state is for storing information that is transitory, and will not be saved with the visualization.
      // For instance, map bounds, which depends on the view port, browser window size, etc.
      _this.sessionState = {};

      _this.API = {
        savedObjectsClient: savedObjectsClient,
        SearchSource: SearchSource,
        indexPatterns: indexPatterns,
        timeFilter: timefilter,
        filterManager: filterManager,
        queryFilter: queryFilter,
        queryManager: (0, _query_manager.queryManagerFactory)(getAppState),
        kuery: kueryAPI,
        events: {
          filter: function filter(event) {
            var appState = getAppState();
            filterBarClickHandler(appState)(event);
          }, brush: function brush(event) {
            var appState = getAppState();
            brushEvent(appState)(event);
          }
        }
      };
      return _this;
    }

    _createClass(Vis, [{
      key: 'isEditorMode',
      value: function isEditorMode() {
        return this.editorMode || false;
      }
    }, {
      key: 'setCurrentState',
      value: function setCurrentState(state) {
        this.title = state.title || '';
        var type = state.type || this.type;
        if (_lodash2.default.isString(type)) {
          this.type = visTypes.byName[type];
          if (!this.type) {
            throw new Error('Invalid type "' + type + '"');
          }
        } else {
          this.type = type;
        }

        this.params = _lodash2.default.defaults({}, _lodash2.default.cloneDeep(state.params || {}), _lodash2.default.cloneDeep(this.type.visConfig.defaults || {}));

        (0, _vis_update.updateVisualizationConfig)(state.params, this.params);

        this.aggs = new AggConfigs(this, state.aggs);
      }
    }, {
      key: 'setState',
      value: function setState(state) {
        var updateCurrentState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        this._state = _lodash2.default.cloneDeep(state);
        if (updateCurrentState) this.resetState();
      }
    }, {
      key: 'updateState',
      value: function updateState() {
        this.setState(this.getCurrentState(true));
        this.emit('update');
      }
    }, {
      key: 'resetState',
      value: function resetState() {
        this.setCurrentState(this._state);
      }
    }, {
      key: 'forceReload',
      value: function forceReload() {
        this.emit('reload');
      }
    }, {
      key: 'getCurrentState',
      value: function getCurrentState(includeDisabled) {
        return {
          title: this.title,
          type: this.type.name,
          params: this.params,
          aggs: this.aggs.map(function (agg) {
            return agg.toJSON();
          }).filter(function (agg) {
            return includeDisabled || agg.enabled;
          }).filter(Boolean)
        };
      }
    }, {
      key: 'getStateInternal',
      value: function getStateInternal(includeDisabled) {
        return {
          title: this._state.title,
          type: this._state.type,
          params: this._state.params,
          aggs: this._state.aggs.filter(function (agg) {
            return includeDisabled || agg.enabled;
          })
        };
      }
    }, {
      key: 'getEnabledState',
      value: function getEnabledState() {
        return this.getStateInternal(false);
      }
    }, {
      key: 'getAggConfig',
      value: function getAggConfig() {
        return new AggConfigs(this, this.aggs.raw.filter(function (agg) {
          return agg.enabled;
        }));
      }
    }, {
      key: 'getState',
      value: function getState() {
        return this.getStateInternal(true);
      }

      /**
       *  Hook for pre-flight logic, see AggType#onSearchRequestStart()
       *  @param {Courier.SearchSource} searchSource
       *  @param {Courier.SearchRequest} searchRequest
       *  @return {Promise<undefined>}
       */

    }, {
      key: 'onSearchRequestStart',
      value: function onSearchRequestStart(searchSource, searchRequest) {
        return Promise.map(this.aggs.getRequestAggs(), function (agg) {
          return agg.onSearchRequestStart(searchSource, searchRequest);
        });
      }
    }, {
      key: 'isHierarchical',
      value: function isHierarchical() {
        if (_lodash2.default.isFunction(this.type.hierarchicalData)) {
          return !!this.type.hierarchicalData(this);
        } else {
          return !!this.type.hierarchicalData;
        }
      }
    }, {
      key: 'hasSchemaAgg',
      value: function hasSchemaAgg(schemaName, aggTypeName) {
        var aggs = this.aggs.bySchemaName[schemaName] || [];
        return aggs.some(function (agg) {
          if (!agg.type || !agg.type.name) return false;
          return agg.type.name === aggTypeName;
        });
      }
    }, {
      key: 'hasUiState',
      value: function hasUiState() {
        return !!this.__uiState;
      }

      /***
       * this should not be used outside of visualize
       * @param uiState
       * @private
       */

    }, {
      key: '_setUiState',
      value: function _setUiState(uiState) {
        if (uiState instanceof _persisted_state.PersistedState) {
          this.__uiState = uiState;
        }
      }
    }, {
      key: 'getUiState',
      value: function getUiState() {
        return this.__uiState;
      }

      /**
       * Currently this is only used to extract map-specific information
       * (e.g. mapZoom, mapCenter).
       */

    }, {
      key: 'uiStateVal',
      value: function uiStateVal(key, val) {
        if (this.hasUiState()) {
          if (_lodash2.default.isUndefined(val)) {
            return this.__uiState.get(key);
          }
          return this.__uiState.set(key, val);
        }
        return val;
      }
    }]);

    return Vis;
  }(_events.EventEmitter);

  Vis.prototype.type = 'histogram';

  return Vis;
}

/***/ }),
/* 3066 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * @name AggConfig
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * @extends IndexedArray
                                                                                                                                                                                                                                                                               *
                                                                                                                                                                                                                                                                               * @description A "data structure"-like class with methods for indexing and
                                                                                                                                                                                                                                                                               * accessing instances of AggConfig.
                                                                                                                                                                                                                                                                               */

exports.VisAggConfigsProvider = VisAggConfigsProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _indexed_array = __webpack_require__(99);

var _agg_config = __webpack_require__(105);

var _index = __webpack_require__(537);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function VisAggConfigsProvider(Private) {
  var AggConfig = Private(_agg_config.VisAggConfigProvider);

  AggConfig.aggTypes = Private(_index.AggTypesIndexProvider);

  _lodash2.default.class(AggConfigs).inherits(_indexed_array.IndexedArray);
  function AggConfigs(vis, configStates) {
    var self = this;
    self.vis = vis;

    configStates = AggConfig.ensureIds(configStates || []);

    AggConfigs.Super.call(self, {
      index: ['id'],
      group: ['schema.group', 'type.name', 'schema.name'],
      initialSet: configStates.map(function (aggConfigState) {
        if (aggConfigState instanceof AggConfig) return aggConfigState;
        return new AggConfig(vis, aggConfigState);
      })
    });

    // Set the defaults for any schema which has them. If the defaults
    // for some reason has more then the max only set the max number
    // of defaults (not sure why a someone define more...
    // but whatever). Also if a schema.name is already set then don't
    // set anything.
    if (vis && vis.type && vis.type.schemas && vis.type.schemas.all) {
      (0, _lodash2.default)(vis.type.schemas.all).filter(function (schema) {
        return Array.isArray(schema.defaults) && schema.defaults.length > 0;
      }).each(function (schema) {
        if (!self.bySchemaName[schema.name]) {
          var defaults = schema.defaults.slice(0, schema.max);
          _lodash2.default.each(defaults, function (defaultState) {
            var state = _lodash2.default.defaults({ id: AggConfig.nextId(self) }, defaultState);
            self.push(new AggConfig(vis, state));
          });
        }
      }).commit();
    }
  }

  /**
   * Data-by-data comparison of this Aggregation
   * Ignores the non-array indexes
   * @param aggConfigs an AggConfigs instance
   */
  AggConfigs.prototype.jsonDataEquals = function (aggConfigs) {
    if (aggConfigs.length !== this.length) {
      return false;
    }
    for (var i = 0; i < this.length; i += 1) {
      if (!_lodash2.default.isEqual(aggConfigs[i].toJSON(), this[i].toJSON())) {
        return false;
      }
    }
    return true;
  };

  function removeParentAggs(obj) {
    for (var prop in obj) {
      if (prop === 'parentAggs') delete obj[prop];else if (_typeof(obj[prop]) === 'object') removeParentAggs(obj[prop]);
    }
  }

  function parseParentAggs(dslLvlCursor, dsl) {
    if (dsl.parentAggs) {
      _lodash2.default.each(dsl.parentAggs, function (agg, key) {
        dslLvlCursor[key] = agg;
        parseParentAggs(dslLvlCursor, agg);
      });
    }
  }

  AggConfigs.prototype.toDsl = function () {
    var dslTopLvl = {};
    var dslLvlCursor = void 0;
    var nestedMetrics = void 0;

    if (this.vis.isHierarchical()) {
      // collect all metrics, and filter out the ones that we won't be copying
      nestedMetrics = (0, _lodash2.default)(this.vis.aggs.bySchemaGroup.metrics).filter(function (agg) {
        return agg.type.name !== 'count';
      }).map(function (agg) {
        return {
          config: agg,
          dsl: agg.toDsl()
        };
      }).value();
    }
    this.getRequestAggs().filter(function (config) {
      return !config.type.hasNoDsl;
    }).forEach(function nestEachConfig(config, i, list) {
      if (!dslLvlCursor) {
        // start at the top level
        dslLvlCursor = dslTopLvl;
      } else {
        var prevConfig = list[i - 1];
        var prevDsl = dslLvlCursor[prevConfig.id];

        // advance the cursor and nest under the previous agg, or
        // put it on the same level if the previous agg doesn't accept
        // sub aggs
        dslLvlCursor = prevDsl.aggs || dslLvlCursor;
      }

      var dsl = dslLvlCursor[config.id] = config.toDsl();
      var subAggs = void 0;

      parseParentAggs(dslLvlCursor, dsl);

      if (config.schema.group === 'buckets' && i < list.length - 1) {
        // buckets that are not the last item in the list accept sub-aggs
        subAggs = dsl.aggs || (dsl.aggs = {});
      }

      if (subAggs && nestedMetrics) {
        nestedMetrics.forEach(function (agg) {
          subAggs[agg.config.id] = agg.dsl;
        });
      }
    });

    removeParentAggs(dslTopLvl);
    return dslTopLvl;
  };

  AggConfigs.prototype.getRequestAggs = function () {
    //collect all the aggregations
    var aggregations = this.reduce(function (requestValuesAggs, agg) {
      var aggs = agg.getRequestAggs();
      return aggs ? requestValuesAggs.concat(aggs) : requestValuesAggs;
    }, []);
    //move metrics to the end
    return _lodash2.default.sortBy(aggregations, function (agg) {
      return agg.schema.group === 'metrics' ? 1 : 0;
    });
  };

  /**
   * Gets the AggConfigs (and possibly ResponseAggConfigs) that
   * represent the values that will be produced when all aggs
   * are run.
   *
   * With multi-value metric aggs it is possible for a single agg
   * request to result in multiple agg values, which is why the length
   * of a vis' responseValuesAggs may be different than the vis' aggs
   *
   * @return {array[AggConfig]}
   */
  AggConfigs.prototype.getResponseAggs = function () {
    return this.getRequestAggs().reduce(function (responseValuesAggs, agg) {
      var aggs = agg.getResponseAggs();
      return aggs ? responseValuesAggs.concat(aggs) : responseValuesAggs;
    }, []);
  };

  /**
   * Find a response agg by it's id. This may be an agg in the aggConfigs, or one
   * created specifically for a response value
   *
   * @param  {string} id - the id of the agg to find
   * @return {AggConfig}
   */
  AggConfigs.prototype.getResponseAggById = function (id) {
    id = String(id);
    var reqAgg = _lodash2.default.find(this.getRequestAggs(), function (agg) {
      return id.substr(0, String(agg.id).length) === agg.id;
    });
    if (!reqAgg) return;
    return _lodash2.default.find(reqAgg.getResponseAggs(), { id: id });
  };

  return AggConfigs;
}

/***/ }),
/* 3067 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesMetricsCountProvider = AggTypesMetricsCountProvider;

var _metric_agg_type = __webpack_require__(40);

var _field_formats = __webpack_require__(64);

function AggTypesMetricsCountProvider(Private) {
  var MetricAggType = Private(_metric_agg_type.AggTypesMetricsMetricAggTypeProvider);
  var fieldFormats = Private(_field_formats.RegistryFieldFormatsProvider);

  return new MetricAggType({
    name: 'count',
    title: 'Count',
    hasNoDsl: true,
    makeLabel: function makeLabel() {
      return 'Count';
    },
    getFormat: function getFormat() {
      return fieldFormats.getDefaultInstance('number');
    },
    getValue: function getValue(agg, bucket) {
      return bucket.doc_count;
    },
    isScalable: function isScalable() {
      return true;
    }
  });
}

/***/ }),
/* 3068 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesMetricsAvgProvider = AggTypesMetricsAvgProvider;

var _metric_agg_type = __webpack_require__(40);

function AggTypesMetricsAvgProvider(Private) {
  var MetricAggType = Private(_metric_agg_type.AggTypesMetricsMetricAggTypeProvider);

  return new MetricAggType({
    name: 'avg',
    title: 'Average',
    makeLabel: function makeLabel(aggConfig) {
      return 'Average ' + aggConfig.getFieldDisplayName();
    },
    params: [{
      name: 'field',
      filterFieldTypes: 'number'
    }]
  });
}

/***/ }),
/* 3069 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesMetricsSumProvider = AggTypesMetricsSumProvider;

var _metric_agg_type = __webpack_require__(40);

function AggTypesMetricsSumProvider(Private) {
  var MetricAggType = Private(_metric_agg_type.AggTypesMetricsMetricAggTypeProvider);

  return new MetricAggType({
    name: 'sum',
    title: 'Sum',
    makeLabel: function makeLabel(aggConfig) {
      return 'Sum of ' + aggConfig.getFieldDisplayName();
    },
    params: [{
      name: 'field',
      filterFieldTypes: 'number'
    }],
    isScalable: function isScalable() {
      return true;
    }
  });
}

/***/ }),
/* 3070 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesMetricsMedianProvider = AggTypesMetricsMedianProvider;

var _metric_agg_type = __webpack_require__(40);

var _percentiles = __webpack_require__(956);

function AggTypesMetricsMedianProvider(Private) {

  var MetricAggType = Private(_metric_agg_type.AggTypesMetricsMetricAggTypeProvider);
  var percentiles = Private(_percentiles.AggTypesMetricsPercentilesProvider);

  return new MetricAggType({
    name: 'median',
    dslName: 'percentiles',
    title: 'Median',
    makeLabel: function makeLabel(aggConfig) {
      return 'Median ' + aggConfig.getFieldDisplayName();
    },
    params: [{
      name: 'field',
      filterFieldTypes: 'number'
    }, {
      name: 'percents',
      default: [50]
    }, {
      write: function write(agg, output) {
        output.params.keyed = false;
      }
    }],
    getResponseAggs: percentiles.getResponseAggs,
    getValue: percentiles.getValue
  });
}

/***/ }),
/* 3071 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ordinalSuffix = ordinalSuffix;
// adopted from http://stackoverflow.com/questions/3109978/php-display-number-with-ordinal-suffix
function ordinalSuffix(num) {
  return num + '' + suffix(num);
}

function suffix(num) {
  var int = Math.floor(parseFloat(num));

  var hunth = int % 100;
  if (hunth >= 11 && hunth <= 13) return 'th';

  var tenth = int % 10;
  if (tenth === 1) return 'st';
  if (tenth === 2) return 'nd';
  if (tenth === 3) return 'rd';
  return 'th';
}

/***/ }),
/* 3072 */
/***/ (function(module, exports) {

module.exports = "<div class=\"form-group\">\n  <label id=\"visEditorPercentileLabel{{agg.id}}\">Percents</label>\n  <kbn-number-list\n    ng-model=\"agg.params.percents\"\n    unit-name=\"percent\"\n    range=\"[0,100]\"\n    validate-ascending-order=\"false\"\n    labelledby-id=\"visEditorPercentileLabel{{agg.id}}\"\n    >\n  </kbn-number-list>\n</div>\n"

/***/ }),
/* 3073 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _range = __webpack_require__(3074);

__webpack_require__(3075);

var _modules = __webpack_require__(2);

var _number_list = __webpack_require__(3076);

var _number_list2 = _interopRequireDefault(_number_list);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_modules.uiModules.get('kibana').directive('kbnNumberList', function () {
  return {
    restrict: 'E',
    template: _number_list2.default,
    controllerAs: 'numberListCntr',
    require: 'ngModel',
    scope: {
      validateAscendingOrder: '=?',
      labelledbyId: '@'
    },
    controller: function controller($scope, $attrs, $parse) {
      var self = this;

      self.labelledbyId = $scope.labelledbyId;

      // Called from the pre-link function once we have the controllers
      self.init = function (modelCntr) {
        self.modelCntr = modelCntr;

        self.getList = function () {
          return self.modelCntr.$modelValue;
        };

        self.getUnitName = _lodash2.default.partial($parse($attrs.unit), $scope);

        var defaultRange = self.range = (0, _range.parseRange)('[0,Infinity)');
        self.validateAscOrder = _lodash2.default.isUndefined($scope.validateAscendingOrder) ? true : $scope.validateAscendingOrder;

        $scope.$watch(function () {
          return $attrs.range;
        }, function (range) {
          if (!range) {
            self.range = defaultRange;
            return;
          }

          try {
            self.range = (0, _range.parseRange)(range);
          } catch (e) {
            throw new TypeError('Unable to parse range: ' + e.message);
          }
        });

        /**
        * Remove an item from list by index
        * @param  {number} index
        * @return {undefined}
        */
        self.remove = function (index) {
          var list = self.getList();
          if (!list) return;

          list.splice(index, 1);
        };

        /**
        * Add an item to the end of the list
        * @return {undefined}
        */
        self.add = function () {
          var list = self.getList();
          if (!list) return;

          list.push(_lodash2.default.last(list) + 1);
        };

        /**
        * Check to see if the list is too short.
        *
        * @return {Boolean}
        */
        self.tooShort = function () {
          return _lodash2.default.size(self.getList()) < 1;
        };

        /**
        * Check to see if the list is too short, but simply
        * because the user hasn't interacted with it yet
        *
        * @return {Boolean}
        */
        self.undefinedLength = function () {
          return self.tooShort() && self.modelCntr.$untouched && self.modelCntr.$pristine;
        };

        /**
        * Check to see if the list is too short
        *
        * @return {Boolean}
        */
        self.invalidLength = function () {
          return self.tooShort() && !self.undefinedLength();
        };

        $scope.$watchCollection(self.getList, function () {
          self.modelCntr.$setValidity('numberListLength', !self.tooShort());
        });
      };
    },
    link: {
      pre: function pre($scope, $el, attrs, ngModelCntr) {
        $scope.numberListCntr.init(ngModelCntr);
      }
    }
  };
});

/***/ }),
/* 3074 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseRange = parseRange;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Regexp portion that matches our number
 *
 * supports:
 *   -100
 *   -100.0
 *   0
 *   0.10
 *   Infinity
 *   -Infinity
 *
 * @type {String}
 */
var _RE_NUMBER = '(\\-?(?:\\d+(?:\\.\\d+)?|Infinity))';

/**
 * Regexp for the interval notation
 *
 * supports:
 *   [num, num]
 *   ( num , num ]
 *   [Infinity,num)
 *
 * @type {RegExp}
 */
var RANGE_RE = new RegExp('^\\s*([\\[|\\(])\\s*' + _RE_NUMBER + '\\s*,\\s*' + _RE_NUMBER + '\\s*([\\]|\\)])\\s*$');

function parseRange(input) {

  var match = String(input).match(RANGE_RE);
  if (!match) {
    throw new TypeError('expected input to be in interval notation eg. (100, 200]');
  }

  return new Range(match[1] === '[', parseFloat(match[2]), parseFloat(match[3]), match[4] === ']');
}

function Range() /* minIncl, min, max, maxIncl */{
  var args = _lodash2.default.toArray(arguments);
  if (args[1] > args[2]) args.reverse();

  this.minInclusive = args[0];
  this.min = args[1];
  this.max = args[2];
  this.maxInclusive = args[3];
}

Range.prototype.within = function (n) {
  if (this.min === n && !this.minInclusive) return false;
  if (this.min > n) return false;

  if (this.max === n && !this.maxInclusive) return false;
  if (this.max < n) return false;

  return true;
};

/***/ }),
/* 3075 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _key_map = __webpack_require__(483);

var _modules = __webpack_require__(2);

var INVALID = {}; // invalid flag
var FLOATABLE = /^[\d\.e\-\+]+$/i;

var VALIDATION_ERROR = 'numberListRangeAndOrder';
var DIRECTIVE_ATTR = 'kbn-number-list-input';

_modules.uiModules.get('kibana').directive('kbnNumberListInput', function ($parse) {
  return {
    restrict: 'A',
    require: ['ngModel', '^kbnNumberList'],
    link: function link($scope, $el, attrs, controllers) {
      var ngModelCntr = controllers[0];
      var numberListCntr = controllers[1];

      var $setModel = $parse(attrs.ngModel).assign;
      var $repeater = $el.closest('[ng-repeat]');

      var handlers = {
        up: change(add, 1),
        'shift-up': change(addTenth, 1),

        down: change(add, -1),
        'shift-down': change(addTenth, -1),

        tab: go('next'),
        'shift-tab': go('prev'),

        'shift-enter': numberListCntr.add,

        backspace: removeIfEmpty,
        delete: removeIfEmpty
      };

      function removeIfEmpty(event) {
        if (!ngModelCntr.$viewValue) {
          $get('prev').focus();
          numberListCntr.remove($scope.$index);
          event.preventDefault();
        }

        return false;
      }

      function $get(dir) {
        return $repeater[dir]().find('[' + DIRECTIVE_ATTR + ']');
      }

      function go(dir) {
        return function () {
          var $to = $get(dir);
          if ($to.length) $to.focus();else return false;
        };
      }

      function idKey(event) {
        var id = [];
        if (event.ctrlKey) id.push('ctrl');
        if (event.shiftKey) id.push('shift');
        if (event.metaKey) id.push('meta');
        if (event.altKey) id.push('alt');
        id.push(_key_map.keyMap[event.keyCode] || event.keyCode);
        return id.join('-');
      }

      function add(n, val) {
        return parse(val + n);
      }

      function addTenth(n, val, str) {
        var int = Math.floor(val);
        var dec = parseInt(str.split('.')[1] || 0, 10);
        dec = dec + parseInt(n, 10);

        if (dec < 0 || dec > 9) {
          int += Math.floor(dec / 10);
          if (dec < 0) {
            dec = 10 + dec % 10;
          } else {
            dec = dec % 10;
          }
        }

        return parse(int + '.' + dec);
      }

      function change(using, mod) {
        return function () {
          var str = String(ngModelCntr.$viewValue);
          var val = parse(str);
          if (val === INVALID) return;

          var next = using(mod, val, str);
          if (next === INVALID) return;

          $el.val(next);
          ngModelCntr.$setViewValue(next);
        };
      }

      function onKeydown(event) {
        var handler = handlers[idKey(event)];
        if (!handler) return;

        if (handler(event) !== false) {
          event.preventDefault();
        }

        $scope.$apply();
      }

      $el.on('keydown', onKeydown);
      $scope.$on('$destroy', function () {
        $el.off('keydown', onKeydown);
      });

      function parse(viewValue) {
        var num = viewValue;

        if (typeof num !== 'number' || isNaN(num)) {
          // parse non-numbers
          num = String(viewValue || 0).trim();
          if (!FLOATABLE.test(num)) return INVALID;

          num = parseFloat(num);
          if (isNaN(num)) return INVALID;
        }

        var range = numberListCntr.range;
        if (!range.within(num)) return INVALID;

        if (numberListCntr.validateAscOrder && $scope.$index > 0) {
          var i = $scope.$index - 1;
          var list = numberListCntr.getList();
          var prev = list[i];
          if (num <= prev) return INVALID;
        }

        return num;
      }

      $scope.$watchMulti(['$index', {
        fn: $scope.$watchCollection,
        get: function get() {
          return numberListCntr.getList();
        }
      }], function () {
        var valid = parse(ngModelCntr.$viewValue) !== INVALID;
        ngModelCntr.$setValidity(VALIDATION_ERROR, valid);
      });

      function validate(then) {
        return function (input) {
          var value = parse(input);
          var valid = value !== INVALID;
          value = valid ? value : input;
          ngModelCntr.$setValidity(VALIDATION_ERROR, valid);
          then && then(input, value);
          return value;
        };
      }

      ngModelCntr.$parsers.push(validate());
      ngModelCntr.$formatters.push(validate(function (input, value) {
        if (input !== value) $setModel($scope, value);
      }));

      if (parse(ngModelCntr.$viewValue) === INVALID) {
        ngModelCntr.$setTouched();
      }
    }
  };
});

/***/ }),
/* 3076 */
/***/ (function(module, exports) {

module.exports = "<div\n  ng-repeat=\"value in numberListCntr.getList() track by $index\"\n  class=\"form-group kuiFieldGroup\"\n>\n  <div class=\"kuiFieldGroupSection kuiFieldGroupSection--wide\">\n    <input\n      ng-model=\"numberListCntr.getList()[$index]\"\n      kbn-number-list-input\n      input-focus\n      aria-labelledby=\"{{numberListCntr.labelledbyId}}\"\n      class=\"form-control\"\n    >\n  </div>\n\n  <div class=\"kuiFieldGroupSection\">\n    <button\n      aria-label=\"Remove this rank value\"\n      ng-click=\"numberListCntr.remove($index, 1)\"\n      class=\"kuiButton kuiButton--danger kuiButton--small\"\n      type=\"button\"\n    >\n      <span class=\"kuiIcon fa-times\"></span>\n    </button>\n  </div>\n</div>\n\n<p ng-show=\"numberListCntr.invalidLength()\" class=\"text-danger text-center\">\n  You must specify at least one {{numberListCntr.getUnitName()}}\n</p>\n\n<p ng-show=\"numberListCntr.undefinedLength()\" class=\"text-primary text-center\">\n  <!-- be a bit more polite when the form is first init'd -->\n  Please specify at least one {{numberListCntr.getUnitName()}}\n</p>\n\n<div class=\"euiSpacer euiSpacer--s\"></div>\n\n<button\n  ng-click=\"numberListCntr.add()\"\n  type=\"button\"\n  class=\"kuiButton kuiButton--primary kuiButton--fullWidth\"\n>\n  <i class=\"fa fa-plus\"></i> Add {{numberListCntr.getUnitName()}}\n</button>\n"

/***/ }),
/* 3077 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesMetricsMinProvider = AggTypesMetricsMinProvider;

var _metric_agg_type = __webpack_require__(40);

function AggTypesMetricsMinProvider(Private) {
  var MetricAggType = Private(_metric_agg_type.AggTypesMetricsMetricAggTypeProvider);

  return new MetricAggType({
    name: 'min',
    title: 'Min',
    makeLabel: function makeLabel(aggConfig) {
      return 'Min ' + aggConfig.getFieldDisplayName();
    },
    params: [{
      name: 'field',
      filterFieldTypes: 'number,date'
    }]
  });
}

/***/ }),
/* 3078 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesMetricsMaxProvider = AggTypesMetricsMaxProvider;

var _metric_agg_type = __webpack_require__(40);

function AggTypesMetricsMaxProvider(Private) {
  var MetricAggType = Private(_metric_agg_type.AggTypesMetricsMetricAggTypeProvider);

  return new MetricAggType({
    name: 'max',
    title: 'Max',
    makeLabel: function makeLabel(aggConfig) {
      return 'Max ' + aggConfig.getFieldDisplayName();
    },
    params: [{
      name: 'field',
      filterFieldTypes: 'number,date'
    }]
  });
}

/***/ }),
/* 3079 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.AggTypesMetricsTopHitProvider = AggTypesMetricsTopHitProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _metric_agg_type = __webpack_require__(40);

var _top_sort = __webpack_require__(3080);

var _top_sort2 = _interopRequireDefault(_top_sort);

var _top_aggregate_and_size = __webpack_require__(3081);

var _top_aggregate_and_size2 = _interopRequireDefault(_top_aggregate_and_size);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function AggTypesMetricsTopHitProvider(Private) {
  var MetricAggType = Private(_metric_agg_type.AggTypesMetricsMetricAggTypeProvider);

  var isNumber = function isNumber(type) {
    return type === 'number';
  };

  return new MetricAggType({
    name: 'top_hits',
    title: 'Top Hit',
    makeLabel: function makeLabel(aggConfig) {
      var prefix = aggConfig.params.sortOrder.val === 'desc' ? 'Last' : 'First';
      if (aggConfig.params.size !== 1) {
        prefix += ' ' + aggConfig.params.size;
      }
      return prefix + ' ' + aggConfig.params.field.displayName;
    },
    params: [{
      name: 'field',
      onlyAggregatable: false,
      filterFieldTypes: function filterFieldTypes(vis, value) {
        if (vis.type.name === 'table' || vis.type.name === 'metric') {
          return true;
        }
        return value === 'number';
      },
      write: function write(agg, output) {
        var field = agg.params.field;
        output.params = {};

        if (field.scripted) {
          output.params.script_fields = _defineProperty({}, field.name, {
            script: {
              inline: field.script,
              lang: field.lang
            }
          });
        } else {
          if (field.readFromDocValues) {
            output.params.docvalue_fields = [field.name];
          }
          output.params._source = field.name === '_source' ? true : field.name;
        }
      }
    }, {
      name: 'aggregate',
      type: 'optioned',
      editor: _top_aggregate_and_size2.default,
      options: [{
        display: 'Min',
        isCompatibleType: isNumber,
        isCompatibleVis: _lodash2.default.constant(true),
        disabled: true,
        val: 'min'
      }, {
        display: 'Max',
        isCompatibleType: isNumber,
        isCompatibleVis: _lodash2.default.constant(true),
        disabled: true,
        val: 'max'
      }, {
        display: 'Sum',
        isCompatibleType: isNumber,
        isCompatibleVis: _lodash2.default.constant(true),
        disabled: true,
        val: 'sum'
      }, {
        display: 'Average',
        isCompatibleType: isNumber,
        isCompatibleVis: _lodash2.default.constant(true),
        disabled: true,
        val: 'average'
      }, {
        display: 'Concatenate',
        isCompatibleType: _lodash2.default.constant(true),
        isCompatibleVis: function isCompatibleVis(name) {
          return name === 'metric' || name === 'table';
        },
        disabled: true,
        val: 'concat'
      }],
      controller: function controller($scope) {
        $scope.options = [];
        $scope.$watchGroup(['agg.vis.type.name', 'agg.params.field.type'], function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              visName = _ref2[0],
              fieldType = _ref2[1];

          if (fieldType && visName) {
            $scope.options = _lodash2.default.filter($scope.aggParam.options, function (option) {
              return option.isCompatibleVis(visName) && option.isCompatibleType(fieldType);
            });
            if ($scope.options.length === 1) {
              $scope.agg.params.aggregate = $scope.options[0];
            }
          }
        });
      },
      write: _lodash2.default.noop
    }, {
      name: 'size',
      editor: null, // size setting is done together with the aggregation setting
      default: 1
    }, {
      name: 'sortField',
      type: 'field',
      editor: null,
      filterFieldTypes: ['number', 'date', 'ip', 'string'],
      default: function _default(agg) {
        return agg.vis.indexPattern.timeFieldName;
      },
      write: _lodash2.default.noop // prevent default write, it is handled below
    }, {
      name: 'sortOrder',
      type: 'optioned',
      default: 'desc',
      editor: _top_sort2.default,
      options: [{ display: 'Descending', val: 'desc' }, { display: 'Ascending', val: 'asc' }],
      write: function write(agg, output) {
        var sortField = agg.params.sortField;
        var sortOrder = agg.params.sortOrder;

        if (sortField.scripted) {
          output.params.sort = [{
            _script: {
              script: {
                inline: sortField.script,
                lang: sortField.lang
              },
              type: sortField.type,
              order: sortOrder.val
            }
          }];
        } else {
          output.params.sort = [_defineProperty({}, sortField.name, {
            order: sortOrder.val
          })];
        }
      }
    }],
    getValue: function getValue(agg, bucket) {
      var hits = _lodash2.default.get(bucket, agg.id + '.hits.hits');
      if (!hits || !hits.length) {
        return null;
      }
      var path = agg.params.field.name;

      var values = (0, _lodash2.default)(hits).map(function (hit) {
        return path === '_source' ? hit._source : agg.vis.indexPattern.flattenHit(hit, true)[path];
      }).flatten().value();

      if (values.length === 1) {
        values = values[0];
      }

      if (Array.isArray(values)) {
        if (!_lodash2.default.compact(values).length) {
          return null;
        }
        switch (agg.params.aggregate.val) {
          case 'max':
            return _lodash2.default.max(values);
          case 'min':
            return _lodash2.default.min(values);
          case 'sum':
            return _lodash2.default.sum(values);
          case 'average':
            return _lodash2.default.sum(values) / values.length;
        }
      }
      return values;
    }
  });
}

/***/ }),
/* 3080 */
/***/ (function(module, exports) {

module.exports = "<div class=\"form-group\">\n  <label>\n    Sort On\n  </label>\n\n  <ui-select\n    name=\"field\"\n    sortField\n    title=\"Sort on\"\n    class=\"vis-editor-field-ui-select\"\n    ng-show=\"sortFieldOptions.length\"\n    ng-model=\"agg.params.sortField\"\n    uis-open-close=\"limit = 100\"\n    auto-select-if-only-one=\"sortFieldOptions\"\n  >\n    <ui-select-match placeholder=\"Select a field\">\n      {{$select.selected.displayName}}\n    </ui-select-match>\n    <ui-select-choices\n      group-by=\"'type'\"\n      kbn-scroll-bottom=\"limit = limit + 100\"\n      repeat=\"field in sortFieldOptions | filter: { displayName: $select.search } | sortPrefixFirst:$select.search:'name' | limitTo: limit\"\n    >\n      <div ng-bind-html=\"field.displayName | highlight: $select.search\"></div>\n    </ui-select-choices>\n  </ui-select>\n</div>\n\n<div class=\"form-group\">\n  <label for=\"visEditorTopSort{{agg.id}}\">\n    Order\n  </label>\n\n  <select\n     id=\"visEditorTopSort{{agg.id}}\"\n     name=\"sortOrder\"\n     ng-model=\"agg.params.sortOrder\"\n     required\n     ng-options=\"opt as opt.display for opt in aggParam.options track by opt.val\"\n     class=\"form-control\">\n  </select>\n</div>\n"

/***/ }),
/* 3081 */
/***/ (function(module, exports) {

module.exports = "<div ng-controller=\"aggParam.controller\" class=\"vis-editor-agg-form-row\">\n  <div class=\"form-group\">\n    <label for=\"visEditorTopHitsAggregate{{agg.id}}\">\n      Aggregate With\n      <kbn-info\n       info=\"Choose a strategy for combining multiple hits or a multi-valued field into a single metric.\"\n       placement=\"right\">\n      </kbn-info>\n    </label>\n\n    <select\n      required\n      id=\"visEditorTopHitsAggregate{{agg.id}}\"\n      name=\"aggregate\"\n      ng-model=\"agg.params.aggregate\"\n      ng-options=\"opt as opt.display for opt in options| orderBy: 'display' track by opt.val\"\n      class=\"form-control\"\n    ></select>\n  </div>\n  <div class=\"form-group\">\n    <label for=\"visEditorTopHitsSize{{agg.id}}\">\n      Size\n      <kbn-info\n       info=\"Request top-K hits. Multiple hits will be combined via 'aggregate with'.\"\n       placement=\"right\">\n      </kbn-info>\n    </label>\n\n    <input\n       required\n       id=\"visEditorTopHitsSize{{agg.id}}\"\n       name=\"size\"\n       ng-model=\"agg.params.size\"\n       class=\"form-control\"\n       type=\"number\"\n       min=\"1\"\n    ></input>\n  </div>\n</div>\n"

/***/ }),
/* 3082 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesMetricsStdDeviationProvider = AggTypesMetricsStdDeviationProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _metric_agg_type = __webpack_require__(40);

var _get_response_agg_config_class = __webpack_require__(538);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function AggTypesMetricsStdDeviationProvider(Private) {
  var MetricAggType = Private(_metric_agg_type.AggTypesMetricsMetricAggTypeProvider);
  var getResponseAggConfigClass = Private(_get_response_agg_config_class.AggTypesMetricsGetResponseAggConfigClassProvider);

  var responseAggConfigProps = {
    valProp: function valProp() {
      var details = this.keyedDetails(this.params.customLabel)[this.key];
      return details.valProp;
    },
    makeLabel: function makeLabel() {
      var fieldDisplayName = this.getFieldDisplayName();
      var details = this.keyedDetails(this.params.customLabel, fieldDisplayName);
      return _lodash2.default.get(details, [this.key, 'title']);
    },
    keyedDetails: function keyedDetails(customLabel, fieldDisplayName) {
      var label = customLabel ? customLabel : 'Standard Deviation of ' + fieldDisplayName;
      return {
        std_lower: {
          valProp: ['std_deviation_bounds', 'lower'],
          title: 'Lower ' + label
        },
        std_upper: {
          valProp: ['std_deviation_bounds', 'upper'],
          title: 'Upper ' + label
        }
      };
    }
  };

  return new MetricAggType({
    name: 'std_dev',
    dslName: 'extended_stats',
    title: 'Standard Deviation',
    makeLabel: function makeLabel(agg) {
      return 'Standard Deviation of ' + agg.getFieldDisplayName();
    },
    params: [{
      name: 'field',
      filterFieldTypes: 'number'
    }],

    getResponseAggs: function getResponseAggs(agg) {
      var ValueAggConfig = getResponseAggConfigClass(agg, responseAggConfigProps);

      return [new ValueAggConfig('std_lower'), new ValueAggConfig('std_upper')];
    },

    getValue: function getValue(agg, bucket) {
      return _lodash2.default.get(bucket[agg.parentId], agg.valProp());
    }
  });
}

/***/ }),
/* 3083 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesMetricsCardinalityProvider = AggTypesMetricsCardinalityProvider;

var _metric_agg_type = __webpack_require__(40);

var _field_formats = __webpack_require__(64);

function AggTypesMetricsCardinalityProvider(Private) {
  var MetricAggType = Private(_metric_agg_type.AggTypesMetricsMetricAggTypeProvider);
  var fieldFormats = Private(_field_formats.RegistryFieldFormatsProvider);

  return new MetricAggType({
    name: 'cardinality',
    title: 'Unique Count',
    makeLabel: function makeLabel(aggConfig) {
      return 'Unique count of ' + aggConfig.getFieldDisplayName();
    },
    getFormat: function getFormat() {
      return fieldFormats.getDefaultInstance('number');
    },
    params: [{
      name: 'field'
    }]
  });
}

/***/ }),
/* 3084 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesMetricsGeoBoundsProvider = AggTypesMetricsGeoBoundsProvider;

var _metric_agg_type = __webpack_require__(40);

function AggTypesMetricsGeoBoundsProvider(Private) {
  var MetricAggType = Private(_metric_agg_type.AggTypesMetricsMetricAggTypeProvider);

  return new MetricAggType({
    name: 'geo_bounds',
    title: 'Geo Bounds',
    makeLabel: function makeLabel() {
      return 'Geo Bounds';
    },
    params: [{
      name: 'field',
      filterFieldTypes: 'geo_point'
    }]
  });
}

/***/ }),
/* 3085 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesMetricsGeoCentroidProvider = AggTypesMetricsGeoCentroidProvider;

var _metric_agg_type = __webpack_require__(40);

function AggTypesMetricsGeoCentroidProvider(Private) {
  var MetricAggType = Private(_metric_agg_type.AggTypesMetricsMetricAggTypeProvider);

  return new MetricAggType({
    name: 'geo_centroid',
    title: 'Geo Centroid',
    makeLabel: function makeLabel() {
      return 'Geo Centroid';
    },
    params: [{
      name: 'field',
      filterFieldTypes: 'geo_point'
    }],
    getValue: function getValue(agg, bucket) {
      return bucket[agg.id] && bucket[agg.id].location;
    }
  });
}

/***/ }),
/* 3086 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesMetricsPercentileRanksProvider = AggTypesMetricsPercentileRanksProvider;

var _percentile_ranks = __webpack_require__(3087);

var _percentile_ranks2 = _interopRequireDefault(_percentile_ranks);

__webpack_require__(957);

var _metric_agg_type = __webpack_require__(40);

var _get_response_agg_config_class = __webpack_require__(538);

var _field_formats = __webpack_require__(64);

var _percentiles_get_value = __webpack_require__(958);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function AggTypesMetricsPercentileRanksProvider(Private) {
  var MetricAggType = Private(_metric_agg_type.AggTypesMetricsMetricAggTypeProvider);
  var getResponseAggConfigClass = Private(_get_response_agg_config_class.AggTypesMetricsGetResponseAggConfigClassProvider);
  var fieldFormats = Private(_field_formats.RegistryFieldFormatsProvider);

  // required by the values editor

  var valueProps = {
    makeLabel: function makeLabel() {
      var field = this.getField();
      var format = field && field.format || fieldFormats.getDefaultInstance('number');
      var label = this.params.customLabel || this.getFieldDisplayName();

      return 'Percentile rank ' + format.convert(this.key, 'text') + ' of "' + label + '"';
    }
  };

  return new MetricAggType({
    name: 'percentile_ranks',
    title: 'Percentile Ranks',
    makeLabel: function makeLabel(agg) {
      return 'Percentile ranks of ' + agg.getFieldDisplayName();
    },
    params: [{
      name: 'field',
      filterFieldTypes: 'number'
    }, {
      name: 'values',
      editor: _percentile_ranks2.default,
      default: []
    }, {
      write: function write(agg, output) {
        output.params.keyed = false;
      }
    }],
    getResponseAggs: function getResponseAggs(agg) {
      var ValueAggConfig = getResponseAggConfigClass(agg, valueProps);

      return agg.params.values.map(function (value) {
        return new ValueAggConfig(value);
      });
    },
    getFormat: function getFormat() {
      return fieldFormats.getInstance('percent') || fieldFormats.getDefaultInstance('number');
    },
    getValue: function getValue(agg, bucket) {
      return (0, _percentiles_get_value.getPercentileValue)(agg, bucket) / 100;
    }
  });
}

/***/ }),
/* 3087 */
/***/ (function(module, exports) {

module.exports = "<div class=\"form-group\">\n  <label id=\"visEditorPercentileRanksLabel{{agg.id}}\">Values</label>\n  <kbn-number-list\n    ng-model=\"agg.params.values\"\n    unit-name=\"value\"\n    range=\"[-Infinity,Infinity]\"\n    labelledby-id=\"visEditorPercentileRanksLabel{{agg.id}}\"\n    >\n  </kbn-number-list>\n</div>\n"

/***/ }),
/* 3088 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesMetricsDerivativeProvider = AggTypesMetricsDerivativeProvider;

var _metric_agg_type = __webpack_require__(40);

var _parent_pipeline_agg_helper = __webpack_require__(359);

var _make_nested_label = __webpack_require__(139);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function AggTypesMetricsDerivativeProvider(Private) {
  var MetricAggType = Private(_metric_agg_type.AggTypesMetricsMetricAggTypeProvider);
  var parentPipelineAggHelper = Private(_parent_pipeline_agg_helper.ParentPipelineAggHelperProvider);

  return new MetricAggType({
    name: 'derivative',
    title: 'Derivative',
    subtype: parentPipelineAggHelper.subtype,
    makeLabel: function makeLabel(agg) {
      return (0, _make_nested_label.makeNestedLabel)(agg, 'derivative');
    },
    params: [].concat(_toConsumableArray(parentPipelineAggHelper.params())),
    getFormat: parentPipelineAggHelper.getFormat
  });
}

/***/ }),
/* 3089 */
/***/ (function(module, exports) {

module.exports = "<div ng-controller=\"aggParam.controller\">\n  <div class=\"form-group\">\n    <label for=\"visEditorSubAggMetric{{agg.id}}\">Metric</label>\n    <select\n      id=\"visEditorSubAggMetric{{agg.id}}\"\n      name=\"metricAgg\"\n      ng-model=\"agg.params.metricAgg\"\n      agg=\"agg\"\n      required\n      validate-agg\n      class=\"form-control\">\n      <option\n        ng-repeat=\"respAgg in responseValueAggs track by respAgg.id\"\n        value=\"{{respAgg.id}}\"\n        ng-if=\"respAgg.type.name !== agg.type.name\"\n        ng-disabled=\"isDisabledAgg(respAgg)\"\n        ng-selected=\"agg.params.metricAgg === respAgg.id\">\n        metric: {{safeMakeLabel(respAgg)}}\n      </option>\n      <option value=\"custom\" ng-selected=\"agg.params.metricAgg === 'custom'\">\n        Custom Metric\n      </option>\n    </select>\n  </div>\n  <div ng-if=\"agg.params.metricAgg === 'custom'\" class=\"vis-editor-agg-order-agg\">\n    <ng-form name=\"customMetricForm\">\n      <vis-editor-agg-params\n        agg=\"agg.params.customMetric\"\n        group-name=\"'metrics'\">\n      </vis-editor-agg-params>\n    </ng-form>\n  </div>\n</div>\n"

/***/ }),
/* 3090 */
/***/ (function(module, exports) {

module.exports = "<div class=\"form-group\">\n  <div class=\"kuiButtonGroup\">\n    <button\n      type=\"button\"\n      class=\"kuiButton kuiButton--basic kuiButton--small\"\n      ng-model=\"agg.params.row\"\n      btn-radio=\"true\">\n      Rows\n    </button>\n    <button\n      type=\"button\"\n      class=\"kuiButton kuiButton--basic kuiButton--small\"\n      ng-model=\"agg.params.row\"\n      btn-radio=\"false\">\n      Columns\n    </button>\n  </div>\n</div>\n"

/***/ }),
/* 3091 */
/***/ (function(module, exports) {

module.exports = "<div>\n  <label>\n    Dot Size Ratio:\n    <kbn-info\n      placement=\"right\"\n      info=\"Change the ratio of the radius of the smallest point to the largest point.\">\n    </kbn-info>\n  </label>\n  <input type=\"range\" step=\"2\" min=\"1\" max=\"100\" class=\"form-control\" ng-model=\"vis.params.radiusRatio\" />\n</div>\n"

/***/ }),
/* 3092 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parentPipelineAggController = undefined;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _safe_make_label = __webpack_require__(959);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var parentPipelineAggController = function parentPipelineAggController($scope) {

  $scope.safeMakeLabel = _safe_make_label.safeMakeLabel;

  $scope.$watch('responseValueAggs', updateOrderAgg);
  $scope.$watch('agg.params.metricAgg', updateOrderAgg);

  $scope.$on('$destroy', function () {
    var lastBucket = _lodash2.default.findLast($scope.vis.getAggConfig(), function (agg) {
      return agg.schema.group === 'buckets';
    });
    if ($scope.aggForm && $scope.aggForm.agg) {
      $scope.aggForm.agg.$setValidity('bucket', true);
    }
    if (lastBucket && lastBucket.error) {
      delete lastBucket.error;
    }
  });

  $scope.isDisabledAgg = function (agg) {
    var invalidAggs = ['top_hits', 'percentiles', 'percentile_ranks', 'median', 'std_dev'];
    return Boolean(invalidAggs.find(function (invalidAgg) {
      return invalidAgg === agg.type.name;
    }));
  };

  function checkBuckets() {
    var lastBucket = _lodash2.default.findLast($scope.vis.getAggConfig(), function (agg) {
      return agg.schema.group === 'buckets';
    });
    var bucketHasType = lastBucket && lastBucket.type;
    var bucketIsHistogram = bucketHasType && ['date_histogram', 'histogram'].includes(lastBucket.type.name);
    var canUseAggregation = lastBucket && bucketIsHistogram;

    // remove errors on all buckets
    _lodash2.default.each($scope.vis.aggs, function (agg) {
      if (agg.error) delete agg.error;
    });

    if ($scope.aggForm.agg) {
      $scope.aggForm.agg.$setValidity('bucket', canUseAggregation);
    }
    if (canUseAggregation) {
      lastBucket.params.min_doc_count = lastBucket.type.name === 'histogram' ? 1 : 0;
    } else {
      if (lastBucket) {
        var type = $scope.agg.type.title;
        lastBucket.error = 'Last bucket aggregation must be "Date Histogram" or \n        "Histogram" when using "' + type + '" metric aggregation!';
      }
    }
  }

  function updateOrderAgg() {
    var agg = $scope.agg;
    var params = agg.params;
    var metricAgg = params.metricAgg;
    var paramDef = agg.type.params.byName.customMetric;

    checkBuckets();

    // we aren't creating a custom aggConfig
    if (metricAgg !== 'custom') {
      if (!$scope.vis.getAggConfig().find(function (agg) {
        return agg.id === metricAgg;
      })) {
        params.metricAgg = null;
      }
      params.customMetric = null;
      return;
    }

    params.customMetric = params.customMetric || paramDef.makeAgg(agg);
  }
};

exports.parentPipelineAggController = parentPipelineAggController;

/***/ }),
/* 3093 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var parentPipelineAggWritter = function parentPipelineAggWritter(agg, output) {
  var vis = agg.vis;
  var selectedMetric = agg.params.customMetric || vis.aggs.getResponseAggById(agg.params.metricAgg);

  if (agg.params.customMetric && agg.params.customMetric.type.name !== 'count') {
    output.parentAggs = (output.parentAggs || []).concat(selectedMetric);
  }

  output.params = {};
  if (selectedMetric.type.name === 'count') {
    output.params.buckets_path = '_count';
  } else {
    output.params.buckets_path = selectedMetric.id;
  }
};

exports.parentPipelineAggWritter = parentPipelineAggWritter;

/***/ }),
/* 3094 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesMetricsCumulativeSumProvider = AggTypesMetricsCumulativeSumProvider;

var _metric_agg_type = __webpack_require__(40);

var _parent_pipeline_agg_helper = __webpack_require__(359);

var _make_nested_label = __webpack_require__(139);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function AggTypesMetricsCumulativeSumProvider(Private) {
  var MetricAggType = Private(_metric_agg_type.AggTypesMetricsMetricAggTypeProvider);
  var parentPipelineAggHelper = Private(_parent_pipeline_agg_helper.ParentPipelineAggHelperProvider);

  return new MetricAggType({
    name: 'cumulative_sum',
    title: 'Cumulative Sum',
    subtype: parentPipelineAggHelper.subtype,
    makeLabel: function makeLabel(agg) {
      return (0, _make_nested_label.makeNestedLabel)(agg, 'cumulative sum');
    },
    params: [].concat(_toConsumableArray(parentPipelineAggHelper.params())),
    getFormat: parentPipelineAggHelper.getFormat
  });
}

/***/ }),
/* 3095 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesMetricsMovingAvgProvider = AggTypesMetricsMovingAvgProvider;

var _metric_agg_type = __webpack_require__(40);

var _parent_pipeline_agg_helper = __webpack_require__(359);

var _make_nested_label = __webpack_require__(139);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function AggTypesMetricsMovingAvgProvider(Private) {
  var MetricAggType = Private(_metric_agg_type.AggTypesMetricsMetricAggTypeProvider);
  var parentPipelineAggHelper = Private(_parent_pipeline_agg_helper.ParentPipelineAggHelperProvider);

  return new MetricAggType({
    name: 'moving_avg',
    title: 'Moving Avg',
    subtype: parentPipelineAggHelper.subtype,
    makeLabel: function makeLabel(agg) {
      return (0, _make_nested_label.makeNestedLabel)(agg, 'moving avg');
    },
    params: [].concat(_toConsumableArray(parentPipelineAggHelper.params())),
    getFormat: parentPipelineAggHelper.getFormat
  });
}

/***/ }),
/* 3096 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesMetricsSerialDiffProvider = AggTypesMetricsSerialDiffProvider;

var _metric_agg_type = __webpack_require__(40);

var _parent_pipeline_agg_helper = __webpack_require__(359);

var _make_nested_label = __webpack_require__(139);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function AggTypesMetricsSerialDiffProvider(Private) {
  var MetricAggType = Private(_metric_agg_type.AggTypesMetricsMetricAggTypeProvider);
  var parentPipelineAggHelper = Private(_parent_pipeline_agg_helper.ParentPipelineAggHelperProvider);

  return new MetricAggType({
    name: 'serial_diff',
    title: 'Serial Diff',
    subtype: parentPipelineAggHelper.subtype,
    makeLabel: function makeLabel(agg) {
      return (0, _make_nested_label.makeNestedLabel)(agg, 'serial diff');
    },
    params: [].concat(_toConsumableArray(parentPipelineAggHelper.params())),
    getFormat: parentPipelineAggHelper.getFormat
  });
}

/***/ }),
/* 3097 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesBucketsDateHistogramProvider = AggTypesBucketsDateHistogramProvider;

var _jstimezonedetect = __webpack_require__(706);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

__webpack_require__(523);

__webpack_require__(488);

var _bucket_agg_type = __webpack_require__(106);

var _time_buckets = __webpack_require__(3098);

var _date_histogram = __webpack_require__(3102);

var _interval_options = __webpack_require__(960);

var _time_interval = __webpack_require__(3103);

var _time_interval2 = _interopRequireDefault(_time_interval);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function AggTypesBucketsDateHistogramProvider(timefilter, config, Private) {
  var BucketAggType = Private(_bucket_agg_type.AggTypesBucketsBucketAggTypeProvider);
  var TimeBuckets = Private(_time_buckets.TimeBucketsProvider);
  var createFilter = Private(_date_histogram.AggTypesBucketsCreateFilterDateHistogramProvider);
  var intervalOptions = Private(_interval_options.AggTypesBucketsIntervalOptionsProvider);

  var detectedTimezone = _jstimezonedetect.jstz.determine().name();
  var tzOffset = (0, _moment2.default)().format('Z');

  function getInterval(agg) {
    var interval = _lodash2.default.get(agg, ['params', 'interval']);
    if (interval && interval.val === 'custom') {
      return _lodash2.default.get(agg, ['params', 'customInterval']);
    }
    return interval;
  }

  function setBounds(agg, force) {
    if (agg.buckets._alreadySet && !force) return;
    agg.buckets._alreadySet = true;
    var timeRange = agg.getTimeRange() || timefilter.getActiveBounds();
    agg.buckets.setBounds(agg.fieldIsTimeField() && timeRange);
  }

  return new BucketAggType({
    name: 'date_histogram',
    title: 'Date Histogram',
    ordered: {
      date: true
    },
    makeLabel: function makeLabel(agg) {
      var output = this.params.write(agg);
      var field = agg.getFieldDisplayName();
      return field + ' per ' + (output.metricScaleText || output.bucketInterval.description);
    },
    createFilter: createFilter,
    decorateAggConfig: function decorateAggConfig() {
      var buckets = void 0;
      var timeRange = void 0;
      return {
        buckets: {
          configurable: true,
          get: function get() {
            if (buckets) return buckets;

            buckets = new TimeBuckets();
            buckets.setInterval(getInterval(this));
            setBounds(this);

            return buckets;
          }
        },
        setTimeRange: {
          configurable: true,
          value: function value(newValue) {
            timeRange = newValue;
            setBounds(this, true);
          }
        },
        getTimeRange: {
          configurable: true,
          value: function value() {
            return timeRange;
          }
        }
      };
    },
    getFormat: function getFormat(agg) {
      return agg.buckets.getScaledDateFormatter();
    },
    params: [{
      name: 'field',
      filterFieldTypes: 'date',
      default: function _default(agg) {
        return agg.vis.indexPattern.timeFieldName;
      },
      onChange: function onChange(agg) {
        if (_lodash2.default.get(agg, 'params.interval.val') === 'auto' && !agg.fieldIsTimeField()) {
          delete agg.params.interval;
        }

        setBounds(agg, true);
      }
    }, {
      name: 'interval',
      type: 'optioned',
      deserialize: function deserialize(state) {
        var interval = _lodash2.default.find(intervalOptions, { val: state });
        return interval || _lodash2.default.find(intervalOptions, function (option) {
          // For upgrading from 4.0.x to 4.1.x - intervals are now stored as 'y' instead of 'year',
          // but this maps the old values to the new values
          return Number(_moment2.default.duration(1, state)) === Number(_moment2.default.duration(1, option.val));
        });
      },
      default: 'auto',
      options: intervalOptions,
      editor: _time_interval2.default,
      modifyAggConfigOnSearchRequestStart: function modifyAggConfigOnSearchRequestStart(agg) {
        setBounds(agg, true);
      },
      write: function write(agg, output) {
        setBounds(agg);
        agg.buckets.setInterval(getInterval(agg));

        var interval = agg.buckets.getInterval();
        output.bucketInterval = interval;
        output.params.interval = interval.expression;

        var isDefaultTimezone = config.isDefault('dateFormat:tz');
        if (isDefaultTimezone) {
          output.params.time_zone = detectedTimezone || tzOffset;
        } else {
          output.params.time_zone = config.get('dateFormat:tz');
        }

        var scaleMetrics = interval.scaled && interval.scale < 1;
        if (scaleMetrics) {
          var all = _lodash2.default.every(agg.vis.getAggConfig().bySchemaGroup.metrics, function (agg) {
            return agg.type && agg.type.isScalable();
          });
          if (all) {
            output.metricScale = interval.scale;
            output.metricScaleText = interval.preScaled.description;
          }
        }
      }
    }, {
      name: 'customInterval',
      default: '2h',
      write: _lodash2.default.noop
    }, {
      name: 'format'
    }, {
      name: 'min_doc_count',
      default: 1
    }, {
      name: 'extended_bounds',
      default: {},
      write: function write(agg, output) {
        var val = agg.params.extended_bounds;

        if (val.min != null || val.max != null) {
          output.params.extended_bounds = {
            min: (0, _moment2.default)(val.min).valueOf(),
            max: (0, _moment2.default)(val.max).valueOf()
          };

          return;
        }
      }
    }]
  });
}

/***/ }),
/* 3098 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _time_buckets = __webpack_require__(3099);

Object.defineProperty(exports, 'TimeBucketsProvider', {
  enumerable: true,
  get: function get() {
    return _time_buckets.TimeBucketsProvider;
  }
});

/***/ }),
/* 3099 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TimeBucketsProvider = TimeBucketsProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

var _parse_interval = __webpack_require__(489);

var _calc_auto_interval = __webpack_require__(3100);

var _calc_es_interval = __webpack_require__(3101);

var _field_formats = __webpack_require__(64);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function TimeBucketsProvider(Private, timefilter, config) {
  var calcAuto = Private(_calc_auto_interval.TimeBucketsCalcAutoIntervalProvider);
  var calcEsInterval = Private(_calc_es_interval.TimeBucketsCalcEsIntervalProvider);
  var fieldFormats = Private(_field_formats.RegistryFieldFormatsProvider);
  var getConfig = function getConfig() {
    return config.get.apply(config, arguments);
  };

  function isValidMoment(m) {
    return m && 'isValid' in m && m.isValid();
  }

  /**
   * Helper class for wrapping the concept of an "Interval",
   * which describes a timespan that will seperate moments.
   *
   * @param {state} object - one of ""
   * @param {[type]} display [description]
   */
  function TimeBuckets() {
    return TimeBuckets.__cached__(this);
  }

  /****
   *  PUBLIC API
   ****/

  /**
   * Set the bounds that these buckets are expected to cover.
   * This is required to support interval "auto" as well
   * as interval scaling.
   *
   * @param {object} input - an object with properties min and max,
   *                       representing the edges for the time span
   *                       we should cover
   *
   * @returns {undefined}
   */
  TimeBuckets.prototype.setBounds = function (input) {
    if (!input) return this.clearBounds();

    var bounds = void 0;
    if (_lodash2.default.isPlainObject(input)) {
      // accept the response from timefilter.getActiveBounds()
      bounds = [input.min, input.max];
    } else {
      bounds = Array.isArray(input) ? input : [];
    }

    var moments = (0, _lodash2.default)(bounds).map(_lodash2.default.ary(_moment2.default, 1)).sortBy(Number);

    var valid = moments.size() === 2 && moments.every(isValidMoment);
    if (!valid) {
      this.clearBounds();
      throw new Error('invalid bounds set: ' + input);
    }

    this._lb = moments.shift();
    this._ub = moments.pop();
    if (this.getDuration().asSeconds() < 0) {
      throw new TypeError('Intervals must be positive');
    }
  };

  /**
   * Clear the stored bounds
   *
   * @return {undefined}
   */
  TimeBuckets.prototype.clearBounds = function () {
    this._lb = this._ub = null;
  };

  /**
   * Check to see if we have received bounds yet
   *
   * @return {Boolean}
   */
  TimeBuckets.prototype.hasBounds = function () {
    return isValidMoment(this._ub) && isValidMoment(this._lb);
  };

  /**
   * Return the current bounds, if we have any.
   *
   * THIS DOES NOT CLONE THE BOUNDS, so editing them
   * may have unexpected side-effects. Always
   * call bounds.min.clone() before editing
   *
   * @return {object|undefined} - If bounds are not defined, this
   *                      returns undefined, else it returns the bounds
   *                      for these buckets. This object has two props,
   *                      min and max. Each property will be a moment()
   *                      object
   *
   */
  TimeBuckets.prototype.getBounds = function () {
    if (!this.hasBounds()) return;
    return {
      min: this._lb,
      max: this._ub
    };
  };

  /**
   * Get a moment duration object representing
   * the distance between the bounds, if the bounds
   * are set.
   *
   * @return {moment.duration|undefined}
   */
  TimeBuckets.prototype.getDuration = function () {
    if (!this.hasBounds()) return;
    return _moment2.default.duration(this._ub - this._lb, 'ms');
  };

  /**
   * Update the interval at which buckets should be
   * generated.
   *
   * Input can be one of the following:
   *  - Any object from src/ui/agg_types/buckets/_interval_options.js
   *  - "auto"
   *  - Pass a valid moment unit
   *  - a moment.duration object.
   *
   * @param {object|string|moment.duration} input - see desc
   */
  TimeBuckets.prototype.setInterval = function (input) {
    var interval = input;

    // selection object -> val
    if (_lodash2.default.isObject(input)) {
      interval = input.val;
    }

    if (!interval || interval === 'auto') {
      this._i = 'auto';
      return;
    }

    if (_lodash2.default.isString(interval)) {
      input = interval;
      interval = (0, _parse_interval.parseInterval)(interval);
      if (+interval === 0) {
        interval = null;
      }
    }

    // if the value wasn't converted to a duration, and isn't
    // already a duration, we have a problem
    if (!_moment2.default.isDuration(interval)) {
      throw new TypeError('"' + input + '" is not a valid interval.');
    }

    this._i = interval;
  };

  /**
   * Get the interval for the buckets. If the
   * number of buckets created by the interval set
   * is larger than config:histogram:maxBars then the
   * interval will be scaled up. If the number of buckets
   * created is less than one, the interval is scaled back.
   *
   * The interval object returned is a moment.duration
   * object that has been decorated with the following
   * properties.
   *
   * interval.description: a text description of the interval.
   *   designed to be used list "field per {{ desc }}".
   *     - "minute"
   *     - "10 days"
   *     - "3 years"
   *
   * interval.expr: the elasticsearch expression that creates this
   *   interval. If the interval does not properly form an elasticsearch
   *   expression it will be forced into one.
   *
   * interval.scaled: the interval was adjusted to
   *   accomidate the maxBars setting.
   *
   * interval.scale: the numer that y-values should be
   *   multiplied by
   *
   * interval.scaleDescription: a description that reflects
   *   the values which will be produced by using the
   *   interval.scale.
   *
   *
   * @return {[type]} [description]
   */
  TimeBuckets.prototype.getInterval = function () {
    var self = this;
    var duration = self.getDuration();
    return decorateInterval(maybeScaleInterval(readInterval()));

    // either pull the interval from state or calculate the auto-interval
    function readInterval() {
      var interval = self._i;
      if (_moment2.default.isDuration(interval)) return interval;
      return calcAuto.near(config.get('histogram:barTarget'), duration);
    }

    // check to see if the interval should be scaled, and scale it if so
    function maybeScaleInterval(interval) {
      if (!self.hasBounds()) return interval;

      var maxLength = config.get('histogram:maxBars');
      var approxLen = duration / interval;
      var scaled = void 0;

      if (approxLen > maxLength) {
        scaled = calcAuto.lessThan(maxLength, duration);
      } else {
        return interval;
      }

      if (+scaled === +interval) return interval;

      decorateInterval(interval);
      return _lodash2.default.assign(scaled, {
        preScaled: interval,
        scale: interval / scaled,
        scaled: true
      });
    }

    // append some TimeBuckets specific props to the interval
    function decorateInterval(interval) {
      var esInterval = calcEsInterval(interval);
      interval.esValue = esInterval.value;
      interval.esUnit = esInterval.unit;
      interval.expression = esInterval.expression;
      interval.overflow = duration > interval ? _moment2.default.duration(interval - duration) : false;

      var prettyUnits = _moment2.default.normalizeUnits(esInterval.unit);
      if (esInterval.value === 1) {
        interval.description = prettyUnits;
      } else {
        interval.description = esInterval.value + ' ' + prettyUnits + 's';
      }

      return interval;
    }
  };

  /**
   * Get a date format string that will represent dates that
   * progress at our interval.
   *
   * Since our interval can be as small as 1ms, the default
   * date format is usually way too much. with `dateFormat:scaled`
   * users can modify how dates are formatted within series
   * produced by TimeBuckets
   *
   * @return {string}
   */
  TimeBuckets.prototype.getScaledDateFormat = function () {
    var interval = this.getInterval();
    var rules = config.get('dateFormat:scaled');

    for (var i = rules.length - 1; i >= 0; i--) {
      var rule = rules[i];
      if (!rule[0] || interval >= _moment2.default.duration(rule[0])) {
        return rule[1];
      }
    }

    return config.get('dateFormat');
  };

  TimeBuckets.prototype.getScaledDateFormatter = function () {
    var DateFieldFormat = fieldFormats.getType('date');
    return new DateFieldFormat({
      pattern: this.getScaledDateFormat()
    }, getConfig);
  };

  TimeBuckets.__cached__ = function (self) {
    var cache = {};
    var sameMoment = same(_moment2.default.isMoment);
    var sameDuration = same(_moment2.default.isDuration);

    var desc = {
      __cached__: {
        value: self
      }
    };

    var breakers = {
      setBounds: 'bounds',
      clearBounds: 'bounds',
      setInterval: 'interval'
    };

    var resources = {
      bounds: {
        setup: function setup() {
          return [self._lb, self._ub];
        },
        changes: function changes(prev) {
          return !sameMoment(prev[0], self._lb) || !sameMoment(prev[1], self._ub);
        }
      },
      interval: {
        setup: function setup() {
          return self._i;
        },
        changes: function changes(prev) {
          return !sameDuration(prev, this._i);
        }
      }
    };

    function cachedGetter(prop) {
      return {
        value: function cachedGetter() {
          if (cache.hasOwnProperty(prop)) {
            return cache[prop];
          }

          return cache[prop] = self[prop]();
        }
      };
    }

    function cacheBreaker(prop) {
      var resource = resources[breakers[prop]];
      var setup = resource.setup;
      var changes = resource.changes;
      var fn = self[prop];

      return {
        value: function cacheBreaker() {
          var prev = setup.call(self);
          var ret = fn.apply(self, arguments);

          if (changes.call(self, prev)) {
            cache = {};
          }

          return ret;
        }
      };
    }

    function same(checkType) {
      return function (a, b) {
        if (a === b) return true;
        if (checkType(a) === checkType(b)) return +a === +b;
        return false;
      };
    }

    _lodash2.default.forOwn(TimeBuckets.prototype, function (fn, prop) {
      if (prop[0] === '_') return;

      if (breakers.hasOwnProperty(prop)) {
        desc[prop] = cacheBreaker(prop);
      } else {
        desc[prop] = cachedGetter(prop);
      }
    });

    return Object.create(self, desc);
  };

  return TimeBuckets;
}

/***/ }),
/* 3100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TimeBucketsCalcAutoIntervalProvider = TimeBucketsCalcAutoIntervalProvider;

var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var d = _moment2.default.duration;
function TimeBucketsCalcAutoIntervalProvider() {
  // these are the rounding rules used by roundInterval()

  var roundingRules = [[d(500, 'ms'), d(100, 'ms')], [d(5, 'second'), d(1, 'second')], [d(7.5, 'second'), d(5, 'second')], [d(15, 'second'), d(10, 'second')], [d(45, 'second'), d(30, 'second')], [d(3, 'minute'), d(1, 'minute')], [d(9, 'minute'), d(5, 'minute')], [d(20, 'minute'), d(10, 'minute')], [d(45, 'minute'), d(30, 'minute')], [d(2, 'hour'), d(1, 'hour')], [d(6, 'hour'), d(3, 'hour')], [d(24, 'hour'), d(12, 'hour')], [d(1, 'week'), d(1, 'd')], [d(3, 'week'), d(1, 'week')], [d(1, 'year'), d(1, 'month')], [Infinity, d(1, 'year')]];

  var revRoundingRules = roundingRules.slice(0).reverse();

  function find(rules, check, last) {
    function pick(buckets, duration) {
      var target = duration / buckets;
      var lastResp = void 0;

      for (var i = 0; i < rules.length; i++) {
        var rule = rules[i];
        var resp = check(rule[0], rule[1], target);

        if (resp == null) {
          if (!last) continue;
          if (lastResp) return lastResp;
          break;
        }

        if (!last) return resp;
        lastResp = resp;
      }

      // fallback to just a number of milliseconds, ensure ms is >= 1
      var ms = Math.max(Math.floor(target), 1);
      return _moment2.default.duration(ms, 'ms');
    }

    return function (buckets, duration) {
      var interval = pick(buckets, duration);
      if (interval) return _moment2.default.duration(interval._data);
    };
  }

  return {
    near: find(revRoundingRules, function near(bound, interval, target) {
      if (bound > target) return interval;
    }, true),

    lessThan: find(revRoundingRules, function (bound, interval, target) {
      if (interval < target) return interval;
    }),

    atLeast: find(revRoundingRules, function atLeast(bound, interval, target) {
      if (interval <= target) return interval;
    })
  };
}

/***/ }),
/* 3101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TimeBucketsCalcEsIntervalProvider = TimeBucketsCalcEsIntervalProvider;

var _datemath = __webpack_require__(90);

var _datemath2 = _interopRequireDefault(_datemath);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function TimeBucketsCalcEsIntervalProvider() {

  var unitsDesc = _datemath2.default.unitsDesc;
  var largeMax = unitsDesc.indexOf('M');

  /**
   * Convert a moment.duration into an es
   * compatible expression, and provide
   * associated metadata
   *
   * @param  {moment.duration} duration
   * @return {object}
   */
  function esDuration(duration) {
    for (var i = 0; i < unitsDesc.length; i++) {
      var unit = unitsDesc[i];
      var val = duration.as(unit);
      // find a unit that rounds neatly
      if (val >= 1 && Math.floor(val) === val) {

        // if the unit is "large", like years, but
        // isn't set to 1 ES will puke. So keep going until
        // we get out of the "large" units
        if (i <= largeMax && val !== 1) {
          continue;
        }

        return {
          value: val,
          unit: unit,
          expression: val + unit
        };
      }
    }

    var ms = duration.as('ms');
    return {
      value: ms,
      unit: 'ms',
      expression: ms + 'ms'
    };
  }

  return esDuration;
}

/***/ }),
/* 3102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesBucketsCreateFilterDateHistogramProvider = AggTypesBucketsCreateFilterDateHistogramProvider;

var _moment = __webpack_require__(15);

var _moment2 = _interopRequireDefault(_moment);

var _range = __webpack_require__(117);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function AggTypesBucketsCreateFilterDateHistogramProvider() {

  return function (agg, key) {
    var start = (0, _moment2.default)(key);
    var interval = agg.buckets.getInterval();

    return (0, _range.buildRangeFilter)(agg.params.field, {
      gte: start.valueOf(),
      lt: start.add(interval).valueOf(),
      format: 'epoch_millis'
    }, agg.vis.indexPattern);
  };
}

/***/ }),
/* 3103 */
/***/ (function(module, exports) {

module.exports = "<div class=\"form-group\">\n  <label for=\"visEditorInterval{{agg.id}}\">\n    Interval\n    <kbn-info\n      ng-show=\"agg.buckets.getInterval().scaled\"\n      placement=\"right\"\n      class=\"text-warning\"\n      info=\"This interval creates {{ agg.buckets.getInterval().scale > 1 ? 'buckets that are too large' : 'too many buckets' }} to show in the selected time range, so it has been scaled to {{ agg.buckets.getInterval().description }}\">\n    </kbn-info>\n  </label>\n  <select\n    id=\"visEditorInterval{{agg.id}}\"\n    ng-model=\"agg.params.interval\"\n    ng-change=\"agg.write()\"\n    required\n    ng-options=\"opt as opt.display for opt in aggParam.options.raw | filter: optionEnabled\"\n    class=\"form-control\"\n    name=\"interval\">\n    <option value=\"\">-- select a valid interval --</option>\n  </select>\n  <input\n    aria-label=\"Custom interval\"\n    type=\"text\"\n    name=\"customInterval\"\n    ng-model=\"agg.params.customInterval\"\n    validate-date-interval\n    ng-change=\"aggForm.customInterval.$valid && agg.write()\"\n    ng-if=\"agg.params.interval.val == 'custom'\"\n    class=\"form-control\"\n    required />\n</div>\n"

/***/ }),
/* 3104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesBucketsHistogramProvider = AggTypesBucketsHistogramProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

__webpack_require__(488);

var _bucket_agg_type = __webpack_require__(106);

var _histogram = __webpack_require__(3105);

var _number_interval = __webpack_require__(3106);

var _number_interval2 = _interopRequireDefault(_number_interval);

var _min_doc_count = __webpack_require__(3107);

var _min_doc_count2 = _interopRequireDefault(_min_doc_count);

var _extended_bounds = __webpack_require__(3108);

var _extended_bounds2 = _interopRequireDefault(_extended_bounds);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function AggTypesBucketsHistogramProvider(Private, config) {
  var BucketAggType = Private(_bucket_agg_type.AggTypesBucketsBucketAggTypeProvider);
  var createFilter = Private(_histogram.AggTypesBucketsCreateFilterHistogramProvider);

  return new BucketAggType({
    name: 'histogram',
    title: 'Histogram',
    ordered: {},
    makeLabel: function makeLabel(aggConfig) {
      return aggConfig.getFieldDisplayName();
    },
    createFilter: createFilter,
    decorateAggConfig: function decorateAggConfig() {
      var autoBounds = void 0;

      return {
        setAutoBounds: {
          configurable: true,
          value: function value(newValue) {
            autoBounds = newValue;
          }
        },
        getAutoBounds: {
          configurable: true,
          value: function value() {
            return autoBounds;
          }
        }
      };
    },
    params: [{
      name: 'field',
      filterFieldTypes: 'number'
    }, {
      name: 'interval',
      editor: _number_interval2.default,
      modifyAggConfigOnSearchRequestStart: function modifyAggConfigOnSearchRequestStart(aggConfig, searchSource) {
        var field = aggConfig.getField();
        var aggBody = field.scripted ? { script: { inline: field.script, lang: field.lang } } : { field: field.name };

        return searchSource.extend().size(0).aggs({
          maxAgg: {
            max: aggBody
          },
          minAgg: {
            min: aggBody
          }
        }).fetchAsRejectablePromise().then(function (resp) {
          aggConfig.setAutoBounds({
            min: _lodash2.default.get(resp, 'aggregations.minAgg.value'),
            max: _lodash2.default.get(resp, 'aggregations.maxAgg.value')
          });
        });
      },

      write: function write(aggConfig, output) {
        var interval = parseFloat(aggConfig.params.interval);
        if (interval <= 0) {
          interval = 1;
        }

        // ensure interval does not create too many buckets and crash browser
        if (aggConfig.getAutoBounds()) {
          var range = aggConfig.getAutoBounds().max - aggConfig.getAutoBounds().min;
          var bars = range / interval;
          if (bars > config.get('histogram:maxBars')) {
            var minInterval = range / config.get('histogram:maxBars');
            // Round interval by order of magnitude to provide clean intervals
            // Always round interval up so there will always be less buckets than histogram:maxBars
            var orderOfMaginute = Math.pow(10, Math.floor(Math.log10(minInterval)));
            var roundInterval = orderOfMaginute;
            while (roundInterval < minInterval) {
              roundInterval += orderOfMaginute;
            }
            interval = roundInterval;
          }
        }

        output.params.interval = interval;
      }
    }, {
      name: 'min_doc_count',
      default: null,
      editor: _min_doc_count2.default,
      write: function write(aggConfig, output) {
        if (aggConfig.params.min_doc_count) {
          output.params.min_doc_count = 0;
        } else {
          output.params.min_doc_count = 1;
        }
      }
    }, {
      name: 'extended_bounds',
      default: {},
      editor: _extended_bounds2.default,
      write: function write(aggConfig, output) {
        var val = aggConfig.params.extended_bounds;

        if (aggConfig.params.min_doc_count && (val.min != null || val.max != null)) {
          output.params.extended_bounds = {
            min: val.min,
            max: val.max
          };
        }
      },

      // called from the editor
      shouldShow: function shouldShow(aggConfig) {
        var field = aggConfig.params.field;
        if (field && (field.type === 'number' || field.type === 'date')) {
          return aggConfig.params.min_doc_count;
        }
      }
    }]
  });
}

/***/ }),
/* 3105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesBucketsCreateFilterHistogramProvider = AggTypesBucketsCreateFilterHistogramProvider;

var _range = __webpack_require__(117);

function AggTypesBucketsCreateFilterHistogramProvider() {
  return function (aggConfig, key) {
    var value = parseInt(key, 10);

    return (0, _range.buildRangeFilter)(aggConfig.params.field, { gte: value, lt: value + aggConfig.params.interval }, aggConfig.vis.indexPattern, aggConfig.fieldFormatter()(key));
  };
}

/***/ }),
/* 3106 */
/***/ (function(module, exports) {

module.exports = "<div class=\"form-group\">\n  <label for=\"visEditorInterval{{agg.id}}\">\n    Minimum Interval\n    <kbn-info\n      placement=\"right\"\n      info=\"Interval will be automatically scaled in the event that the provided value creates more buckets than specified by Advanced Setting's histogram:maxBars\">\n    </kbn-info>\n  </label>\n  <input\n    id=\"visEditorInterval{{agg.id}}\"\n    ng-model=\"agg.params.interval\"\n    required\n    type=\"number\"\n    class=\"form-control\"\n    name=\"interval\"\n    min=\"0\"\n    input-number\n    >\n</div>\n"

/***/ }),
/* 3107 */
/***/ (function(module, exports) {

module.exports = "<div class=\"checkbox\">\n  <label>\n    <input ng-model=\"agg.params.min_doc_count\" type=\"checkbox\">\n    Show empty buckets&nbsp;\n    <kbn-info\n      info=\"Show all buckets, not only the buckets with results.\"\n      placement=\"right\">\n      </kbn-info>\n  </label>\n</div>\n"

/***/ }),
/* 3108 */
/***/ (function(module, exports) {

module.exports = "<div ng-if=\"aggParam.shouldShow(agg)\">\n  <div>\n    <label id=\"extendedBoundsLabel{{agg.id}}\">Extended Bounds</label>\n    <kbn-info info=\"Min and Max do not filter the results, but rather extend the bounds of the result set.\"></kbn-info>\n  </div>\n  <div class=\"vis-editor-agg-form-row\">\n    <div class=\"form-group\">\n      <label\n        id=\"extendedBoundsMinLabel{{agg.id}}\"\n        for=\"extendedBoundsMinInput{{agg.id}}\"\n      >\n        Min <small>(optional)</small>\n      </label>\n      <input\n        id=\"extendedBoundsMinInput{{agg.id}}\"\n        aria-labelledby=\"extendedBoundsLabel{{agg.id}} extendedBoundsMinLabel{{agg.id}}\"\n        ng-model=\"agg.params.extended_bounds.min\"\n        type=\"number\"\n        class=\"form-control\"\n        name=\"extended_bounds.min\" />\n    </div>\n    <div class=\"form-group\">\n      <label\n        id=\"extendedBoundsMaxLabel{{agg.id}}\"\n        for=\"extendedBoundsMaxInput{{agg.id}}\"\n      >\n        Max <small>(optional)</small>\n      </label>\n      <input\n        id=\"extendedBoundsMaxInput{{agg.id}}\"\n        aria-labelledby=\"extendedBoundsLabel{{agg.id}} extendedBoundsMaxLabel{{agg.id}}\"\n        ng-model=\"agg.params.extended_bounds.max\"\n        type=\"number\"\n        class=\"form-control\"\n        name=\"extended_bounds.max\" />\n    </div>\n  </div>\n</div>\n"

/***/ }),
/* 3109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesBucketsRangeProvider = AggTypesBucketsRangeProvider;

var _bucket_agg_type = __webpack_require__(106);

var _range = __webpack_require__(3110);

var _field_format = __webpack_require__(321);

var _range_key = __webpack_require__(3111);

var _ranges = __webpack_require__(3112);

var _ranges2 = _interopRequireDefault(_ranges);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function AggTypesBucketsRangeProvider(Private) {
  var BucketAggType = Private(_bucket_agg_type.AggTypesBucketsBucketAggTypeProvider);
  var createFilter = Private(_range.AggTypesBucketsCreateFilterRangeProvider);
  var RangeKey = Private(_range_key.RangeKeyProvider);

  var keyCaches = new WeakMap();
  var formats = new WeakMap();

  return new BucketAggType({
    name: 'range',
    title: 'Range',
    createFilter: createFilter,
    makeLabel: function makeLabel(aggConfig) {
      return aggConfig.getFieldDisplayName() + ' ranges';
    },
    getKey: function getKey(bucket, key, agg) {
      var keys = keyCaches.get(agg);

      if (!keys) {
        keys = new Map();
        keyCaches.set(agg, keys);
      }

      var id = RangeKey.idBucket(bucket);

      key = keys.get(id);
      if (!key) {
        key = new RangeKey(bucket);
        keys.set(id, key);
      }

      return key;
    },
    getFormat: function getFormat(agg) {
      var format = formats.get(agg);
      if (format) return format;

      var RangeFormat = _field_format.FieldFormat.from(function (range) {
        var format = agg.fieldOwnFormatter();
        return format(range.gte) + ' to ' + format(range.lt);
      });

      format = new RangeFormat();

      formats.set(agg, format);
      return format;
    },
    params: [{
      name: 'field',
      filterFieldTypes: ['number']
    }, {
      name: 'ranges',
      default: [{ from: 0, to: 1000 }, { from: 1000, to: 2000 }],
      editor: _ranges2.default,
      write: function write(aggConfig, output) {
        output.params.ranges = aggConfig.params.ranges;
        output.params.keyed = true;
      }
    }]
  });
}

/***/ }),
/* 3110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesBucketsCreateFilterRangeProvider = AggTypesBucketsCreateFilterRangeProvider;

var _range = __webpack_require__(117);

function AggTypesBucketsCreateFilterRangeProvider() {
  return function (aggConfig, key) {
    return (0, _range.buildRangeFilter)(aggConfig.params.field, key, aggConfig.vis.indexPattern, aggConfig.fieldFormatter()(key));
  };
}

/***/ }),
/* 3111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.RangeKeyProvider = RangeKeyProvider;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function RangeKeyProvider() {

  var id = Symbol('id');

  var RangeKey = function () {
    function RangeKey(bucket) {
      _classCallCheck(this, RangeKey);

      this.gte = bucket.from == null ? -Infinity : bucket.from;
      this.lt = bucket.to == null ? +Infinity : bucket.to;

      this[id] = RangeKey.idBucket(bucket);
    }

    _createClass(RangeKey, [{
      key: 'toString',
      value: function toString() {
        return this[id];
      }
    }], [{
      key: 'idBucket',
      value: function idBucket(bucket) {
        return 'from:' + bucket.from + ',to:' + bucket.to;
      }
    }]);

    return RangeKey;
  }();

  return RangeKey;
}

/***/ }),
/* 3112 */
/***/ (function(module, exports) {

module.exports = "<table class=\"vis-editor-agg-editor-ranges form-group\" ng-show=\"agg.params.ranges.length\">\n  <tr>\n    <th scope=\"col\">\n      <label id=\"visEditorRangeFrom{{agg.id}}\">From</label>\n    </th>\n    <th scope=\"col\" colspan=\"2\">\n      <label id=\"visEditorRangeTo{{agg.id}}\">To</label>\n    </th>\n  </tr>\n\n  <tr\n    ng-repeat=\"range in agg.params.ranges track by $index\">\n    <td>\n      <input\n        aria-labelledby=\"visEditorRangeFrom{{agg.id}}\"\n        ng-model=\"range.from\"\n        type=\"number\"\n        class=\"form-control\"\n        name=\"range.from\"\n        step=\"any\" />\n    </td>\n    <td>\n      <input\n        aria-labelledby=\"visEditorRangeTo{{agg.id}}\"\n        ng-model=\"range.to\"\n        type=\"number\"\n        class=\"form-control\"\n        name=\"range.to\"\n        step=\"any\" />\n    </td>\n    <td>\n      <button\n        type=\"button\"\n        aria-label=\"Remove this range\"\n        ng-click=\"agg.params.ranges.splice($index, 1)\"\n        class=\"kuiButton kuiButton--danger kuiButton--small\">\n        <i class=\"fa fa-times\"></i>\n      </button>\n    </td>\n  </tr>\n</table>\n\n<input ng-model=\"agg.params.ranges.length\" name=\"rangeLength\" required min=\"1\" type=\"number\" class=\"ng-hide\" />\n<div class=\"hintbox\" ng-show=\"aggForm.rangeLength.$invalid\">\n  <p>\n    <i class=\"fa fa-danger text-danger\"></i>\n    <strong>Required:</strong> You must specify at least one range.\n  </p>\n</div>\n\n<button\n  ng-click=\"agg.params.ranges.push({})\"\n  class=\"kuiButton kuiButton--primary kuiButton--fullWidth\"\n>\n  Add Range\n</button>\n"

/***/ }),
/* 3113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesBucketsDateRangeProvider = AggTypesBucketsDateRangeProvider;

var _date_range = __webpack_require__(961);

__webpack_require__(479);

__webpack_require__(118);

var _bucket_agg_type = __webpack_require__(106);

var _date_range2 = __webpack_require__(3114);

var _field_formats = __webpack_require__(64);

var _date_ranges = __webpack_require__(3115);

var _date_ranges2 = _interopRequireDefault(_date_ranges);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function AggTypesBucketsDateRangeProvider(Private) {
  var BucketAggType = Private(_bucket_agg_type.AggTypesBucketsBucketAggTypeProvider);
  var createFilter = Private(_date_range2.AggTypesBucketsCreateFilterDateRangeProvider);
  var fieldFormats = Private(_field_formats.RegistryFieldFormatsProvider);

  return new BucketAggType({
    name: 'date_range',
    title: 'Date Range',
    createFilter: createFilter,
    getKey: function getKey(bucket, key, agg) {
      var formatter = agg.fieldOwnFormatter('text', fieldFormats.getDefaultInstance('date'));
      return _date_range.dateRange.toString(bucket, formatter);
    },
    getFormat: function getFormat() {
      return fieldFormats.getDefaultInstance('string');
    },
    makeLabel: function makeLabel(aggConfig) {
      return aggConfig.getFieldDisplayName() + ' date ranges';
    },
    params: [{
      name: 'field',
      filterFieldTypes: 'date',
      default: function _default(agg) {
        return agg.vis.indexPattern.timeFieldName;
      }
    }, {
      name: 'ranges',
      default: [{
        from: 'now-1w/w',
        to: 'now'
      }],
      editor: _date_ranges2.default
    }]
  });
}

/***/ }),
/* 3114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesBucketsCreateFilterDateRangeProvider = AggTypesBucketsCreateFilterDateRangeProvider;

var _date_range = __webpack_require__(961);

var _range = __webpack_require__(117);

function AggTypesBucketsCreateFilterDateRangeProvider(config) {

  return function (agg, key) {
    var range = _date_range.dateRange.parse(key, config.get('dateFormat'));

    var filter = {};
    if (range.from) filter.gte = +range.from;
    if (range.to) filter.lt = +range.to;
    if (range.to && range.from) filter.format = 'epoch_millis';

    return (0, _range.buildRangeFilter)(agg.params.field, filter, agg.vis.indexPattern);
  };
}

/***/ }),
/* 3115 */
/***/ (function(module, exports) {

module.exports = "<div>\n    <table class=\"vis-editor-agg-editor-ranges form-group\" ng-show=\"agg.params.ranges.length\">\n      <tr>\n        <th scope=\"col\">\n          <label id=\"visEditorDateRangeFrom{{agg.id}}\">From</label>\n        </th>\n        <th scope=\"col\" colspan=\"2\">\n          <label id=\"visEditorDateRangeTo{{agg.id}}\">To</label>\n        </th>\n      </tr>\n\n      <tr\n        ng-repeat=\"range in agg.params.ranges track by $index\">\n        <td>\n          <input\n            aria-labelledby=\"visEditorDateRangeFrom{{agg.id}}\"\n            ng-model=\"range.from\"\n            validate-date-math\n            type=\"text\"\n            class=\"form-control\"\n            name=\"range.from\" />\n        </td>\n        <td>\n          <input\n            aria-labelledby=\"visEditorDateRangeTo{{agg.id}}\"\n            ng-model=\"range.to\"\n            validate-date-math\n            class=\"form-control\"\n            name=\"range.to\" />\n        </td>\n        <td>\n          <button\n            type=\"button\"\n            aria-label=\"Remove this range\"\n            ng-click=\"agg.params.ranges.splice($index, 1)\"\n            class=\"kuiButton kuiButton--danger kuiButton--small\">\n            <i class=\"fa fa-times\" ></i>\n          </button>\n        </td>\n      </tr>\n      <tr>\n        <td colspan=\"3\">\n          <small>\n            <a\n              class=\"kuiLink\"\n              documentation-href=\"date.dateMath\"\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              Accepted date formats\n            </a>\n          </small>\n        </td>\n      </tr>\n    </table>\n\n    <input ng-model=\"agg.params.ranges.length\" name=\"rangeLength\" required min=\"1\" type=\"number\" class=\"ng-hide\" />\n    <div class=\"hintbox\" ng-show=\"aggForm.rangeLength.$invalid\">\n      <p>\n        <i class=\"fa fa-danger text-danger\"></i>\n        <strong>Required:</strong> You must specify at least one date range.\n      </p>\n    </div>\n\n    <button\n      ng-click=\"agg.params.ranges.push({})\"\n      class=\"kuiButton kuiButton--primary kuiButton--fullWidth\"\n    >\n      Add Range\n    </button>\n  </div>\n</div>\n"

/***/ }),
/* 3116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesBucketsIpRangeProvider = AggTypesBucketsIpRangeProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

__webpack_require__(480);

__webpack_require__(912);

var _bucket_agg_type = __webpack_require__(106);

var _ip_range = __webpack_require__(3117);

var _ip_ranges = __webpack_require__(3118);

var _ip_ranges2 = _interopRequireDefault(_ip_ranges);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function AggTypesBucketsIpRangeProvider(Private) {
  var BucketAggType = Private(_bucket_agg_type.AggTypesBucketsBucketAggTypeProvider);
  var createFilter = Private(_ip_range.AggTypesBucketsCreateFilterIpRangeProvider);

  return new BucketAggType({
    name: 'ip_range',
    title: 'IPv4 Range',
    createFilter: createFilter,
    getKey: function getKey(bucket, key) {
      if (key) return key;
      var from = _lodash2.default.get(bucket, 'from', '-Infinity');
      var to = _lodash2.default.get(bucket, 'to', 'Infinity');
      return from + ' to ' + to;
    },
    makeLabel: function makeLabel(aggConfig) {
      return aggConfig.getFieldDisplayName() + ' IP ranges';
    },
    params: [{
      name: 'field',
      filterFieldTypes: 'ip'
    }, {
      name: 'ipRangeType',
      default: 'fromTo',
      write: _lodash2.default.noop
    }, {
      name: 'ranges',
      default: {
        fromTo: [{ from: '0.0.0.0', to: '127.255.255.255' }, { from: '128.0.0.0', to: '191.255.255.255' }],
        mask: [{ mask: '0.0.0.0/1' }, { mask: '128.0.0.0/2' }]
      },
      editor: _ip_ranges2.default,
      write: function write(aggConfig, output) {
        var ipRangeType = aggConfig.params.ipRangeType;
        var ranges = aggConfig.params.ranges[ipRangeType];

        if (ipRangeType === 'fromTo') {
          ranges = _lodash2.default.map(ranges, function (range) {
            return _lodash2.default.omit(range, _lodash2.default.isNull);
          });
        }

        output.params.ranges = ranges;
      }
    }]
  });
}

/***/ }),
/* 3117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.AggTypesBucketsCreateFilterIpRangeProvider = AggTypesBucketsCreateFilterIpRangeProvider;

var _cidr_mask = __webpack_require__(913);

var _range = __webpack_require__(117);

function AggTypesBucketsCreateFilterIpRangeProvider() {
  return function (aggConfig, key) {
    var range = void 0;
    if (aggConfig.params.ipRangeType === 'mask') {
      range = new _cidr_mask.CidrMask(key).getRange();
    } else {
      var _key$split = key.split(/\s+to\s+/),
          _key$split2 = _slicedToArray(_key$split, 2),
          from = _key$split2[0],
          to = _key$split2[1];

      range = {
        from: from === '-Infinity' ? -Infinity : from,
        to: to === 'Infinity' ? Infinity : to
      };
    }

    return (0, _range.buildRangeFilter)(aggConfig.params.field, { gte: range.from, lte: range.to }, aggConfig.vis.indexPattern);
  };
}

/***/ }),
/* 3118 */
/***/ (function(module, exports) {

module.exports = "<div>\n\n  <p>\n    <button type=\"button\" class=\"kuiButton kuiButton--secondary\" ng-show=\"agg.params.ipRangeType == 'mask'\" ng-click=\"agg.params.ipRangeType = 'fromTo'\">Use From/To</button>\n    <button type=\"button\" class=\"kuiButton kuiButton--secondary\" ng-show=\"agg.params.ipRangeType != 'mask'\" ng-click=\"agg.params.ipRangeType = 'mask'\">Use CIDR Masks</button>\n  </p>\n\n  <div class=\"euiSpacer euiSpacer--s\"></div>\n\n  <div ng-show=\"agg.params.ipRangeType != 'mask'\">\n    <table class=\"vis-editor-agg-editor-ranges form-group\" ng-show=\"agg.params.ranges.fromTo.length\">\n      <tr>\n        <th scope=\"col\">\n          <label id=\"visEditorIpRangeFromLabel{{agg.id}}\">From</label>\n        </th>\n        <th scope=\"col\" colspan=\"2\">\n          <label id=\"visEditorIpRangeToLabel{{agg.id}}\">To</label>\n        </th>\n      </tr>\n\n      <tr\n        ng-repeat=\"range in agg.params.ranges.fromTo track by $index\">\n        <td>\n          <input\n            aria-labelledby=\"visEditorIpRangeFromLabel{{agg.id}}\"\n            validate-ip\n            ng-model=\"range.from\"\n            type=\"text\"\n            class=\"form-control\"\n            name=\"range.from\" />\n        </td>\n        <td>\n          <input\n            aria-labelledby=\"visEditorIpRangeToLabel{{agg.id}}\"\n            validate-ip\n            ng-model=\"range.to\"\n            class=\"form-control\"\n            name=\"range.to\" />\n        </td>\n        <td>\n          <button\n            type=\"button\"\n            aria-label=\"Remove this range\"\n            ng-click=\"agg.params.ranges.fromTo.splice($index, 1)\"\n            class=\"kuiButton kuiButton--danger kuiButton--small\">\n            <i class=\"fa fa-times\" ></i>\n          </button>\n        </td>\n      </tr>\n    </table>\n\n    <input ng-if=\"agg.params.ipRangeType != 'mask'\" ng-model=\"agg.params.ranges.fromTo.length\" name=\"rangeLength\" required min=\"1\" type=\"number\" class=\"ng-hide\" />\n    <div class=\"hintbox\" ng-show=\"aggForm.rangeLength.$invalid\">\n      <p>\n        <i class=\"fa fa-danger text-danger\"></i>\n        <strong>Required:</strong> You must specify at least one IP range.\n      </p>\n    </div>\n\n    <button\n      ng-click=\"agg.params.ranges.fromTo.push({})\"\n      class=\"kuiButton kuiButton--primary kuiButton--fullWidth\"\n    >\n      Add Range\n    </button>\n  </div>\n\n  <div ng-show=\"agg.params.ipRangeType == 'mask'\">\n    <table class=\"vis-editor-agg-editor-ranges form-group\" ng-show=\"agg.params.ranges.mask.length\">\n      <tr>\n        <th scope=\"col\">\n          <label id=\"visEditorIpRangeCidrLabel{{agg.id}}\">CIDR Mask</label>\n        </th>\n      </tr>\n\n      <tr\n        ng-repeat=\"range in agg.params.ranges.mask track by $index\">\n        <td>\n          <input\n            aria-labelledby=\"visEditorIpRangeCidrLabel{{agg.id}}\"\n            validate-cidr-mask\n            ng-model=\"range.mask\"\n            type=\"text\"\n            class=\"form-control\"\n            name=\"range.from\" />\n        </td>\n        <td>\n          <button\n            type=\"button\"\n            aria-label=\"Remove this CIDR mask\"\n            ng-click=\"agg.params.ranges.mask.splice($index, 1)\"\n            class=\"kuiButton kuiButton--danger kuiButton--small\">\n            <i class=\"fa fa-times\" ></i>\n          </button>\n        </td>\n      </tr>\n    </table>\n\n    <input ng-if=\"agg.params.ipRangeType == 'mask'\" ng-model=\"agg.params.ranges.mask.length\" name=\"rangeLength\" required min=\"1\" type=\"number\" class=\"ng-hide\" />\n    <div class=\"hintbox\" ng-show=\"aggForm.rangeLength.$invalid\">\n      <p>\n        <i class=\"fa fa-danger text-danger\"></i>\n        <strong>Required:</strong> You must specify at least one IP range.\n      </p>\n    </div>\n\n    <button\n      ng-click=\"agg.params.ranges.mask.push({})\"\n      class=\"kuiButton kuiButton--primary  kuiButton--fullWidth\"\n    >\n      Add Range\n    </button>\n  </div>\n</div>\n"

/***/ }),
/* 3119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.AggTypesBucketsTermsProvider = AggTypesBucketsTermsProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _bucket_agg_type = __webpack_require__(106);

var _agg_config = __webpack_require__(105);

var _schemas = __webpack_require__(56);

var _terms = __webpack_require__(962);

var _order_agg = __webpack_require__(3120);

var _order_agg2 = _interopRequireDefault(_order_agg);

var _order_and_size = __webpack_require__(963);

var _order_and_size2 = _interopRequireDefault(_order_and_size);

var _route_based_notifier = __webpack_require__(3121);

var _terms_other_bucket_helper = __webpack_require__(3122);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function AggTypesBucketsTermsProvider(Private) {
  var _this = this;

  var BucketAggType = Private(_bucket_agg_type.AggTypesBucketsBucketAggTypeProvider);
  var AggConfig = Private(_agg_config.VisAggConfigProvider);
  var Schemas = Private(_schemas.VisSchemasProvider);
  var createFilter = Private(_terms.AggTypesBucketsCreateFilterTermsProvider);
  var routeBasedNotifier = Private(_route_based_notifier.RouteBasedNotifierProvider);

  var _Private = Private(_terms_other_bucket_helper.OtherBucketHelperProvider),
      buildOtherBucketAgg = _Private.buildOtherBucketAgg,
      mergeOtherBucketAggResponse = _Private.mergeOtherBucketAggResponse,
      updateMissingBucket = _Private.updateMissingBucket;

  var aggFilter = ['!top_hits', '!percentiles', '!median', '!std_dev', '!derivative', '!moving_avg', '!serial_diff', '!cumulative_sum', '!avg_bucket', '!max_bucket', '!min_bucket', '!sum_bucket'];

  var orderAggSchema = new Schemas([{
    group: 'none',
    name: 'orderAgg',
    title: 'Order Agg',
    hideCustomLabel: true,
    aggFilter: aggFilter
  }]).all[0];

  function isNotType(type) {
    return function (agg) {
      var field = agg.params.field;
      return !field || field.type !== type;
    };
  }

  var migrateIncludeExcludeFormat = {
    serialize: function serialize(value) {
      if (!value || _lodash2.default.isString(value)) return value;else return value.pattern;
    },
    write: function write(aggConfig, output) {
      var value = aggConfig.params[this.name];
      if (_lodash2.default.isObject(value)) {
        output.params[this.name] = value.pattern;
      } else if (value) {
        output.params[this.name] = value;
      }
    }
  };

  return new BucketAggType({
    name: 'terms',
    title: 'Terms',
    makeLabel: function makeLabel(agg) {
      var params = agg.params;
      return agg.getFieldDisplayName() + ': ' + params.order.display;
    },
    createFilter: createFilter,
    postFlightRequest: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(resp, aggConfigs, aggConfig, nestedSearchSource) {
        var filterAgg, response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!aggConfig.params.otherBucket) {
                  _context.next = 7;
                  break;
                }

                filterAgg = buildOtherBucketAgg(aggConfigs, aggConfig, resp);

                nestedSearchSource.set('aggs', filterAgg);
                _context.next = 5;
                return nestedSearchSource.fetchAsRejectablePromise();

              case 5:
                response = _context.sent;

                resp = mergeOtherBucketAggResponse(aggConfigs, resp, response, aggConfig, filterAgg());

              case 7:
                if (aggConfig.params.missingBucket) {
                  resp = updateMissingBucket(resp, aggConfigs, aggConfig);
                }
                return _context.abrupt('return', resp);

              case 9:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, _this);
      }));

      function postFlightRequest(_x, _x2, _x3, _x4) {
        return _ref.apply(this, arguments);
      }

      return postFlightRequest;
    }(),
    params: [{
      name: 'field',
      filterFieldTypes: ['number', 'boolean', 'date', 'ip', 'string']
    }, {
      name: 'otherBucket',
      default: false,
      write: _lodash2.default.noop
    }, {
      name: 'otherBucketLabel',
      default: 'Other',
      write: _lodash2.default.noop
    }, {
      name: 'missingBucket',
      default: false,
      write: _lodash2.default.noop
    }, {
      name: 'missingBucketLabel',
      default: 'Missing',
      write: _lodash2.default.noop
    }, _extends({
      name: 'exclude',
      type: 'string',
      advanced: true,
      disabled: isNotType('string')
    }, migrateIncludeExcludeFormat), _extends({
      name: 'include',
      type: 'string',
      advanced: true,
      disabled: isNotType('string')
    }, migrateIncludeExcludeFormat), {
      name: 'size',
      default: 5
    }, {
      name: 'orderAgg',
      type: AggConfig,
      default: null,
      editor: _order_agg2.default,
      serialize: function serialize(orderAgg) {
        return orderAgg.toJSON();
      },
      deserialize: function deserialize(state, agg) {
        return this.makeOrderAgg(agg, state);
      },
      makeOrderAgg: function makeOrderAgg(termsAgg, state) {
        state = state || {};
        state.schema = orderAggSchema;
        var orderAgg = new AggConfig(termsAgg.vis, state);
        orderAgg.id = termsAgg.id + '-orderAgg';
        return orderAgg;
      },
      controller: function controller($scope) {
        $scope.safeMakeLabel = function (agg) {
          try {
            return agg.makeLabel();
          } catch (e) {
            return '- agg not valid -';
          }
        };

        var INIT = {}; // flag to know when prevOrderBy has changed
        var prevOrderBy = INIT;

        $scope.$watch('responseValueAggs', updateOrderAgg);
        $scope.$watch('agg.params.orderBy', updateOrderAgg);

        // Returns true if the agg is not compatible with the terms bucket
        $scope.rejectAgg = function rejectAgg(agg) {
          return aggFilter.includes('!' + agg.type.name);
        };

        function updateOrderAgg() {
          // abort until we get the responseValueAggs
          if (!$scope.responseValueAggs) return;
          var agg = $scope.agg;
          var params = agg.params;
          var orderBy = params.orderBy;
          var paramDef = agg.type.params.byName.orderAgg;

          // setup the initial value of orderBy
          if (!orderBy && prevOrderBy === INIT) {
            var respAgg = (0, _lodash2.default)($scope.responseValueAggs).filter(function (agg) {
              return !$scope.rejectAgg(agg);
            }).first();
            if (!respAgg) {
              respAgg = { id: '_term' };
            }
            params.orderBy = respAgg.id;
            return;
          }

          // track the previous value
          prevOrderBy = orderBy;

          // we aren't creating a custom aggConfig
          if (!orderBy || orderBy !== 'custom') {
            params.orderAgg = null;
            // ensure that orderBy is set to a valid agg
            var _respAgg = (0, _lodash2.default)($scope.responseValueAggs).filter(function (agg) {
              return !$scope.rejectAgg(agg);
            }).find({ id: orderBy });
            if (!_respAgg) {
              params.orderBy = '_term';
            }
            return;
          }

          params.orderAgg = params.orderAgg || paramDef.makeOrderAgg(agg);
        }
      },
      write: function write(agg, output) {
        var vis = agg.vis;
        var dir = agg.params.order.val;
        var order = output.params.order = {};

        var orderAgg = agg.params.orderAgg || vis.aggs.getResponseAggById(agg.params.orderBy);

        // TODO: This works around an Elasticsearch bug the always casts terms agg scripts to strings
        // thus causing issues with filtering. This probably causes other issues since float might not
        // be able to contain the number on the elasticsearch side
        if (output.params.script) {
          output.params.valueType = agg.getField().type === 'number' ? 'float' : agg.getField().type;
        }

        if (agg.params.missingBucket) {
          output.params.missing = '__missing__';
        }

        if (!orderAgg) {
          order[agg.params.orderBy || '_count'] = dir;
          return;
        }

        if (orderAgg.type.name === 'count') {
          if (dir === 'asc') {
            routeBasedNotifier.warning('Sorting in Ascending order by Count in Terms aggregations is deprecated');
          }
          order._count = dir;
          return;
        }

        var orderAggId = orderAgg.id;
        if (orderAgg.parentId) {
          orderAgg = vis.aggs.byId[orderAgg.parentId];
        }

        output.subAggs = (output.subAggs || []).concat(orderAgg);
        order[orderAggId] = dir;
      }
    }, {
      name: 'order',
      type: 'optioned',
      default: 'desc',
      editor: _order_and_size2.default,
      options: [{ display: 'Descending', val: 'desc' }, { display: 'Ascending', val: 'asc' }],
      write: _lodash2.default.noop // prevent default write, it's handled by orderAgg
    }, {
      name: 'orderBy',
      write: _lodash2.default.noop // prevent default write, it's handled by orderAgg
    }]
  });
}

/***/ }),
/* 3120 */
/***/ (function(module, exports) {

module.exports = "<div ng-controller=\"aggParam.controller\">\n  <div class=\"form-group\">\n    <label for=\"visEditorOrder{{agg.id}}\">Order By</label>\n    <select\n      id=\"visEditorOrder{{agg.id}}\"\n      name=\"orderBy\"\n      ng-model=\"agg.params.orderBy\"\n      required\n      class=\"form-control\">\n      <option\n        ng-repeat=\"respAgg in responseValueAggs track by respAgg.id\"\n        value=\"{{respAgg.id}}\"\n        ng-disabled=\"rejectAgg(respAgg)\"\n        ng-selected=\"agg.params.orderBy === respAgg.id\">\n        metric: {{safeMakeLabel(respAgg)}}\n      </option>\n      <option value=\"custom\" ng-selected=\"agg.params.orderBy === 'custom'\">\n        Custom Metric\n      </option>\n       <option value=\"_term\" ng-selected=\"agg.params.orderBy === '_term'\">\n        Term\n      </option>\n    </select>\n  </div>\n  <div ng-show=\"agg.params.orderAgg\" class=\"vis-editor-agg-order-agg\">\n    <vis-editor-agg-params\n      agg=\"agg.params.orderAgg\"\n      ng-if=\"agg.params.orderAgg\"\n      group-name=\"'metrics'\">\n    </vis-editor-agg-params>\n  </div>\n</div>\n"

/***/ }),
/* 3121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RouteBasedNotifierProvider = RouteBasedNotifierProvider;

var _lodash = __webpack_require__(1);

var _notifier = __webpack_require__(43);

/*
 * Caches notification attempts so each one is only actually sent to the
 * notifier service once per route.
 */
function RouteBasedNotifierProvider($rootScope) {
  var notifier = new _notifier.Notifier();

  var notifications = {
    warnings: []
  };

  // empty the tracked notifications whenever the route changes so we can start
  // fresh for the next route cycle
  $rootScope.$on('$routeChangeSuccess', function () {
    notifications = (0, _lodash.mapValues)(notifications, function () {
      return [];
    });
  });

  // Executes the given notify function if the message has not been seen in
  // this route cycle
  function executeIfNew(messages, message, notifyFn) {
    if ((0, _lodash.includes)(messages, message)) {
      return;
    }

    messages.push(message);
    notifyFn.call(notifier, message);
  }

  return {
    /**
     * Notify a given warning once in this route cycle
     * @param {string} message
     */
    warning: function warning(message) {
      executeIfNew(notifications.warnings, message, notifier.warning);
    }
  };
}

/***/ }),
/* 3122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OtherBucketHelperProvider = undefined;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _agg_config = __webpack_require__(105);

var _phrases = __webpack_require__(482);

var _exists = __webpack_require__(785);

var _from_filters = __webpack_require__(773);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * walks the aggregation DSL and returns DSL starting at aggregation with id of startFromAggId
 * @param aggNestedDsl: aggregation config DSL (top level)
 * @param startFromId: id of an aggregation from where we want to get the nested DSL
 */
var getNestedAggDSL = function getNestedAggDSL(aggNestedDsl, startFromAggId) {
  if (aggNestedDsl[startFromAggId]) return aggNestedDsl[startFromAggId];
  return getNestedAggDSL(_lodash2.default.values(aggNestedDsl)[0].aggs, startFromAggId);
};

/**
 * returns buckets from response for a specific other bucket
 * @param aggConfigs: configuration for the aggregations
 * @param response: response from elasticsearch
 * @param aggWithOtherBucket: AggConfig of the aggregation with other bucket enabled
 * @param key: key from the other bucket request for a specific other bucket
 */
var getAggResultBuckets = function getAggResultBuckets(aggConfigs, response, aggWithOtherBucket, key) {
  var keyParts = key.split('-');
  var responseAgg = response;

  var _loop = function _loop(i) {
    if (keyParts[i]) {
      var agg = _lodash2.default.values(responseAgg)[0];
      var aggKey = _lodash2.default.keys(responseAgg)[0];
      var aggConfig = _lodash2.default.find(aggConfigs, function (agg) {
        return agg.id === aggKey;
      });
      var bucket = _lodash2.default.find(agg.buckets, function (bucket, bucketObjKey) {
        var bucketKey = aggConfig.getKey(bucket, Number.isInteger(bucketObjKey) ? null : bucketObjKey).toString();
        return bucketKey === keyParts[i];
      });
      if (bucket) {
        responseAgg = bucket;
      }
    }
  };

  for (var i in keyParts) {
    _loop(i);
  }
  if (responseAgg[aggWithOtherBucket.id]) return responseAgg[aggWithOtherBucket.id].buckets;
  return [];
};

/**
 * gets all the missing buckets in our response for a specific aggregation id
 * @param responseAggs: array of aggregations from response
 * @param aggId: id of the aggregation with missing bucket
 */
var getAggConfigResultMissingBuckets = function getAggConfigResultMissingBuckets(responseAggs, aggId) {
  var missingKey = '__missing__';
  var resultBuckets = [];
  if (responseAggs[aggId]) {
    var matchingBucket = responseAggs[aggId].buckets.find(function (bucket) {
      return bucket.key === missingKey;
    });
    if (matchingBucket) resultBuckets.push(matchingBucket);
    return resultBuckets;
  }
  _lodash2.default.each(responseAggs, function (agg) {
    if (agg.buckets) {
      _lodash2.default.each(agg.buckets, function (bucket) {
        resultBuckets = [].concat(_toConsumableArray(resultBuckets), _toConsumableArray(getAggConfigResultMissingBuckets(bucket, aggId, missingKey)));
      });
    }
  });

  return resultBuckets;
};

/**
 * gets all the terms that are NOT in the other bucket
 * @param requestAgg: an aggregation we are looking at
 * @param key: the key for this specific other bucket
 * @param otherAgg: AggConfig of the aggregation with other bucket
 */
var getOtherAggTerms = function getOtherAggTerms(requestAgg, key, otherAgg) {
  return requestAgg['other-filter'].filters.filters[key].bool.must_not.filter(function (filter) {
    return filter.match_phrase && filter.match_phrase[otherAgg.params.field.name];
  }).map(function (filter) {
    return filter.match_phrase[otherAgg.params.field.name].query;
  });
};

var OtherBucketHelperProvider = exports.OtherBucketHelperProvider = function OtherBucketHelperProvider(Private) {
  var AggConfig = Private(_agg_config.VisAggConfigProvider);

  var buildOtherBucketAgg = function buildOtherBucketAgg(aggConfigs, aggWithOtherBucket, response) {
    var bucketAggs = aggConfigs.filter(function (agg) {
      return agg.type.type === 'buckets';
    });
    var index = bucketAggs.findIndex(function (agg) {
      return agg.id === aggWithOtherBucket.id;
    });
    var aggs = aggConfigs.toDsl();
    var indexPattern = aggWithOtherBucket.params.field.indexPattern;

    // create filters aggregation
    var filterAgg = new AggConfig(aggConfigs[index].vis, {
      type: 'filters',
      id: 'other',
      schema: {
        group: 'buckets'
      }
    });

    // nest all the child aggregations of aggWithOtherBucket
    var resultAgg = {
      aggs: getNestedAggDSL(aggs, aggWithOtherBucket.id).aggs,
      filters: filterAgg.toDsl()
    };

    // create filters for all parent aggregation buckets
    var walkBucketTree = function walkBucketTree(aggIndex, aggs, aggId, filters, key) {
      var agg = aggs[aggId];
      var newAggIndex = aggIndex + 1;
      var newAgg = bucketAggs[newAggIndex];
      var currentAgg = bucketAggs[aggIndex];
      if (aggIndex < index) {
        _lodash2.default.each(agg.buckets, function (bucket, bucketObjKey) {
          var bucketKey = currentAgg.getKey(bucket, Number.isInteger(bucketObjKey) ? null : bucketObjKey);
          var filter = _lodash2.default.cloneDeep(bucket.filter) || currentAgg.createFilter(bucketKey);
          var newFilters = [].concat(_toConsumableArray(filters), [filter]);
          walkBucketTree(newAggIndex, bucket, newAgg.id, newFilters, key + '-' + bucketKey.toString());
        });
        return;
      }

      if (!aggWithOtherBucket.params.missingBucket || agg.buckets.some(function (bucket) {
        return bucket.key === '__missing__';
      })) {
        filters.push((0, _exists.buildExistsFilter)(aggWithOtherBucket.params.field, aggWithOtherBucket.params.field.indexPattern));
      }

      // create not filters for all the buckets
      _lodash2.default.each(agg.buckets, function (bucket) {
        if (bucket.key === '__missing__') return;
        var filter = currentAgg.createFilter(bucket.key);
        filter.meta.negate = true;
        filters.push(filter);
      });

      resultAgg.filters.filters[key] = {
        bool: (0, _from_filters.buildQueryFromFilters)(filters, _lodash2.default.noop, indexPattern)
      };
    };
    walkBucketTree(0, response.aggregations, bucketAggs[0].id, [], '');

    return function () {
      return {
        'other-filter': resultAgg
      };
    };
  };

  var mergeOtherBucketAggResponse = function mergeOtherBucketAggResponse(aggsConfig, response, otherResponse, otherAgg, requestAgg) {
    var updatedResponse = _lodash2.default.cloneDeep(response);
    _lodash2.default.each(otherResponse.aggregations['other-filter'].buckets, function (bucket, key) {
      if (!bucket.doc_count) return;
      var bucketKey = key.replace(/^-/, '');
      var aggResultBuckets = getAggResultBuckets(aggsConfig, updatedResponse.aggregations, otherAgg, bucketKey);
      var requestFilterTerms = getOtherAggTerms(requestAgg, key, otherAgg);

      var phraseFilter = (0, _phrases.buildPhrasesFilter)(otherAgg.params.field, requestFilterTerms, otherAgg.params.field.indexPattern);
      phraseFilter.meta.negate = true;
      bucket.filters = [phraseFilter];
      bucket.key = otherAgg.params.otherBucketLabel;

      if (aggResultBuckets.some(function (bucket) {
        return bucket.key === '__missing__';
      })) {
        bucket.filters.push((0, _exists.buildExistsFilter)(otherAgg.params.field, otherAgg.params.field.indexPattern));
      }

      aggResultBuckets.push(bucket);
    });
    return updatedResponse;
  };

  var updateMissingBucket = function updateMissingBucket(response, aggConfigs, agg) {
    var updatedResponse = _lodash2.default.cloneDeep(response);
    var aggResultBuckets = getAggConfigResultMissingBuckets(updatedResponse.aggregations, agg.id);
    aggResultBuckets.forEach(function (bucket) {
      bucket.key = agg.params.missingBucketLabel;
      var existsFilter = (0, _exists.buildExistsFilter)(agg.params.field, agg.params.field.indexPattern);
      existsFilter.meta.negate = true;
      bucket.filters = [existsFilter];
    });
    return updatedResponse;
  };

  return { buildOtherBucketAgg: buildOtherBucketAgg, mergeOtherBucketAggResponse: mergeOtherBucketAggResponse, updateMissingBucket: updateMissingBucket };
};

/***/ }),
/* 3123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesBucketsFilterProvider = AggTypesBucketsFilterProvider;

var _bucket_agg_type = __webpack_require__(106);

function AggTypesBucketsFilterProvider(Private) {
  var BucketAggType = Private(_bucket_agg_type.AggTypesBucketsBucketAggTypeProvider);

  return new BucketAggType({
    name: 'filter',
    title: 'Filter',
    params: [{
      name: 'geo_bounding_box'
    }]
  });
}

/***/ }),
/* 3124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesBucketsFiltersProvider = AggTypesBucketsFiltersProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _angular = __webpack_require__(16);

var _angular2 = _interopRequireDefault(_angular);

var _lucene_string_to_dsl = __webpack_require__(474);

var _bucket_agg_type = __webpack_require__(106);

var _filters = __webpack_require__(3125);

var _decorate_query = __webpack_require__(769);

var _filters2 = __webpack_require__(3126);

var _filters3 = _interopRequireDefault(_filters2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function AggTypesBucketsFiltersProvider(Private, Notifier) {
  var BucketAggType = Private(_bucket_agg_type.AggTypesBucketsBucketAggTypeProvider);
  var createFilter = Private(_filters.AggTypesBucketsCreateFilterFiltersProvider);
  var decorateQuery = Private(_decorate_query.DecorateQueryProvider);
  var notif = new Notifier({ location: 'Filters Agg' });

  return new BucketAggType({
    name: 'filters',
    title: 'Filters',
    createFilter: createFilter,
    customLabels: false,
    params: [{
      name: 'filters',
      editor: _filters3.default,
      default: [{ input: {}, label: '' }],
      write: function write(aggConfig, output) {
        var inFilters = aggConfig.params.filters;
        if (!_lodash2.default.size(inFilters)) return;

        var outFilters = _lodash2.default.transform(inFilters, function (filters, filter) {
          var input = _lodash2.default.cloneDeep(filter.input);
          if (!input) return notif.log('malformed filter agg params, missing "input" query');

          var query = input.query = (0, _lucene_string_to_dsl.luceneStringToDsl)(input.query);
          if (!query) return notif.log('malformed filter agg params, missing "query" on input');

          decorateQuery(query);

          var matchAllLabel = filter.input.query === '' && _lodash2.default.has(query, 'match_all') ? '*' : '';
          var label = filter.label || matchAllLabel || _lodash2.default.get(query, 'query_string.query') || _angular2.default.toJson(query);
          filters[label] = input;
        }, {});

        if (!_lodash2.default.size(outFilters)) return;

        var params = output.params || (output.params = {});
        params.filters = outFilters;
      }
    }]
  });
}

/***/ }),
/* 3125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesBucketsCreateFilterFiltersProvider = AggTypesBucketsCreateFilterFiltersProvider;

var _query = __webpack_require__(786);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function AggTypesBucketsCreateFilterFiltersProvider() {
  return function (aggConfig, key) {
    // have the aggConfig write agg dsl params
    var dslFilters = _lodash2.default.get(aggConfig.toDsl(), 'filters.filters');
    var filter = dslFilters[key];

    if (filter) {
      return (0, _query.buildQueryFilter)(filter.query, aggConfig.vis.indexPattern.id);
    }
  };
}

/***/ }),
/* 3126 */
/***/ (function(module, exports) {

module.exports = "<div class=\"form-group\">\n  <div ng-repeat=\"filter in agg.params.filters\">\n    <div class=\"vis-editor-agg-header\">\n      <label for=\"visEditorFilterInput{{agg.id}}\">\n          Filter {{$index + 1}}\n          <span ng-if=\"filter.label\">- {{ filter.label }}</span>\n      </label>\n\n      <div class=\"kuiButtonGroup kuiButtonGroup--united\">\n        <button\n          ng-click=\"showConfig = !showConfig\"\n          type=\"button\"\n          aria-label=\"Toggle filter label\"\n          aria-expanded=\"{{!!showConfig}}\"\n          aria-controls=\"visEditorFilterLabel{{agg.id}}\"\n          class=\"kuiButton kuiButton--basic kuiButton--small\">\n          <i class=\"fa fa-tag\"></i>\n        </button>\n        <button\n          type=\"button\"\n          aria-label=\"Remove this filter\"\n          ng-click=\"agg.params.filters.splice($index, 1)\"\n          class=\"kuiButton kuiButton--danger kuiButton--small\">\n          <i class=\"fa fa-times\"></i>\n        </button>\n      </div>\n    </div>\n\n    <div class=\"form-group\">\n      <input\n        id=\"visEditorFilterInput{{agg.id}}\"\n        parse-query\n        ng-model=\"filter.input.query\"\n        type=\"text\"\n        class=\"form-control\"\n        name=\"filter{{$index}}\">\n    </div>\n\n    <div class=\"form-group\" ng-show=\"showConfig\" id=\"visEditorFilterLabel{{agg.id}}\">\n      <label for=\"visEditorFilterLabelInput{{agg.id}}\">Filter {{$index + 1}} label</label>\n      <input\n        id=\"visEditorFilterLabelInput{{agg.id}}\"\n        ng-model=\"filter.label\"\n        placeholder=\"Label\"\n        type=\"text\"\n        class=\"form-control\"\n        name=\"label{{$index}}\">\n    </div>\n  </div>\n</div>\n\n<input ng-model=\"agg.params.filters.length\" name=\"filterLength\" required min=\"1\" type=\"number\" class=\"ng-hide\" />\n<div class=\"hintbox\" ng-show=\"aggForm.filterLength.$invalid\">\n  <p>\n    <i class=\"fa fa-danger text-danger\"></i>\n    <strong>Required:</strong> You must specify at least one filter.\n  </p>\n</div>\n\n<button\n  click-focus=\"'filter'+(agg.params.filters.length-1)\"\n  ng-click=\"agg.params.filters.push({input:{}})\"\n  class=\"kuiButton kuiButton--primary kuiButton--fullWidth\"\n>\n  Add Filter\n</button>\n\n<div class=\"euiSpacer euiSpacer--s\"></div>\n"

/***/ }),
/* 3127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesBucketsSignificantTermsProvider = AggTypesBucketsSignificantTermsProvider;

var _bucket_agg_type = __webpack_require__(106);

var _terms = __webpack_require__(962);

var _order_and_size = __webpack_require__(963);

var _order_and_size2 = _interopRequireDefault(_order_and_size);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function AggTypesBucketsSignificantTermsProvider(Private) {
  var BucketAggType = Private(_bucket_agg_type.AggTypesBucketsBucketAggTypeProvider);
  var createFilter = Private(_terms.AggTypesBucketsCreateFilterTermsProvider);

  return new BucketAggType({
    name: 'significant_terms',
    title: 'Significant Terms',
    makeLabel: function makeLabel(aggConfig) {
      return 'Top ' + aggConfig.params.size + ' unusual terms in ' + aggConfig.getFieldDisplayName();
    },
    createFilter: createFilter,
    params: [{
      name: 'field',
      scriptable: false,
      filterFieldTypes: 'string'
    }, {
      name: 'size',
      editor: _order_and_size2.default
    }, {
      name: 'exclude',
      type: 'regex',
      advanced: true
    }, {
      name: 'include',
      type: 'regex',
      advanced: true
    }]
  });
}

/***/ }),
/* 3128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesBucketsGeoHashProvider = AggTypesBucketsGeoHashProvider;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _bucket_agg_type = __webpack_require__(106);

var _agg_config = __webpack_require__(105);

var _precision = __webpack_require__(3129);

var _precision2 = _interopRequireDefault(_precision);

var _decode_geo_hash = __webpack_require__(539);

var _geo_utils = __webpack_require__(3130);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function AggTypesBucketsGeoHashProvider(Private, config) {
  var BucketAggType = Private(_bucket_agg_type.AggTypesBucketsBucketAggTypeProvider);
  var AggConfig = Private(_agg_config.VisAggConfigProvider);

  var defaultPrecision = 2;
  var maxPrecision = parseInt(config.get('visualization:tileMap:maxPrecision'), 10) || 12;
  /**
   * Map Leaflet zoom levels to geohash precision levels.
   * The size of a geohash column-width on the map should be at least `minGeohashPixels` pixels wide.
   */
  var zoomPrecision = {};
  var minGeohashPixels = 16;
  for (var zoom = 0; zoom <= 21; zoom += 1) {
    var worldPixels = 256 * Math.pow(2, zoom);
    zoomPrecision[zoom] = 1;
    for (var precision = 2; precision <= maxPrecision; precision += 1) {
      var columns = (0, _decode_geo_hash.geohashColumns)(precision);
      if (worldPixels / columns >= minGeohashPixels) {
        zoomPrecision[zoom] = precision;
      } else {
        break;
      }
    }
  }

  function getPrecision(precision) {

    precision = parseInt(precision, 10);

    if (isNaN(precision)) {
      precision = defaultPrecision;
    }

    if (precision > maxPrecision) {
      return maxPrecision;
    }

    return precision;
  }

  function getMapZoom(vis) {
    if (vis.hasUiState() && parseInt(vis.uiStateVal('mapZoom')) >= 0) {
      return parseInt(vis.uiStateVal('mapZoom'));
    }

    return vis.params.mapZoom;
  }

  function isOutsideCollar(bounds, collar) {
    return bounds && collar && !(0, _geo_utils.geoContains)(collar, bounds);
  }

  return new BucketAggType({
    name: 'geohash_grid',
    title: 'Geohash',
    params: [{
      name: 'field',
      filterFieldTypes: 'geo_point'
    }, {
      name: 'autoPrecision',
      default: true,
      write: _lodash2.default.noop
    }, {
      name: 'isFilteredByCollar',
      default: true,
      write: _lodash2.default.noop
    }, {
      name: 'useGeocentroid',
      default: true,
      write: _lodash2.default.noop
    }, {
      name: 'mapZoom',
      write: _lodash2.default.noop
    }, {
      name: 'mapCenter',
      write: _lodash2.default.noop
    }, {
      name: 'precision',
      editor: _precision2.default,
      default: defaultPrecision,
      deserialize: getPrecision,
      controller: function controller() {},
      write: function write(aggConfig, output) {
        var vis = aggConfig.vis;
        var currZoom = getMapZoom(vis);
        var autoPrecisionVal = zoomPrecision[currZoom];
        output.params.precision = aggConfig.params.autoPrecision ? autoPrecisionVal : getPrecision(aggConfig.params.precision);
      }
    }],
    getRequestAggs: function getRequestAggs(agg) {
      var aggs = [];

      if (agg.params.isFilteredByCollar && agg.getField()) {
        var vis = agg.vis;
        var mapBounds = vis.sessionState.mapBounds;
        var mapZoom = getMapZoom(vis);
        if (mapBounds) {
          var lastMapCollar = vis.sessionState.mapCollar;
          var mapCollar = void 0;
          if (!lastMapCollar || lastMapCollar.zoom !== mapZoom || isOutsideCollar(mapBounds, lastMapCollar)) {
            mapCollar = (0, _geo_utils.scaleBounds)(mapBounds);
            mapCollar.zoom = mapZoom;
            vis.sessionState.mapCollar = mapCollar;
          } else {
            mapCollar = lastMapCollar;
          }
          var boundingBox = {};
          boundingBox[agg.getField().name] = {
            top_left: mapCollar.top_left,
            bottom_right: mapCollar.bottom_right
          };
          aggs.push(new AggConfig(agg.vis, {
            type: 'filter',
            id: 'filter_agg',
            enabled: true,
            params: {
              geo_bounding_box: boundingBox
            },
            schema: {
              group: 'buckets'
            }
          }));
        }
      }

      aggs.push(agg);

      if (agg.params.useGeocentroid) {
        aggs.push(new AggConfig(agg.vis, {
          type: 'geo_centroid',
          enabled: true,
          params: {
            field: agg.getField()
          },
          schema: 'metric'
        }));
      }

      return aggs;
    }
  });
}

/***/ }),
/* 3129 */
/***/ (function(module, exports) {

module.exports = "<div class=\"vis-editor-agg-form-row\" ng-controller=\"agg.type.params.byName.precision.controller\">\n  <div ng-if=\"!agg.params.autoPrecision\" class=\"form-group\">\n    <label for=\"visEditorMapPrecision{{agg.id}}\">Precision</label>\n    <div class=\"vis-editor-agg-form-row\">\n      <input\n        id=\"visEditorMapPrecision{{agg.id}}\"\n        name=\"precision\"\n        ng-model=\"agg.params.precision\"\n        required\n        class=\"form-control\"\n        type=\"range\"\n        min=\"1\"\n        max=\"{{config.get('visualization:tileMap:maxPrecision')}}\"\n        >\n      <div class=\"form-group vis-editor-agg-form-value\">\n        {{agg.params.precision}}\n      </div>\n    </div>\n  </div>\n</div>\n\n<div class=\"vis-option-item indented\">\n  <label>\n    <input type=\"checkbox\"\n    name=\"autoPrecision\"\n    ng-model=\"agg.params.autoPrecision\">\n    Change precision on map zoom\n  </label>\n</div>\n\n<div class=\"vis-option-item indented\">\n  <label>\n    <input type=\"checkbox\"\n           name=\"useGeocentroid\"\n           ng-model=\"agg.params.useGeocentroid\">\n    Place markers off grid (use geocentroid)\n  </label>\n</div>\n\n<div class=\"vis-option-item indented\">\n  <label>\n    <input type=\"checkbox\"\n           data-test-subj=\"isFilteredByCollarCheckbox\"\n           name=\"isFilteredByCollar\"\n           ng-model=\"agg.params.isFilteredByCollar\">\n    Only request data around extent of map <kbn-info info=\"Apply geo_bounding_box filter aggregation to narrow the subject area to the map view box with collar.\"></kbn-info>\n  </label>\n</div>\n"

/***/ }),
/* 3130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.geoContains = geoContains;
exports.scaleBounds = scaleBounds;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function geoContains(collar, bounds) {
  //test if bounds top_left is outside collar
  if (bounds.top_left.lat > collar.top_left.lat || bounds.top_left.lon < collar.top_left.lon) {
    return false;
  }

  //test if bounds bottom_right is outside collar
  if (bounds.bottom_right.lat < collar.bottom_right.lat || bounds.bottom_right.lon > collar.bottom_right.lon) {
    return false;
  }

  //both corners are inside collar so collar contains bounds
  return true;
}

function scaleBounds(bounds) {
  if (!bounds) return;

  var scale = .5; // scale bounds by 50%

  var topLeft = bounds.top_left;
  var bottomRight = bounds.bottom_right;
  var latDiff = _lodash2.default.round(Math.abs(topLeft.lat - bottomRight.lat), 5);
  var lonDiff = _lodash2.default.round(Math.abs(bottomRight.lon - topLeft.lon), 5);
  //map height can be zero when vis is first created
  if (latDiff === 0) latDiff = lonDiff;

  var latDelta = latDiff * scale;
  var topLeftLat = _lodash2.default.round(topLeft.lat, 5) + latDelta;
  if (topLeftLat > 90) topLeftLat = 90;
  var bottomRightLat = _lodash2.default.round(bottomRight.lat, 5) - latDelta;
  if (bottomRightLat < -90) bottomRightLat = -90;
  var lonDelta = lonDiff * scale;
  var topLeftLon = _lodash2.default.round(topLeft.lon, 5) - lonDelta;
  if (topLeftLon < -180) topLeftLon = -180;
  var bottomRightLon = _lodash2.default.round(bottomRight.lon, 5) + lonDelta;
  if (bottomRightLon > 180) bottomRightLon = 180;

  return {
    'top_left': { lat: topLeftLat, lon: topLeftLon },
    'bottom_right': { lat: bottomRightLat, lon: bottomRightLon }
  };
}

/***/ }),
/* 3131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesMetricsBucketSumProvider = AggTypesMetricsBucketSumProvider;

var _metric_agg_type = __webpack_require__(40);

var _make_nested_label = __webpack_require__(139);

var _sibling_pipeline_agg_helper = __webpack_require__(360);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function AggTypesMetricsBucketSumProvider(Private) {
  var MetricAggType = Private(_metric_agg_type.AggTypesMetricsMetricAggTypeProvider);
  var siblingPipelineHelper = Private(_sibling_pipeline_agg_helper.SiblingPipelineAggHelperProvider);

  return new MetricAggType({
    name: 'sum_bucket',
    title: 'Sum Bucket',
    makeLabel: function makeLabel(agg) {
      return (0, _make_nested_label.makeNestedLabel)(agg, 'overall sum');
    },
    subtype: siblingPipelineHelper.subtype,
    params: [].concat(_toConsumableArray(siblingPipelineHelper.params())),
    getFormat: siblingPipelineHelper.getFormat
  });
}

/***/ }),
/* 3132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.siblingPipelineAggController = undefined;

var _safe_make_label = __webpack_require__(959);

var siblingPipelineAggController = function siblingPipelineAggController(type) {
  return function ($scope) {

    $scope.aggType = type;
    $scope.aggTitle = type === 'customMetric' ? 'Metric' : 'Bucket';
    $scope.aggGroup = type === 'customMetric' ? 'metrics' : 'buckets';
    $scope.safeMakeLabel = _safe_make_label.safeMakeLabel;

    function updateAgg() {
      var agg = $scope.agg;
      var params = agg.params;
      var paramDef = agg.type.params.byName[type];

      params[type] = params[type] || paramDef.makeAgg(agg);
    }

    updateAgg();
  };
};

exports.siblingPipelineAggController = siblingPipelineAggController;

/***/ }),
/* 3133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var siblingPipelineAggWritter = function siblingPipelineAggWritter(agg, output) {
  if (!agg.params.customMetric) return;

  var metricAgg = agg.params.customMetric;
  var bucketAgg = agg.params.customBucket;

  // if a bucket is selected, we must add this agg as a sibling to it, and add a metric to that bucket (or select one of its)
  if (metricAgg.type.name !== 'count') {
    bucketAgg.subAggs = (output.subAggs || []).concat(metricAgg);
    output.params.buckets_path = bucketAgg.id + '>' + metricAgg.id;
  } else {
    output.params.buckets_path = bucketAgg.id + '>_count';
  }

  output.parentAggs = (output.parentAggs || []).concat(bucketAgg);
};

exports.siblingPipelineAggWritter = siblingPipelineAggWritter;

/***/ }),
/* 3134 */
/***/ (function(module, exports) {

module.exports = "<div ng-controller=\"aggParam.controller\">\n  <div class=\"form-group\" ng-if=\"agg.params[aggType]\">\n    <label>{{aggTitle}}</label>\n    <div class=\"vis-editor-agg-order-agg\">\n      <ng-form name=\"{{aggType}}Form\">\n        <vis-editor-agg-params\n          agg=\"agg.params[aggType]\"\n          group-name=\"'{{aggGroup}}'\">\n        </vis-editor-agg-params>\n      </ng-form>\n    </div>\n  </div>\n\n</div>\n"

/***/ }),
/* 3135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesMetricsBucketAvgProvider = AggTypesMetricsBucketAvgProvider;

var _lodash = __webpack_require__(1);

var _metric_agg_type = __webpack_require__(40);

var _make_nested_label = __webpack_require__(139);

var _sibling_pipeline_agg_helper = __webpack_require__(360);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function AggTypesMetricsBucketAvgProvider(Private) {
  var MetricAggType = Private(_metric_agg_type.AggTypesMetricsMetricAggTypeProvider);
  var siblingPipelineHelper = Private(_sibling_pipeline_agg_helper.SiblingPipelineAggHelperProvider);

  return new MetricAggType({
    name: 'avg_bucket',
    title: 'Average Bucket',
    makeLabel: function makeLabel(agg) {
      return (0, _make_nested_label.makeNestedLabel)(agg, 'overall average');
    },
    subtype: siblingPipelineHelper.subtype,
    params: [].concat(_toConsumableArray(siblingPipelineHelper.params())),
    getFormat: siblingPipelineHelper.getFormat,
    getValue: function getValue(agg, bucket) {
      var customMetric = agg.params.customMetric;
      var scaleMetrics = customMetric.type && customMetric.type.isScalable();

      var value = bucket[agg.id] && bucket[agg.id].value;
      if (scaleMetrics) {
        var aggInfo = agg.params.customBucket.write();
        value *= (0, _lodash.get)(aggInfo, 'bucketInterval.scale', 1);
      }
      return value;
    }
  });
}

/***/ }),
/* 3136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesMetricsBucketMinProvider = AggTypesMetricsBucketMinProvider;

var _metric_agg_type = __webpack_require__(40);

var _make_nested_label = __webpack_require__(139);

var _sibling_pipeline_agg_helper = __webpack_require__(360);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function AggTypesMetricsBucketMinProvider(Private) {
  var MetricAggType = Private(_metric_agg_type.AggTypesMetricsMetricAggTypeProvider);
  var siblingPipelineHelper = Private(_sibling_pipeline_agg_helper.SiblingPipelineAggHelperProvider);

  return new MetricAggType({
    name: 'min_bucket',
    title: 'Min Bucket',
    makeLabel: function makeLabel(agg) {
      return (0, _make_nested_label.makeNestedLabel)(agg, 'overall min');
    },
    subtype: siblingPipelineHelper.subtype,
    params: [].concat(_toConsumableArray(siblingPipelineHelper.params())),
    getFormat: siblingPipelineHelper.getFormat
  });
}

/***/ }),
/* 3137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AggTypesMetricsBucketMaxProvider = AggTypesMetricsBucketMaxProvider;

var _metric_agg_type = __webpack_require__(40);

var _make_nested_label = __webpack_require__(139);

var _sibling_pipeline_agg_helper = __webpack_require__(360);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function AggTypesMetricsBucketMaxProvider(Private) {
  var MetricAggType = Private(_metric_agg_type.AggTypesMetricsMetricAggTypeProvider);
  var siblingPipelineHelper = Private(_sibling_pipeline_agg_helper.SiblingPipelineAggHelperProvider);

  return new MetricAggType({
    name: 'max_bucket',
    title: 'Max Bucket',
    makeLabel: function makeLabel(agg) {
      return (0, _make_nested_label.makeNestedLabel)(agg, 'overall max');
    },
    subtype: siblingPipelineHelper.subtype,
    params: [].concat(_toConsumableArray(siblingPipelineHelper.params())),
    getFormat: siblingPipelineHelper.getFormat
  });
}

/***/ }),
/* 3138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

// TODO: this should be moved to vis_update_state
// Currently the migration takes place in Vis when calling setCurrentState.
// It should rather convert the raw saved object before starting to instantiate
// any JavaScript classes from it.
var updateVisualizationConfig = function updateVisualizationConfig(stateConfig, config) {
  if (!stateConfig || stateConfig.seriesParams) return;
  if (!['line', 'area', 'histogram'].includes(config.type)) return;

  // update value axis options
  var isUserDefinedYAxis = config.setYExtents;
  var mode = ['stacked', 'overlap'].includes(config.mode) ? 'normal' : config.mode || 'normal';
  config.valueAxes[0].scale = _extends({}, config.valueAxes[0].scale, {
    type: config.scale || 'linear',
    setYExtents: config.setYExtents || false,
    defaultYExtents: config.defaultYExtents || false,
    min: isUserDefinedYAxis ? config.yAxis.min : undefined,
    max: isUserDefinedYAxis ? config.yAxis.max : undefined,
    mode: mode
  });

  // update series options
  var interpolate = config.smoothLines ? 'cardinal' : config.interpolate;
  var stacked = ['stacked', 'percentage', 'wiggle', 'silhouette'].includes(config.mode);
  config.seriesParams[0] = _extends({}, config.seriesParams[0], {
    type: config.type || 'line',
    mode: stacked ? 'stacked' : 'normal',
    interpolate: interpolate,
    drawLinesBetweenPoints: config.drawLinesBetweenPoints,
    showCircles: config.showCircles,
    radiusRatio: config.radiusRatio
  });
};

exports.updateVisualizationConfig = updateVisualizationConfig;

/***/ }),
/* 3139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _query_manager = __webpack_require__(3140);

Object.defineProperty(exports, 'queryManagerFactory', {
  enumerable: true,
  get: function get() {
    return _query_manager.queryManagerFactory;
  }
});

/***/ }),
/* 3140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.queryManagerFactory = queryManagerFactory;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function queryManagerFactory(getState) {

  function getQuery() {
    return _extends({}, getState().query);
  }

  function setQuery(newQuery) {
    var state = getState();
    state.query = newQuery;

    if (_lodash2.default.isFunction(state.save)) {
      state.save();
    }
  }

  return {
    getQuery: getQuery,
    setQuery: setQuery
  };
}

/***/ }),
/* 3141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateOldState = undefined;

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This function is responsible for updating old visStates - the actual saved object
 * object - into the format, that will be required by the current Kibana version.
 * This method will be executed for each saved vis object, that will be loaded.
 * It will return the updated version as Kibana would expect it. It does not modify
 * the passed state.
 */
var updateOldState = exports.updateOldState = function updateOldState(visState) {
  if (!visState) return visState;
  var newState = _lodash2.default.cloneDeep(visState);

  if (visState.type === 'gauge' && visState.fontSize) {
    delete newState.fontSize;
    _lodash2.default.set(newState, 'gauge.style.fontSize', visState.fontSize);
  }

  // update old metric to the new one
  if (['gauge', 'metric'].includes(visState.type) && _lodash2.default.get(visState.params, 'gauge.gaugeType', null) === 'Metric') {
    newState.type = 'metric';
    newState.params.addLegend = false;
    newState.params.type = 'metric';
    newState.params.metric = newState.params.gauge;
    delete newState.params.gauge;
    delete newState.params.metric.gaugeType;
    delete newState.params.metric.gaugeStyle;
    delete newState.params.metric.backStyle;
    delete newState.params.metric.scale;
    delete newState.params.metric.type;
    delete newState.params.metric.orientation;
    delete newState.params.metric.verticalSplit;
    delete newState.params.metric.autoExtend;
    newState.params.metric.metricColorMode = newState.params.metric.gaugeColorMode;
    delete newState.params.metric.gaugeColorMode;
  }

  return newState;
};

/***/ }),
/* 3142 */,
/* 3143 */,
/* 3144 */,
/* 3145 */
/***/ (function(module, exports) {

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

(function() {

var ACE_NAMESPACE = "consoleAce";

var global = (function() {
    return this;
})();


if (!ACE_NAMESPACE && typeof requirejs !== "undefined")
    return;


var _define = function(module, deps, payload) {
    if (typeof module !== 'string') {
        if (_define.original)
            _define.original.apply(window, arguments);
        else {
            console.error('dropping module because define wasn\'t a string.');
            console.trace();
        }
        return;
    }

    if (arguments.length == 2)
        payload = deps;

    if (!_define.modules) {
        _define.modules = {};
        _define.payloads = {};
    }
    
    _define.payloads[module] = payload;
    _define.modules[module] = null;
};
var _require = function(parentId, module, callback) {
    if (Object.prototype.toString.call(module) === "[object Array]") {
        var params = [];
        for (var i = 0, l = module.length; i < l; ++i) {
            var dep = lookup(parentId, module[i]);
            if (!dep && _require.original)
                return _require.original.apply(window, arguments);
            params.push(dep);
        }
        if (callback) {
            callback.apply(null, params);
        }
    }
    else if (typeof module === 'string') {
        var payload = lookup(parentId, module);
        if (!payload && _require.original)
            return _require.original.apply(window, arguments);

        if (callback) {
            callback();
        }

        return payload;
    }
    else {
        if (_require.original)
            return _require.original.apply(window, arguments);
    }
};

var normalizeModule = function(parentId, moduleName) {
    if (moduleName.indexOf("!") !== -1) {
        var chunks = moduleName.split("!");
        return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
    }
    if (moduleName.charAt(0) == ".") {
        var base = parentId.split("/").slice(0, -1).join("/");
        moduleName = base + "/" + moduleName;

        while(moduleName.indexOf(".") !== -1 && previous != moduleName) {
            var previous = moduleName;
            moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
        }
    }

    return moduleName;
};
var lookup = function(parentId, moduleName) {

    moduleName = normalizeModule(parentId, moduleName);

    var module = _define.modules[moduleName];
    if (!module) {
        module = _define.payloads[moduleName];
        if (typeof module === 'function') {
            var exports = {};
            var mod = {
                id: moduleName,
                uri: '',
                exports: exports,
                packaged: true
            };

            var req = function(module, callback) {
                return _require(moduleName, module, callback);
            };

            var returnValue = module(req, exports, mod);
            exports = returnValue || mod.exports;
            _define.modules[moduleName] = exports;
            delete _define.payloads[moduleName];
        }
        module = _define.modules[moduleName] = exports || module;
    }
    return module;
};

function exportAce(ns) {
    var require = function(module, callback) {
        return _require("", module, callback);
    };    

    var root = global;
    if (ns) {
        if (!global[ns])
            global[ns] = {};
        root = global[ns];
    }

    if (!root.define || !root.define.packaged) {
        _define.original = root.define;
        root.define = _define;
        root.define.packaged = true;
    }

    if (!root.require || !root.require.packaged) {
        _require.original = root.require;
        root.require = require;
        root.require.packaged = true;
    }
}

exportAce(ACE_NAMESPACE);

})();

consoleAce.define('ace/ace', ['require', 'exports', 'module' , 'ace/lib/fixoldbrowsers', 'ace/lib/dom', 'ace/lib/event', 'ace/editor', 'ace/edit_session', 'ace/undomanager', 'ace/virtual_renderer', 'ace/multi_select', 'ace/worker/worker_client', 'ace/keyboard/hash_handler', 'ace/placeholder', 'ace/mode/folding/fold_mode', 'ace/theme/textmate', 'ace/ext/error_marker', 'ace/config'], function(require, exports, module) {


require("./lib/fixoldbrowsers");

var dom = require("./lib/dom");
var event = require("./lib/event");

var Editor = require("./editor").Editor;
var EditSession = require("./edit_session").EditSession;
var UndoManager = require("./undomanager").UndoManager;
var Renderer = require("./virtual_renderer").VirtualRenderer;
var MultiSelect = require("./multi_select").MultiSelect;
require("./worker/worker_client");
require("./keyboard/hash_handler");
require("./placeholder");
require("./mode/folding/fold_mode");
require("./theme/textmate");
require("./ext/error_marker");

exports.config = require("./config");
exports.require = require;
exports.edit = function(el) {
    if (typeof(el) == "string") {
        var _id = el;
        var el = document.getElementById(_id);
        if (!el)
            throw new Error("ace.edit can't find div #" + _id);
    }

    if (el.env && el.env.editor instanceof Editor)
        return el.env.editor;

    var doc = exports.createEditSession(dom.getInnerText(el));
    el.innerHTML = '';

    var editor = new Editor(new Renderer(el));
    new MultiSelect(editor);
    editor.setSession(doc);

    var env = {
        document: doc,
        editor: editor,
        onResize: editor.resize.bind(editor, null)
    };
    event.addListener(window, "resize", env.onResize);
    editor.on("destroy", function() {
        event.removeListener(window, "resize", env.onResize);
    });
    el.env = editor.env = env;
    return editor;
};
exports.createEditSession = function(text, mode) {
    var doc = new EditSession(text, mode);
    doc.setUndoManager(new UndoManager());
    return doc;
}
exports.EditSession = EditSession;
exports.UndoManager = UndoManager;
});

consoleAce.define('ace/lib/fixoldbrowsers', ['require', 'exports', 'module' , 'ace/lib/regexp', 'ace/lib/es5-shim'], function(require, exports, module) {


require("./regexp");
require("./es5-shim");

});
 
consoleAce.define('ace/lib/regexp', ['require', 'exports', 'module' ], function(require, exports, module) {

    var real = {
            exec: RegExp.prototype.exec,
            test: RegExp.prototype.test,
            match: String.prototype.match,
            replace: String.prototype.replace,
            split: String.prototype.split
        },
        compliantExecNpcg = real.exec.call(/()??/, "")[1] === undefined, // check `exec` handling of nonparticipating capturing groups
        compliantLastIndexIncrement = function () {
            var x = /^/g;
            real.test.call(x, "");
            return !x.lastIndex;
        }();

    if (compliantLastIndexIncrement && compliantExecNpcg)
        return;
    RegExp.prototype.exec = function (str) {
        var match = real.exec.apply(this, arguments),
            name, r2;
        if ( typeof(str) == 'string' && match) {
            if (!compliantExecNpcg && match.length > 1 && indexOf(match, "") > -1) {
                r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), "g", ""));
                real.replace.call(str.slice(match.index), r2, function () {
                    for (var i = 1; i < arguments.length - 2; i++) {
                        if (arguments[i] === undefined)
                            match[i] = undefined;
                    }
                });
            }
            if (this._xregexp && this._xregexp.captureNames) {
                for (var i = 1; i < match.length; i++) {
                    name = this._xregexp.captureNames[i - 1];
                    if (name)
                       match[name] = match[i];
                }
            }
            if (!compliantLastIndexIncrement && this.global && !match[0].length && (this.lastIndex > match.index))
                this.lastIndex--;
        }
        return match;
    };
    if (!compliantLastIndexIncrement) {
        RegExp.prototype.test = function (str) {
            var match = real.exec.call(this, str);
            if (match && this.global && !match[0].length && (this.lastIndex > match.index))
                this.lastIndex--;
            return !!match;
        };
    }

    function getNativeFlags (regex) {
        return (regex.global     ? "g" : "") +
               (regex.ignoreCase ? "i" : "") +
               (regex.multiline  ? "m" : "") +
               (regex.extended   ? "x" : "") + // Proposed for ES4; included in AS3
               (regex.sticky     ? "y" : "");
    }

    function indexOf (array, item, from) {
        if (Array.prototype.indexOf) // Use the native array method if available
            return array.indexOf(item, from);
        for (var i = from || 0; i < array.length; i++) {
            if (array[i] === item)
                return i;
        }
        return -1;
    }

});

consoleAce.define('ace/lib/es5-shim', ['require', 'exports', 'module' ], function(require, exports, module) {

function Empty() {}

if (!Function.prototype.bind) {
    Function.prototype.bind = function bind(that) { // .length is 1
        var target = this;
        if (typeof target != "function") {
            throw new TypeError("Function.prototype.bind called on incompatible " + target);
        }
        var args = slice.call(arguments, 1); // for normal call
        var bound = function () {

            if (this instanceof bound) {

                var result = target.apply(
                    this,
                    args.concat(slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                return target.apply(
                    that,
                    args.concat(slice.call(arguments))
                );

            }

        };
        if(target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            Empty.prototype = null;
        }
        return bound;
    };
}
var call = Function.prototype.call;
var prototypeOfArray = Array.prototype;
var prototypeOfObject = Object.prototype;
var slice = prototypeOfArray.slice;
var _toString = call.bind(prototypeOfObject.toString);
var owns = call.bind(prototypeOfObject.hasOwnProperty);
var defineGetter;
var defineSetter;
var lookupGetter;
var lookupSetter;
var supportsAccessors;
if ((supportsAccessors = owns(prototypeOfObject, "__defineGetter__"))) {
    defineGetter = call.bind(prototypeOfObject.__defineGetter__);
    defineSetter = call.bind(prototypeOfObject.__defineSetter__);
    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
}
if ([1,2].splice(0).length != 2) {
    if(function() { // test IE < 9 to splice bug - see issue #138
        function makeArray(l) {
            var a = new Array(l+2);
            a[0] = a[1] = 0;
            return a;
        }
        var array = [], lengthBefore;
        
        array.splice.apply(array, makeArray(20));
        array.splice.apply(array, makeArray(26));

        lengthBefore = array.length; //46
        array.splice(5, 0, "XXX"); // add one element

        lengthBefore + 1 == array.length

        if (lengthBefore + 1 == array.length) {
            return true;// has right splice implementation without bugs
        }
    }()) {//IE 6/7
        var array_splice = Array.prototype.splice;
        Array.prototype.splice = function(start, deleteCount) {
            if (!arguments.length) {
                return [];
            } else {
                return array_splice.apply(this, [
                    start === void 0 ? 0 : start,
                    deleteCount === void 0 ? (this.length - start) : deleteCount
                ].concat(slice.call(arguments, 2)))
            }
        };
    } else {//IE8
        Array.prototype.splice = function(pos, removeCount){
            var length = this.length;
            if (pos > 0) {
                if (pos > length)
                    pos = length;
            } else if (pos == void 0) {
                pos = 0;
            } else if (pos < 0) {
                pos = Math.max(length + pos, 0);
            }

            if (!(pos+removeCount < length))
                removeCount = length - pos;

            var removed = this.slice(pos, pos+removeCount);
            var insert = slice.call(arguments, 2);
            var add = insert.length;            
            if (pos === length) {
                if (add) {
                    this.push.apply(this, insert);
                }
            } else {
                var remove = Math.min(removeCount, length - pos);
                var tailOldPos = pos + remove;
                var tailNewPos = tailOldPos + add - remove;
                var tailCount = length - tailOldPos;
                var lengthAfterRemove = length - remove;

                if (tailNewPos < tailOldPos) { // case A
                    for (var i = 0; i < tailCount; ++i) {
                        this[tailNewPos+i] = this[tailOldPos+i];
                    }
                } else if (tailNewPos > tailOldPos) { // case B
                    for (i = tailCount; i--; ) {
                        this[tailNewPos+i] = this[tailOldPos+i];
                    }
                } // else, add == remove (nothing to do)

                if (add && pos === lengthAfterRemove) {
                    this.length = lengthAfterRemove; // truncate array
                    this.push.apply(this, insert);
                } else {
                    this.length = lengthAfterRemove + add; // reserves space
                    for (i = 0; i < add; ++i) {
                        this[pos+i] = insert[i];
                    }
                }
            }
            return removed;
        };
    }
}
if (!Array.isArray) {
    Array.isArray = function isArray(obj) {
        return _toString(obj) == "[object Array]";
    };
}
var boxedString = Object("a"),
    splitString = boxedString[0] != "a" || !(0 in boxedString);

if (!Array.prototype.forEach) {
    Array.prototype.forEach = function forEach(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(); // TODO message
        }

        while (++i < length) {
            if (i in self) {
                fun.call(thisp, self[i], i, object);
            }
        }
    };
}
if (!Array.prototype.map) {
    Array.prototype.map = function map(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0,
            result = Array(length),
            thisp = arguments[1];
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self)
                result[i] = fun.call(thisp, self[i], i, object);
        }
        return result;
    };
}
if (!Array.prototype.filter) {
    Array.prototype.filter = function filter(fun /*, thisp */) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                    object,
            length = self.length >>> 0,
            result = [],
            value,
            thisp = arguments[1];
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self) {
                value = self[i];
                if (fun.call(thisp, value, i, object)) {
                    result.push(value);
                }
            }
        }
        return result;
    };
}
if (!Array.prototype.every) {
    Array.prototype.every = function every(fun /*, thisp */) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0,
            thisp = arguments[1];
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self && !fun.call(thisp, self[i], i, object)) {
                return false;
            }
        }
        return true;
    };
}
if (!Array.prototype.some) {
    Array.prototype.some = function some(fun /*, thisp */) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0,
            thisp = arguments[1];
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self && fun.call(thisp, self[i], i, object)) {
                return true;
            }
        }
        return false;
    };
}
if (!Array.prototype.reduce) {
    Array.prototype.reduce = function reduce(fun /*, initial*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0;
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }
        if (!length && arguments.length == 1) {
            throw new TypeError("reduce of empty array with no initial value");
        }

        var i = 0;
        var result;
        if (arguments.length >= 2) {
            result = arguments[1];
        } else {
            do {
                if (i in self) {
                    result = self[i++];
                    break;
                }
                if (++i >= length) {
                    throw new TypeError("reduce of empty array with no initial value");
                }
            } while (true);
        }

        for (; i < length; i++) {
            if (i in self) {
                result = fun.call(void 0, result, self[i], i, object);
            }
        }

        return result;
    };
}
if (!Array.prototype.reduceRight) {
    Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0;
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }
        if (!length && arguments.length == 1) {
            throw new TypeError("reduceRight of empty array with no initial value");
        }

        var result, i = length - 1;
        if (arguments.length >= 2) {
            result = arguments[1];
        } else {
            do {
                if (i in self) {
                    result = self[i--];
                    break;
                }
                if (--i < 0) {
                    throw new TypeError("reduceRight of empty array with no initial value");
                }
            } while (true);
        }

        do {
            if (i in this) {
                result = fun.call(void 0, result, self[i], i, object);
            }
        } while (i--);

        return result;
    };
}
if (!Array.prototype.indexOf || ([0, 1].indexOf(1, 2) != -1)) {
    Array.prototype.indexOf = function indexOf(sought /*, fromIndex */ ) {
        var self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    };
}
if (!Array.prototype.lastIndexOf || ([0, 1].lastIndexOf(0, -3) != -1)) {
    Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {
        var self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }
        var i = length - 1;
        if (arguments.length > 1) {
            i = Math.min(i, toInteger(arguments[1]));
        }
        i = i >= 0 ? i : length - Math.abs(i);
        for (; i >= 0; i--) {
            if (i in self && sought === self[i]) {
                return i;
            }
        }
        return -1;
    };
}
if (!Object.getPrototypeOf) {
    Object.getPrototypeOf = function getPrototypeOf(object) {
        return object.__proto__ || (
            object.constructor ?
            object.constructor.prototype :
            prototypeOfObject
        );
    };
}
if (!Object.getOwnPropertyDescriptor) {
    var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a " +
                         "non-object: ";
    Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
        if ((typeof object != "object" && typeof object != "function") || object === null)
            throw new TypeError(ERR_NON_OBJECT + object);
        if (!owns(object, property))
            return;

        var descriptor, getter, setter;
        descriptor =  { enumerable: true, configurable: true };
        if (supportsAccessors) {
            var prototype = object.__proto__;
            object.__proto__ = prototypeOfObject;

            var getter = lookupGetter(object, property);
            var setter = lookupSetter(object, property);
            object.__proto__ = prototype;

            if (getter || setter) {
                if (getter) descriptor.get = getter;
                if (setter) descriptor.set = setter;
                return descriptor;
            }
        }
        descriptor.value = object[property];
        return descriptor;
    };
}
if (!Object.getOwnPropertyNames) {
    Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
        return Object.keys(object);
    };
}
if (!Object.create) {
    var createEmpty;
    if (Object.prototype.__proto__ === null) {
        createEmpty = function () {
            return { "__proto__": null };
        };
    } else {
        createEmpty = function () {
            var empty = {};
            for (var i in empty)
                empty[i] = null;
            empty.constructor =
            empty.hasOwnProperty =
            empty.propertyIsEnumerable =
            empty.isPrototypeOf =
            empty.toLocaleString =
            empty.toString =
            empty.valueOf =
            empty.__proto__ = null;
            return empty;
        }
    }

    Object.create = function create(prototype, properties) {
        var object;
        if (prototype === null) {
            object = createEmpty();
        } else {
            if (typeof prototype != "object")
                throw new TypeError("typeof prototype["+(typeof prototype)+"] != 'object'");
            var Type = function () {};
            Type.prototype = prototype;
            object = new Type();
            object.__proto__ = prototype;
        }
        if (properties !== void 0)
            Object.defineProperties(object, properties);
        return object;
    };
}

function doesDefinePropertyWork(object) {
    try {
        Object.defineProperty(object, "sentinel", {});
        return "sentinel" in object;
    } catch (exception) {
    }
}
if (Object.defineProperty) {
    var definePropertyWorksOnObject = doesDefinePropertyWork({});
    var definePropertyWorksOnDom = typeof document == "undefined" ||
        doesDefinePropertyWork(document.createElement("div"));
    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
        var definePropertyFallback = Object.defineProperty;
    }
}

if (!Object.defineProperty || definePropertyFallback) {
    var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
    var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: "
    var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " +
                                      "on this javascript engine";

    Object.defineProperty = function defineProperty(object, property, descriptor) {
        if ((typeof object != "object" && typeof object != "function") || object === null)
            throw new TypeError(ERR_NON_OBJECT_TARGET + object);
        if ((typeof descriptor != "object" && typeof descriptor != "function") || descriptor === null)
            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
        if (definePropertyFallback) {
            try {
                return definePropertyFallback.call(Object, object, property, descriptor);
            } catch (exception) {
            }
        }
        if (owns(descriptor, "value")) {

            if (supportsAccessors && (lookupGetter(object, property) ||
                                      lookupSetter(object, property)))
            {
                var prototype = object.__proto__;
                object.__proto__ = prototypeOfObject;
                delete object[property];
                object[property] = descriptor.value;
                object.__proto__ = prototype;
            } else {
                object[property] = descriptor.value;
            }
        } else {
            if (!supportsAccessors)
                throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
            if (owns(descriptor, "get"))
                defineGetter(object, property, descriptor.get);
            if (owns(descriptor, "set"))
                defineSetter(object, property, descriptor.set);
        }

        return object;
    };
}
if (!Object.defineProperties) {
    Object.defineProperties = function defineProperties(object, properties) {
        for (var property in properties) {
            if (owns(properties, property))
                Object.defineProperty(object, property, properties[property]);
        }
        return object;
    };
}
if (!Object.seal) {
    Object.seal = function seal(object) {
        return object;
    };
}
if (!Object.freeze) {
    Object.freeze = function freeze(object) {
        return object;
    };
}
try {
    Object.freeze(function () {});
} catch (exception) {
    Object.freeze = (function freeze(freezeObject) {
        return function freeze(object) {
            if (typeof object == "function") {
                return object;
            } else {
                return freezeObject(object);
            }
        };
    })(Object.freeze);
}
if (!Object.preventExtensions) {
    Object.preventExtensions = function preventExtensions(object) {
        return object;
    };
}
if (!Object.isSealed) {
    Object.isSealed = function isSealed(object) {
        return false;
    };
}
if (!Object.isFrozen) {
    Object.isFrozen = function isFrozen(object) {
        return false;
    };
}
if (!Object.isExtensible) {
    Object.isExtensible = function isExtensible(object) {
        if (Object(object) === object) {
            throw new TypeError(); // TODO message
        }
        var name = '';
        while (owns(object, name)) {
            name += '?';
        }
        object[name] = true;
        var returnValue = owns(object, name);
        delete object[name];
        return returnValue;
    };
}
if (!Object.keys) {
    var hasDontEnumBug = true,
        dontEnums = [
            "toString",
            "toLocaleString",
            "valueOf",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "constructor"
        ],
        dontEnumsLength = dontEnums.length;

    for (var key in {"toString": null}) {
        hasDontEnumBug = false;
    }

    Object.keys = function keys(object) {

        if (
            (typeof object != "object" && typeof object != "function") ||
            object === null
        ) {
            throw new TypeError("Object.keys called on a non-object");
        }

        var keys = [];
        for (var name in object) {
            if (owns(object, name)) {
                keys.push(name);
            }
        }

        if (hasDontEnumBug) {
            for (var i = 0, ii = dontEnumsLength; i < ii; i++) {
                var dontEnum = dontEnums[i];
                if (owns(object, dontEnum)) {
                    keys.push(dontEnum);
                }
            }
        }
        return keys;
    };

}
if (!Date.now) {
    Date.now = function now() {
        return new Date().getTime();
    };
}
var ws = "\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003" +
    "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" +
    "\u2029\uFEFF";
if (!String.prototype.trim || ws.trim()) {
    ws = "[" + ws + "]";
    var trimBeginRegexp = new RegExp("^" + ws + ws + "*"),
        trimEndRegexp = new RegExp(ws + ws + "*$");
    String.prototype.trim = function trim() {
        return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
    };
}

function toInteger(n) {
    n = +n;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1/0) && n !== -(1/0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
}

function isPrimitive(input) {
    var type = typeof input;
    return (
        input === null ||
        type === "undefined" ||
        type === "boolean" ||
        type === "number" ||
        type === "string"
    );
}

function toPrimitive(input) {
    var val, valueOf, toString;
    if (isPrimitive(input)) {
        return input;
    }
    valueOf = input.valueOf;
    if (typeof valueOf === "function") {
        val = valueOf.call(input);
        if (isPrimitive(val)) {
            return val;
        }
    }
    toString = input.toString;
    if (typeof toString === "function") {
        val = toString.call(input);
        if (isPrimitive(val)) {
            return val;
        }
    }
    throw new TypeError();
}
var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert "+o+" to object");
    }
    return Object(o);
};

});

consoleAce.define('ace/lib/dom', ['require', 'exports', 'module' ], function(require, exports, module) {


if (typeof document == "undefined")
    return;

var XHTML_NS = "http://www.w3.org/1999/xhtml";

exports.getDocumentHead = function(doc) {
    if (!doc)
        doc = document;
    return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
}

exports.createElement = function(tag, ns) {
    return document.createElementNS ?
           document.createElementNS(ns || XHTML_NS, tag) :
           document.createElement(tag);
};

exports.hasCssClass = function(el, name) {
    var classes = el.className.split(/\s+/g);
    return classes.indexOf(name) !== -1;
};
exports.addCssClass = function(el, name) {
    if (!exports.hasCssClass(el, name)) {
        el.className += " " + name;
    }
};
exports.removeCssClass = function(el, name) {
    var classes = el.className.split(/\s+/g);
    while (true) {
        var index = classes.indexOf(name);
        if (index == -1) {
            break;
        }
        classes.splice(index, 1);
    }
    el.className = classes.join(" ");
};

exports.toggleCssClass = function(el, name) {
    var classes = el.className.split(/\s+/g), add = true;
    while (true) {
        var index = classes.indexOf(name);
        if (index == -1) {
            break;
        }
        add = false;
        classes.splice(index, 1);
    }
    if(add)
        classes.push(name);

    el.className = classes.join(" ");
    return add;
};
exports.setCssClass = function(node, className, include) {
    if (include) {
        exports.addCssClass(node, className);
    } else {
        exports.removeCssClass(node, className);
    }
};

exports.hasCssString = function(id, doc) {
    var index = 0, sheets;
    doc = doc || document;

    if (doc.createStyleSheet && (sheets = doc.styleSheets)) {
        while (index < sheets.length)
            if (sheets[index++].owningElement.id === id) return true;
    } else if ((sheets = doc.getElementsByTagName("style"))) {
        while (index < sheets.length)
            if (sheets[index++].id === id) return true;
    }

    return false;
};

exports.importCssString = function importCssString(cssText, id, doc) {
    doc = doc || document;
    if (id && exports.hasCssString(id, doc))
        return null;
    
    var style;
    
    if (doc.createStyleSheet) {
        style = doc.createStyleSheet();
        style.cssText = cssText;
        if (id)
            style.owningElement.id = id;
    } else {
        style = doc.createElementNS
            ? doc.createElementNS(XHTML_NS, "style")
            : doc.createElement("style");

        style.appendChild(doc.createTextNode(cssText));
        if (id)
            style.id = id;

        exports.getDocumentHead(doc).appendChild(style);
    }
};

exports.importCssStylsheet = function(uri, doc) {
    if (doc.createStyleSheet) {
        doc.createStyleSheet(uri);
    } else {
        var link = exports.createElement('link');
        link.rel = 'stylesheet';
        link.href = uri;

        exports.getDocumentHead(doc).appendChild(link);
    }
};

exports.getInnerWidth = function(element) {
    return (
        parseInt(exports.computedStyle(element, "paddingLeft"), 10) +
        parseInt(exports.computedStyle(element, "paddingRight"), 10) + 
        element.clientWidth
    );
};

exports.getInnerHeight = function(element) {
    return (
        parseInt(exports.computedStyle(element, "paddingTop"), 10) +
        parseInt(exports.computedStyle(element, "paddingBottom"), 10) +
        element.clientHeight
    );
};

if (window.pageYOffset !== undefined) {
    exports.getPageScrollTop = function() {
        return window.pageYOffset;
    };

    exports.getPageScrollLeft = function() {
        return window.pageXOffset;
    };
}
else {
    exports.getPageScrollTop = function() {
        return document.body.scrollTop;
    };

    exports.getPageScrollLeft = function() {
        return document.body.scrollLeft;
    };
}

if (window.getComputedStyle)
    exports.computedStyle = function(element, style) {
        if (style)
            return (window.getComputedStyle(element, "") || {})[style] || "";
        return window.getComputedStyle(element, "") || {};
    };
else
    exports.computedStyle = function(element, style) {
        if (style)
            return element.currentStyle[style];
        return element.currentStyle;
    };

exports.scrollbarWidth = function(document) {
    var inner = exports.createElement("ace_inner");
    inner.style.width = "100%";
    inner.style.minWidth = "0px";
    inner.style.height = "200px";
    inner.style.display = "block";

    var outer = exports.createElement("ace_outer");
    var style = outer.style;

    style.position = "absolute";
    style.left = "-10000px";
    style.overflow = "hidden";
    style.width = "200px";
    style.minWidth = "0px";
    style.height = "150px";
    style.display = "block";

    outer.appendChild(inner);

    var body = document.documentElement;
    body.appendChild(outer);

    var noScrollbar = inner.offsetWidth;

    style.overflow = "scroll";
    var withScrollbar = inner.offsetWidth;

    if (noScrollbar == withScrollbar) {
        withScrollbar = outer.clientWidth;
    }

    body.removeChild(outer);

    return noScrollbar-withScrollbar;
};
exports.setInnerHtml = function(el, innerHtml) {
    var element = el.cloneNode(false);//document.createElement("div");
    element.innerHTML = innerHtml;
    el.parentNode.replaceChild(element, el);
    return element;
};

if ("textContent" in document.documentElement) {
    exports.setInnerText = function(el, innerText) {
        el.textContent = innerText;
    };

    exports.getInnerText = function(el) {
        return el.textContent;
    };
}
else {
    exports.setInnerText = function(el, innerText) {
        el.innerText = innerText;
    };

    exports.getInnerText = function(el) {
        return el.innerText;
    };
}

exports.getParentWindow = function(document) {
    return document.defaultView || document.parentWindow;
};

});

consoleAce.define('ace/lib/event', ['require', 'exports', 'module' , 'ace/lib/keys', 'ace/lib/useragent', 'ace/lib/dom'], function(require, exports, module) {


var keys = require("./keys");
var useragent = require("./useragent");
var dom = require("./dom");

exports.addListener = function(elem, type, callback) {
    if (elem.addEventListener) {
        return elem.addEventListener(type, callback, false);
    }
    if (elem.attachEvent) {
        var wrapper = function() {
            callback.call(elem, window.event);
        };
        callback._wrapper = wrapper;
        elem.attachEvent("on" + type, wrapper);
    }
};

exports.removeListener = function(elem, type, callback) {
    if (elem.removeEventListener) {
        return elem.removeEventListener(type, callback, false);
    }
    if (elem.detachEvent) {
        elem.detachEvent("on" + type, callback._wrapper || callback);
    }
};
exports.stopEvent = function(e) {
    exports.stopPropagation(e);
    exports.preventDefault(e);
    return false;
};

exports.stopPropagation = function(e) {
    if (e.stopPropagation)
        e.stopPropagation();
    else
        e.cancelBubble = true;
};

exports.preventDefault = function(e) {
    if (e.preventDefault)
        e.preventDefault();
    else
        e.returnValue = false;
};
exports.getButton = function(e) {
    if (e.type == "dblclick")
        return 0;
    if (e.type == "contextmenu" || (e.ctrlKey && useragent.isMac))
        return 2;
    if (e.preventDefault) {
        return e.button;
    }
    else {
        return {1:0, 2:2, 4:1}[e.button];
    }
};

exports.capture = function(el, eventHandler, releaseCaptureHandler) {
    function onMouseUp(e) {
        eventHandler && eventHandler(e);
        releaseCaptureHandler && releaseCaptureHandler(e);

        exports.removeListener(document, "mousemove", eventHandler, true);
        exports.removeListener(document, "mouseup", onMouseUp, true);
        exports.removeListener(document, "dragstart", onMouseUp, true);
    }

    exports.addListener(document, "mousemove", eventHandler, true);
    exports.addListener(document, "mouseup", onMouseUp, true);
    exports.addListener(document, "dragstart", onMouseUp, true);
    
    return onMouseUp;
};

exports.addMouseWheelListener = function(el, callback) {
    if ("onmousewheel" in el) {
        exports.addListener(el, "mousewheel", function(e) {
            var factor = 8;
            if (e.wheelDeltaX !== undefined) {
                e.wheelX = -e.wheelDeltaX / factor;
                e.wheelY = -e.wheelDeltaY / factor;
            } else {
                e.wheelX = 0;
                e.wheelY = -e.wheelDelta / factor;
            }
            callback(e);
        });
    } else if ("onwheel" in el) {
        exports.addListener(el, "wheel",  function(e) {
            var factor = 0.35;
            switch (e.deltaMode) {
                case e.DOM_DELTA_PIXEL:
                    e.wheelX = e.deltaX * factor || 0;
                    e.wheelY = e.deltaY * factor || 0;
                    break;
                case e.DOM_DELTA_LINE:
                case e.DOM_DELTA_PAGE:
                    e.wheelX = (e.deltaX || 0) * 5;
                    e.wheelY = (e.deltaY || 0) * 5;
                    break;
            }
            
            callback(e);
        });
    } else {
        exports.addListener(el, "DOMMouseScroll", function(e) {
            if (e.axis && e.axis == e.HORIZONTAL_AXIS) {
                e.wheelX = (e.detail || 0) * 5;
                e.wheelY = 0;
            } else {
                e.wheelX = 0;
                e.wheelY = (e.detail || 0) * 5;
            }
            callback(e);
        });
    }
};

exports.addMultiMouseDownListener = function(el, timeouts, eventHandler, callbackName) {
    var clicks = 0;
    var startX, startY, timer;
    var eventNames = {
        2: "dblclick",
        3: "tripleclick",
        4: "quadclick"
    };

    exports.addListener(el, "mousedown", function(e) {
        if (exports.getButton(e) != 0) {
            clicks = 0;
        } else if (e.detail > 1) {
            clicks++;
            if (clicks > 4)
                clicks = 1;
        } else {
            clicks = 1;
        }
        if (useragent.isIE) {
            var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
            if (isNewClick) {
                clicks = 1;
            }
            if (clicks == 1) {
                startX = e.clientX;
                startY = e.clientY;
            }
        }

        eventHandler[callbackName]("mousedown", e);

        if (clicks > 4)
            clicks = 0;
        else if (clicks > 1)
            return eventHandler[callbackName](eventNames[clicks], e);
    });

    if (useragent.isOldIE) {
        exports.addListener(el, "dblclick", function(e) {
            clicks = 2;
            if (timer)
                clearTimeout(timer);
            timer = setTimeout(function() {timer = null}, timeouts[clicks - 1] || 600);
            eventHandler[callbackName]("mousedown", e);
            eventHandler[callbackName](eventNames[clicks], e);
        });
    }
};

function normalizeCommandKeys(callback, e, keyCode) {
    var hashId = 0;
    if ((useragent.isOpera && !("KeyboardEvent" in window)) && useragent.isMac) {
        hashId = 0 | (e.metaKey ? 1 : 0) | (e.altKey ? 2 : 0)
            | (e.shiftKey ? 4 : 0) | (e.ctrlKey ? 8 : 0);
    } else {
        hashId = 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0)
            | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
    }

    if (!useragent.isMac && pressedKeys) {
        if (pressedKeys[91] || pressedKeys[92])
            hashId |= 8;
        if (pressedKeys.altGr) {
            if ((3 & hashId) != 3)
                pressedKeys.altGr = 0
            else
                return;
        }
        if (keyCode === 18 || keyCode === 17) {
            var location = e.location || e.keyLocation;
            if (keyCode === 17 && location === 1) {
                ts = e.timeStamp;
            } else if (keyCode === 18 && hashId === 3 && location === 2) {
                var dt = -ts;
                ts = e.timeStamp;
                dt += ts;
                if (dt < 3)
                    pressedKeys.altGr = true;
            }
        }
    }
    
    if (keyCode in keys.MODIFIER_KEYS) {
        switch (keys.MODIFIER_KEYS[keyCode]) {
            case "Alt":
                hashId = 2;
                break;
            case "Shift":
                hashId = 4;
                break;
            case "Ctrl":
                hashId = 1;
                break;
            default:
                hashId = 8;
                break;
        }
        keyCode = 0;
    }

    if (hashId & 8 && (keyCode === 91 || keyCode === 93)) {
        keyCode = 0;
    }
    
    if (!hashId && keyCode === 13) {
        if (e.location || e.keyLocation === 3) {
            callback(e, hashId, -keyCode)
            if (e.defaultPrevented)
                return;
        }
    }
    if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
        return false;
    }
    
    
    
    return callback(e, hashId, keyCode);
}

var pressedKeys = null;
var ts = 0;
exports.addCommandKeyListener = function(el, callback) {
    var addListener = exports.addListener;
    if (useragent.isOldGecko || (useragent.isOpera && !("KeyboardEvent" in window))) {
        var lastKeyDownKeyCode = null;
        addListener(el, "keydown", function(e) {
            lastKeyDownKeyCode = e.keyCode;
        });
        addListener(el, "keypress", function(e) {
            return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
        });
    } else {
        var lastDefaultPrevented = null;

        addListener(el, "keydown", function(e) {
            pressedKeys[e.keyCode] = true;
            var result = normalizeCommandKeys(callback, e, e.keyCode);
            lastDefaultPrevented = e.defaultPrevented;
            return result;
        });

        addListener(el, "keypress", function(e) {
            if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
                exports.stopEvent(e);
                lastDefaultPrevented = null;
            }
        });

        addListener(el, "keyup", function(e) {
            pressedKeys[e.keyCode] = null;
        });

        if (!pressedKeys) {
            pressedKeys = Object.create(null);
            addListener(window, "focus", function(e) {
                pressedKeys = Object.create(null);
            });
        }
    }
};

if (window.postMessage && !useragent.isOldIE) {
    var postMessageId = 1;
    exports.nextTick = function(callback, win) {
        win = win || window;
        var messageName = "zero-timeout-message-" + postMessageId;
        exports.addListener(win, "message", function listener(e) {
            if (e.data == messageName) {
                exports.stopPropagation(e);
                exports.removeListener(win, "message", listener);
                callback();
            }
        });
        win.postMessage(messageName, "*");
    };
}


exports.nextFrame = window.requestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    window.oRequestAnimationFrame;

if (exports.nextFrame)
    exports.nextFrame = exports.nextFrame.bind(window);
else
    exports.nextFrame = function(callback) {
        setTimeout(callback, 17);
    };
});

consoleAce.define('ace/lib/keys', ['require', 'exports', 'module' , 'ace/lib/oop'], function(require, exports, module) {


var oop = require("./oop");
var Keys = (function() {
    var ret = {
        MODIFIER_KEYS: {
            16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta'
        },

        KEY_MODS: {
            "ctrl": 1, "alt": 2, "option" : 2,
            "shift": 4, "meta": 8, "command": 8, "cmd": 8
        },

        FUNCTION_KEYS : {
            8  : "Backspace",
            9  : "Tab",
            13 : "Return",
            19 : "Pause",
            27 : "Esc",
            32 : "Space",
            33 : "PageUp",
            34 : "PageDown",
            35 : "End",
            36 : "Home",
            37 : "Left",
            38 : "Up",
            39 : "Right",
            40 : "Down",
            44 : "Print",
            45 : "Insert",
            46 : "Delete",
            96 : "Numpad0",
            97 : "Numpad1",
            98 : "Numpad2",
            99 : "Numpad3",
            100: "Numpad4",
            101: "Numpad5",
            102: "Numpad6",
            103: "Numpad7",
            104: "Numpad8",
            105: "Numpad9",
            '-13': "NumpadEnter",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "Numlock",
            145: "Scrolllock"
        },

        PRINTABLE_KEYS: {
           32: ' ',  48: '0',  49: '1',  50: '2',  51: '3',  52: '4', 53:  '5',
           54: '6',  55: '7',  56: '8',  57: '9',  59: ';',  61: '=', 65:  'a',
           66: 'b',  67: 'c',  68: 'd',  69: 'e',  70: 'f',  71: 'g', 72:  'h',
           73: 'i',  74: 'j',  75: 'k',  76: 'l',  77: 'm',  78: 'n', 79:  'o',
           80: 'p',  81: 'q',  82: 'r',  83: 's',  84: 't',  85: 'u', 86:  'v',
           87: 'w',  88: 'x',  89: 'y',  90: 'z', 107: '+', 109: '-', 110: '.',
          188: ',', 190: '.', 191: '/', 192: '`', 219: '[', 220: '\\',
          221: ']', 222: '\''
        }
    };
    for (var i in ret.FUNCTION_KEYS) {
        var name = ret.FUNCTION_KEYS[i].toLowerCase();
        ret[name] = parseInt(i, 10);
    }
    oop.mixin(ret, ret.MODIFIER_KEYS);
    oop.mixin(ret, ret.PRINTABLE_KEYS);
    oop.mixin(ret, ret.FUNCTION_KEYS);
    ret.enter = ret["return"];
    ret.escape = ret.esc;
    ret.del = ret["delete"];
    ret[173] = '-';

    return ret;
})();
oop.mixin(exports, Keys);

exports.keyCodeToString = function(keyCode) {
    return (Keys[keyCode] || String.fromCharCode(keyCode)).toLowerCase();
}

});

consoleAce.define('ace/lib/oop', ['require', 'exports', 'module' ], function(require, exports, module) {


exports.inherits = function(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
};

exports.mixin = function(obj, mixin) {
    for (var key in mixin) {
        obj[key] = mixin[key];
    }
    return obj;
};

exports.implement = function(proto, mixin) {
    exports.mixin(proto, mixin);
};

});

consoleAce.define('ace/lib/useragent', ['require', 'exports', 'module' ], function(require, exports, module) {
exports.OS = {
    LINUX: "LINUX",
    MAC: "MAC",
    WINDOWS: "WINDOWS"
};
exports.getOS = function() {
    if (exports.isMac) {
        return exports.OS.MAC;
    } else if (exports.isLinux) {
        return exports.OS.LINUX;
    } else {
        return exports.OS.WINDOWS;
    }
};
if (typeof navigator != "object")
    return;

var os = (navigator.platform.match(/mac|win|linux/i) || ["other"])[0].toLowerCase();
var ua = navigator.userAgent;
exports.isWin = (os == "win");
exports.isMac = (os == "mac");
exports.isLinux = (os == "linux");
exports.isIE = 
    (navigator.appName == "Microsoft Internet Explorer" || navigator.appName.indexOf("MSAppHost") >= 0)
    && parseFloat(navigator.userAgent.match(/MSIE ([0-9]+[\.0-9]+)/)[1]);
    
exports.isOldIE = exports.isIE && exports.isIE < 9;
exports.isGecko = exports.isMozilla = window.controllers && window.navigator.product === "Gecko";
exports.isOldGecko = exports.isGecko && parseInt((navigator.userAgent.match(/rv\:(\d+)/)||[])[1], 10) < 4;
exports.isOpera = window.opera && Object.prototype.toString.call(window.opera) == "[object Opera]";
exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;

exports.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;

exports.isAIR = ua.indexOf("AdobeAIR") >= 0;

exports.isIPad = ua.indexOf("iPad") >= 0;

exports.isTouchPad = ua.indexOf("TouchPad") >= 0;

});

consoleAce.define('ace/editor', ['require', 'exports', 'module' , 'ace/lib/fixoldbrowsers', 'ace/lib/oop', 'ace/lib/dom', 'ace/lib/lang', 'ace/lib/useragent', 'ace/keyboard/textinput', 'ace/mouse/mouse_handler', 'ace/mouse/fold_handler', 'ace/keyboard/keybinding', 'ace/edit_session', 'ace/search', 'ace/range', 'ace/lib/event_emitter', 'ace/commands/command_manager', 'ace/commands/default_commands', 'ace/config'], function(require, exports, module) {


require("./lib/fixoldbrowsers");

var oop = require("./lib/oop");
var dom = require("./lib/dom");
var lang = require("./lib/lang");
var useragent = require("./lib/useragent");
var TextInput = require("./keyboard/textinput").TextInput;
var MouseHandler = require("./mouse/mouse_handler").MouseHandler;
var FoldHandler = require("./mouse/fold_handler").FoldHandler;
var KeyBinding = require("./keyboard/keybinding").KeyBinding;
var EditSession = require("./edit_session").EditSession;
var Search = require("./search").Search;
var Range = require("./range").Range;
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var CommandManager = require("./commands/command_manager").CommandManager;
var defaultCommands = require("./commands/default_commands").commands;
var config = require("./config");
var Editor = function(renderer, session) {
    var container = renderer.getContainerElement();
    this.container = container;
    this.renderer = renderer;

    this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
    this.textInput  = new TextInput(renderer.getTextAreaContainer(), this);
    this.renderer.textarea = this.textInput.getElement();
    this.keyBinding = new KeyBinding(this);
    this.$mouseHandler = new MouseHandler(this);
    new FoldHandler(this);

    this.$blockScrolling = 0;
    this.$search = new Search().set({
        wrap: true
    });

    this.$historyTracker = this.$historyTracker.bind(this);
    this.commands.on("exec", this.$historyTracker);

    this.$initOperationListeners();
    
    this._$emitInputEvent = lang.delayedCall(function() {
        this._signal("input", {});
        this.session.bgTokenizer && this.session.bgTokenizer.scheduleStart();
    }.bind(this));
    
    this.on("change", function(_, _self) {
        _self._$emitInputEvent.schedule(31);
    });

    this.setSession(session || new EditSession(""));
    config.resetOptions(this);
    config._emit("editor", this);
};

(function(){

    oop.implement(this, EventEmitter);

    this.$initOperationListeners = function() {
        function last(a) {return a[a.length - 1]}

        this.selections = [];
        this.commands.on("exec", function(e) {
            this.startOperation(e);

            var command = e.command;
            if (command.aceCommandGroup == "fileJump") {
                var prev = this.prevOp;
                if (!prev || prev.command.aceCommandGroup != "fileJump") {
                    this.lastFileJumpPos = last(this.selections);
                }
            } else {
                this.lastFileJumpPos = null;
            }
        }.bind(this), true);

        this.commands.on("afterExec", function(e) {
            var command = e.command;

            if (command.aceCommandGroup == "fileJump") {
                if (this.lastFileJumpPos && !this.curOp.selectionChanged) {
                    this.selection.fromJSON(this.lastFileJumpPos);
                }
            }
            this.endOperation(e);
        }.bind(this), true);

        this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this));

        this.on("change", function() {
            this.curOp || this.startOperation();
            this.curOp.docChanged = true;
        }.bind(this), true);

        this.on("changeSelection", function() {
            this.curOp || this.startOperation();
            this.curOp.selectionChanged = true;
        }.bind(this), true);
    };

    this.curOp = null;
    this.prevOp = {};
    this.startOperation = function(commadEvent) {
        if (this.curOp) {
            if (!commadEvent || this.curOp.command)
                return;
            this.prevOp = this.curOp;
        }
        if (!commadEvent) {
            this.previousCommand = null;
            commadEvent = {};
        }

        this.$opResetTimer.schedule();
        this.curOp = {
            command: commadEvent.command || {},
            args: commadEvent.args,
            scrollTop: this.renderer.scrollTop
        };
        
        var command = this.curOp.command;
        if (command && command.scrollIntoView)
            this.$blockScrolling++;

        this.selections.push(this.selection.toJSON());
    };

    this.endOperation = function() {
        if (this.curOp) {
            var command = this.curOp.command;
            if (command && command.scrollIntoView) {
                this.$blockScrolling--;
                switch (command.scrollIntoView) {
                    case "center":
                        this.renderer.scrollCursorIntoView(null, 0.5);
                        break;
                    case "animate":
                    case "cursor":
                        this.renderer.scrollCursorIntoView();
                        break;
                    case "selectionPart":
                        var range = this.selection.getRange();
                        var config = this.renderer.layerConfig;
                        if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
                            this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                        }
                        break;
                    default:
                        break;
                }
                if (command.scrollIntoView == "animate")
                    this.renderer.animateScrolling(this.curOp.scrollTop);
            }
            
            this.prevOp = this.curOp;
            this.curOp = null;
        }
    };

    this.$historyTracker = function(e) {
        if (!this.$mergeUndoDeltas)
            return;


        var prev = this.prevOp;
        var mergeableCommands = ["backspace", "del", "insertstring"];
        var shouldMerge = prev.command && (e.command.name == prev.command.name);
        if (e.command.name == "insertstring") {
            var text = e.args;
            if (this.mergeNextCommand === undefined)
                this.mergeNextCommand = true;

            shouldMerge = shouldMerge
                && this.mergeNextCommand // previous command allows to coalesce with
                && (!/\s/.test(text) || /\s/.test(prev.args)); // previous insertion was of same type

            this.mergeNextCommand = true;
        } else {
            shouldMerge = shouldMerge
                && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable
        }

        if (
            this.$mergeUndoDeltas != "always"
            && Date.now() - this.sequenceStartTime > 2000
        ) {
            shouldMerge = false; // the sequence is too long
        }

        if (shouldMerge)
            this.session.mergeUndoDeltas = true;
        else if (mergeableCommands.indexOf(e.command.name) !== -1)
            this.sequenceStartTime = Date.now();
    };
    this.setKeyboardHandler = function(keyboardHandler) {
        if (!keyboardHandler) {
            this.keyBinding.setKeyboardHandler(null);
        } else if (typeof keyboardHandler === "string") {
            this.$keybindingId = keyboardHandler;
            var _self = this;
            config.loadModule(["keybinding", keyboardHandler], function(module) {
                if (_self.$keybindingId == keyboardHandler)
                    _self.keyBinding.setKeyboardHandler(module && module.handler);
            });
        } else {
            this.$keybindingId = null;
            this.keyBinding.setKeyboardHandler(keyboardHandler);
        }
    };
    this.getKeyboardHandler = function() {
        return this.keyBinding.getKeyboardHandler();
    };
    this.setSession = function(session) {
        if (this.session == session)
            return;

        if (this.session) {
            var oldSession = this.session;
            this.session.removeEventListener("change", this.$onDocumentChange);
            this.session.removeEventListener("changeMode", this.$onChangeMode);
            this.session.removeEventListener("tokenizerUpdate", this.$onTokenizerUpdate);
            this.session.removeEventListener("changeTabSize", this.$onChangeTabSize);
            this.session.removeEventListener("changeWrapLimit", this.$onChangeWrapLimit);
            this.session.removeEventListener("changeWrapMode", this.$onChangeWrapMode);
            this.session.removeEventListener("onChangeFold", this.$onChangeFold);
            this.session.removeEventListener("changeFrontMarker", this.$onChangeFrontMarker);
            this.session.removeEventListener("changeBackMarker", this.$onChangeBackMarker);
            this.session.removeEventListener("changeBreakpoint", this.$onChangeBreakpoint);
            this.session.removeEventListener("changeAnnotation", this.$onChangeAnnotation);
            this.session.removeEventListener("changeOverwrite", this.$onCursorChange);
            this.session.removeEventListener("changeScrollTop", this.$onScrollTopChange);
            this.session.removeEventListener("changeScrollLeft", this.$onScrollLeftChange);

            var selection = this.session.getSelection();
            selection.removeEventListener("changeCursor", this.$onCursorChange);
            selection.removeEventListener("changeSelection", this.$onSelectionChange);
        }

        this.session = session;

        this.$onDocumentChange = this.onDocumentChange.bind(this);
        session.addEventListener("change", this.$onDocumentChange);
        this.renderer.setSession(session);

        this.$onChangeMode = this.onChangeMode.bind(this);
        session.addEventListener("changeMode", this.$onChangeMode);

        this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
        session.addEventListener("tokenizerUpdate", this.$onTokenizerUpdate);

        this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
        session.addEventListener("changeTabSize", this.$onChangeTabSize);

        this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
        session.addEventListener("changeWrapLimit", this.$onChangeWrapLimit);

        this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
        session.addEventListener("changeWrapMode", this.$onChangeWrapMode);

        this.$onChangeFold = this.onChangeFold.bind(this);
        session.addEventListener("changeFold", this.$onChangeFold);

        this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
        this.session.addEventListener("changeFrontMarker", this.$onChangeFrontMarker);

        this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
        this.session.addEventListener("changeBackMarker", this.$onChangeBackMarker);

        this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
        this.session.addEventListener("changeBreakpoint", this.$onChangeBreakpoint);

        this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
        this.session.addEventListener("changeAnnotation", this.$onChangeAnnotation);

        this.$onCursorChange = this.onCursorChange.bind(this);
        this.session.addEventListener("changeOverwrite", this.$onCursorChange);

        this.$onScrollTopChange = this.onScrollTopChange.bind(this);
        this.session.addEventListener("changeScrollTop", this.$onScrollTopChange);

        this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
        this.session.addEventListener("changeScrollLeft", this.$onScrollLeftChange);

        this.selection = session.getSelection();
        this.selection.addEventListener("changeCursor", this.$onCursorChange);

        this.$onSelectionChange = this.onSelectionChange.bind(this);
        this.selection.addEventListener("changeSelection", this.$onSelectionChange);

        this.onChangeMode();

        this.$blockScrolling += 1;
        this.onCursorChange();
        this.$blockScrolling -= 1;

        this.onScrollTopChange();
        this.onScrollLeftChange();
        this.onSelectionChange();
        this.onChangeFrontMarker();
        this.onChangeBackMarker();
        this.onChangeBreakpoint();
        this.onChangeAnnotation();
        this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
        this.renderer.updateFull();

        this._emit("changeSession", {
            session: session,
            oldSession: oldSession
        });
    };
    this.getSession = function() {
        return this.session;
    };
    this.setValue = function(val, cursorPos) {
        this.session.doc.setValue(val);

        if (!cursorPos)
            this.selectAll();
        else if (cursorPos == 1)
            this.navigateFileEnd();
        else if (cursorPos == -1)
            this.navigateFileStart();

        return val;
    };
    this.getValue = function() {
        return this.session.getValue();
    };
    this.getSelection = function() {
        return this.selection;
    };
    this.resize = function(force) {
        this.renderer.onResize(force);
    };
    this.setTheme = function(theme) {
        this.renderer.setTheme(theme);
    };
    this.getTheme = function() {
        return this.renderer.getTheme();
    };
    this.setStyle = function(style) {
        this.renderer.setStyle(style);
    };
    this.unsetStyle = function(style) {
        this.renderer.unsetStyle(style);
    };
    this.getFontSize = function () {
        return this.getOption("fontSize") ||
           dom.computedStyle(this.container, "fontSize");
    };
    this.setFontSize = function(size) {
        this.setOption("fontSize", size);
    };

    this.$highlightBrackets = function() {
        if (this.session.$bracketHighlight) {
            this.session.removeMarker(this.session.$bracketHighlight);
            this.session.$bracketHighlight = null;
        }

        if (this.$highlightPending) {
            return;
        }
        var self = this;
        this.$highlightPending = true;
        setTimeout(function() {
            self.$highlightPending = false;

            var pos = self.session.findMatchingBracket(self.getCursorPosition());
            if (pos) {
                var range = new Range(pos.row, pos.column, pos.row, pos.column+1);
            } else if (self.session.$mode.getMatching) {
                var range = self.session.$mode.getMatching(self.session);
            }
            if (range)
                self.session.$bracketHighlight = self.session.addMarker(range, "ace_bracket", "text");
        }, 50);
    };
    this.focus = function() {
        var _self = this;
        setTimeout(function() {
            _self.textInput.focus();
        });
        this.textInput.focus();
    };
    this.isFocused = function() {
        return this.textInput.isFocused();
    };
    this.blur = function() {
        this.textInput.blur();
    };
    this.onFocus = function() {
        if (this.$isFocused)
            return;
        this.$isFocused = true;
        this.renderer.showCursor();
        this.renderer.visualizeFocus();
        this._emit("focus");
    };
    this.onBlur = function() {
        if (!this.$isFocused)
            return;
        this.$isFocused = false;
        this.renderer.hideCursor();
        this.renderer.visualizeBlur();
        this._emit("blur");
    };

    this.$cursorChange = function() {
        this.renderer.updateCursor();
    };
    this.onDocumentChange = function(e) {
        var delta = e.data;
        var range = delta.range;
        var lastRow;

        if (range.start.row == range.end.row && delta.action != "insertLines" && delta.action != "removeLines")
            lastRow = range.end.row;
        else
            lastRow = Infinity;
        this.renderer.updateLines(range.start.row, lastRow);

        this._emit("change", e);
        this.$cursorChange();
    };

    this.onTokenizerUpdate = function(e) {
        var rows = e.data;
        this.renderer.updateLines(rows.first, rows.last);
    };


    this.onScrollTopChange = function() {
        this.renderer.scrollToY(this.session.getScrollTop());
    };

    this.onScrollLeftChange = function() {
        this.renderer.scrollToX(this.session.getScrollLeft());
    };
    this.onCursorChange = function() {
        this.$cursorChange();

        if (!this.$blockScrolling) {
            this.renderer.scrollCursorIntoView();
        }

        this.$highlightBrackets();
        this.$updateHighlightActiveLine();
        this._emit("changeSelection");
    };

    this.$updateHighlightActiveLine = function() {
        var session = this.getSession();

        var highlight;
        if (this.$highlightActiveLine) {
            if ((this.$selectionStyle != "line" || !this.selection.isMultiLine()))
                highlight = this.getCursorPosition();
            if (this.renderer.$maxLines && this.session.getLength() === 1)
                highlight = false;
        }

        if (session.$highlightLineMarker && !highlight) {
            session.removeMarker(session.$highlightLineMarker.id);
            session.$highlightLineMarker = null;
        } else if (!session.$highlightLineMarker && highlight) {
            var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
            range.id = session.addMarker(range, "ace_active-line", "screenLine");
            session.$highlightLineMarker = range;
        } else if (highlight) {
            session.$highlightLineMarker.start.row = highlight.row;
            session.$highlightLineMarker.end.row = highlight.row;
            session.$highlightLineMarker.start.column = highlight.column;
            session._emit("changeBackMarker");
        }
    };

    this.onSelectionChange = function(e) {
        var session = this.session;

        if (session.$selectionMarker) {
            session.removeMarker(session.$selectionMarker);
        }
        session.$selectionMarker = null;

        if (!this.selection.isEmpty()) {
            var range = this.selection.getRange();
            var style = this.getSelectionStyle();
            session.$selectionMarker = session.addMarker(range, "ace_selection", style);
        } else {
            this.$updateHighlightActiveLine();
        }

        var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
        this.session.highlight(re);

        this._emit("changeSelection");
    };

    this.$getSelectionHighLightRegexp = function() {
        var session = this.session;

        var selection = this.getSelectionRange();
        if (selection.isEmpty() || selection.isMultiLine())
            return;

        var startOuter = selection.start.column - 1;
        var endOuter = selection.end.column + 1;
        var line = session.getLine(selection.start.row);
        var lineCols = line.length;
        var needle = line.substring(Math.max(startOuter, 0),
                                    Math.min(endOuter, lineCols));
        if ((startOuter >= 0 && /^[\w\d]/.test(needle)) ||
            (endOuter <= lineCols && /[\w\d]$/.test(needle)))
            return;

        needle = line.substring(selection.start.column, selection.end.column);
        if (!/^[\w\d]+$/.test(needle))
            return;

        var re = this.$search.$assembleRegExp({
            wholeWord: true,
            caseSensitive: true,
            needle: needle
        });

        return re;
    };


    this.onChangeFrontMarker = function() {
        this.renderer.updateFrontMarkers();
    };

    this.onChangeBackMarker = function() {
        this.renderer.updateBackMarkers();
    };


    this.onChangeBreakpoint = function() {
        this.renderer.updateBreakpoints();
    };

    this.onChangeAnnotation = function() {
        this.renderer.setAnnotations(this.session.getAnnotations());
    };


    this.onChangeMode = function(e) {
        this.renderer.updateText();
        this._emit("changeMode", e);
    };


    this.onChangeWrapLimit = function() {
        this.renderer.updateFull();
    };

    this.onChangeWrapMode = function() {
        this.renderer.onResize(true);
    };


    this.onChangeFold = function() {
        this.$updateHighlightActiveLine();
        this.renderer.updateFull();
    };
    this.getSelectedText = function() {
        return this.session.getTextRange(this.getSelectionRange());
    };
    this.getCopyText = function() {
        var text = this.getSelectedText();
        this._signal("copy", text);
        return text;
    };
    this.onCopy = function() {
        this.commands.exec("copy", this);
    };
    this.onCut = function() {
        this.commands.exec("cut", this);
    };
    this.onPaste = function(text) {
        if (this.$readOnly)
            return;
        this._emit("paste", text);
        this.insert(text);
    };


    this.execCommand = function(command, args) {
        this.commands.exec(command, this, args);
    };
    this.insert = function(text) {
        var session = this.session;
        var mode = session.getMode();
        var cursor = this.getCursorPosition();

        if (this.getBehavioursEnabled()) {
            var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
            if (transform) {
                if (text !== transform.text) {
                    this.session.mergeUndoDeltas = false;
                    this.$mergeNextCommand = false;
                }
                text = transform.text;

            }
        }
        
        if (text == "\t")
            text = this.session.getTabString();
        if (!this.selection.isEmpty()) {
            var range = this.getSelectionRange();
            cursor = this.session.remove(range);
            this.clearSelection();
        }
        else if (this.session.getOverwrite()) {
            var range = new Range.fromPoints(cursor, cursor);
            range.end.column += text.length;
            this.session.remove(range);
        }

        if (text == "\n" || text == "\r\n") {
            var line = session.getLine(cursor.row);
            if (cursor.column > line.search(/\S|$/)) {
                var d = line.substr(cursor.column).search(/\S|$/);
                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
            }
        }
        this.clearSelection();

        var start = cursor.column;
        var lineState = session.getState(cursor.row);
        var line = session.getLine(cursor.row);
        var shouldOutdent = mode.checkOutdent(lineState, line, text);
        var end = session.insert(cursor, text);

        if (transform && transform.selection) {
            if (transform.selection.length == 2) { // Transform relative to the current column
                this.selection.setSelectionRange(
                    new Range(cursor.row, start + transform.selection[0],
                              cursor.row, start + transform.selection[1]));
            } else { // Transform relative to the current row.
                this.selection.setSelectionRange(
                    new Range(cursor.row + transform.selection[0],
                              transform.selection[1],
                              cursor.row + transform.selection[2],
                              transform.selection[3]));
            }
        }

        if (session.getDocument().isNewLine(text)) {
            var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());

            session.insert({row: cursor.row+1, column: 0}, lineIndent);
        }
        if (shouldOutdent)
            mode.autoOutdent(lineState, session, cursor.row);
    };

    this.onTextInput = function(text) {
        this.keyBinding.onTextInput(text);
    };

    this.onCommandKey = function(e, hashId, keyCode) {
        this.keyBinding.onCommandKey(e, hashId, keyCode);
    };
    this.setOverwrite = function(overwrite) {
        this.session.setOverwrite(overwrite);
    };
    this.getOverwrite = function() {
        return this.session.getOverwrite();
    };
    this.toggleOverwrite = function() {
        this.session.toggleOverwrite();
    };
    this.setScrollSpeed = function(speed) {
        this.setOption("scrollSpeed", speed);
    };
    this.getScrollSpeed = function() {
        return this.getOption("scrollSpeed");
    };
    this.setDragDelay = function(dragDelay) {
        this.setOption("dragDelay", dragDelay);
    };
    this.getDragDelay = function() {
        return this.getOption("dragDelay");
    };
    this.setSelectionStyle = function(val) {
        this.setOption("selectionStyle", val);
    };
    this.getSelectionStyle = function() {
        return this.getOption("selectionStyle");
    };
    this.setHighlightActiveLine = function(shouldHighlight) {
        this.setOption("highlightActiveLine", shouldHighlight);
    };
    this.getHighlightActiveLine = function() {
        return this.getOption("highlightActiveLine");
    };
    this.setHighlightGutterLine = function(shouldHighlight) {
        this.setOption("highlightGutterLine", shouldHighlight);
    };

    this.getHighlightGutterLine = function() {
        return this.getOption("highlightGutterLine");
    };
    this.setHighlightSelectedWord = function(shouldHighlight) {
        this.setOption("highlightSelectedWord", shouldHighlight);
    };
    this.getHighlightSelectedWord = function() {
        return this.$highlightSelectedWord;
    };

    this.setAnimatedScroll = function(shouldAnimate){
        this.renderer.setAnimatedScroll(shouldAnimate);
    };

    this.getAnimatedScroll = function(){
        return this.renderer.getAnimatedScroll();
    };
    this.setShowInvisibles = function(showInvisibles) {
        this.renderer.setShowInvisibles(showInvisibles);
    };
    this.getShowInvisibles = function() {
        return this.renderer.getShowInvisibles();
    };

    this.setDisplayIndentGuides = function(display) {
        this.renderer.setDisplayIndentGuides(display);
    };

    this.getDisplayIndentGuides = function() {
        return this.renderer.getDisplayIndentGuides();
    };
    this.setShowPrintMargin = function(showPrintMargin) {
        this.renderer.setShowPrintMargin(showPrintMargin);
    };
    this.getShowPrintMargin = function() {
        return this.renderer.getShowPrintMargin();
    };
    this.setPrintMarginColumn = function(showPrintMargin) {
        this.renderer.setPrintMarginColumn(showPrintMargin);
    };
    this.getPrintMarginColumn = function() {
        return this.renderer.getPrintMarginColumn();
    };
    this.setReadOnly = function(readOnly) {
        this.setOption("readOnly", readOnly);
    };
    this.getReadOnly = function() {
        return this.getOption("readOnly");
    };
    this.setBehavioursEnabled = function (enabled) {
        this.setOption("behavioursEnabled", enabled);
    };
    this.getBehavioursEnabled = function () {
        return this.getOption("behavioursEnabled");
    };
    this.setWrapBehavioursEnabled = function (enabled) {
        this.setOption("wrapBehavioursEnabled", enabled);
    };
    this.getWrapBehavioursEnabled = function () {
        return this.getOption("wrapBehavioursEnabled");
    };
    this.setShowFoldWidgets = function(show) {
        this.setOption("showFoldWidgets", show);

    };
    this.getShowFoldWidgets = function() {
        return this.getOption("showFoldWidgets");
    };

    this.setFadeFoldWidgets = function(fade) {
        this.setOption("fadeFoldWidgets", fade);
    };

    this.getFadeFoldWidgets = function() {
        return this.getOption("fadeFoldWidgets");
    };
    this.remove = function(dir) {
        if (this.selection.isEmpty()){
            if (dir == "left")
                this.selection.selectLeft();
            else
                this.selection.selectRight();
        }

        var range = this.getSelectionRange();
        if (this.getBehavioursEnabled()) {
            var session = this.session;
            var state = session.getState(range.start.row);
            var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);

            if (range.end.column === 0) {
                var text = session.getTextRange(range);
                if (text[text.length - 1] == "\n") {
                    var line = session.getLine(range.end.row);
                    if (/^\s+$/.test(line)) {
                        range.end.column = line.length;
                    }
                }
            }
            if (new_range)
                range = new_range;
        }

        this.session.remove(range);
        this.clearSelection();
    };
    this.removeWordRight = function() {
        if (this.selection.isEmpty())
            this.selection.selectWordRight();

        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    };
    this.removeWordLeft = function() {
        if (this.selection.isEmpty())
            this.selection.selectWordLeft();

        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    };
    this.removeToLineStart = function() {
        if (this.selection.isEmpty())
            this.selection.selectLineStart();

        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    };
    this.removeToLineEnd = function() {
        if (this.selection.isEmpty())
            this.selection.selectLineEnd();

        var range = this.getSelectionRange();
        if (range.start.column == range.end.column && range.start.row == range.end.row) {
            range.end.column = 0;
            range.end.row++;
        }

        this.session.remove(range);
        this.clearSelection();
    };
    this.splitLine = function() {
        if (!this.selection.isEmpty()) {
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
        }

        var cursor = this.getCursorPosition();
        this.insert("\n");
        this.moveCursorToPosition(cursor);
    };
    this.transposeLetters = function() {
        if (!this.selection.isEmpty()) {
            return;
        }

        var cursor = this.getCursorPosition();
        var column = cursor.column;
        if (column === 0)
            return;

        var line = this.session.getLine(cursor.row);
        var swap, range;
        if (column < line.length) {
            swap = line.charAt(column) + line.charAt(column-1);
            range = new Range(cursor.row, column-1, cursor.row, column+1);
        }
        else {
            swap = line.charAt(column-1) + line.charAt(column-2);
            range = new Range(cursor.row, column-2, cursor.row, column);
        }
        this.session.replace(range, swap);
    };
    this.toLowerCase = function() {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
            this.selection.selectWord();
        }

        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toLowerCase());
        this.selection.setSelectionRange(originalRange);
    };
    this.toUpperCase = function() {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
            this.selection.selectWord();
        }

        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toUpperCase());
        this.selection.setSelectionRange(originalRange);
    };
    this.indent = function() {
        var session = this.session;
        var range = this.getSelectionRange();

        if (range.start.row < range.end.row) {
            var rows = this.$getSelectedRows();
            session.indentRows(rows.first, rows.last, "\t");
            return;
        } else if (range.start.column < range.end.column) {
            var text = session.getTextRange(range);
            if (!/^\s+$/.test(text)) {
                var rows = this.$getSelectedRows();
                session.indentRows(rows.first, rows.last, "\t");
                return;
            }
        }
        
        var line = session.getLine(range.start.row);
        var position = range.start;
        var size = session.getTabSize();
        var column = session.documentToScreenColumn(position.row, position.column);

        if (this.session.getUseSoftTabs()) {
            var count = (size - column % size);
            var indentString = lang.stringRepeat(" ", count);
        } else {
            var count = column % size;
            while (line[range.start.column] == " " && count) {
                range.start.column--;
                count--;
            }
            this.selection.setSelectionRange(range);
            indentString = "\t";
        }
        return this.insert(indentString);
    };
    this.blockIndent = function() {
        var rows = this.$getSelectedRows();
        this.session.indentRows(rows.first, rows.last, "\t");
    };
    this.blockOutdent = function() {
        var selection = this.session.getSelection();
        this.session.outdentRows(selection.getRange());
    };
    this.sortLines = function() {
        var rows = this.$getSelectedRows();
        var session = this.session;

        var lines = [];
        for (i = rows.first; i <= rows.last; i++)
            lines.push(session.getLine(i));

        lines.sort(function(a, b) {
            if (a.toLowerCase() < b.toLowerCase()) return -1;
            if (a.toLowerCase() > b.toLowerCase()) return 1;
            return 0;
        });

        var deleteRange = new Range(0, 0, 0, 0);
        for (var i = rows.first; i <= rows.last; i++) {
            var line = session.getLine(i);
            deleteRange.start.row = i;
            deleteRange.end.row = i;
            deleteRange.end.column = line.length;
            session.replace(deleteRange, lines[i-rows.first]);
        }
    };
    this.toggleCommentLines = function() {
        var state = this.session.getState(this.getCursorPosition().row);
        var rows = this.$getSelectedRows();
        this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
    };

    this.toggleBlockComment = function() {
        var cursor = this.getCursorPosition();
        var state = this.session.getState(cursor.row);
        var range = this.getSelectionRange();
        this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
    };
    this.getNumberAt = function(row, column) {
        var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
        _numberRx.lastIndex = 0;

        var s = this.session.getLine(row);
        while (_numberRx.lastIndex < column) {
            var m = _numberRx.exec(s);
            if(m.index <= column && m.index+m[0].length >= column){
                var number = {
                    value: m[0],
                    start: m.index,
                    end: m.index+m[0].length
                };
                return number;
            }
        }
        return null;
    };
    this.modifyNumber = function(amount) {
        var row = this.selection.getCursor().row;
        var column = this.selection.getCursor().column;
        var charRange = new Range(row, column-1, row, column);

        var c = this.session.getTextRange(charRange);
        if (!isNaN(parseFloat(c)) && isFinite(c)) {
            var nr = this.getNumberAt(row, column);
            if (nr) {
                var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
                var decimals = nr.start + nr.value.length - fp;

                var t = parseFloat(nr.value);
                t *= Math.pow(10, decimals);


                if(fp !== nr.end && column < fp){
                    amount *= Math.pow(10, nr.end - column - 1);
                } else {
                    amount *= Math.pow(10, nr.end - column);
                }

                t += amount;
                t /= Math.pow(10, decimals);
                var nnr = t.toFixed(decimals);
                var replaceRange = new Range(row, nr.start, row, nr.end);
                this.session.replace(replaceRange, nnr);
                this.moveCursorTo(row, Math.max(nr.start +1, column + nnr.length - nr.value.length));

            }
        }
    };
    this.removeLines = function() {
        var rows = this.$getSelectedRows();
        var range;
        if (rows.first === 0 || rows.last+1 < this.session.getLength())
            range = new Range(rows.first, 0, rows.last+1, 0);
        else
            range = new Range(
                rows.first-1, this.session.getLine(rows.first-1).length,
                rows.last, this.session.getLine(rows.last).length
            );
        this.session.remove(range);
        this.clearSelection();
    };

    this.duplicateSelection = function() {
        var sel = this.selection;
        var doc = this.session;
        var range = sel.getRange();
        var reverse = sel.isBackwards();
        if (range.isEmpty()) {
            var row = range.start.row;
            doc.duplicateLines(row, row);
        } else {
            var point = reverse ? range.start : range.end;
            var endPoint = doc.insert(point, doc.getTextRange(range), false);
            range.start = point;
            range.end = endPoint;

            sel.setSelectionRange(range, reverse);
        }
    };
    this.moveLinesDown = function() {
        this.$moveLines(function(firstRow, lastRow) {
            return this.session.moveLinesDown(firstRow, lastRow);
        });
    };
    this.moveLinesUp = function() {
        this.$moveLines(function(firstRow, lastRow) {
            return this.session.moveLinesUp(firstRow, lastRow);
        });
    };
    this.moveText = function(range, toPosition, copy) {
        return this.session.moveText(range, toPosition, copy);
    };
    this.copyLinesUp = function() {
        this.$moveLines(function(firstRow, lastRow) {
            this.session.duplicateLines(firstRow, lastRow);
            return 0;
        });
    };
    this.copyLinesDown = function() {
        this.$moveLines(function(firstRow, lastRow) {
            return this.session.duplicateLines(firstRow, lastRow);
        });
    };
    this.$moveLines = function(mover) {
        var selection = this.selection;
        if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
            var range = selection.toOrientedRange();
            var rows = this.$getSelectedRows(range);
            var linesMoved = mover.call(this, rows.first, rows.last);
            range.moveBy(linesMoved, 0);
            selection.fromOrientedRange(range);
        } else {
            var ranges = selection.rangeList.ranges;
            selection.rangeList.detach(this.session);

            for (var i = ranges.length; i--; ) {
                var rangeIndex = i;
                var rows = ranges[i].collapseRows();
                var last = rows.end.row;
                var first = rows.start.row;
                while (i--) {
                    rows = ranges[i].collapseRows();
                    if (first - rows.end.row <= 1)
                        first = rows.end.row;
                    else
                        break;
                }
                i++;

                var linesMoved = mover.call(this, first, last);
                while (rangeIndex >= i) {
                    ranges[rangeIndex].moveBy(linesMoved, 0);
                    rangeIndex--;
                }
            }
            selection.fromOrientedRange(selection.ranges[0]);
            selection.rangeList.attach(this.session);
        }
    };
    this.$getSelectedRows = function() {
        var range = this.getSelectionRange().collapseRows();

        return {
            first: this.session.getRowFoldStart(range.start.row),
            last: this.session.getRowFoldEnd(range.end.row)
        };
    };

    this.onCompositionStart = function(text) {
        this.renderer.showComposition(this.getCursorPosition());
    };

    this.onCompositionUpdate = function(text) {
        this.renderer.setCompositionText(text);
    };

    this.onCompositionEnd = function() {
        this.renderer.hideComposition();
    };
    this.getFirstVisibleRow = function() {
        return this.renderer.getFirstVisibleRow();
    };
    this.getLastVisibleRow = function() {
        return this.renderer.getLastVisibleRow();
    };
    this.isRowVisible = function(row) {
        return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());
    };
    this.isRowFullyVisible = function(row) {
        return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());
    };
    this.$getVisibleRowCount = function() {
        return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
    };

    this.$moveByPage = function(dir, select) {
        var renderer = this.renderer;
        var config = this.renderer.layerConfig;
        var rows = dir * Math.floor(config.height / config.lineHeight);

        this.$blockScrolling++;
        if (select === true) {
            this.selection.$moveSelection(function(){
                this.moveCursorBy(rows, 0);
            });
        } else if (select === false) {
            this.selection.moveCursorBy(rows, 0);
            this.selection.clearSelection();
        }
        this.$blockScrolling--;

        var scrollTop = renderer.scrollTop;

        renderer.scrollBy(0, rows * config.lineHeight);
        if (select != null)
            renderer.scrollCursorIntoView(null, 0.5);

        renderer.animateScrolling(scrollTop);
    };
    this.selectPageDown = function() {
        this.$moveByPage(1, true);
    };
    this.selectPageUp = function() {
        this.$moveByPage(-1, true);
    };
    this.gotoPageDown = function() {
       this.$moveByPage(1, false);
    };
    this.gotoPageUp = function() {
        this.$moveByPage(-1, false);
    };
    this.scrollPageDown = function() {
        this.$moveByPage(1);
    };
    this.scrollPageUp = function() {
        this.$moveByPage(-1);
    };
    this.scrollToRow = function(row) {
        this.renderer.scrollToRow(row);
    };
    this.scrollToLine = function(line, center, animate, callback) {
        this.renderer.scrollToLine(line, center, animate, callback);
    };
    this.centerSelection = function() {
        var range = this.getSelectionRange();
        var pos = {
            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
        };
        this.renderer.alignCursor(pos, 0.5);
    };
    this.getCursorPosition = function() {
        return this.selection.getCursor();
    };
    this.getCursorPositionScreen = function() {
        return this.session.documentToScreenPosition(this.getCursorPosition());
    };
    this.getSelectionRange = function() {
        return this.selection.getRange();
    };
    this.selectAll = function() {
        this.$blockScrolling += 1;
        this.selection.selectAll();
        this.$blockScrolling -= 1;
    };
    this.clearSelection = function() {
        this.selection.clearSelection();
    };
    this.moveCursorTo = function(row, column) {
        this.selection.moveCursorTo(row, column);
    };
    this.moveCursorToPosition = function(pos) {
        this.selection.moveCursorToPosition(pos);
    };
    this.jumpToMatching = function(select) {
        var cursor = this.getCursorPosition();

        var range = this.session.getBracketRange(cursor);
        if (!range) {
            range = this.find({
                needle: /[{}()\[\]]/g,
                preventScroll:true,
                start: {row: cursor.row, column: cursor.column - 1}
            });
            if (!range)
                return;
            var pos = range.start;
            if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2)
                range = this.session.getBracketRange(pos);
        }

        pos = range && range.cursor || pos;
        if (pos) {
            if (select) {
                if (range && range.isEqual(this.getSelectionRange()))
                    this.clearSelection();
                else
                    this.selection.selectTo(pos.row, pos.column);
            } else {
                this.clearSelection();
                this.moveCursorTo(pos.row, pos.column);
            }
        }
    };
    this.gotoLine = function(lineNumber, column, animate) {
        this.selection.clearSelection();
        this.session.unfold({row: lineNumber - 1, column: column || 0});

        this.$blockScrolling += 1;
        this.exitMultiSelectMode && this.exitMultiSelectMode();
        this.moveCursorTo(lineNumber - 1, column || 0);
        this.$blockScrolling -= 1;

        if (!this.isRowFullyVisible(lineNumber - 1))
            this.scrollToLine(lineNumber - 1, true, animate);
    };
    this.navigateTo = function(row, column) {
        this.clearSelection();
        this.moveCursorTo(row, column);
    };
    this.navigateUp = function(times) {
        if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
            var selectionStart = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionStart);
        }
        this.selection.clearSelection();
        times = times || 1;
        this.selection.moveCursorBy(-times, 0);
    };
    this.navigateDown = function(times) {
        if (this.selection.isMultiLine() && this.selection.isBackwards()) {
            var selectionEnd = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionEnd);
        }
        this.selection.clearSelection();
        times = times || 1;
        this.selection.moveCursorBy(times, 0);
    };
    this.navigateLeft = function(times) {
        if (!this.selection.isEmpty()) {
            var selectionStart = this.getSelectionRange().start;
            this.moveCursorToPosition(selectionStart);
        }
        else {
            times = times || 1;
            while (times--) {
                this.selection.moveCursorLeft();
            }
        }
        this.clearSelection();
    };
    this.navigateRight = function(times) {
        if (!this.selection.isEmpty()) {
            var selectionEnd = this.getSelectionRange().end;
            this.moveCursorToPosition(selectionEnd);
        }
        else {
            times = times || 1;
            while (times--) {
                this.selection.moveCursorRight();
            }
        }
        this.clearSelection();
    };
    this.navigateLineStart = function() {
        this.selection.moveCursorLineStart();
        this.clearSelection();
    };
    this.navigateLineEnd = function() {
        this.selection.moveCursorLineEnd();
        this.clearSelection();
    };
    this.navigateFileEnd = function() {
        this.selection.moveCursorFileEnd();
        this.clearSelection();
    };
    this.navigateFileStart = function() {
        this.selection.moveCursorFileStart();
        this.clearSelection();
    };
    this.navigateWordRight = function() {
        this.selection.moveCursorWordRight();
        this.clearSelection();
    };
    this.navigateWordLeft = function() {
        this.selection.moveCursorWordLeft();
        this.clearSelection();
    };
    this.replace = function(replacement, options) {
        if (options)
            this.$search.set(options);

        var range = this.$search.find(this.session);
        var replaced = 0;
        if (!range)
            return replaced;

        if (this.$tryReplace(range, replacement)) {
            replaced = 1;
        }
        if (range !== null) {
            this.selection.setSelectionRange(range);
            this.renderer.scrollSelectionIntoView(range.start, range.end);
        }

        return replaced;
    };
    this.replaceAll = function(replacement, options) {
        if (options) {
            this.$search.set(options);
        }

        var ranges = this.$search.findAll(this.session);
        var replaced = 0;
        if (!ranges.length)
            return replaced;

        this.$blockScrolling += 1;

        var selection = this.getSelectionRange();
        this.clearSelection();
        this.selection.moveCursorTo(0, 0);

        for (var i = ranges.length - 1; i >= 0; --i) {
            if(this.$tryReplace(ranges[i], replacement)) {
                replaced++;
            }
        }

        this.selection.setSelectionRange(selection);
        this.$blockScrolling -= 1;

        return replaced;
    };

    this.$tryReplace = function(range, replacement) {
        var input = this.session.getTextRange(range);
        replacement = this.$search.replace(input, replacement);
        if (replacement !== null) {
            range.end = this.session.replace(range, replacement);
            return range;
        } else {
            return null;
        }
    };
    this.getLastSearchOptions = function() {
        return this.$search.getOptions();
    };
    this.find = function(needle, options, animate) {
        if (!options)
            options = {};

        if (typeof needle == "string" || needle instanceof RegExp)
            options.needle = needle;
        else if (typeof needle == "object")
            oop.mixin(options, needle);

        var range = this.selection.getRange();
        if (options.needle == null) {
            needle = this.session.getTextRange(range)
                || this.$search.$options.needle;
            if (!needle) {
                range = this.session.getWordRange(range.start.row, range.start.column);
                needle = this.session.getTextRange(range);
            }
            this.$search.set({needle: needle});
        }

        this.$search.set(options);
        if (!options.start)
            this.$search.set({start: range});

        var newRange = this.$search.find(this.session);
        if (options.preventScroll)
            return newRange;
        if (newRange) {
            this.revealRange(newRange, animate);
            return newRange;
        }
        if (options.backwards)
            range.start = range.end;
        else
            range.end = range.start;
        this.selection.setRange(range);
    };
    this.findNext = function(options, animate) {
        this.find({skipCurrent: true, backwards: false}, options, animate);
    };
    this.findPrevious = function(options, animate) {
        this.find(options, {skipCurrent: true, backwards: true}, animate);
    };

    this.revealRange = function(range, animate) {
        this.$blockScrolling += 1;
        this.session.unfold(range);
        this.selection.setSelectionRange(range);
        this.$blockScrolling -= 1;

        var scrollTop = this.renderer.scrollTop;
        this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
        if (animate !== false)
            this.renderer.animateScrolling(scrollTop);
    };
    this.undo = function() {
        this.$blockScrolling++;
        this.session.getUndoManager().undo();
        this.$blockScrolling--;
        this.renderer.scrollCursorIntoView(null, 0.5);
    };
    this.redo = function() {
        this.$blockScrolling++;
        this.session.getUndoManager().redo();
        this.$blockScrolling--;
        this.renderer.scrollCursorIntoView(null, 0.5);
    };
    this.destroy = function() {
        this.renderer.destroy();
        this._emit("destroy", this);
    };
    this.setAutoScrollEditorIntoView = function(enable) {
        if (enable === false)
            return;
        var rect;
        var self = this;
        var shouldScroll = false;
        if (!this.$scrollAnchor)
            this.$scrollAnchor = document.createElement("div");
        var scrollAnchor = this.$scrollAnchor;
        scrollAnchor.style.cssText = "position:absolute";
        this.container.insertBefore(scrollAnchor, this.container.firstChild);
        var onChangeSelection = this.on("changeSelection", function() {
            shouldScroll = true;
        });
        var onBeforeRender = this.renderer.on("beforeRender", function() {
            if (shouldScroll)
                rect = self.renderer.container.getBoundingClientRect();
        });
        var onAfterRender = this.renderer.on("afterRender", function() {
            if (shouldScroll && rect && self.isFocused()) {
                var renderer = self.renderer;
                var pos = renderer.$cursorLayer.$pixelPos;
                var config = renderer.layerConfig;
                var top = pos.top - config.offset;
                if (pos.top >= 0 && top + rect.top < 0) {
                    shouldScroll = true;
                } else if (pos.top < config.height &&
                    pos.top + rect.top + config.lineHeight > window.innerHeight) {
                    shouldScroll = false;
                } else {
                    shouldScroll = null;
                }
                if (shouldScroll != null) {
                    scrollAnchor.style.top = top + "px";
                    scrollAnchor.style.left = pos.left + "px";
                    scrollAnchor.style.height = config.lineHeight + "px";
                    scrollAnchor.scrollIntoView(shouldScroll);
                }
                shouldScroll = rect = null;
            }
        });
        this.setAutoScrollEditorIntoView = function(enable) {
            if (enable === true)
                return;
            delete this.setAutoScrollEditorIntoView;
            this.removeEventListener("changeSelection", onChangeSelection);
            this.renderer.removeEventListener("afterRender", onAfterRender);
            this.renderer.removeEventListener("beforeRender", onBeforeRender);
        };
    };


    this.$resetCursorStyle = function() {
        var style = this.$cursorStyle || "ace";
        var cursorLayer = this.renderer.$cursorLayer;
        if (!cursorLayer)
            return;
        cursorLayer.setSmoothBlinking(style == "smooth");
        cursorLayer.isBlinking = !this.$readOnly && style != "wide";
    };

}).call(Editor.prototype);



config.defineOptions(Editor.prototype, "editor", {
    selectionStyle: {
        set: function(style) {
            this.onSelectionChange();
            this._emit("changeSelectionStyle", {data: style});
        },
        initialValue: "line"
    },
    highlightActiveLine: {
        set: function() {this.$updateHighlightActiveLine();},
        initialValue: true
    },
    highlightSelectedWord: {
        set: function(shouldHighlight) {this.$onSelectionChange();},
        initialValue: true
    },
    readOnly: {
        set: function(readOnly) {
            this.textInput.setReadOnly(readOnly); 
            this.$resetCursorStyle(); 
        },
        initialValue: false
    },
    cursorStyle: {
        set: function(val) { this.$resetCursorStyle(); },
        values: ["ace", "slim", "smooth", "wide"],
        initialValue: "ace"
    },
    mergeUndoDeltas: {
        values: [false, true, "always"],
        initialValue: true
    },
    behavioursEnabled: {initialValue: true},
    wrapBehavioursEnabled: {initialValue: true},

    hScrollBarAlwaysVisible: "renderer",
    vScrollBarAlwaysVisible: "renderer",
    highlightGutterLine: "renderer",
    animatedScroll: "renderer",
    showInvisibles: "renderer",
    showPrintMargin: "renderer",
    printMarginColumn: "renderer",
    printMargin: "renderer",
    fadeFoldWidgets: "renderer",
    showFoldWidgets: "renderer",
    showGutter: "renderer",
    displayIndentGuides: "renderer",
    fontSize: "renderer",
    fontFamily: "renderer",
    maxLines: "renderer",
    minLines: "renderer",
    scrollPastEnd: "renderer",
    fixedWidthGutter: "renderer",
    theme: "renderer",

    scrollSpeed: "$mouseHandler",
    dragDelay: "$mouseHandler",
    dragEnabled: "$mouseHandler",
    focusTimout: "$mouseHandler",

    firstLineNumber: "session",
    overwrite: "session",
    newLineMode: "session",
    useWorker: "session",
    useSoftTabs: "session",
    tabSize: "session",
    wrap: "session",
    foldStyle: "session",
    mode: "session"
});

exports.Editor = Editor;
});

consoleAce.define('ace/lib/lang', ['require', 'exports', 'module' ], function(require, exports, module) {


exports.stringReverse = function(string) {
    return string.split("").reverse().join("");
};

exports.stringRepeat = function (string, count) {
    var result = '';
    while (count > 0) {
        if (count & 1)
            result += string;

        if (count >>= 1)
            string += string;
    }
    return result;
};

var trimBeginRegexp = /^\s\s*/;
var trimEndRegexp = /\s\s*$/;

exports.stringTrimLeft = function (string) {
    return string.replace(trimBeginRegexp, '');
};

exports.stringTrimRight = function (string) {
    return string.replace(trimEndRegexp, '');
};

exports.copyObject = function(obj) {
    var copy = {};
    for (var key in obj) {
        copy[key] = obj[key];
    }
    return copy;
};

exports.copyArray = function(array){
    var copy = [];
    for (var i=0, l=array.length; i<l; i++) {
        if (array[i] && typeof array[i] == "object")
            copy[i] = this.copyObject( array[i] );
        else 
            copy[i] = array[i];
    }
    return copy;
};

exports.deepCopy = function (obj) {
    if (typeof obj !== "object" || !obj)
        return obj;
    var cons = obj.constructor;
    if (cons === RegExp)
        return obj;
    
    var copy = cons();
    for (var key in obj) {
        if (typeof obj[key] === "object") {
            copy[key] = exports.deepCopy(obj[key]);
        } else {
            copy[key] = obj[key];
        }
    }
    return copy;
};

exports.arrayToMap = function(arr) {
    var map = {};
    for (var i=0; i<arr.length; i++) {
        map[arr[i]] = 1;
    }
    return map;

};

exports.createMap = function(props) {
    var map = Object.create(null);
    for (var i in props) {
        map[i] = props[i];
    }
    return map;
};
exports.arrayRemove = function(array, value) {
  for (var i = 0; i <= array.length; i++) {
    if (value === array[i]) {
      array.splice(i, 1);
    }
  }
};

exports.escapeRegExp = function(str) {
    return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
};

exports.escapeHTML = function(str) {
    return str.replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
};

exports.getMatchOffsets = function(string, regExp) {
    var matches = [];

    string.replace(regExp, function(str) {
        matches.push({
            offset: arguments[arguments.length-2],
            length: str.length
        });
    });

    return matches;
};
exports.deferredCall = function(fcn) {

    var timer = null;
    var callback = function() {
        timer = null;
        fcn();
    };

    var deferred = function(timeout) {
        deferred.cancel();
        timer = setTimeout(callback, timeout || 0);
        return deferred;
    };

    deferred.schedule = deferred;

    deferred.call = function() {
        this.cancel();
        fcn();
        return deferred;
    };

    deferred.cancel = function() {
        clearTimeout(timer);
        timer = null;
        return deferred;
    };
    
    deferred.isPending = function() {
        return timer;
    };

    return deferred;
};


exports.delayedCall = function(fcn, defaultTimeout) {
    var timer = null;
    var callback = function() {
        timer = null;
        fcn();
    };

    var _self = function(timeout) {
        if (timer == null)
            timer = setTimeout(callback, timeout || defaultTimeout);
    };

    _self.delay = function(timeout) {
        timer && clearTimeout(timer);
        timer = setTimeout(callback, timeout || defaultTimeout);
    };
    _self.schedule = _self;

    _self.call = function() {
        this.cancel();
        fcn();
    };

    _self.cancel = function() {
        timer && clearTimeout(timer);
        timer = null;
    };

    _self.isPending = function() {
        return timer;
    };

    return _self;
};
});

consoleAce.define('ace/keyboard/textinput', ['require', 'exports', 'module' , 'ace/lib/event', 'ace/lib/useragent', 'ace/lib/dom', 'ace/lib/lang'], function(require, exports, module) {


var event = require("../lib/event");
var useragent = require("../lib/useragent");
var dom = require("../lib/dom");
var lang = require("../lib/lang");
var BROKEN_SETDATA = useragent.isChrome < 18;

var TextInput = function(parentNode, host) {
    var text = dom.createElement("textarea");
    text.className = "ace_text-input";

    if (useragent.isTouchPad)
        text.setAttribute("x-palm-disable-auto-cap", true);

    text.wrap = "off";
    text.autocorrect = "off";
    text.autocapitalize = "off";
    text.spellcheck = false;

    text.style.opacity = "0";
    parentNode.insertBefore(text, parentNode.firstChild);

    var PLACEHOLDER = "\x01\x01";

    var cut = false;
    var copied = false;
    var pasted = false;
    var inComposition = false;
    var tempStyle = '';
    var isSelectionEmpty = true;
    try { var isFocused = document.activeElement === text; } catch(e) {}
    
    event.addListener(text, "blur", function() {
        host.onBlur();
        isFocused = false;
    });
    event.addListener(text, "focus", function() {
        isFocused = true;
        host.onFocus();
        resetSelection();
    });
    this.focus = function() { text.focus(); };
    this.blur = function() { text.blur(); };
    this.isFocused = function() {
        return isFocused;
    };
    var syncSelection = lang.delayedCall(function() {
        isFocused && resetSelection(isSelectionEmpty);
    });
    var syncValue = lang.delayedCall(function() {
         if (!inComposition) {
            text.value = PLACEHOLDER;
            isFocused && resetSelection();
         }
    });

    function resetSelection(isEmpty) {
        if (inComposition)
            return;
        if (inputHandler) {
            selectionStart = 0;
            selectionEnd = isEmpty ? 0 : text.value.length - 1;
        } else {
            var selectionStart = isEmpty ? 2 : 1;
            var selectionEnd = 2;
        }
        try {
            text.setSelectionRange(selectionStart, selectionEnd);
        } catch(e){}
    }

    function resetValue() {
        if (inComposition)
            return;
        text.value = PLACEHOLDER;
        if (useragent.isWebKit)
            syncValue.schedule();
    }

    useragent.isWebKit || host.addEventListener('changeSelection', function() {
        if (host.selection.isEmpty() != isSelectionEmpty) {
            isSelectionEmpty = !isSelectionEmpty;
            syncSelection.schedule();
        }
    });

    resetValue();
    if (isFocused)
        host.onFocus();


    var isAllSelected = function(text) {
        return text.selectionStart === 0 && text.selectionEnd === text.value.length;
    };
    if (!text.setSelectionRange && text.createTextRange) {
        text.setSelectionRange = function(selectionStart, selectionEnd) {
            var range = this.createTextRange();
            range.collapse(true);
            range.moveStart('character', selectionStart);
            range.moveEnd('character', selectionEnd);
            range.select();
        };
        isAllSelected = function(text) {
            try {
                var range = text.ownerDocument.selection.createRange();
            }catch(e) {}
            if (!range || range.parentElement() != text) return false;
                return range.text == text.value;
        }
    }
    if (useragent.isOldIE) {
        var inPropertyChange = false;
        var onPropertyChange = function(e){
            if (inPropertyChange)
                return;
            var data = text.value;
            if (inComposition || !data || data == PLACEHOLDER)
                return;
            if (e && data == PLACEHOLDER[0])
                return syncProperty.schedule();

            sendText(data);
            inPropertyChange = true;
            resetValue();
            inPropertyChange = false;
        };
        var syncProperty = lang.delayedCall(onPropertyChange);
        event.addListener(text, "propertychange", onPropertyChange);

        var keytable = { 13:1, 27:1 };
        event.addListener(text, "keyup", function (e) {
            if (inComposition && (!text.value || keytable[e.keyCode]))
                setTimeout(onCompositionEnd, 0);
            if ((text.value.charCodeAt(0)||0) < 129) {
                return syncProperty.call();
            }
            inComposition ? onCompositionUpdate() : onCompositionStart();
        });
        event.addListener(text, "keydown", function (e) {
            syncProperty.schedule(50);
        });
    }

    var onSelect = function(e) {
        if (cut) {
            cut = false;
        } else if (copied) {
            copied = false;
        } else if (isAllSelected(text)) {
            host.selectAll();
            resetSelection();
        } else if (inputHandler) {
            resetSelection(host.selection.isEmpty());
        }
    };

    var inputHandler = null;
    this.setInputHandler = function(cb) {inputHandler = cb};
    this.getInputHandler = function() {return inputHandler};
    var afterContextMenu = false;
    
    var sendText = function(data) {
        if (inputHandler) {
            data = inputHandler(data);
            inputHandler = null;
        }
        if (pasted) {
            resetSelection();
            if (data)
                host.onPaste(data);
            pasted = false;
        } else if (data == PLACEHOLDER.charAt(0)) {
            if (afterContextMenu)
                host.execCommand("del", {source: "ace"});
            else // some versions of android do not fire keydown when pressing backspace
                host.execCommand("backspace", {source: "ace"});
        } else {
            if (data.substring(0, 2) == PLACEHOLDER)
                data = data.substr(2);
            else if (data.charAt(0) == PLACEHOLDER.charAt(0))
                data = data.substr(1);
            else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
                data = data.slice(0, -1);
            if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
                data = data.slice(0, -1);
            
            if (data)
                host.onTextInput(data);
        }
        if (afterContextMenu)
            afterContextMenu = false;
    };
    var onInput = function(e) {
        if (inComposition)
            return;
        var data = text.value;
        sendText(data);
        resetValue();
    };

    var onCut = function(e) {
        var data = host.getCopyText();
        if (!data) {
            event.preventDefault(e);
            return;
        }

        var clipboardData = e.clipboardData || window.clipboardData;

        if (clipboardData && !BROKEN_SETDATA) {
            var supported = clipboardData.setData("Text", data);
            if (supported) {
                host.onCut();
                event.preventDefault(e);
            }
        }

        if (!supported) {
            cut = true;
            text.value = data;
            text.select();
            setTimeout(function(){
                cut = false;
                resetValue();
                resetSelection();
                host.onCut();
            });
        }
    };

    var onCopy = function(e) {
        var data = host.getCopyText();
        if (!data) {
            event.preventDefault(e);
            return;
        }

        var clipboardData = e.clipboardData || window.clipboardData;
        if (clipboardData && !BROKEN_SETDATA) {
            var supported = clipboardData.setData("Text", data);
            if (supported) {
                host.onCopy();
                event.preventDefault(e);
            }
        }
        if (!supported) {
            copied = true;
            text.value = data;
            text.select();
            setTimeout(function(){
                copied = false;
                resetValue();
                resetSelection();
                host.onCopy();
            });
        }
    };

    var onPaste = function(e) {
        var clipboardData = e.clipboardData || window.clipboardData;

        if (clipboardData) {
            var data = clipboardData.getData("Text");
            if (data)
                host.onPaste(data);
            if (useragent.isIE)
                setTimeout(resetSelection);
            event.preventDefault(e);
        }
        else {
            text.value = "";
            pasted = true;
        }
    };

    event.addCommandKeyListener(text, host.onCommandKey.bind(host));

    event.addListener(text, "select", onSelect);

    event.addListener(text, "input", onInput);

    event.addListener(text, "cut", onCut);
    event.addListener(text, "copy", onCopy);
    event.addListener(text, "paste", onPaste);
    if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)){
        event.addListener(parentNode, "keydown", function(e) {
            if ((useragent.isMac && !e.metaKey) || !e.ctrlKey)
            return;

            switch (e.keyCode) {
                case 67:
                    onCopy(e);
                    break;
                case 86:
                    onPaste(e);
                    break;
                case 88:
                    onCut(e);
                    break;
            }
        });
    }
    var onCompositionStart = function(e) {
        if (inComposition) return;
        inComposition = {};
        host.onCompositionStart();
        setTimeout(onCompositionUpdate, 0);
        host.on("mousedown", onCompositionEnd);
        if (!host.selection.isEmpty()) {
            host.insert("");
            host.session.markUndoGroup();
            host.selection.clearSelection();
        }
        host.session.markUndoGroup();
    };

    var onCompositionUpdate = function() {
        if (!inComposition) return;
        var val = text.value.replace(/\x01/g, "");
        if (inComposition.lastValue === val) return;
        
        host.onCompositionUpdate(val);
        if (inComposition.lastValue)
            host.undo();
        inComposition.lastValue = val;
        if (inComposition.lastValue) {
            var r = host.selection.getRange();
            host.insert(inComposition.lastValue);
            host.session.markUndoGroup();
            inComposition.range = host.selection.getRange();
            host.selection.setRange(r);
            host.selection.clearSelection();
        }
    };

    var onCompositionEnd = function(e) {
        var c = inComposition;
        inComposition = false;
        var timer = setTimeout(function() {
            timer = null;
            var str = text.value.replace(/\x01/g, "");
            if (inComposition)
                return
            else if (str == c.lastValue)
                resetValue();
            else if (!c.lastValue && str) {
                resetValue();
                sendText(str);
            }
        });
        inputHandler = function compositionInputHandler(str) {
            if (timer)
                clearTimeout(timer);
            str = str.replace(/\x01/g, "");
            if (str == c.lastValue)
                return "";
            if (c.lastValue && timer)
                host.undo();
            return str;
        };
        host.onCompositionEnd();
        host.removeListener("mousedown", onCompositionEnd);
        if (e.type == "compositionend" && c.range) {
            host.selection.setRange(c.range);
        }
    };
    
    

    var syncComposition = lang.delayedCall(onCompositionUpdate, 50);

    event.addListener(text, "compositionstart", onCompositionStart);
    if (useragent.isGecko) {
        event.addListener(text, "text", function(){syncComposition.schedule()});
    } else {
        event.addListener(text, "keyup", function(){syncComposition.schedule()});
        event.addListener(text, "keydown", function(){syncComposition.schedule()});
    }
    event.addListener(text, "compositionend", onCompositionEnd);

    this.getElement = function() {
        return text;
    };

    this.setReadOnly = function(readOnly) {
       text.readOnly = readOnly;
    };

    this.onContextMenu = function(e) {
        afterContextMenu = true;
        if (!tempStyle)
            tempStyle = text.style.cssText;

        text.style.cssText = "z-index:100000;" + (useragent.isIE ? "opacity:0.1;" : "");

        resetSelection(host.selection.isEmpty());
        host._emit("nativecontextmenu", {target: host, domEvent: e});
        var rect = host.container.getBoundingClientRect();
        var style = dom.computedStyle(host.container);
        var top = rect.top + (parseInt(style.borderTopWidth) || 0);
        var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
        var maxTop = rect.bottom - top - text.clientHeight;
        var move = function(e) {
            text.style.left = e.clientX - left - 2 + "px";
            text.style.top = Math.min(e.clientY - top - 2, maxTop) + "px";
        }; 
        move(e);

        if (e.type != "mousedown")
            return;

        if (host.renderer.$keepTextAreaAtCursor)
            host.renderer.$keepTextAreaAtCursor = null;
        if (useragent.isWin)
            event.capture(host.container, move, onContextMenuClose);
    };

    this.onContextMenuClose = onContextMenuClose;
    function onContextMenuClose() {
        setTimeout(function () {
            if (tempStyle) {
                text.style.cssText = tempStyle;
                tempStyle = '';
            }
            if (host.renderer.$keepTextAreaAtCursor == null) {
                host.renderer.$keepTextAreaAtCursor = true;
                host.renderer.$moveTextAreaToCursor();
            }
        }, 0);
    }
    if (!useragent.isGecko || useragent.isMac) {
        var onContextMenu = function(e) {
            host.textInput.onContextMenu(e);
            onContextMenuClose();
        };
        event.addListener(host.renderer.scroller, "contextmenu", onContextMenu);
        event.addListener(text, "contextmenu", onContextMenu);
    }
};

exports.TextInput = TextInput;
});

consoleAce.define('ace/mouse/mouse_handler', ['require', 'exports', 'module' , 'ace/lib/event', 'ace/lib/useragent', 'ace/mouse/default_handlers', 'ace/mouse/default_gutter_handler', 'ace/mouse/mouse_event', 'ace/mouse/dragdrop_handler', 'ace/config'], function(require, exports, module) {


var event = require("../lib/event");
var useragent = require("../lib/useragent");
var DefaultHandlers = require("./default_handlers").DefaultHandlers;
var DefaultGutterHandler = require("./default_gutter_handler").GutterHandler;
var MouseEvent = require("./mouse_event").MouseEvent;
var DragdropHandler = require("./dragdrop_handler").DragdropHandler;
var config = require("../config");

var MouseHandler = function(editor) {
    this.editor = editor;

    new DefaultHandlers(this);
    new DefaultGutterHandler(this);
    new DragdropHandler(this);

    var mouseTarget = editor.renderer.getMouseEventTarget();
    event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"));
    event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"));
    event.addMultiMouseDownListener(mouseTarget, [300, 300, 250], this, "onMouseEvent");
    if (editor.renderer.scrollBarV) {
        event.addMultiMouseDownListener(editor.renderer.scrollBarV.inner, [300, 300, 250], this, "onMouseEvent");
        event.addMultiMouseDownListener(editor.renderer.scrollBarH.inner, [300, 300, 250], this, "onMouseEvent");
    }
    event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"));

    var gutterEl = editor.renderer.$gutter;
    event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"));
    event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"));
    event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"));
    event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"));

    event.addListener(mouseTarget, "mousedown", function(e) {
        editor.focus();
    });

    event.addListener(gutterEl, "mousedown", function(e) {
        editor.focus();
        return event.preventDefault(e);
    });
};

(function() {
    this.onMouseEvent = function(name, e) {
        this.editor._emit(name, new MouseEvent(e, this.editor));
    };

    this.onMouseMove = function(name, e) {
        var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
        if (!listeners || !listeners.length)
            return;

        this.editor._emit(name, new MouseEvent(e, this.editor));
    };

    this.onMouseWheel = function(name, e) {
        var mouseEvent = new MouseEvent(e, this.editor);
        mouseEvent.speed = this.$scrollSpeed * 2;
        mouseEvent.wheelX = e.wheelX;
        mouseEvent.wheelY = e.wheelY;

        this.editor._emit(name, mouseEvent);
    };

    this.setState = function(state) {
        this.state = state;
    };

    this.captureMouse = function(ev, mouseMoveHandler) {
        this.x = ev.x;
        this.y = ev.y;

        this.isMousePressed = true;
        var renderer = this.editor.renderer;
        if (renderer.$keepTextAreaAtCursor)
            renderer.$keepTextAreaAtCursor = null;

        var self = this;
        var onMouseMove = function(e) {
            self.x = e.clientX;
            self.y = e.clientY;
            mouseMoveHandler && mouseMoveHandler(e);
            self.mouseEvent = new MouseEvent(e, self.editor);
            self.$mouseMoved = true;
        };

        var onCaptureEnd = function(e) {
            clearInterval(timerId);
            onCaptureInterval();
            self[self.state + "End"] && self[self.state + "End"](e);
            self.$clickSelection = null;
            if (renderer.$keepTextAreaAtCursor == null) {
                renderer.$keepTextAreaAtCursor = true;
                renderer.$moveTextAreaToCursor();
            }
            self.isMousePressed = false;
            self.$onCaptureMouseMove = self.releaseMouse = null;
            self.onMouseEvent("mouseup", e);
        };

        var onCaptureInterval = function() {
            self[self.state] && self[self.state]();
            self.$mouseMoved = false;
        };

        if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
            return setTimeout(function() {onCaptureEnd(ev);});
        }

        self.$onCaptureMouseMove = onMouseMove;
        self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
        var timerId = setInterval(onCaptureInterval, 20);
    };
    this.releaseMouse = null;
}).call(MouseHandler.prototype);

config.defineOptions(MouseHandler.prototype, "mouseHandler", {
    scrollSpeed: {initialValue: 2},
    dragDelay: {initialValue: 150},
    dragEnabled: {initialValue: true},
    focusTimout: {initialValue: 0}
});


exports.MouseHandler = MouseHandler;
});

consoleAce.define('ace/mouse/default_handlers', ['require', 'exports', 'module' , 'ace/lib/dom', 'ace/lib/event', 'ace/lib/useragent'], function(require, exports, module) {


var dom = require("../lib/dom");
var event = require("../lib/event");
var useragent = require("../lib/useragent");

var DRAG_OFFSET = 0; // pixels

function DefaultHandlers(mouseHandler) {
    mouseHandler.$clickSelection = null;

    var editor = mouseHandler.editor;
    editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
    editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
    editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
    editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
    editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));

    var exports = ["select", "startSelect", "selectEnd", "selectAllEnd", "selectByWordsEnd",
        "selectByLinesEnd", "dragWait", "dragWaitEnd", "focusWait"];

    exports.forEach(function(x) {
        mouseHandler[x] = this[x];
    }, this);

    mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
    mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
}

(function() {

    this.onMouseDown = function(ev) {
        var inSelection = ev.inSelection();
        var pos = ev.getDocumentPosition();
        this.mousedownEvent = ev;
        var editor = this.editor;

        var button = ev.getButton();
        if (button !== 0) {
            var selectionRange = editor.getSelectionRange();
            var selectionEmpty = selectionRange.isEmpty();

            if (selectionEmpty) {
                editor.moveCursorToPosition(pos);
                editor.selection.clearSelection();
            }
            editor.textInput.onContextMenu(ev.domEvent);
            return; // stopping event here breaks contextmenu on ff mac
        }
        if (inSelection && !editor.isFocused()) {
            editor.focus();
            if (this.$focusTimout && !this.$clickSelection && !editor.inMultiSelectMode) {
                this.mousedownEvent.time = Date.now();
                this.setState("focusWait");
                this.captureMouse(ev);
                return;
            }
        }

        if (!inSelection || this.$clickSelection || ev.getShiftKey() || editor.inMultiSelectMode) {
            this.startSelect(pos);
        } else if (inSelection) {
            this.mousedownEvent.time = Date.now();
            this.startSelect(pos);
        }
        this.captureMouse(ev);
        return ev.preventDefault();
    };

    this.startSelect = function(pos) {
        pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
        var editor = this.editor;
        var shiftPressed = this.mousedownEvent.getShiftKey();
        if (shiftPressed) {
            editor.selection.selectToPosition(pos);
        }
        else if (!this.$clickSelection) {
            editor.moveCursorToPosition(pos);
            editor.selection.clearSelection();
        }
        if (editor.renderer.scroller.setCapture) {
            editor.renderer.scroller.setCapture();
        }
        editor.setStyle("ace_selecting");
        this.setState("select");
    };

    this.select = function() {
        var anchor, editor = this.editor;
        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);

        if (this.$clickSelection) {
            var cmp = this.$clickSelection.comparePoint(cursor);

            if (cmp == -1) {
                anchor = this.$clickSelection.end;
            } else if (cmp == 1) {
                anchor = this.$clickSelection.start;
            } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
            }
            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
        }
        editor.selection.selectToPosition(cursor);

        editor.renderer.scrollCursorIntoView();
    };

    this.extendSelectionBy = function(unitName) {
        var anchor, editor = this.editor;
        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
        var range = editor.selection[unitName](cursor.row, cursor.column);

        if (this.$clickSelection) {
            var cmpStart = this.$clickSelection.comparePoint(range.start);
            var cmpEnd = this.$clickSelection.comparePoint(range.end);

            if (cmpStart == -1 && cmpEnd <= 0) {
                anchor = this.$clickSelection.end;
                if (range.end.row != cursor.row || range.end.column != cursor.column)
                    cursor = range.start;
            } else if (cmpEnd == 1 && cmpStart >= 0) {
                anchor = this.$clickSelection.start;
                if (range.start.row != cursor.row || range.start.column != cursor.column)
                    cursor = range.end;
            } else if (cmpStart == -1 && cmpEnd == 1) {
                cursor = range.end;
                anchor = range.start;
            } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
            }
            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
        }
        editor.selection.selectToPosition(cursor);

        editor.renderer.scrollCursorIntoView();
    };

    this.selectEnd =
    this.selectAllEnd =
    this.selectByWordsEnd =
    this.selectByLinesEnd = function() {
        this.editor.unsetStyle("ace_selecting");
        if (this.editor.renderer.scroller.releaseCapture) {
            this.editor.renderer.scroller.releaseCapture();
        }
    };

    this.focusWait = function() {
        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
        var time = Date.now();

        if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimout)
            this.startSelect(this.mousedownEvent.getDocumentPosition());
    };

    this.onDoubleClick = function(ev) {
        var pos = ev.getDocumentPosition();
        var editor = this.editor;
        var session = editor.session;

        var range = session.getBracketRange(pos);
        if (range) {
            if (range.isEmpty()) {
                range.start.column--;
                range.end.column++;
            }
            this.setState("select");
        } else {
            range = editor.selection.getWordRange(pos.row, pos.column);
            this.setState("selectByWords");
        }
        this.$clickSelection = range;
        this[this.state] && this[this.state](ev);
    };

    this.onTripleClick = function(ev) {
        var pos = ev.getDocumentPosition();
        var editor = this.editor;

        this.setState("selectByLines");
        this.$clickSelection = editor.selection.getLineRange(pos.row);
        this[this.state] && this[this.state](ev);
    };

    this.onQuadClick = function(ev) {
        var editor = this.editor;

        editor.selectAll();
        this.$clickSelection = editor.getSelectionRange();
        this.setState("selectAll");
    };

    this.onMouseWheel = function(ev) {
        if (ev.getShiftKey() || ev.getAccelKey())
            return;
        var t = ev.domEvent.timeStamp;
        var dt = t - (this.$lastScrollTime||0);
        
        var editor = this.editor;
        var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
        if (isScrolable || dt < 200) {
            this.$lastScrollTime = t;
            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
            return ev.stop();
        }
    };

}).call(DefaultHandlers.prototype);

exports.DefaultHandlers = DefaultHandlers;

function calcDistance(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
}

function calcRangeOrientation(range, cursor) {
    if (range.start.row == range.end.row)
        var cmp = 2 * cursor.column - range.start.column - range.end.column;
    else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
        var cmp = cursor.column - 4;
    else
        var cmp = 2 * cursor.row - range.start.row - range.end.row;

    if (cmp < 0)
        return {cursor: range.start, anchor: range.end};
    else
        return {cursor: range.end, anchor: range.start};
}

});

consoleAce.define('ace/mouse/default_gutter_handler', ['require', 'exports', 'module' , 'ace/lib/dom', 'ace/lib/event'], function(require, exports, module) {

var dom = require("../lib/dom");
var event = require("../lib/event");

function GutterHandler(mouseHandler) {
    var editor = mouseHandler.editor;
    var gutter = editor.renderer.$gutterLayer;

    mouseHandler.editor.setDefaultHandler("guttermousedown", function(e) {
        if (!editor.isFocused() || e.getButton() != 0)
            return;
        var gutterRegion = gutter.getRegion(e);

        if (gutterRegion == "foldWidgets")
            return;

        var row = e.getDocumentPosition().row;
        var selection = editor.session.selection;

        if (e.getShiftKey())
            selection.selectTo(row, 0);
        else {
            if (e.domEvent.detail == 2) {
                editor.selectAll();
                return e.preventDefault();
            }
            mouseHandler.$clickSelection = editor.selection.getLineRange(row);
        }
        mouseHandler.setState("selectByLines");
        mouseHandler.captureMouse(e);
        return e.preventDefault();
    });


    var tooltipTimeout, mouseEvent, tooltip, tooltipAnnotation;
    function createTooltip() {
        tooltip = dom.createElement("div");
        tooltip.className = "ace_gutter-tooltip";
        tooltip.style.display = "none";
        editor.container.appendChild(tooltip);
    }

    function showTooltip() {
        if (!tooltip) {
            createTooltip();
        }
        var row = mouseEvent.getDocumentPosition().row;
        var annotation = gutter.$annotations[row];
        if (!annotation)
            return hideTooltip();

        var maxRow = editor.session.getLength();
        if (row == maxRow) {
            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
            var pos = mouseEvent.$pos;
            if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))
                return hideTooltip();
        }

        if (tooltipAnnotation == annotation)
            return;
        tooltipAnnotation = annotation.text.join("<br/>");

        tooltip.style.display = "block";
        tooltip.innerHTML = tooltipAnnotation;
        editor.on("mousewheel", hideTooltip);

        moveTooltip(mouseEvent);
    }

    function hideTooltip() {
        if (tooltipTimeout)
            tooltipTimeout = clearTimeout(tooltipTimeout);
        if (tooltipAnnotation) {
            tooltip.style.display = "none";
            tooltipAnnotation = null;
            editor.removeEventListener("mousewheel", hideTooltip);
        }
    }

    function moveTooltip(e) {
        var rect = editor.renderer.$gutter.getBoundingClientRect();
        tooltip.style.left = e.x + 15 + "px";
        if (e.y + 3 * editor.renderer.lineHeight + 15 < rect.bottom) {
            tooltip.style.bottom = "";
            tooltip.style.top =  e.y + 15 + "px";
        } else {
            tooltip.style.top = "";
            var innerHeight = window.innerHeight || document.documentElement.clientHeight;
            tooltip.style.bottom = innerHeight - e.y + 5 + "px";
        }
    }

    mouseHandler.editor.setDefaultHandler("guttermousemove", function(e) {
        var target = e.domEvent.target || e.domEvent.srcElement;
        if (dom.hasCssClass(target, "ace_fold-widget"))
            return hideTooltip();

        if (tooltipAnnotation)
            moveTooltip(e);

        mouseEvent = e;
        if (tooltipTimeout)
            return;
        tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            if (mouseEvent && !mouseHandler.isMousePressed)
                showTooltip();
            else
                hideTooltip();
        }, 50);
    });

    event.addListener(editor.renderer.$gutter, "mouseout", function(e) {
        mouseEvent = null;
        if (!tooltipAnnotation || tooltipTimeout)
            return;

        tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            hideTooltip();
        }, 50);
    });
    
    editor.on("changeSession", hideTooltip);
}

exports.GutterHandler = GutterHandler;

});

consoleAce.define('ace/mouse/mouse_event', ['require', 'exports', 'module' , 'ace/lib/event', 'ace/lib/useragent'], function(require, exports, module) {


var event = require("../lib/event");
var useragent = require("../lib/useragent");
var MouseEvent = exports.MouseEvent = function(domEvent, editor) {
    this.domEvent = domEvent;
    this.editor = editor;
    
    this.x = this.clientX = domEvent.clientX;
    this.y = this.clientY = domEvent.clientY;

    this.$pos = null;
    this.$inSelection = null;
    
    this.propagationStopped = false;
    this.defaultPrevented = false;
};

(function() {  
    
    this.stopPropagation = function() {
        event.stopPropagation(this.domEvent);
        this.propagationStopped = true;
    };
    
    this.preventDefault = function() {
        event.preventDefault(this.domEvent);
        this.defaultPrevented = true;
    };
    
    this.stop = function() {
        this.stopPropagation();
        this.preventDefault();
    };
    this.getDocumentPosition = function() {
        if (this.$pos)
            return this.$pos;
        
        this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
        return this.$pos;
    };
    this.inSelection = function() {
        if (this.$inSelection !== null)
            return this.$inSelection;
            
        var editor = this.editor;
        

        var selectionRange = editor.getSelectionRange();
        if (selectionRange.isEmpty())
            this.$inSelection = false;
        else {
            var pos = this.getDocumentPosition();
            this.$inSelection = selectionRange.contains(pos.row, pos.column);
        }

        return this.$inSelection;
    };
    this.getButton = function() {
        return event.getButton(this.domEvent);
    };
    this.getShiftKey = function() {
        return this.domEvent.shiftKey;
    };
    
    this.getAccelKey = useragent.isMac
        ? function() { return this.domEvent.metaKey; }
        : function() { return this.domEvent.ctrlKey; };
    
}).call(MouseEvent.prototype);

});

consoleAce.define('ace/mouse/dragdrop_handler', ['require', 'exports', 'module' , 'ace/lib/dom', 'ace/lib/event', 'ace/lib/useragent'], function(require, exports, module) {


var dom = require("../lib/dom");
var event = require("../lib/event");
var useragent = require("../lib/useragent");

var AUTOSCROLL_DELAY = 200;
var SCROLL_CURSOR_DELAY = 200;
var SCROLL_CURSOR_HYSTERESIS = 5;

function DragdropHandler(mouseHandler) {

    var editor = mouseHandler.editor;

    var blankImage = dom.createElement("img");
    blankImage.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
    if (useragent.isOpera)
        blankImage.style.cssText = "width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;";

    var exports = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];

     exports.forEach(function(x) {
         mouseHandler[x] = this[x];
    }, this);
    editor.addEventListener("mousedown", this.onMouseDown.bind(mouseHandler));


    var mouseTarget = editor.container;
    var dragSelectionMarker, x, y;
    var timerId, range;
    var dragCursor, counter = 0;
    var dragOperation;
    var isInternal;
    var autoScrollStartTime;
    var cursorMovedTime;
    var cursorPointOnCaretMoved;

    this.onDragStart = function(e) {
        if (this.cancelDrag || !mouseTarget.draggable) {
            var self = this;
            setTimeout(function(){
                self.startSelect();
                self.captureMouse(e);
            }, 0);
            return e.preventDefault();
        }
        range = editor.getSelectionRange();

        var dataTransfer = e.dataTransfer;
        dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
        if (useragent.isOpera) {
            editor.container.appendChild(blankImage);
            blankImage._top = blankImage.offsetTop;
        }
        dataTransfer.setDragImage && dataTransfer.setDragImage(blankImage, 0, 0);
        if (useragent.isOpera) {
            editor.container.removeChild(blankImage);
        }
        dataTransfer.clearData();
        dataTransfer.setData("Text", editor.session.getTextRange());

        isInternal = true;
        this.setState("drag");
    };

    this.onDragEnd = function(e) {
        mouseTarget.draggable = false;
        isInternal = false;
        this.setState(null);
        if (!editor.getReadOnly()) {
            var dropEffect = e.dataTransfer.dropEffect;
            if (!dragOperation && dropEffect == "move")
                editor.session.remove(editor.getSelectionRange());
            editor.renderer.$cursorLayer.setBlinking(true);
        }
        this.editor.unsetStyle("ace_dragging");
    };

    this.onDragEnter = function(e) {
        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return;
        if (!dragSelectionMarker)
            addDragMarker();
        counter++;
        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
        return event.preventDefault(e);
    };

    this.onDragOver = function(e) {
        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return;
        if (!dragSelectionMarker) {
            addDragMarker();
            counter++;
        }
        if (onMouseMoveTimer !== null)
            onMouseMoveTimer = null;
        x = e.clientX;
        y = e.clientY;

        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
        return event.preventDefault(e);
    };

    this.onDragLeave = function(e) {
        counter--;
        if (counter <= 0 && dragSelectionMarker) {
            clearDragMarker();
            dragOperation = null;
            return event.preventDefault(e);
        }
    };

    this.onDrop = function(e) {
        if (!dragSelectionMarker)
            return;
        var dataTransfer = e.dataTransfer;
        if (isInternal) {
            switch (dragOperation) {
                case "move":
                    if (range.contains(dragCursor.row, dragCursor.column)) {
                        range = {
                            start: dragCursor,
                            end: dragCursor
                        };
                    } else {
                        range = editor.moveText(range, dragCursor);
                    }
                    break;
                case "copy":
                    range = editor.moveText(range, dragCursor, true);
                    break;
            }
        } else {
            var dropData = dataTransfer.getData('Text');
            range = {
                start: dragCursor,
                end: editor.session.insert(dragCursor, dropData)
            };
            editor.focus();
            dragOperation = null;
        }
        clearDragMarker();
        return event.preventDefault(e);
    };

    event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler));
    event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler));
    event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler));
    event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler));
    event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler));
    event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler));

    function scrollCursorIntoView(cursor, prevCursor) {
        var now = Date.now();
        var vMovement = !prevCursor || cursor.row != prevCursor.row;
        var hMovement = !prevCursor || cursor.column != prevCursor.column;
        if (!cursorMovedTime || vMovement || hMovement) {
            editor.$blockScrolling += 1;
            editor.moveCursorToPosition(cursor);
            editor.$blockScrolling -= 1;
            cursorMovedTime = now;
            cursorPointOnCaretMoved = {x: x, y: y};
        } else {
            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
            if (distance > SCROLL_CURSOR_HYSTERESIS) {
                cursorMovedTime = null;
            } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
                editor.renderer.scrollCursorIntoView();
                cursorMovedTime = null;
            }
        }
    }

    function autoScroll(cursor, prevCursor) {
        var now = Date.now();
        var lineHeight = editor.renderer.layerConfig.lineHeight;
        var characterWidth = editor.renderer.layerConfig.characterWidth;
        var editorRect = editor.renderer.scroller.getBoundingClientRect();
        var offsets = {
           x: {
               left: x - editorRect.left,
               right: editorRect.right - x
           },
           y: {
               top: y - editorRect.top,
               bottom: editorRect.bottom - y
           }
        };
        var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
        var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
        var scrollCursor = {row: cursor.row, column: cursor.column};
        if (nearestXOffset / characterWidth <= 2) {
            scrollCursor.column += (offsets.x.left < offsets.x.right ? -3 : +2);
        }
        if (nearestYOffset / lineHeight <= 1) {
            scrollCursor.row += (offsets.y.top < offsets.y.bottom ? -1 : +1);
        }
        var vScroll = cursor.row != scrollCursor.row;
        var hScroll = cursor.column != scrollCursor.column;
        var vMovement = !prevCursor || cursor.row != prevCursor.row;
        if (vScroll || (hScroll && !vMovement)) {
            if (!autoScrollStartTime)
                autoScrollStartTime = now;
            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
                editor.renderer.scrollCursorIntoView(scrollCursor);
        } else {
            autoScrollStartTime = null;
        }
    }

    function onDragInterval() {
        var prevCursor = dragCursor;
        dragCursor = editor.renderer.screenToTextCoordinates(x, y);
        scrollCursorIntoView(dragCursor, prevCursor);
        autoScroll(dragCursor, prevCursor);
    }

    function addDragMarker() {
        range = editor.selection.toOrientedRange();
        dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
        editor.clearSelection();
        if (editor.isFocused())
            editor.renderer.$cursorLayer.setBlinking(false);
        clearInterval(timerId);
        timerId = setInterval(onDragInterval, 20);
        counter = 0;
        event.addListener(document, "mousemove", onMouseMove);
    }

    function clearDragMarker() {
        clearInterval(timerId);
        editor.session.removeMarker(dragSelectionMarker);
        dragSelectionMarker = null;
        editor.$blockScrolling += 1;
        editor.selection.fromOrientedRange(range);
        editor.$blockScrolling -= 1;
        if (editor.isFocused() && !isInternal)
            editor.renderer.$cursorLayer.setBlinking(!editor.getReadOnly());
        range = null;
        counter = 0;
        autoScrollStartTime = null;
        cursorMovedTime = null;
        event.removeListener(document, "mousemove", onMouseMove);
    }
    var onMouseMoveTimer = null;
    function onMouseMove() {
        if (onMouseMoveTimer == null) {
            onMouseMoveTimer = setTimeout(function() {
                if (onMouseMoveTimer != null && dragSelectionMarker)
                    clearDragMarker();
            }, 20);
        }
    }

    function canAccept(dataTransfer) {
        var types = dataTransfer.types;
        return !types || Array.prototype.some.call(types, function(type) {
            return type == 'text/plain' || type == 'Text';
        });
    }

    function getDropEffect(e) {
        var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];
        var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];

        var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
        var effectAllowed = "uninitialized";
        try {
            effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
        } catch (e) {}
        var dropEffect = "none";

        if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";
        else if (moveAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "move";
        else if (copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";

        return dropEffect;
    }
}

(function() {

    this.dragWait = function() {
        var interval = Date.now() - this.mousedownEvent.time;
        if (interval > this.editor.getDragDelay())
            this.startDrag();
    };

    this.dragWaitEnd = function() {
        var target = this.editor.container;
        target.draggable = false;
        this.startSelect(this.mousedownEvent.getDocumentPosition());
        this.selectEnd();
    };

    this.dragReadyEnd = function(e) {
        this.editor.renderer.$cursorLayer.setBlinking(!this.editor.getReadOnly());
        this.editor.unsetStyle("ace_dragging");
        this.dragWaitEnd();
    };

    this.startDrag = function(){
        this.cancelDrag = false;
        var target = this.editor.container;
        target.draggable = true;
        this.editor.renderer.$cursorLayer.setBlinking(false);
        this.editor.setStyle("ace_dragging");
        this.setState("dragReady");
    };

    this.onMouseDrag = function(e) {
        var target = this.editor.container;
        if (useragent.isIE && this.state == "dragReady") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 3)
                target.dragDrop();
        }
        if (this.state === "dragWait") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 0) {
                target.draggable = false;
                this.startSelect(this.mousedownEvent.getDocumentPosition());
            }
        }
    };

    this.onMouseDown = function(e) {
        if (!this.$dragEnabled)
            return;
        this.mousedownEvent = e;
        var editor = this.editor;

        var inSelection = e.inSelection();
        var button = e.getButton();
        var clickCount = e.domEvent.detail || 1;
        if (clickCount === 1 && button === 0 && inSelection) {
            if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))
                return;
            this.mousedownEvent.time = Date.now();
            var eventTarget = e.domEvent.target || e.domEvent.srcElement;
            if ("unselectable" in eventTarget)
                eventTarget.unselectable = "on";
            if (editor.getDragDelay()) {
                if (useragent.isWebKit) {
                    this.cancelDrag = true;
                    var mouseTarget = editor.container;
                    mouseTarget.draggable = true;
                }
                this.setState("dragWait");
            } else {
                this.startDrag();
            }
            this.captureMouse(e, this.onMouseDrag.bind(this));
            e.defaultPrevented = true;
        }
    };

}).call(DragdropHandler.prototype);


function calcDistance(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
}

exports.DragdropHandler = DragdropHandler;

});

consoleAce.define('ace/config', ['require', 'exports', 'module' , 'ace/lib/lang', 'ace/lib/oop', 'ace/lib/net', 'ace/lib/event_emitter'], function(require, exports, module) {
"no use strict";

var lang = require("./lib/lang");
var oop = require("./lib/oop");
var net = require("./lib/net");
var EventEmitter = require("./lib/event_emitter").EventEmitter;

var global = (function() {
    return this;
})();

var options = {
    packaged: false,
    workerPath: null,
    modePath: null,
    themePath: null,
    basePath: "",
    suffix: ".js",
    $moduleUrls: {}
};

exports.get = function(key) {
    if (!options.hasOwnProperty(key))
        throw new Error("Unknown config key: " + key);

    return options[key];
};

exports.set = function(key, value) {
    if (!options.hasOwnProperty(key))
        throw new Error("Unknown config key: " + key);

    options[key] = value;
};

exports.all = function() {
    return lang.copyObject(options);
};
oop.implement(exports, EventEmitter);

exports.moduleUrl = function(name, component) {
    if (options.$moduleUrls[name])
        return options.$moduleUrls[name];

    var parts = name.split("/");
    component = component || parts[parts.length - 2] || "";
    var sep = component == "snippets" ? "/" : "-";
    var base = parts[parts.length - 1];    
    if (sep == "-") {
        var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
        base = base.replace(re, "");
    }

    if ((!base || base == component) && parts.length > 1)
        base = parts[parts.length - 2];
    var path = options[component + "Path"];
    if (path == null) {
        path = options.basePath;
    } else if (sep == "/") {
        component = sep = "";
    }
    if (path && path.slice(-1) != "/")
        path += "/";
    return path + component + sep + base + this.get("suffix");
};

exports.setModuleUrl = function(name, subst) {
    return options.$moduleUrls[name] = subst;
};

exports.$loading = {};
exports.loadModule = function(moduleName, onLoad) {
    var module, moduleType;
    if (Array.isArray(moduleName)) {
        moduleType = moduleName[0];
        moduleName = moduleName[1];
    }

    try {
        module = require(moduleName);
    } catch (e) {}
    if (module && !exports.$loading[moduleName])
        return onLoad && onLoad(module);

    if (!exports.$loading[moduleName])
        exports.$loading[moduleName] = [];

    exports.$loading[moduleName].push(onLoad);

    if (exports.$loading[moduleName].length > 1)
        return;

    var afterLoad = function() {
        require([moduleName], function(module) {
            exports._emit("load.module", {name: moduleName, module: module});
            var listeners = exports.$loading[moduleName];
            exports.$loading[moduleName] = null;
            listeners.forEach(function(onLoad) {
                onLoad && onLoad(module);
            });
        });
    };

    if (!exports.get("packaged"))
        return afterLoad();
    net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
};
exports.init = function() {
    options.packaged = require.packaged || module.packaged || (global.define && define.packaged);

    if (!global.document)
        return "";

    var scriptOptions = {};
    var scriptUrl = "";

    var scripts = document.getElementsByTagName("script");
    for (var i=0; i<scripts.length; i++) {
        var script = scripts[i];

        var src = script.src || script.getAttribute("src");
        if (!src)
            continue;

        var attributes = script.attributes;
        for (var j=0, l=attributes.length; j < l; j++) {
            var attr = attributes[j];
            if (attr.name.indexOf("data-ace-") === 0) {
                scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
            }
        }

        var m = src.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
        if (m)
            scriptUrl = m[1];
    }

    if (scriptUrl) {
        scriptOptions.base = scriptOptions.base || scriptUrl;
        scriptOptions.packaged = true;
    }

    scriptOptions.basePath = scriptOptions.base;
    scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
    scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
    scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
    delete scriptOptions.base;

    for (var key in scriptOptions)
        if (typeof scriptOptions[key] !== "undefined")
            exports.set(key, scriptOptions[key]);
};

function deHyphenate(str) {
    return str.replace(/-(.)/g, function(m, m1) { return m1.toUpperCase(); });
}

var optionsProvider = {
    setOptions: function(optList) {
        Object.keys(optList).forEach(function(key) {
            this.setOption(key, optList[key]);
        }, this);
    },
    getOptions: function(optionNames) {
        var result = {};
        if (!optionNames) {
            optionNames = Object.keys(this.$options);
        } else if (!Array.isArray(optionNames)) {
            result = optionNames;
            optionNames = Object.keys(result);
        }
        optionNames.forEach(function(key) {
            result[key] = this.getOption(key);
        }, this);
        return result;
    },
    setOption: function(name, value) {
        if (this["$" + name] === value)
            return;
        var opt = this.$options[name];
        if (!opt) {
            if (typeof console != "undefined" && console.warn)
                console.warn('misspelled option "' + name + '"');
            return undefined;
        }
        if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);

        if (!opt.handlesSet)
            this["$" + name] = value;
        if (opt && opt.set)
            opt.set.call(this, value);
    },
    getOption: function(name) {
        var opt = this.$options[name];
        if (!opt) {
            if (typeof console != "undefined" && console.warn)
                console.warn('misspelled option "' + name + '"');
            return undefined;
        }
        if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
        return opt && opt.get ? opt.get.call(this) : this["$" + name];
    }
};

var defaultOptions = {};
exports.defineOptions = function(obj, path, options) {
    if (!obj.$options)
        defaultOptions[path] = obj.$options = {};

    Object.keys(options).forEach(function(key) {
        var opt = options[key];
        if (typeof opt == "string")
            opt = {forwardTo: opt};

        opt.name || (opt.name = key);
        obj.$options[opt.name] = opt;
        if ("initialValue" in opt)
            obj["$" + opt.name] = opt.initialValue;
    });
    oop.implement(obj, optionsProvider);

    return this;
};

exports.resetOptions = function(obj) {
    Object.keys(obj.$options).forEach(function(key) {
        var opt = obj.$options[key];
        if ("value" in opt)
            obj.setOption(key, opt.value);
    });
};

exports.setDefaultValue = function(path, name, value) {
    var opts = defaultOptions[path] || (defaultOptions[path] = {});
    if (opts[name]) {
        if (opts.forwardTo)
            exports.setDefaultValue(opts.forwardTo, name, value);
        else
            opts[name].value = value;
    }
};

exports.setDefaultValues = function(path, optionHash) {
    Object.keys(optionHash).forEach(function(key) {
        exports.setDefaultValue(path, key, optionHash[key]);
    });
};

});
consoleAce.define('ace/lib/net', ['require', 'exports', 'module' , 'ace/lib/dom'], function(require, exports, module) {

var dom = require("./dom");

exports.get = function (url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
            callback(xhr.responseText);
        }
    };
    xhr.send(null);
};

exports.loadScript = function(path, callback) {
    var head = dom.getDocumentHead();
    var s = document.createElement('script');

    s.src = path;
    head.appendChild(s);

    s.onload = s.onreadystatechange = function(_, isAbort) {
        if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
            s = s.onload = s.onreadystatechange = null;
            if (!isAbort)
                callback();
        }
    };
};

});

consoleAce.define('ace/lib/event_emitter', ['require', 'exports', 'module' ], function(require, exports, module) {


var EventEmitter = {};
var stopPropagation = function() { this.propagationStopped = true; };
var preventDefault = function() { this.defaultPrevented = true; };

EventEmitter._emit =
EventEmitter._dispatchEvent = function(eventName, e) {
    this._eventRegistry || (this._eventRegistry = {});
    this._defaultHandlers || (this._defaultHandlers = {});

    var listeners = this._eventRegistry[eventName] || [];
    var defaultHandler = this._defaultHandlers[eventName];
    if (!listeners.length && !defaultHandler)
        return;

    if (typeof e != "object" || !e)
        e = {};

    if (!e.type)
        e.type = eventName;
    if (!e.stopPropagation)
        e.stopPropagation = stopPropagation;
    if (!e.preventDefault)
        e.preventDefault = preventDefault;

    listeners = listeners.slice();
    for (var i=0; i<listeners.length; i++) {
        listeners[i](e, this);
        if (e.propagationStopped)
            break;
    }
    
    if (defaultHandler && !e.defaultPrevented)
        return defaultHandler(e, this);
};


EventEmitter._signal = function(eventName, e) {
    var listeners = (this._eventRegistry || {})[eventName];
    if (!listeners)
        return;
    listeners = listeners.slice();
    for (var i=0; i<listeners.length; i++)
        listeners[i](e, this);
};

EventEmitter.once = function(eventName, callback) {
    var _self = this;
    callback && this.addEventListener(eventName, function newCallback() {
        _self.removeEventListener(eventName, newCallback);
        callback.apply(null, arguments);
    });
};


EventEmitter.setDefaultHandler = function(eventName, callback) {
    var handlers = this._defaultHandlers
    if (!handlers)
        handlers = this._defaultHandlers = {_disabled_: {}};
    
    if (handlers[eventName]) {
        var old = handlers[eventName];
        var disabled = handlers._disabled_[eventName];
        if (!disabled)
            handlers._disabled_[eventName] = disabled = [];
        disabled.push(old);
        var i = disabled.indexOf(callback);
        if (i != -1) 
            disabled.splice(i, 1);
    }
    handlers[eventName] = callback;
};
EventEmitter.removeDefaultHandler = function(eventName, callback) {
    var handlers = this._defaultHandlers
    if (!handlers)
        return;
    var disabled = handlers._disabled_[eventName];
    
    if (handlers[eventName] == callback) {
        var old = handlers[eventName];
        if (disabled)
            this.setDefaultHandler(eventName, disabled.pop());
    } else if (disabled) {
        var i = disabled.indexOf(callback);
        if (i != -1)
            disabled.splice(i, 1);
    }
};

EventEmitter.on =
EventEmitter.addEventListener = function(eventName, callback, capturing) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
        listeners = this._eventRegistry[eventName] = [];

    if (listeners.indexOf(callback) == -1)
        listeners[capturing ? "unshift" : "push"](callback);
    return callback;
};

EventEmitter.off =
EventEmitter.removeListener =
EventEmitter.removeEventListener = function(eventName, callback) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
        return;

    var index = listeners.indexOf(callback);
    if (index !== -1)
        listeners.splice(index, 1);
};

EventEmitter.removeAllListeners = function(eventName) {
    if (this._eventRegistry) this._eventRegistry[eventName] = [];
};

exports.EventEmitter = EventEmitter;

});

consoleAce.define('ace/mouse/fold_handler', ['require', 'exports', 'module' ], function(require, exports, module) {


function FoldHandler(editor) {

    editor.on("click", function(e) {
        var position = e.getDocumentPosition();
        var session = editor.session;
        var fold = session.getFoldAt(position.row, position.column, 1);
        if (fold) {
            if (e.getAccelKey())
                session.removeFold(fold);
            else
                session.expandFold(fold);

            e.stop();
        }
    });

    editor.on("gutterclick", function(e) {
        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

        if (gutterRegion == "foldWidgets") {
            var row = e.getDocumentPosition().row;
            var session = editor.session;
            if (session.foldWidgets && session.foldWidgets[row])
                editor.session.onFoldWidgetClick(row, e);
            if (!editor.isFocused())
                editor.focus();
            e.stop();
        }
    });

    editor.on("gutterdblclick", function(e) {
        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

        if (gutterRegion == "foldWidgets") {
            var row = e.getDocumentPosition().row;
            var session = editor.session;
            var data = session.getParentFoldRangeData(row, true);
            var range = data.range || data.firstRange;

            if (range) {
                row = range.start.row;
                var fold = session.getFoldAt(row, session.getLine(row).length, 1);

                if (fold) {
                    session.removeFold(fold);
                } else {
                    session.addFold("...", range);
                    editor.renderer.scrollCursorIntoView({row: range.start.row, column: 0});
                }
            }
            e.stop();
        }
    });
}

exports.FoldHandler = FoldHandler;

});

consoleAce.define('ace/keyboard/keybinding', ['require', 'exports', 'module' , 'ace/lib/keys', 'ace/lib/event'], function(require, exports, module) {


var keyUtil  = require("../lib/keys");
var event = require("../lib/event");

var KeyBinding = function(editor) {
    this.$editor = editor;
    this.$data = { };
    this.$handlers = [];
    this.setDefaultHandler(editor.commands);
};

(function() {
    this.setDefaultHandler = function(kb) {
        this.removeKeyboardHandler(this.$defaultHandler);
        this.$defaultHandler = kb;
        this.addKeyboardHandler(kb, 0);
        this.$data = {editor: this.$editor};
    };

    this.setKeyboardHandler = function(kb) {
        var h = this.$handlers;
        if (h[h.length - 1] == kb)
            return;

        while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
            this.removeKeyboardHandler(h[h.length - 1]);

        this.addKeyboardHandler(kb, 1);
    };

    this.addKeyboardHandler = function(kb, pos) {
        if (!kb)
            return;
        var i = this.$handlers.indexOf(kb);
        if (i != -1)
            this.$handlers.splice(i, 1);

        if (pos == undefined)
            this.$handlers.push(kb);
        else
            this.$handlers.splice(pos, 0, kb);

        if (i == -1 && kb.attach)
            kb.attach(this.$editor);
    };

    this.removeKeyboardHandler = function(kb) {
        var i = this.$handlers.indexOf(kb);
        if (i == -1)
            return false;
        this.$handlers.splice(i, 1);
        kb.detach && kb.detach(this.$editor);
        return true;
    };

    this.getKeyboardHandler = function() {
        return this.$handlers[this.$handlers.length - 1];
    };

    this.$callKeyboardHandlers = function (hashId, keyString, keyCode, e) {
        var toExecute;
        var success = false;
        var commands = this.$editor.commands;

        for (var i = this.$handlers.length; i--;) {
            toExecute = this.$handlers[i].handleKeyboard(
                this.$data, hashId, keyString, keyCode, e
            );
            if (!toExecute || !toExecute.command)
                continue;
            if (toExecute.command == "null") {
                success = true;
            } else {
                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);                
            }
            if (success && e && hashId != -1 && 
                toExecute.passEvent != true && toExecute.command.passEvent != true
            ) {
                event.stopEvent(e);
            }
            if (success)
                break;
        }
        return success;
    };

    this.onCommandKey = function(e, hashId, keyCode) {
        var keyString = keyUtil.keyCodeToString(keyCode);
        this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
    };

    this.onTextInput = function(text) {
        var success = this.$callKeyboardHandlers(-1, text);
        if (!success)
            this.$editor.commands.exec("insertstring", this.$editor, text);
    };

}).call(KeyBinding.prototype);

exports.KeyBinding = KeyBinding;
});

consoleAce.define('ace/edit_session', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/lib/lang', 'ace/config', 'ace/lib/event_emitter', 'ace/selection', 'ace/mode/text', 'ace/range', 'ace/document', 'ace/background_tokenizer', 'ace/search_highlight', 'ace/edit_session/folding', 'ace/edit_session/bracket_match'], function(require, exports, module) {


var oop = require("./lib/oop");
var lang = require("./lib/lang");
var config = require("./config");
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var Selection = require("./selection").Selection;
var TextMode = require("./mode/text").Mode;
var Range = require("./range").Range;
var Document = require("./document").Document;
var BackgroundTokenizer = require("./background_tokenizer").BackgroundTokenizer;
var SearchHighlight = require("./search_highlight").SearchHighlight;

var EditSession = function(text, mode) {
    this.$breakpoints = [];
    this.$decorations = [];
    this.$frontMarkers = {};
    this.$backMarkers = {};
    this.$markerId = 1;
    this.$undoSelect = true;

    this.$foldData = [];
    this.$foldData.toString = function() {
        return this.join("\n");
    }
    this.on("changeFold", this.onChangeFold.bind(this));
    this.$onChange = this.onChange.bind(this);

    if (typeof text != "object" || !text.getLine)
        text = new Document(text);

    this.setDocument(text);
    this.selection = new Selection(this);

    config.resetOptions(this);
    this.setMode(mode);
    config._emit("session", this);
};


(function() {

    oop.implement(this, EventEmitter);
    this.setDocument = function(doc) {
        if (this.doc)
            this.doc.removeListener("change", this.$onChange);

        this.doc = doc;
        doc.on("change", this.$onChange);

        if (this.bgTokenizer)
            this.bgTokenizer.setDocument(this.getDocument());

        this.resetCaches();
    };
    this.getDocument = function() {
        return this.doc;
    };
    this.$resetRowCache = function(docRow) {
        if (!docRow) {
            this.$docRowCache = [];
            this.$screenRowCache = [];
            return;
        }
        var l = this.$docRowCache.length;
        var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
        if (l > i) {
            this.$docRowCache.splice(i, l);
            this.$screenRowCache.splice(i, l);
        }
    };

    this.$getRowCacheIndex = function(cacheArray, val) {
        var low = 0;
        var hi = cacheArray.length - 1;

        while (low <= hi) {
            var mid = (low + hi) >> 1;
            var c = cacheArray[mid];

            if (val > c)
                low = mid + 1;
            else if (val < c)
                hi = mid - 1;
            else
                return mid;
        }

        return low -1;
    };

    this.resetCaches = function() {
        this.$modified = true;
        this.$wrapData = [];
        this.$rowLengthCache = [];
        this.$resetRowCache(0);
        if (this.bgTokenizer)
            this.bgTokenizer.start(0);
    };

    this.onChangeFold = function(e) {
        var fold = e.data;
        this.$resetRowCache(fold.start.row);
    };

    this.onChange = function(e) {
        var delta = e.data;
        this.$modified = true;

        this.$resetRowCache(delta.range.start.row);

        var removedFolds = this.$updateInternalDataOnChange(e);
        if (!this.$fromUndo && this.$undoManager && !delta.ignore) {
            this.$deltasDoc.push(delta);
            if (removedFolds && removedFolds.length != 0) {
                this.$deltasFold.push({
                    action: "removeFolds",
                    folds:  removedFolds
                });
            }

            this.$informUndoManager.schedule();
        }

        this.bgTokenizer.$updateOnChange(delta);
        this._emit("change", e);
    };
    this.setValue = function(text) {
        this.doc.setValue(text);
        this.selection.moveCursorTo(0, 0);
        this.selection.clearSelection();

        this.$resetRowCache(0);
        this.$deltas = [];
        this.$deltasDoc = [];
        this.$deltasFold = [];
        this.getUndoManager().reset();
    };
    this.getValue =
    this.toString = function() {
        return this.doc.getValue();
    };
    this.getSelection = function() {
        return this.selection;
    };
    this.getState = function(row) {
        return this.bgTokenizer.getState(row);
    };
    this.getTokens = function(row) {
        return this.bgTokenizer.getTokens(row);
    };
    this.getTokenAt = function(row, column) {
        var tokens = this.bgTokenizer.getTokens(row);
        var token, c = 0;
        if (column == null) {
            i = tokens.length - 1;
            c = this.getLine(row).length;
        } else {
            for (var i = 0; i < tokens.length; i++) {
                c += tokens[i].value.length;
                if (c >= column)
                    break;
            }
        }
        token = tokens[i];
        if (!token)
            return null;
        token.index = i;
        token.start = c - token.value.length;
        return token;
    };
    this.setUndoManager = function(undoManager) {
        this.$undoManager = undoManager;
        this.$deltas = [];
        this.$deltasDoc = [];
        this.$deltasFold = [];

        if (this.$informUndoManager)
            this.$informUndoManager.cancel();

        if (undoManager) {
            var self = this;

            this.$syncInformUndoManager = function() {
                self.$informUndoManager.cancel();

                if (self.$deltasFold.length) {
                    self.$deltas.push({
                        group: "fold",
                        deltas: self.$deltasFold
                    });
                    self.$deltasFold = [];
                }

                if (self.$deltasDoc.length) {
                    self.$deltas.push({
                        group: "doc",
                        deltas: self.$deltasDoc
                    });
                    self.$deltasDoc = [];
                }

                if (self.$deltas.length > 0) {
                    undoManager.execute({
                        action: "aceupdate",
                        args: [self.$deltas, self],
                        merge: self.mergeUndoDeltas
                    });
                }
                self.mergeUndoDeltas = false;
                self.$deltas = [];
            }
            this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
        }
    };
    this.markUndoGroup = function() {
        if (this.$syncInformUndoManager)
            this.$syncInformUndoManager();
    };
    
    this.$defaultUndoManager = {
        undo: function() {},
        redo: function() {},
        reset: function() {}
    };
    this.getUndoManager = function() {
        return this.$undoManager || this.$defaultUndoManager;
    };
    this.getTabString = function() {
        if (this.getUseSoftTabs()) {
            return lang.stringRepeat(" ", this.getTabSize());
        } else {
            return "\t";
        }
    };
    this.setUseSoftTabs = function(val) {
        this.setOption("useSoftTabs", val);
    };
    this.getUseSoftTabs = function() {
        return this.$useSoftTabs && !this.$mode.$indentWithTabs;
    };
    this.setTabSize = function(tabSize) {
        this.setOption("tabSize", tabSize)
    };
    this.getTabSize = function() {
        return this.$tabSize;
    };
    this.isTabStop = function(position) {
        return this.$useSoftTabs && (position.column % this.$tabSize == 0);
    };

    this.$overwrite = false;
    this.setOverwrite = function(overwrite) {
        this.setOption("overwrite", overwrite)
    };
    this.getOverwrite = function() {
        return this.$overwrite;
    };
    this.toggleOverwrite = function() {
        this.setOverwrite(!this.$overwrite);
    };
    this.addGutterDecoration = function(row, className) {
        if (!this.$decorations[row])
            this.$decorations[row] = "";
        this.$decorations[row] += " " + className;
        this._emit("changeBreakpoint", {});
    };
    this.removeGutterDecoration = function(row, className) {
        this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
        this._emit("changeBreakpoint", {});
    };
    this.getBreakpoints = function() {
        return this.$breakpoints;
    };
    this.setBreakpoints = function(rows) {
        this.$breakpoints = [];
        for (var i=0; i<rows.length; i++) {
            this.$breakpoints[rows[i]] = "ace_breakpoint";
        }
        this._emit("changeBreakpoint", {});
    };
    this.clearBreakpoints = function() {
        this.$breakpoints = [];
        this._emit("changeBreakpoint", {});
    };
    this.setBreakpoint = function(row, className) {
        if (className === undefined)
            className = "ace_breakpoint";
        if (className)
            this.$breakpoints[row] = className;
        else
            delete this.$breakpoints[row];
        this._emit("changeBreakpoint", {});
    };
    this.clearBreakpoint = function(row) {
        delete this.$breakpoints[row];
        this._emit("changeBreakpoint", {});
    };
    this.addMarker = function(range, clazz, type, inFront) {
        var id = this.$markerId++;

        var marker = {
            range : range,
            type : type || "line",
            renderer: typeof type == "function" ? type : null,
            clazz : clazz,
            inFront: !!inFront,
            id: id
        }

        if (inFront) {
            this.$frontMarkers[id] = marker;
            this._emit("changeFrontMarker")
        } else {
            this.$backMarkers[id] = marker;
            this._emit("changeBackMarker")
        }

        return id;
    };
    this.addDynamicMarker = function(marker, inFront) {
        if (!marker.update)
            return;
        var id = this.$markerId++;
        marker.id = id;
        marker.inFront = !!inFront;

        if (inFront) {
            this.$frontMarkers[id] = marker;
            this._emit("changeFrontMarker")
        } else {
            this.$backMarkers[id] = marker;
            this._emit("changeBackMarker")
        }

        return marker;
    };
    this.removeMarker = function(markerId) {
        var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
        if (!marker)
            return;

        var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
        if (marker) {
            delete (markers[markerId]);
            this._emit(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
        }
    };
    this.getMarkers = function(inFront) {
        return inFront ? this.$frontMarkers : this.$backMarkers;
    };

    this.highlight = function(re) {
        if (!this.$searchHighlight) {
            var highlight = new SearchHighlight(null, "ace_selected-word", "text");
            this.$searchHighlight = this.addDynamicMarker(highlight);
        }
        this.$searchHighlight.setRegexp(re);
    }
    this.highlightLines = function(startRow, endRow, clazz, inFront) {
        if (typeof endRow != "number") {
            clazz = endRow;
            endRow = startRow;
        }
        if (!clazz)
            clazz = "ace_step";

        var range = new Range(startRow, 0, endRow, Infinity);
        range.id = this.addMarker(range, clazz, "fullLine", inFront);
        return range;
    };
    this.setAnnotations = function(annotations) {
        this.$annotations = annotations;
        this._emit("changeAnnotation", {});
    };
    this.getAnnotations = function() {
        return this.$annotations || [];
    };
    this.clearAnnotations = function() {
        this.setAnnotations([]);
    };
    this.$detectNewLine = function(text) {
        var match = text.match(/^.*?(\r?\n)/m);
        if (match) {
            this.$autoNewLine = match[1];
        } else {
            this.$autoNewLine = "\n";
        }
    };
    this.getWordRange = function(row, column) {
        var line = this.getLine(row);

        var inToken = false;
        if (column > 0)
            inToken = !!line.charAt(column - 1).match(this.tokenRe);

        if (!inToken)
            inToken = !!line.charAt(column).match(this.tokenRe);

        if (inToken)
            var re = this.tokenRe;
        else if (/^\s+$/.test(line.slice(column-1, column+1)))
            var re = /\s/;
        else
            var re = this.nonTokenRe;

        var start = column;
        if (start > 0) {
            do {
                start--;
            }
            while (start >= 0 && line.charAt(start).match(re));
            start++;
        }

        var end = column;
        while (end < line.length && line.charAt(end).match(re)) {
            end++;
        }

        return new Range(row, start, row, end);
    };
    this.getAWordRange = function(row, column) {
        var wordRange = this.getWordRange(row, column);
        var line = this.getLine(wordRange.end.row);

        while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
            wordRange.end.column += 1;
        }
        return wordRange;
    };
    this.setNewLineMode = function(newLineMode) {
        this.doc.setNewLineMode(newLineMode);
    };
    this.getNewLineMode = function() {
        return this.doc.getNewLineMode();
    };
    this.setUseWorker = function(useWorker) { this.setOption("useWorker", useWorker); };
    this.getUseWorker = function() { return this.$useWorker; };
    this.onReloadTokenizer = function(e) {
        var rows = e.data;
        this.bgTokenizer.start(rows.first);
        this._emit("tokenizerUpdate", e);
    };

    this.$modes = {};
    this.$mode = null;
    this.$modeId = null;
    this.setMode = function(mode, cb) {
        if (mode && typeof mode === "object") {
            if (mode.getTokenizer)
                return this.$onChangeMode(mode);
            var options = mode;
            var path = options.path;
        } else {
            path = mode || "ace/mode/text";
        }
        if (!this.$modes["ace/mode/text"])
            this.$modes["ace/mode/text"] = new TextMode();

        if (this.$modes[path] && !options) {
            this.$onChangeMode(this.$modes[path]);
            cb && cb();
            return;
        }
        this.$modeId = path;
        config.loadModule(["mode", path], function(m) {
            if (this.$modeId !== path)
                return cb && cb();
            if (this.$modes[path] && !options)
                return this.$onChangeMode(this.$modes[path]);
            if (m && m.Mode) {
                m = new m.Mode(options);
                if (!options) {
                    this.$modes[path] = m;
                    m.$id = path;
                }
                this.$onChangeMode(m);
                cb && cb();
            }
        }.bind(this));
        if (!this.$mode)
            this.$onChangeMode(this.$modes["ace/mode/text"], true);
    };

    this.$onChangeMode = function(mode, $isPlaceholder) {
        if (!$isPlaceholder)
            this.$modeId = mode.$id;
        if (this.$mode === mode) 
            return;

        this.$mode = mode;

        this.$stopWorker();

        if (this.$useWorker)
            this.$startWorker();

        var tokenizer = mode.getTokenizer();

        if(tokenizer.addEventListener !== undefined) {
            var onReloadTokenizer = this.onReloadTokenizer.bind(this);
            tokenizer.addEventListener("update", onReloadTokenizer);
        }

        if (!this.bgTokenizer) {
            this.bgTokenizer = new BackgroundTokenizer(tokenizer);
            var _self = this;
            this.bgTokenizer.addEventListener("update", function(e) {
                _self._emit("tokenizerUpdate", e);
            });
        } else {
            this.bgTokenizer.setTokenizer(tokenizer);
        }

        this.bgTokenizer.setDocument(this.getDocument());

        this.tokenRe = mode.tokenRe;
        this.nonTokenRe = mode.nonTokenRe;

        
        if (!$isPlaceholder) {
            this.$options.wrapMethod.set.call(this, this.$wrapMethod);
            this.$setFolding(mode.foldingRules);
            this.bgTokenizer.start(0);
            this._emit("changeMode");
        }
    };


    this.$stopWorker = function() {
        if (this.$worker)
            this.$worker.terminate();

        this.$worker = null;
    };

    this.$startWorker = function() {
        if (typeof Worker !== "undefined" && !require.noWorker) {
            try {
                this.$worker = this.$mode.createWorker(this);
            } catch (e) {
                console.log("Could not load worker");
                console.log(e);
                this.$worker = null;
            }
        }
        else
            this.$worker = null;
    };
    this.getMode = function() {
        return this.$mode;
    };

    this.$scrollTop = 0;
    this.setScrollTop = function(scrollTop) {
        if (this.$scrollTop === scrollTop || isNaN(scrollTop))
            return;

        this.$scrollTop = scrollTop;
        this._signal("changeScrollTop", scrollTop);
    };
    this.getScrollTop = function() {
        return this.$scrollTop;
    };

    this.$scrollLeft = 0;
    this.setScrollLeft = function(scrollLeft) {
        if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
            return;

        this.$scrollLeft = scrollLeft;
        this._signal("changeScrollLeft", scrollLeft);
    };
    this.getScrollLeft = function() {
        return this.$scrollLeft;
    };
    this.getScreenWidth = function() {
        this.$computeWidth();
        if (this.lineWidgets) 
            return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
        return this.screenWidth;
    };
    
    this.getLineWidgetMaxWidth = function() {
        if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth
        var width = 0;
        this.lineWidgets.forEach(function(w) {
            if (w && w.screenWidth > width)
                width = w.screenWidth;
        });
        return this.lineWidgetWidth = width;
    }

    this.$computeWidth = function(force) {
        if (this.$modified || force) {
            this.$modified = false;

            if (this.$useWrapMode)
                return this.screenWidth = this.$wrapLimit;

            var lines = this.doc.getAllLines();
            var cache = this.$rowLengthCache;
            var longestScreenLine = 0;
            var foldIndex = 0;
            var foldLine = this.$foldData[foldIndex];
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            var len = lines.length;

            for (var i = 0; i < len; i++) {
                if (i > foldStart) {
                    i = foldLine.end.row + 1;
                    if (i >= len)
                        break;
                    foldLine = this.$foldData[foldIndex++];
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }

                if (cache[i] == null)
                    cache[i] = this.$getStringScreenWidth(lines[i])[0];

                if (cache[i] > longestScreenLine)
                    longestScreenLine = cache[i];
            }
            this.screenWidth = longestScreenLine;
        }
    };
    this.getLine = function(row) {
        return this.doc.getLine(row);
    };
    this.getLines = function(firstRow, lastRow) {
        return this.doc.getLines(firstRow, lastRow);
    };
    this.getLength = function() {
        return this.doc.getLength();
    };
    this.getTextRange = function(range) {
        return this.doc.getTextRange(range || this.selection.getRange());
    };
    this.insert = function(position, text) {
        return this.doc.insert(position, text);
    };
    this.remove = function(range) {
        return this.doc.remove(range);
    };
    this.undoChanges = function(deltas, dontSelect) {
        if (!deltas.length)
            return;

        this.$fromUndo = true;
        var lastUndoRange = null;
        for (var i = deltas.length - 1; i != -1; i--) {
            var delta = deltas[i];
            if (delta.group == "doc") {
                this.doc.revertDeltas(delta.deltas);
                lastUndoRange =
                    this.$getUndoSelection(delta.deltas, true, lastUndoRange);
            } else {
                delta.deltas.forEach(function(foldDelta) {
                    this.addFolds(foldDelta.folds);
                }, this);
            }
        }
        this.$fromUndo = false;
        lastUndoRange &&
            this.$undoSelect &&
            !dontSelect &&
            this.selection.setSelectionRange(lastUndoRange);
        return lastUndoRange;
    };
    this.redoChanges = function(deltas, dontSelect) {
        if (!deltas.length)
            return;

        this.$fromUndo = true;
        var lastUndoRange = null;
        for (var i = 0; i < deltas.length; i++) {
            var delta = deltas[i];
            if (delta.group == "doc") {
                this.doc.applyDeltas(delta.deltas);
                lastUndoRange =
                    this.$getUndoSelection(delta.deltas, false, lastUndoRange);
            }
        }
        this.$fromUndo = false;
        lastUndoRange &&
            this.$undoSelect &&
            !dontSelect &&
            this.selection.setSelectionRange(lastUndoRange);
        return lastUndoRange;
    };
    this.setUndoSelect = function(enable) {
        this.$undoSelect = enable;
    };

    this.$getUndoSelection = function(deltas, isUndo, lastUndoRange) {
        function isInsert(delta) {
            var insert =
                delta.action === "insertText" || delta.action === "insertLines";
            return isUndo ? !insert : insert;
        }

        var delta = deltas[0];
        var range, point;
        var lastDeltaIsInsert = false;
        if (isInsert(delta)) {
            range = Range.fromPoints(delta.range.start, delta.range.end);
            lastDeltaIsInsert = true;
        } else {
            range = Range.fromPoints(delta.range.start, delta.range.start);
            lastDeltaIsInsert = false;
        }

        for (var i = 1; i < deltas.length; i++) {
            delta = deltas[i];
            if (isInsert(delta)) {
                point = delta.range.start;
                if (range.compare(point.row, point.column) == -1) {
                    range.setStart(delta.range.start);
                }
                point = delta.range.end;
                if (range.compare(point.row, point.column) == 1) {
                    range.setEnd(delta.range.end);
                }
                lastDeltaIsInsert = true;
            } else {
                point = delta.range.start;
                if (range.compare(point.row, point.column) == -1) {
                    range =
                        Range.fromPoints(delta.range.start, delta.range.start);
                }
                lastDeltaIsInsert = false;
            }
        }
        if (lastUndoRange != null) {
            if (Range.comparePoints(lastUndoRange.start, range.start) == 0) {
                lastUndoRange.start.column += range.end.column - range.start.column;
                lastUndoRange.end.column += range.end.column - range.start.column;
            }

            var cmp = lastUndoRange.compareRange(range);
            if (cmp == 1) {
                range.setStart(lastUndoRange.start);
            } else if (cmp == -1) {
                range.setEnd(lastUndoRange.end);
            }
        }

        return range;
    };
    this.replace = function(range, text) {
        return this.doc.replace(range, text);
    };
    this.moveText = function(fromRange, toPosition, copy) {
        var text = this.getTextRange(fromRange);
        var folds = this.getFoldsInRange(fromRange);

        var toRange = Range.fromPoints(toPosition, toPosition);
        if (!copy) {
            this.remove(fromRange);
            var rowDiff = fromRange.start.row - fromRange.end.row;
            var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
            if (collDiff) {
                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
                    toRange.start.column += collDiff;
                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
                    toRange.end.column += collDiff;
            }
            if (rowDiff && toRange.start.row >= fromRange.end.row) {
                toRange.start.row += rowDiff;
                toRange.end.row += rowDiff;
            }
        }

        toRange.end = this.insert(toRange.start, text);
        if (folds.length) {
            var oldStart = fromRange.start;
            var newStart = toRange.start;
            var rowDiff = newStart.row - oldStart.row;
            var collDiff = newStart.column - oldStart.column;
            this.addFolds(folds.map(function(x) {
                x = x.clone();
                if (x.start.row == oldStart.row)
                    x.start.column += collDiff;
                if (x.end.row == oldStart.row)
                    x.end.column += collDiff;
                x.start.row += rowDiff;
                x.end.row += rowDiff;
                return x;
            }));
        }

        return toRange;
    };
    this.indentRows = function(startRow, endRow, indentString) {
        indentString = indentString.replace(/\t/g, this.getTabString());
        for (var row=startRow; row<=endRow; row++)
            this.insert({row: row, column:0}, indentString);
    };
    this.outdentRows = function (range) {
        var rowRange = range.collapseRows();
        var deleteRange = new Range(0, 0, 0, 0);
        var size = this.getTabSize();

        for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
            var line = this.getLine(i);

            deleteRange.start.row = i;
            deleteRange.end.row = i;
            for (var j = 0; j < size; ++j)
                if (line.charAt(j) != ' ')
                    break;
            if (j < size && line.charAt(j) == '\t') {
                deleteRange.start.column = j;
                deleteRange.end.column = j + 1;
            } else {
                deleteRange.start.column = 0;
                deleteRange.end.column = j;
            }
            this.remove(deleteRange);
        }
    };

    this.$moveLines = function(firstRow, lastRow, dir) {
        firstRow = this.getRowFoldStart(firstRow);
        lastRow = this.getRowFoldEnd(lastRow);
        if (dir < 0) {
            var row = this.getRowFoldStart(firstRow + dir);
            if (row < 0) return 0;
            var diff = row-firstRow;
        } else if (dir > 0) {
            var row = this.getRowFoldEnd(lastRow + dir);
            if (row > this.doc.getLength()-1) return 0;
            var diff = row-lastRow;
        } else {
            firstRow = this.$clipRowToDocument(firstRow);
            lastRow = this.$clipRowToDocument(lastRow);
            var diff = lastRow - firstRow + 1;
        }

        var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
        var folds = this.getFoldsInRange(range).map(function(x){
            x = x.clone();
            x.start.row += diff;
            x.end.row += diff;
            return x;
        });

        var lines = dir == 0
            ? this.doc.getLines(firstRow, lastRow)
            : this.doc.removeLines(firstRow, lastRow);
        this.doc.insertLines(firstRow+diff, lines);
        folds.length && this.addFolds(folds);
        return diff;
    };
    this.moveLinesUp = function(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, -1);
    };
    this.moveLinesDown = function(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, 1);
    };
    this.duplicateLines = function(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, 0);
    };


    this.$clipRowToDocument = function(row) {
        return Math.max(0, Math.min(row, this.doc.getLength()-1));
    };

    this.$clipColumnToRow = function(row, column) {
        if (column < 0)
            return 0;
        return Math.min(this.doc.getLine(row).length, column);
    };


    this.$clipPositionToDocument = function(row, column) {
        column = Math.max(0, column);

        if (row < 0) {
            row = 0;
            column = 0;
        } else {
            var len = this.doc.getLength();
            if (row >= len) {
                row = len - 1;
                column = this.doc.getLine(len-1).length;
            } else {
                column = Math.min(this.doc.getLine(row).length, column);
            }
        }

        return {
            row: row,
            column: column
        };
    };

    this.$clipRangeToDocument = function(range) {
        if (range.start.row < 0) {
            range.start.row = 0;
            range.start.column = 0;
        } else {
            range.start.column = this.$clipColumnToRow(
                range.start.row,
                range.start.column
            );
        }

        var len = this.doc.getLength() - 1;
        if (range.end.row > len) {
            range.end.row = len;
            range.end.column = this.doc.getLine(len).length;
        } else {
            range.end.column = this.$clipColumnToRow(
                range.end.row,
                range.end.column
            );
        }
        return range;
    };
    this.$wrapLimit = 80;
    this.$useWrapMode = false;
    this.$wrapLimitRange = {
        min : null,
        max : null
    };
    this.setUseWrapMode = function(useWrapMode) {
        if (useWrapMode != this.$useWrapMode) {
            this.$useWrapMode = useWrapMode;
            this.$modified = true;
            this.$resetRowCache(0);
            if (useWrapMode) {
                var len = this.getLength();
                this.$wrapData = [];
                for (var i = 0; i < len; i++) {
                    this.$wrapData.push([]);
                }
                this.$updateWrapData(0, len - 1);
            }

            this._emit("changeWrapMode");
        }
    };
    this.getUseWrapMode = function() {
        return this.$useWrapMode;
    };
    this.setWrapLimitRange = function(min, max) {
        if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
            this.$wrapLimitRange = {
                min: min,
                max: max
            };
            this.$modified = true;
            this._emit("changeWrapMode");
        }
    };
    this.adjustWrapLimit = function(desiredLimit, $printMargin) {
        var limits = this.$wrapLimitRange
        if (limits.max < 0)
            limits = {min: $printMargin, max: $printMargin};
        var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
        if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
            this.$wrapLimit = wrapLimit;
            this.$modified = true;
            if (this.$useWrapMode) {
                this.$updateWrapData(0, this.getLength() - 1);
                this.$resetRowCache(0);
                this._emit("changeWrapLimit");
            }
            return true;
        }
        return false;
    };

    this.$constrainWrapLimit = function(wrapLimit, min, max) {
        if (min)
            wrapLimit = Math.max(min, wrapLimit);

        if (max)
            wrapLimit = Math.min(max, wrapLimit);

        return wrapLimit;
    };
    this.getWrapLimit = function() {
        return this.$wrapLimit;
    };
    this.setWrapLimit = function (limit) {
        this.setWrapLimitRange(limit, limit);
    };
    this.getWrapLimitRange = function() {
        return {
            min : this.$wrapLimitRange.min,
            max : this.$wrapLimitRange.max
        };
    };

    this.$updateInternalDataOnChange = function(e) {
        var useWrapMode = this.$useWrapMode;
        var len;
        var action = e.data.action;
        var firstRow = e.data.range.start.row;
        var lastRow = e.data.range.end.row;
        var start = e.data.range.start;
        var end = e.data.range.end;
        var removedFolds = null;

        if (action.indexOf("Lines") != -1) {
            if (action == "insertLines") {
                lastRow = firstRow + (e.data.lines.length);
            } else {
                lastRow = firstRow;
            }
            len = e.data.lines ? e.data.lines.length : lastRow - firstRow;
        } else {
            len = lastRow - firstRow;
        }

        this.$updating = true;
        if (len != 0) {
            if (action.indexOf("remove") != -1) {
                this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);

                var foldLines = this.$foldData;
                removedFolds = this.getFoldsInRange(e.data.range);
                this.removeFolds(removedFolds);

                var foldLine = this.getFoldLine(end.row);
                var idx = 0;
                if (foldLine) {
                    foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                    foldLine.shiftRow(-len);

                    var foldLineBefore = this.getFoldLine(firstRow);
                    if (foldLineBefore && foldLineBefore !== foldLine) {
                        foldLineBefore.merge(foldLine);
                        foldLine = foldLineBefore;
                    }
                    idx = foldLines.indexOf(foldLine) + 1;
                }

                for (idx; idx < foldLines.length; idx++) {
                    var foldLine = foldLines[idx];
                    if (foldLine.start.row >= end.row) {
                        foldLine.shiftRow(-len);
                    }
                }

                lastRow = firstRow;
            } else {
                var args;
                if (useWrapMode) {
                    args = [firstRow, 0];
                    for (var i = 0; i < len; i++) args.push([]);
                    this.$wrapData.splice.apply(this.$wrapData, args);
                } else {
                    args = Array(len);
                    args.unshift(firstRow, 0);
                    this.$rowLengthCache.splice.apply(this.$rowLengthCache, args);
                }
                var foldLines = this.$foldData;
                var foldLine = this.getFoldLine(firstRow);
                var idx = 0;
                if (foldLine) {
                    var cmp = foldLine.range.compareInside(start.row, start.column)
                    if (cmp == 0) {
                        foldLine = foldLine.split(start.row, start.column);
                        foldLine.shiftRow(len);
                        foldLine.addRemoveChars(
                            lastRow, 0, end.column - start.column);
                    } else
                    if (cmp == -1) {
                        foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                        foldLine.shiftRow(len);
                    }
                    idx = foldLines.indexOf(foldLine) + 1;
                }

                for (idx; idx < foldLines.length; idx++) {
                    var foldLine = foldLines[idx];
                    if (foldLine.start.row >= firstRow) {
                        foldLine.shiftRow(len);
                    }
                }
            }
        } else {
            len = Math.abs(e.data.range.start.column - e.data.range.end.column);
            if (action.indexOf("remove") != -1) {
                removedFolds = this.getFoldsInRange(e.data.range);
                this.removeFolds(removedFolds);

                len = -len;
            }
            var foldLine = this.getFoldLine(firstRow);
            if (foldLine) {
                foldLine.addRemoveChars(firstRow, start.column, len);
            }
        }

        if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
            console.error("doc.getLength() and $wrapData.length have to be the same!");
        }
        this.$updating = false;

        if (useWrapMode)
            this.$updateWrapData(firstRow, lastRow);
        else
            this.$updateRowLengthCache(firstRow, lastRow);

        return removedFolds;
    };

    this.$updateRowLengthCache = function(firstRow, lastRow, b) {
        this.$rowLengthCache[firstRow] = null;
        this.$rowLengthCache[lastRow] = null;
    };

    this.$updateWrapData = function(firstRow, lastRow) {
        var lines = this.doc.getAllLines();
        var tabSize = this.getTabSize();
        var wrapData = this.$wrapData;
        var wrapLimit = this.$wrapLimit;
        var tokens;
        var foldLine;

        var row = firstRow;
        lastRow = Math.min(lastRow, lines.length - 1);
        while (row <= lastRow) {
            foldLine = this.getFoldLine(row, foldLine);
            if (!foldLine) {
                tokens = this.$getDisplayTokens(lines[row]);
                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row ++;
            } else {
                tokens = [];
                foldLine.walk(function(placeholder, row, column, lastColumn) {
                        var walkTokens;
                        if (placeholder != null) {
                            walkTokens = this.$getDisplayTokens(
                                            placeholder, tokens.length);
                            walkTokens[0] = PLACEHOLDER_START;
                            for (var i = 1; i < walkTokens.length; i++) {
                                walkTokens[i] = PLACEHOLDER_BODY;
                            }
                        } else {
                            walkTokens = this.$getDisplayTokens(
                                lines[row].substring(lastColumn, column),
                                tokens.length);
                        }
                        tokens = tokens.concat(walkTokens);
                    }.bind(this),
                    foldLine.end.row,
                    lines[foldLine.end.row].length + 1
                );

                wrapData[foldLine.start.row]
                    = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row = foldLine.end.row + 1;
            }
        }
    };
    var CHAR = 1,
        CHAR_EXT = 2,
        PLACEHOLDER_START = 3,
        PLACEHOLDER_BODY =  4,
        PUNCTUATION = 9,
        SPACE = 10,
        TAB = 11,
        TAB_SPACE = 12;


    this.$computeWrapSplits = function(tokens, wrapLimit) {
        if (tokens.length == 0) {
            return [];
        }

        var splits = [];
        var displayLength = tokens.length;
        var lastSplit = 0, lastDocSplit = 0;

        var isCode = this.$wrapAsCode;

        function addSplit(screenPos) {
            var displayed = tokens.slice(lastSplit, screenPos);
            var len = displayed.length;
            displayed.join("").
                replace(/12/g, function() {
                    len -= 1;
                }).
                replace(/2/g, function() {
                    len -= 1;
                });

            lastDocSplit += len;
            splits.push(lastDocSplit);
            lastSplit = screenPos;
        }

        while (displayLength - lastSplit > wrapLimit) {
            var split = lastSplit + wrapLimit;
            if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
                addSplit(split);
                continue;
            }
            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
                for (split; split != lastSplit - 1; split--) {
                    if (tokens[split] == PLACEHOLDER_START) {
                        break;
                    }
                }
                if (split > lastSplit) {
                    addSplit(split);
                    continue;
                }
                split = lastSplit + wrapLimit;
                for (split; split < tokens.length; split++) {
                    if (tokens[split] != PLACEHOLDER_BODY) {
                        break;
                    }
                }
                if (split == tokens.length) {
                    break;  // Breaks the while-loop.
                }
                addSplit(split);
                continue;
            }
            var minSplit = Math.max(split - (isCode ? 10 : wrapLimit-(wrapLimit>>2)), lastSplit - 1);
            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                split --;
            }
            if (isCode) {
                while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                    split --;
                }
                while (split > minSplit && tokens[split] == PUNCTUATION) {
                    split --;
                }
            } else {
                while (split > minSplit && tokens[split] < SPACE) {
                    split --;
                }
            }
            if (split > minSplit) {
                addSplit(++split);
                continue;
            }
            split = lastSplit + wrapLimit;
            addSplit(split);
        }
        return splits;
    };
    this.$getDisplayTokens = function(str, offset) {
        var arr = [];
        var tabSize;
        offset = offset || 0;

        for (var i = 0; i < str.length; i++) {
            var c = str.charCodeAt(i);
            if (c == 9) {
                tabSize = this.getScreenTabSize(arr.length + offset);
                arr.push(TAB);
                for (var n = 1; n < tabSize; n++) {
                    arr.push(TAB_SPACE);
                }
            }
            else if (c == 32) {
                arr.push(SPACE);
            } else if((c > 39 && c < 48) || (c > 57 && c < 64)) {
                arr.push(PUNCTUATION);
            }
            else if (c >= 0x1100 && isFullWidth(c)) {
                arr.push(CHAR, CHAR_EXT);
            } else {
                arr.push(CHAR);
            }
        }
        return arr;
    };
    this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
        if (maxScreenColumn == 0)
            return [0, 0];
        if (maxScreenColumn == null)
            maxScreenColumn = Infinity;
        screenColumn = screenColumn || 0;

        var c, column;
        for (column = 0; column < str.length; column++) {
            c = str.charCodeAt(column);
            if (c == 9) {
                screenColumn += this.getScreenTabSize(screenColumn);
            }
            else if (c >= 0x1100 && isFullWidth(c)) {
                screenColumn += 2;
            } else {
                screenColumn += 1;
            }
            if (screenColumn > maxScreenColumn) {
                break;
            }
        }

        return [screenColumn, column];
    };

    this.lineWidgets = null;
    this.getRowLength = function(row) {
        if (this.lineWidgets)
            var h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
        else 
            h = 0
        if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1 + h;
        } else {
            return this.$wrapData[row].length + 1 + h;
        }
    };
    this.getRowLineCount = function(row) {
        if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1;
        } else {
            return this.$wrapData[row].length + 1;
        }
    };
    this.getScreenLastRowColumn = function(screenRow) {
        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
        return this.documentToScreenColumn(pos.row, pos.column);
    };
    this.getDocumentLastRowColumn = function(docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.getScreenLastRowColumn(screenRow);
    };
    this.getDocumentLastRowColumnPosition = function(docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
    };
    this.getRowSplitData = function(row) {
        if (!this.$useWrapMode) {
            return undefined;
        } else {
            return this.$wrapData[row];
        }
    };
    this.getScreenTabSize = function(screenColumn) {
        return this.$tabSize - screenColumn % this.$tabSize;
    };


    this.screenToDocumentRow = function(screenRow, screenColumn) {
        return this.screenToDocumentPosition(screenRow, screenColumn).row;
    };


    this.screenToDocumentColumn = function(screenRow, screenColumn) {
        return this.screenToDocumentPosition(screenRow, screenColumn).column;
    };
    this.screenToDocumentPosition = function(screenRow, screenColumn) {
        if (screenRow < 0)
            return {row: 0, column: 0};

        var line;
        var docRow = 0;
        var docColumn = 0;
        var column;
        var row = 0;
        var rowLength = 0;

        var rowCache = this.$screenRowCache;
        var i = this.$getRowCacheIndex(rowCache, screenRow);
        var l = rowCache.length;
        if (l && i >= 0) {
            var row = rowCache[i];
            var docRow = this.$docRowCache[i];
            var doCache = screenRow > rowCache[l - 1];
        } else {
            var doCache = !l;
        }

        var maxRow = this.getLength() - 1;
        var foldLine = this.getNextFoldLine(docRow);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (row <= screenRow) {
            rowLength = this.getRowLength(docRow);
            if (row + rowLength > screenRow || docRow >= maxRow) {
                break;
            } else {
                row += rowLength;
                docRow++;
                if (docRow > foldStart) {
                    docRow = foldLine.end.row+1;
                    foldLine = this.getNextFoldLine(docRow, foldLine);
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }
            }

            if (doCache) {
                this.$docRowCache.push(docRow);
                this.$screenRowCache.push(row);
            }
        }

        if (foldLine && foldLine.start.row <= docRow) {
            line = this.getFoldDisplayLine(foldLine);
            docRow = foldLine.start.row;
        } else if (row + rowLength <= screenRow || docRow > maxRow) {
            return {
                row: maxRow,
                column: this.getLine(maxRow).length
            }
        } else {
            line = this.getLine(docRow);
            foldLine = null;
        }

        if (this.$useWrapMode) {
            var splits = this.$wrapData[docRow];
            if (splits) {
                var splitIndex = Math.floor(screenRow - row);
                column = splits[splitIndex];
                if(splitIndex > 0 && splits.length) {
                    docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                    line = line.substring(docColumn);
                }
            }
        }

        docColumn += this.$getStringScreenWidth(line, screenColumn)[1];
        if (this.$useWrapMode && docColumn >= column)
            docColumn = column - 1;

        if (foldLine)
            return foldLine.idxToPosition(docColumn);

        return {row: docRow, column: docColumn};
    };
    this.documentToScreenPosition = function(docRow, docColumn) {
        if (typeof docColumn === "undefined")
            var pos = this.$clipPositionToDocument(docRow.row, docRow.column);
        else
            pos = this.$clipPositionToDocument(docRow, docColumn);

        docRow = pos.row;
        docColumn = pos.column;

        var screenRow = 0;
        var foldStartRow = null;
        var fold = null;
        fold = this.getFoldAt(docRow, docColumn, 1);
        if (fold) {
            docRow = fold.start.row;
            docColumn = fold.start.column;
        }

        var rowEnd, row = 0;


        var rowCache = this.$docRowCache;
        var i = this.$getRowCacheIndex(rowCache, docRow);
        var l = rowCache.length;
        if (l && i >= 0) {
            var row = rowCache[i];
            var screenRow = this.$screenRowCache[i];
            var doCache = docRow > rowCache[l - 1];
        } else {
            var doCache = !l;
        }

        var foldLine = this.getNextFoldLine(row);
        var foldStart = foldLine ?foldLine.start.row :Infinity;

        while (row < docRow) {
            if (row >= foldStart) {
                rowEnd = foldLine.end.row + 1;
                if (rowEnd > docRow)
                    break;
                foldLine = this.getNextFoldLine(rowEnd, foldLine);
                foldStart = foldLine ?foldLine.start.row :Infinity;
            }
            else {
                rowEnd = row + 1;
            }

            screenRow += this.getRowLength(row);
            row = rowEnd;

            if (doCache) {
                this.$docRowCache.push(row);
                this.$screenRowCache.push(screenRow);
            }
        }
        var textLine = "";
        if (foldLine && row >= foldStart) {
            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
            foldStartRow = foldLine.start.row;
        } else {
            textLine = this.getLine(docRow).substring(0, docColumn);
            foldStartRow = docRow;
        }
        if (this.$useWrapMode) {
            var wrapRow = this.$wrapData[foldStartRow];
            var screenRowOffset = 0;
            while (textLine.length >= wrapRow[screenRowOffset]) {
                screenRow ++;
                screenRowOffset++;
            }
            textLine = textLine.substring(
                wrapRow[screenRowOffset - 1] || 0, textLine.length
            );
        }

        return {
            row: screenRow,
            column: this.$getStringScreenWidth(textLine)[0]
        };
    };
    this.documentToScreenColumn = function(row, docColumn) {
        return this.documentToScreenPosition(row, docColumn).column;
    };
    this.documentToScreenRow = function(docRow, docColumn) {
        return this.documentToScreenPosition(docRow, docColumn).row;
    };
    this.getScreenLength = function() {
        var screenRows = 0;
        var fold = null;
        if (!this.$useWrapMode) {
            screenRows = this.getLength();
            var foldData = this.$foldData;
            for (var i = 0; i < foldData.length; i++) {
                fold = foldData[i];
                screenRows -= fold.end.row - fold.start.row;
            }
        } else {
            var lastRow = this.$wrapData.length;
            var row = 0, i = 0;
            var fold = this.$foldData[i++];
            var foldStart = fold ? fold.start.row :Infinity;

            while (row < lastRow) {
                screenRows += this.$wrapData[row].length + 1;
                row ++;
                if (row > foldStart) {
                    row = fold.end.row+1;
                    fold = this.$foldData[i++];
                    foldStart = fold ?fold.start.row :Infinity;
                }
            }
        }
        if (this.lineWidgets)
            screenRows += this.$getWidgetScreenLength();

        return screenRows;
    };
    function isFullWidth(c) {
        if (c < 0x1100)
            return false;
        return c >= 0x1100 && c <= 0x115F ||
               c >= 0x11A3 && c <= 0x11A7 ||
               c >= 0x11FA && c <= 0x11FF ||
               c >= 0x2329 && c <= 0x232A ||
               c >= 0x2E80 && c <= 0x2E99 ||
               c >= 0x2E9B && c <= 0x2EF3 ||
               c >= 0x2F00 && c <= 0x2FD5 ||
               c >= 0x2FF0 && c <= 0x2FFB ||
               c >= 0x3000 && c <= 0x303E ||
               c >= 0x3041 && c <= 0x3096 ||
               c >= 0x3099 && c <= 0x30FF ||
               c >= 0x3105 && c <= 0x312D ||
               c >= 0x3131 && c <= 0x318E ||
               c >= 0x3190 && c <= 0x31BA ||
               c >= 0x31C0 && c <= 0x31E3 ||
               c >= 0x31F0 && c <= 0x321E ||
               c >= 0x3220 && c <= 0x3247 ||
               c >= 0x3250 && c <= 0x32FE ||
               c >= 0x3300 && c <= 0x4DBF ||
               c >= 0x4E00 && c <= 0xA48C ||
               c >= 0xA490 && c <= 0xA4C6 ||
               c >= 0xA960 && c <= 0xA97C ||
               c >= 0xAC00 && c <= 0xD7A3 ||
               c >= 0xD7B0 && c <= 0xD7C6 ||
               c >= 0xD7CB && c <= 0xD7FB ||
               c >= 0xF900 && c <= 0xFAFF ||
               c >= 0xFE10 && c <= 0xFE19 ||
               c >= 0xFE30 && c <= 0xFE52 ||
               c >= 0xFE54 && c <= 0xFE66 ||
               c >= 0xFE68 && c <= 0xFE6B ||
               c >= 0xFF01 && c <= 0xFF60 ||
               c >= 0xFFE0 && c <= 0xFFE6;
    };

}).call(EditSession.prototype);

require("./edit_session/folding").Folding.call(EditSession.prototype);
require("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);


config.defineOptions(EditSession.prototype, "session", {
    wrap: {
        set: function(value) {
            if (!value || value == "off")
                value = false;
            else if (value == "free")
                value = true;
            else if (value == "printMargin")
                value = -1;
            else if (typeof value == "string")
                value = parseInt(value, 10) || false;

            if (this.$wrap == value)
                return;
            if (!value) {
                this.setUseWrapMode(false);
            } else {
                var col = typeof value == "number" ? value : null;
                this.setWrapLimitRange(col, col);
                this.setUseWrapMode(true);
            }
            this.$wrap = value;
        },
        get: function() {
            if (this.getUseWrapMode()) {
                if (this.$wrap == -1)
                    return "printMargin";
                if (!this.getWrapLimitRange().min)
                    return "free";
                return this.$wrap;
            }
            return "off";
        },
        handlesSet: true
    },    
    wrapMethod: {
        set: function(val) {
            val = val == "auto"
                ? this.$mode.type != "text"
                : val != "text";
            if (val != this.$wrapAsCode) {
                this.$wrapAsCode = val;
                if (this.$useWrapMode) {
                    this.$modified = true;
                    this.$resetRowCache(0);
                    this.$updateWrapData(0, this.getLength() - 1);
                }
            }
        },
        initialValue: "auto"
    },
    firstLineNumber: {
        set: function() {this._emit("changeBreakpoint");},
        initialValue: 1
    },
    useWorker: {
        set: function(useWorker) {
            this.$useWorker = useWorker;

            this.$stopWorker();
            if (useWorker)
                this.$startWorker();
        },
        initialValue: true
    },
    useSoftTabs: {initialValue: true},
    tabSize: {
        set: function(tabSize) {
            if (isNaN(tabSize) || this.$tabSize === tabSize) return;

            this.$modified = true;
            this.$rowLengthCache = [];
            this.$tabSize = tabSize;
            this._emit("changeTabSize");
        },
        initialValue: 4,
        handlesSet: true
    },
    overwrite: {
        set: function(val) {this._emit("changeOverwrite");},
        initialValue: false
    },
    newLineMode: {
        set: function(val) {this.doc.setNewLineMode(val)},
        get: function() {return this.doc.getNewLineMode()},
        handlesSet: true
    },
    mode: {
        set: function(val) { this.setMode(val) },
        get: function() { return this.$modeId }
    }
});

exports.EditSession = EditSession;
});

consoleAce.define('ace/selection', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/lib/lang', 'ace/lib/event_emitter', 'ace/range'], function(require, exports, module) {


var oop = require("./lib/oop");
var lang = require("./lib/lang");
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var Range = require("./range").Range;
var Selection = function(session) {
    this.session = session;
    this.doc = session.getDocument();

    this.clearSelection();
    this.lead = this.selectionLead = this.doc.createAnchor(0, 0);
    this.anchor = this.selectionAnchor = this.doc.createAnchor(0, 0);

    var self = this;
    this.lead.on("change", function(e) {
        self._emit("changeCursor");
        if (!self.$isEmpty)
            self._emit("changeSelection");
        if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)
            self.$desiredColumn = null;
    });

    this.selectionAnchor.on("change", function() {
        if (!self.$isEmpty)
            self._emit("changeSelection");
    });
};

(function() {

    oop.implement(this, EventEmitter);
    this.isEmpty = function() {
        return (this.$isEmpty || (
            this.anchor.row == this.lead.row &&
            this.anchor.column == this.lead.column
        ));
    };
    this.isMultiLine = function() {
        if (this.isEmpty()) {
            return false;
        }

        return this.getRange().isMultiLine();
    };
    this.getCursor = function() {
        return this.lead.getPosition();
    };
    this.setSelectionAnchor = function(row, column) {
        this.anchor.setPosition(row, column);

        if (this.$isEmpty) {
            this.$isEmpty = false;
            this._emit("changeSelection");
        }
    };
    this.getSelectionAnchor = function() {
        if (this.$isEmpty)
            return this.getSelectionLead()
        else
            return this.anchor.getPosition();
    };
    this.getSelectionLead = function() {
        return this.lead.getPosition();
    };
    this.shiftSelection = function(columns) {
        if (this.$isEmpty) {
            this.moveCursorTo(this.lead.row, this.lead.column + columns);
            return;
        };

        var anchor = this.getSelectionAnchor();
        var lead = this.getSelectionLead();

        var isBackwards = this.isBackwards();

        if (!isBackwards || anchor.column !== 0)
            this.setSelectionAnchor(anchor.row, anchor.column + columns);

        if (isBackwards || lead.column !== 0) {
            this.$moveSelection(function() {
                this.moveCursorTo(lead.row, lead.column + columns);
            });
        }
    };
    this.isBackwards = function() {
        var anchor = this.anchor;
        var lead = this.lead;
        return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));
    };
    this.getRange = function() {
        var anchor = this.anchor;
        var lead = this.lead;

        if (this.isEmpty())
            return Range.fromPoints(lead, lead);

        if (this.isBackwards()) {
            return Range.fromPoints(lead, anchor);
        }
        else {
            return Range.fromPoints(anchor, lead);
        }
    };
    this.clearSelection = function() {
        if (!this.$isEmpty) {
            this.$isEmpty = true;
            this._emit("changeSelection");
        }
    };
    this.selectAll = function() {
        var lastRow = this.doc.getLength() - 1;
        this.setSelectionAnchor(0, 0);
        this.moveCursorTo(lastRow, this.doc.getLine(lastRow).length);
    };
    this.setRange =
    this.setSelectionRange = function(range, reverse) {
        if (reverse) {
            this.setSelectionAnchor(range.end.row, range.end.column);
            this.selectTo(range.start.row, range.start.column);
        } else {
            this.setSelectionAnchor(range.start.row, range.start.column);
            this.selectTo(range.end.row, range.end.column);
        }
        if (this.getRange().isEmpty())
            this.$isEmpty = true;
        this.$desiredColumn = null;
    };

    this.$moveSelection = function(mover) {
        var lead = this.lead;
        if (this.$isEmpty)
            this.setSelectionAnchor(lead.row, lead.column);

        mover.call(this);
    };
    this.selectTo = function(row, column) {
        this.$moveSelection(function() {
            this.moveCursorTo(row, column);
        });
    };
    this.selectToPosition = function(pos) {
        this.$moveSelection(function() {
            this.moveCursorToPosition(pos);
        });
    };
    this.selectUp = function() {
        this.$moveSelection(this.moveCursorUp);
    };
    this.selectDown = function() {
        this.$moveSelection(this.moveCursorDown);
    };
    this.selectRight = function() {
        this.$moveSelection(this.moveCursorRight);
    };
    this.selectLeft = function() {
        this.$moveSelection(this.moveCursorLeft);
    };
    this.selectLineStart = function() {
        this.$moveSelection(this.moveCursorLineStart);
    };
    this.selectLineEnd = function() {
        this.$moveSelection(this.moveCursorLineEnd);
    };
    this.selectFileEnd = function() {
        this.$moveSelection(this.moveCursorFileEnd);
    };
    this.selectFileStart = function() {
        this.$moveSelection(this.moveCursorFileStart);
    };
    this.selectWordRight = function() {
        this.$moveSelection(this.moveCursorWordRight);
    };
    this.selectWordLeft = function() {
        this.$moveSelection(this.moveCursorWordLeft);
    };
    this.getWordRange = function(row, column) {
        if (typeof column == "undefined") {
            var cursor = row || this.lead;
            row = cursor.row;
            column = cursor.column;
        }
        return this.session.getWordRange(row, column);
    };
    this.selectWord = function() {
        this.setSelectionRange(this.getWordRange());
    };
    this.selectAWord = function() {
        var cursor = this.getCursor();
        var range = this.session.getAWordRange(cursor.row, cursor.column);
        this.setSelectionRange(range);
    };

    this.getLineRange = function(row, excludeLastChar) {
        var rowStart = typeof row == "number" ? row : this.lead.row;
        var rowEnd;

        var foldLine = this.session.getFoldLine(rowStart);
        if (foldLine) {
            rowStart = foldLine.start.row;
            rowEnd = foldLine.end.row;
        } else {
            rowEnd = rowStart;
        }
        if (excludeLastChar === true)
            return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
        else
            return new Range(rowStart, 0, rowEnd + 1, 0);
    };
    this.selectLine = function() {
        this.setSelectionRange(this.getLineRange());
    };
    this.moveCursorUp = function() {
        this.moveCursorBy(-1, 0);
    };
    this.moveCursorDown = function() {
        this.moveCursorBy(1, 0);
    };
    this.moveCursorLeft = function() {
        var cursor = this.lead.getPosition(),
            fold;

        if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
        } else if (cursor.column == 0) {
            if (cursor.row > 0) {
                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
            }
        }
        else {
            var tabSize = this.session.getTabSize();
            if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column-tabSize, cursor.column).split(" ").length-1 == tabSize)
                this.moveCursorBy(0, -tabSize);
            else
                this.moveCursorBy(0, -1);
        }
    };
    this.moveCursorRight = function() {
        var cursor = this.lead.getPosition(),
            fold;
        if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
            this.moveCursorTo(fold.end.row, fold.end.column);
        }
        else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
            if (this.lead.row < this.doc.getLength() - 1) {
                this.moveCursorTo(this.lead.row + 1, 0);
            }
        }
        else {
            var tabSize = this.session.getTabSize();
            var cursor = this.lead;
            if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column, cursor.column+tabSize).split(" ").length-1 == tabSize)
                this.moveCursorBy(0, tabSize);
            else
                this.moveCursorBy(0, 1);
        }
    };
    this.moveCursorLineStart = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var screenRow = this.session.documentToScreenRow(row, column);
        var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
        var beforeCursor = this.session.getDisplayLine(
            row, null, firstColumnPosition.row,
            firstColumnPosition.column
        );

        var leadingSpace = beforeCursor.match(/^\s*/);
        if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
            firstColumnPosition.column += leadingSpace[0].length;
        this.moveCursorToPosition(firstColumnPosition);
    };
    this.moveCursorLineEnd = function() {
        var lead = this.lead;
        var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
        if (this.lead.column == lineEnd.column) {
            var line = this.session.getLine(lineEnd.row);
            if (lineEnd.column == line.length) {
                var textEnd = line.search(/\s+$/);
                if (textEnd > 0)
                    lineEnd.column = textEnd;
            }
        }

        this.moveCursorTo(lineEnd.row, lineEnd.column);
    };
    this.moveCursorFileEnd = function() {
        var row = this.doc.getLength() - 1;
        var column = this.doc.getLine(row).length;
        this.moveCursorTo(row, column);
    };
    this.moveCursorFileStart = function() {
        this.moveCursorTo(0, 0);
    };
    this.moveCursorLongWordRight = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var line = this.doc.getLine(row);
        var rightOfCursor = line.substring(column);

        var match;
        this.session.nonTokenRe.lastIndex = 0;
        this.session.tokenRe.lastIndex = 0;
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold) {
            this.moveCursorTo(fold.end.row, fold.end.column);
            return;
        }
        if (match = this.session.nonTokenRe.exec(rightOfCursor)) {
            column += this.session.nonTokenRe.lastIndex;
            this.session.nonTokenRe.lastIndex = 0;
            rightOfCursor = line.substring(column);
        }
        if (column >= line.length) {
            this.moveCursorTo(row, line.length);
            this.moveCursorRight();
            if (row < this.doc.getLength() - 1)
                this.moveCursorWordRight();
            return;
        }
        if (match = this.session.tokenRe.exec(rightOfCursor)) {
            column += this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
        }

        this.moveCursorTo(row, column);
    };
    this.moveCursorLongWordLeft = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var fold;
        if (fold = this.session.getFoldAt(row, column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
            return;
        }

        var str = this.session.getFoldStringAt(row, column, -1);
        if (str == null) {
            str = this.doc.getLine(row).substring(0, column)
        }

        var leftOfCursor = lang.stringReverse(str);
        var match;
        this.session.nonTokenRe.lastIndex = 0;
        this.session.tokenRe.lastIndex = 0;
        if (match = this.session.nonTokenRe.exec(leftOfCursor)) {
            column -= this.session.nonTokenRe.lastIndex;
            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
            this.session.nonTokenRe.lastIndex = 0;
        }
        if (column <= 0) {
            this.moveCursorTo(row, 0);
            this.moveCursorLeft();
            if (row > 0)
                this.moveCursorWordLeft();
            return;
        }
        if (match = this.session.tokenRe.exec(leftOfCursor)) {
            column -= this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
        }

        this.moveCursorTo(row, column);
    };

    this.$shortWordEndIndex = function(rightOfCursor) {
        var match, index = 0, ch;
        var whitespaceRe = /\s/;
        var tokenRe = this.session.tokenRe;

        tokenRe.lastIndex = 0;
        if (match = this.session.tokenRe.exec(rightOfCursor)) {
            index = this.session.tokenRe.lastIndex;
        } else {
            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                index ++;

            if (index < 1) {
                tokenRe.lastIndex = 0;
                 while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
                    tokenRe.lastIndex = 0;
                    index ++;
                    if (whitespaceRe.test(ch)) {
                        if (index > 2) {
                            index--
                            break;
                        } else {
                            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                                index ++;
                            if (index > 2)
                                break
                        }
                    }
                }
            }
        }
        tokenRe.lastIndex = 0;

        return index;
    };

    this.moveCursorShortWordRight = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var line = this.doc.getLine(row);
        var rightOfCursor = line.substring(column);

        var fold = this.session.getFoldAt(row, column, 1);
        if (fold)
            return this.moveCursorTo(fold.end.row, fold.end.column);

        if (column == line.length) {
            var l = this.doc.getLength();
            do {
                row++;
                rightOfCursor = this.doc.getLine(row)
            } while (row < l && /^\s*$/.test(rightOfCursor))

            if (!/^\s+/.test(rightOfCursor))
                rightOfCursor = ""
            column = 0;
        }

        var index = this.$shortWordEndIndex(rightOfCursor);

        this.moveCursorTo(row, column + index);
    };

    this.moveCursorShortWordLeft = function() {
        var row = this.lead.row;
        var column = this.lead.column;

        var fold;
        if (fold = this.session.getFoldAt(row, column, -1))
            return this.moveCursorTo(fold.start.row, fold.start.column);

        var line = this.session.getLine(row).substring(0, column);
        if (column == 0) {
            do {
                row--;
                line = this.doc.getLine(row);
            } while (row > 0 && /^\s*$/.test(line))

            column = line.length;
            if (!/\s+$/.test(line))
                line = ""
        }

        var leftOfCursor = lang.stringReverse(line);
        var index = this.$shortWordEndIndex(leftOfCursor);

        return this.moveCursorTo(row, column - index);
    };

    this.moveCursorWordRight = function() {
        if (this.session.$selectLongWords)
            this.moveCursorLongWordRight();
        else
            this.moveCursorShortWordRight();
    };

    this.moveCursorWordLeft = function() {
        if (this.session.$selectLongWords)
            this.moveCursorLongWordLeft();
        else
            this.moveCursorShortWordLeft();
    };
    this.moveCursorBy = function(rows, chars) {
        var screenPos = this.session.documentToScreenPosition(
            this.lead.row,
            this.lead.column
        );

        if (chars === 0) {
            if (this.$desiredColumn)
                screenPos.column = this.$desiredColumn;
            else
                this.$desiredColumn = screenPos.column;
        }

        var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column);
        
        if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {
            if (this.session.lineWidgets && this.session.lineWidgets[docPos.row])
                docPos.row++;
        }
        this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
    };
    this.moveCursorToPosition = function(position) {
        this.moveCursorTo(position.row, position.column);
    };
    this.moveCursorTo = function(row, column, keepDesiredColumn) {
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold) {
            row = fold.start.row;
            column = fold.start.column;
        }

        this.$keepDesiredColumnOnChange = true;
        this.lead.setPosition(row, column);
        this.$keepDesiredColumnOnChange = false;

        if (!keepDesiredColumn)
            this.$desiredColumn = null;
    };
    this.moveCursorToScreen = function(row, column, keepDesiredColumn) {
        var pos = this.session.screenToDocumentPosition(row, column);
        this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
    };
    this.detach = function() {
        this.lead.detach();
        this.anchor.detach();
        this.session = this.doc = null;
    }

    this.fromOrientedRange = function(range) {
        this.setSelectionRange(range, range.cursor == range.start);
        this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
    }

    this.toOrientedRange = function(range) {
        var r = this.getRange();
        if (range) {
            range.start.column = r.start.column;
            range.start.row = r.start.row;
            range.end.column = r.end.column;
            range.end.row = r.end.row;
        } else {
            range = r;
        }

        range.cursor = this.isBackwards() ? range.start : range.end;
        range.desiredColumn = this.$desiredColumn;
        return range;
    }

    this.toJSON = function() {
        if (this.rangeCount) {
            var data = this.ranges.map(function(r) {
                var r1 = r.clone();
                r1.isBackwards = r.cursor == r.start;
                return r1;
            });
        } else {
            var data = this.getRange();
            data.isBackwards = this.isBackwards();
        }
        return data;
    };

    this.fromJSON = function(data) {
        if (data.start == undefined) {
            if (this.rangeList) {
                this.toSingleRange(data[0]);
                for (var i = data.length; i--; ) {
                    var r = Range.fromPoints(data[i].start, data[i].end);
                    if (data.isBackwards)
                        r.cursor = r.start;
                    this.addRange(r, true);
                }
                return;
            } else
                data = data[0];
        }
        if (this.rangeList)
            this.toSingleRange(data);
        this.setSelectionRange(data, data.isBackwards);
    };

    this.isEqual = function(data) {
        if ((data.length || this.rangeCount) && data.length != this.rangeCount)
            return false;
        if (!data.length || !this.ranges)
            return this.getRange().isEqual(data);

        for (var i = this.ranges.length; i--; ) {
            if (!this.ranges[i].isEqual(data[i]))
                return false
        }
        return true;
    }

}).call(Selection.prototype);

exports.Selection = Selection;
});

consoleAce.define('ace/range', ['require', 'exports', 'module' ], function(require, exports, module) {

var comparePoints = function(p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};
var Range = function(startRow, startColumn, endRow, endColumn) {
    this.start = {
        row: startRow,
        column: startColumn
    };

    this.end = {
        row: endRow,
        column: endColumn
    };
};

(function() {
    this.isEqual = function(range) {
        return this.start.row === range.start.row &&
            this.end.row === range.end.row &&
            this.start.column === range.start.column &&
            this.end.column === range.end.column;
    };
    this.toString = function() {
        return ("Range: [" + this.start.row + "/" + this.start.column +
            "] -> [" + this.end.row + "/" + this.end.column + "]");
    };

    this.contains = function(row, column) {
        return this.compare(row, column) == 0;
    };
    this.compareRange = function(range) {
        var cmp,
            end = range.end,
            start = range.start;

        cmp = this.compare(end.row, end.column);
        if (cmp == 1) {
            cmp = this.compare(start.row, start.column);
            if (cmp == 1) {
                return 2;
            } else if (cmp == 0) {
                return 1;
            } else {
                return 0;
            }
        } else if (cmp == -1) {
            return -2;
        } else {
            cmp = this.compare(start.row, start.column);
            if (cmp == -1) {
                return -1;
            } else if (cmp == 1) {
                return 42;
            } else {
                return 0;
            }
        }
    };
    this.comparePoint = function(p) {
        return this.compare(p.row, p.column);
    };
    this.containsRange = function(range) {
        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
    };
    this.intersects = function(range) {
        var cmp = this.compareRange(range);
        return (cmp == -1 || cmp == 0 || cmp == 1);
    };
    this.isEnd = function(row, column) {
        return this.end.row == row && this.end.column == column;
    };
    this.isStart = function(row, column) {
        return this.start.row == row && this.start.column == column;
    };
    this.setStart = function(row, column) {
        if (typeof row == "object") {
            this.start.column = row.column;
            this.start.row = row.row;
        } else {
            this.start.row = row;
            this.start.column = column;
        }
    };
    this.setEnd = function(row, column) {
        if (typeof row == "object") {
            this.end.column = row.column;
            this.end.row = row.row;
        } else {
            this.end.row = row;
            this.end.column = column;
        }
    };
    this.inside = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column) || this.isStart(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    };
    this.insideStart = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    };
    this.insideEnd = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isStart(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    };
    this.compare = function(row, column) {
        if (!this.isMultiLine()) {
            if (row === this.start.row) {
                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);
            };
        }

        if (row < this.start.row)
            return -1;

        if (row > this.end.row)
            return 1;

        if (this.start.row === row)
            return column >= this.start.column ? 0 : -1;

        if (this.end.row === row)
            return column <= this.end.column ? 0 : 1;

        return 0;
    };
    this.compareStart = function(row, column) {
        if (this.start.row == row && this.start.column == column) {
            return -1;
        } else {
            return this.compare(row, column);
        }
    };
    this.compareEnd = function(row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        } else {
            return this.compare(row, column);
        }
    };
    this.compareInside = function(row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        } else if (this.start.row == row && this.start.column == column) {
            return -1;
        } else {
            return this.compare(row, column);
        }
    };
    this.clipRows = function(firstRow, lastRow) {
        if (this.end.row > lastRow)
            var end = {row: lastRow + 1, column: 0};
        else if (this.end.row < firstRow)
            var end = {row: firstRow, column: 0};

        if (this.start.row > lastRow)
            var start = {row: lastRow + 1, column: 0};
        else if (this.start.row < firstRow)
            var start = {row: firstRow, column: 0};

        return Range.fromPoints(start || this.start, end || this.end);
    };
    this.extend = function(row, column) {
        var cmp = this.compare(row, column);

        if (cmp == 0)
            return this;
        else if (cmp == -1)
            var start = {row: row, column: column};
        else
            var end = {row: row, column: column};

        return Range.fromPoints(start || this.start, end || this.end);
    };

    this.isEmpty = function() {
        return (this.start.row === this.end.row && this.start.column === this.end.column);
    };
    this.isMultiLine = function() {
        return (this.start.row !== this.end.row);
    };
    this.clone = function() {
        return Range.fromPoints(this.start, this.end);
    };
    this.collapseRows = function() {
        if (this.end.column == 0)
            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0)
        else
            return new Range(this.start.row, 0, this.end.row, 0)
    };
    this.toScreenRange = function(session) {
        var screenPosStart = session.documentToScreenPosition(this.start);
        var screenPosEnd = session.documentToScreenPosition(this.end);

        return new Range(
            screenPosStart.row, screenPosStart.column,
            screenPosEnd.row, screenPosEnd.column
        );
    };
    this.moveBy = function(row, column) {
        this.start.row += row;
        this.start.column += column;
        this.end.row += row;
        this.end.column += column;
    };

}).call(Range.prototype);
Range.fromPoints = function(start, end) {
    return new Range(start.row, start.column, end.row, end.column);
};
Range.comparePoints = comparePoints;

Range.comparePoints = function(p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};


exports.Range = Range;
});

consoleAce.define('ace/mode/text', ['require', 'exports', 'module' , 'ace/tokenizer', 'ace/mode/text_highlight_rules', 'ace/mode/behaviour', 'ace/unicode', 'ace/lib/lang', 'ace/token_iterator', 'ace/range'], function(require, exports, module) {


var Tokenizer = require("../tokenizer").Tokenizer;
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
var Behaviour = require("./behaviour").Behaviour;
var unicode = require("../unicode");
var lang = require("../lib/lang");
var TokenIterator = require("../token_iterator").TokenIterator;
var Range = require("../range").Range;

var Mode = function() {
    this.HighlightRules = TextHighlightRules;
    this.$behaviour = new Behaviour();
};

(function() {

    this.tokenRe = new RegExp("^["
        + unicode.packages.L
        + unicode.packages.Mn + unicode.packages.Mc
        + unicode.packages.Nd
        + unicode.packages.Pc + "\\$_]+", "g"
    );

    this.nonTokenRe = new RegExp("^(?:[^"
        + unicode.packages.L
        + unicode.packages.Mn + unicode.packages.Mc
        + unicode.packages.Nd
        + unicode.packages.Pc + "\\$_]|\s])+", "g"
    );

    this.getTokenizer = function() {
        if (!this.$tokenizer) {
            this.$highlightRules = new this.HighlightRules();
            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
        }
        return this.$tokenizer;
    };

    this.lineCommentStart = "";
    this.blockComment = "";

    this.toggleCommentLines = function(state, session, startRow, endRow) {
        var doc = session.doc;

        var ignoreBlankLines = true;
        var shouldRemove = true;
        var minIndent = Infinity;
        var tabSize = session.getTabSize();
        var insertAtTabStop = false;

        if (!this.lineCommentStart) {
            if (!this.blockComment)
                return false;
            var lineCommentStart = this.blockComment.start;
            var lineCommentEnd = this.blockComment.end;
            var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
            var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");

            var comment = function(line, i) {
                if (testRemove(line, i))
                    return;
                if (!ignoreBlankLines || /\S/.test(line)) {
                    doc.insertInLine({row: i, column: line.length}, lineCommentEnd);
                    doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
                }
            };

            var uncomment = function(line, i) {
                var m;
                if (m = line.match(regexpEnd))
                    doc.removeInLine(i, line.length - m[0].length, line.length);
                if (m = line.match(regexpStart))
                    doc.removeInLine(i, m[1].length, m[0].length);
            };

            var testRemove = function(line, row) {
                if (regexpStart.test(line))
                    return true;
                var tokens = session.getTokens(row);
                for (var i = 0; i < tokens.length; i++) {
                    if (tokens[i].type === 'comment')
                        return true;
                }
            };
        } else {
            if (Array.isArray(this.lineCommentStart)) {
                var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
                var lineCommentStart = this.lineCommentStart[0];
            } else {
                var regexpStart = lang.escapeRegExp(this.lineCommentStart);
                var lineCommentStart = this.lineCommentStart;
            }
            regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");
            
            insertAtTabStop = session.getUseSoftTabs();

            var uncomment = function(line, i) {
                var m = line.match(regexpStart);
                if (!m) return;
                var start = m[1].length, end = m[0].length;
                if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ")
                    end--;
                doc.removeInLine(i, start, end);
            };
            var commentWithSpace = lineCommentStart + " ";
            var comment = function(line, i) {
                if (!ignoreBlankLines || /\S/.test(line)) {
                    if (shouldInsertSpace(line, minIndent, minIndent))
                        doc.insertInLine({row: i, column: minIndent}, commentWithSpace);
                    else
                        doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
                }
            };
            var testRemove = function(line, i) {
                return regexpStart.test(line);
            };
            
            var shouldInsertSpace = function(line, before, after) {
                var spaces = 0;
                while (before-- && line.charAt(before) == " ")
                    spaces++;
                if (spaces % tabSize != 0)
                    return false;
                var spaces = 0;
                while (line.charAt(after++) == " ")
                    spaces++;
                if (tabSize > 2)
                    return spaces % tabSize != tabSize - 1;
                else
                    return spaces % tabSize == 0;
                return true;
            };
        }

        function iter(fun) {
            for (var i = startRow; i <= endRow; i++)
                fun(doc.getLine(i), i);
        }


        var minEmptyLength = Infinity;
        iter(function(line, i) {
            var indent = line.search(/\S/);
            if (indent !== -1) {
                if (indent < minIndent)
                    minIndent = indent;
                if (shouldRemove && !testRemove(line, i))
                    shouldRemove = false;
            } else if (minEmptyLength > line.length) {
                minEmptyLength = line.length;
            }
        });

        if (minIndent == Infinity) {
            minIndent = minEmptyLength;
            ignoreBlankLines = false;
            shouldRemove = false;
        }

        if (insertAtTabStop && minIndent % tabSize != 0)
            minIndent = Math.floor(minIndent / tabSize) * tabSize;

        iter(shouldRemove ? uncomment : comment);
    };

    this.toggleBlockComment = function(state, session, range, cursor) {
        var comment = this.blockComment;
        if (!comment)
            return;
        if (!comment.start && comment[0])
            comment = comment[0];

        var iterator = new TokenIterator(session, cursor.row, cursor.column);
        var token = iterator.getCurrentToken();

        var sel = session.selection;
        var initialRange = session.selection.toOrientedRange();
        var startRow, colDiff;

        if (token && /comment/.test(token.type)) {
            var startRange, endRange;
            while (token && /comment/.test(token.type)) {
                var i = token.value.indexOf(comment.start);
                if (i != -1) {
                    var row = iterator.getCurrentTokenRow();
                    var column = iterator.getCurrentTokenColumn() + i;
                    startRange = new Range(row, column, row, column + comment.start.length);
                    break
                }
                token = iterator.stepBackward();
            };

            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            while (token && /comment/.test(token.type)) {
                var i = token.value.indexOf(comment.end);
                if (i != -1) {
                    var row = iterator.getCurrentTokenRow();
                    var column = iterator.getCurrentTokenColumn() + i;
                    endRange = new Range(row, column, row, column + comment.end.length);
                    break;
                }
                token = iterator.stepForward();
            }
            if (endRange)
                session.remove(endRange);
            if (startRange) {
                session.remove(startRange);
                startRow = startRange.start.row;
                colDiff = -comment.start.length
            }
        } else {
            colDiff = comment.start.length
            startRow = range.start.row;
            session.insert(range.end, comment.end);
            session.insert(range.start, comment.start);
        }
        if (initialRange.start.row == startRow)
            initialRange.start.column += colDiff;
        if (initialRange.end.row == startRow)
            initialRange.end.column += colDiff;
        session.selection.fromOrientedRange(initialRange);
    };

    this.getNextLineIndent = function(state, line, tab) {
        return this.$getIndent(line);
    };

    this.checkOutdent = function(state, line, input) {
        return false;
    };

    this.autoOutdent = function(state, doc, row) {
    };

    this.$getIndent = function(line) {
        return line.match(/^\s*/)[0];
    };

    this.createWorker = function(session) {
        return null;
    };

    this.createModeDelegates = function (mapping) {
        this.$embeds = [];
        this.$modes = {};
        for (var i in mapping) {
            if (mapping[i]) {
                this.$embeds.push(i);
                this.$modes[i] = new mapping[i]();
            }
        }

        var delegations = ['toggleCommentLines', 'getNextLineIndent', 'checkOutdent', 'autoOutdent', 'transformAction', 'getCompletions'];

        for (var i = 0; i < delegations.length; i++) {
            (function(scope) {
              var functionName = delegations[i];
              var defaultHandler = scope[functionName];
              scope[delegations[i]] = function() {
                  return this.$delegator(functionName, arguments, defaultHandler);
              }
            } (this));
        }
    };

    this.$delegator = function(method, args, defaultHandler) {
        var state = args[0];
        if (typeof state != "string")
            state = state[0];
        for (var i = 0; i < this.$embeds.length; i++) {
            if (!this.$modes[this.$embeds[i]]) continue;

            var split = state.split(this.$embeds[i]);
            if (!split[0] && split[1]) {
                args[0] = split[1];
                var mode = this.$modes[this.$embeds[i]];
                return mode[method].apply(mode, args);
            }
        }
        var ret = defaultHandler.apply(this, args);
        return defaultHandler ? ret : undefined;
    };

    this.transformAction = function(state, action, editor, session, param) {
        if (this.$behaviour) {
            var behaviours = this.$behaviour.getBehaviours();
            for (var key in behaviours) {
                if (behaviours[key][action]) {
                    var ret = behaviours[key][action].apply(this, arguments);
                    if (ret) {
                        return ret;
                    }
                }
            }
        }
    };
    
    this.getKeywords = function(append) {
        if (!this.completionKeywords) {
            var rules = this.$tokenizer.rules;
            var completionKeywords = [];
            for (var rule in rules) {
                var ruleItr = rules[rule];
                for (var r = 0, l = ruleItr.length; r < l; r++) {
                    if (typeof ruleItr[r].token === "string") {
                        if (/keyword|support|storage/.test(ruleItr[r].token))
                            completionKeywords.push(ruleItr[r].regex);
                    }
                    else if (typeof ruleItr[r].token === "object") {
                        for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {    
                            if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                                var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                                completionKeywords.push(rule.substr(1, rule.length - 2));
                            }
                        }
                    }
                }
            }
            this.completionKeywords = completionKeywords;
        }
        if (!append)
            return this.$keywordList;
        return completionKeywords.concat(this.$keywordList || []);
    };
    
    this.$createKeywordList = function() {
        if (!this.$highlightRules)
            this.getTokenizer();
        return this.$keywordList = this.$highlightRules.$keywordList || [];
    }

    this.getCompletions = function(state, session, pos, prefix) {
        var keywords = this.$keywordList || this.$createKeywordList();
        return keywords.map(function(word) {
            return {
                name: word,
                value: word,
                score: 0,
                meta: "keyword"
            };
        });
    };

    this.$id = "ace/mode/text";
}).call(Mode.prototype);

exports.Mode = Mode;
});

consoleAce.define('ace/tokenizer', ['require', 'exports', 'module' ], function(require, exports, module) {
var MAX_TOKEN_COUNT = 1000;
var Tokenizer = function(rules) {
    this.states = rules;

    this.regExps = {};
    this.matchMappings = {};
    for (var key in this.states) {
        var state = this.states[key];
        var ruleRegExps = [];
        var matchTotal = 0;
        var mapping = this.matchMappings[key] = {defaultToken: "text"};
        var flag = "g";

        var splitterRurles = [];
        for (var i = 0; i < state.length; i++) {
            var rule = state[i];
            if (rule.defaultToken)
                mapping.defaultToken = rule.defaultToken;
            if (rule.caseInsensitive)
                flag = "gi";
            if (rule.regex == null)
                continue;

            if (rule.regex instanceof RegExp)
                rule.regex = rule.regex.toString().slice(1, -1);
            var adjustedregex = rule.regex;
            var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
            if (Array.isArray(rule.token)) {
                if (rule.token.length == 1 || matchcount == 1) {
                    rule.token = rule.token[0];
                } else if (matchcount - 1 != rule.token.length) {
                    throw new Error("number of classes and regexp groups in '" + 
                        rule.token + "'\n'" + rule.regex +  "' doesn't match\n"
                        + (matchcount - 1) + "!=" + rule.token.length);
                } else {
                    rule.tokenArray = rule.token;
                    rule.token = null;
                    rule.onMatch = this.$arrayTokens;
                }
            } else if (typeof rule.token == "function" && !rule.onMatch) {
                if (matchcount > 1)
                    rule.onMatch = this.$applyToken;
                else
                    rule.onMatch = rule.token;
            }

            if (matchcount > 1) {
                if (/\\\d/.test(rule.regex)) {
                    adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match, digit) {
                        return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                    });
                } else {
                    matchcount = 1;
                    adjustedregex = this.removeCapturingGroups(rule.regex);
                }
                if (!rule.splitRegex && typeof rule.token != "string")
                    splitterRurles.push(rule); // flag will be known only at the very end
            }

            mapping[matchTotal] = i;
            matchTotal += matchcount;

            ruleRegExps.push(adjustedregex);
            if (!rule.onMatch)
                rule.onMatch = null;
            rule.__proto__ = null;
        }
        
        splitterRurles.forEach(function(rule) {
            rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
        }, this);

        this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
    }
};

(function() {
    this.$setMaxTokenCount = function(m) {
        MAX_TOKEN_COUNT = m | 0;
    };
    
    this.$applyToken = function(str) {
        var values = this.splitRegex.exec(str).slice(1);
        var types = this.token.apply(this, values);
        if (typeof types === "string")
            return [{type: types, value: str}];

        var tokens = [];
        for (var i = 0, l = types.length; i < l; i++) {
            if (values[i])
                tokens[tokens.length] = {
                    type: types[i],
                    value: values[i]
                };
        }
        return tokens;
    },

    this.$arrayTokens = function(str) {
        if (!str)
            return [];
        var values = this.splitRegex.exec(str);
        if (!values)
            return "text";
        var tokens = [];
        var types = this.tokenArray;
        for (var i = 0, l = types.length; i < l; i++) {
            if (values[i + 1])
                tokens[tokens.length] = {
                    type: types[i],
                    value: values[i + 1]
                };
        }
        return tokens;
    };

    this.removeCapturingGroups = function(src) {
        var r = src.replace(
            /\[(?:\\.|[^\]])*?\]|\\.|\(\?[:=!]|(\()/g,
            function(x, y) {return y ? "(?:" : x;}
        );
        return r;
    };

    this.createSplitterRegexp = function(src, flag) {
        if (src.indexOf("(?=") != -1) {
            var stack = 0;
            var inChClass = false;
            var lastCapture = {};
            src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(
                m, esc, parenOpen, parenClose, square, index
            ) {
                if (inChClass) {
                    inChClass = square != "]";
                } else if (square) {
                    inChClass = true;
                } else if (parenClose) {
                    if (stack == lastCapture.stack) {
                        lastCapture.end = index+1;
                        lastCapture.stack = -1;
                    }
                    stack--;
                } else if (parenOpen) {
                    stack++;
                    if (parenOpen.length != 1) {
                        lastCapture.stack = stack
                        lastCapture.start = index;
                    }
                }
                return m;
            });

            if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
                src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
        }
        return new RegExp(src, (flag||"").replace("g", ""));
    };
    this.getLineTokens = function(line, startState) {
        if (startState && typeof startState != "string") {
            var stack = startState.slice(0);
            startState = stack[0];
        } else
            var stack = [];

        var currentState = startState || "start";
        var state = this.states[currentState];
        if (!state) {
            currentState = "start";
            state = this.states[currentState];
        }
        var mapping = this.matchMappings[currentState];
        var re = this.regExps[currentState];
        re.lastIndex = 0;

        var match, tokens = [];
        var lastIndex = 0;

        var token = {type: null, value: ""};

        while (match = re.exec(line)) {
            var type = mapping.defaultToken;
            var rule = null;
            var value = match[0];
            var index = re.lastIndex;

            if (index - value.length > lastIndex) {
                var skipped = line.substring(lastIndex, index - value.length);
                if (token.type == type) {
                    token.value += skipped;
                } else {
                    if (token.type)
                        tokens.push(token);
                    token = {type: type, value: skipped};
                }
            }

            for (var i = 0; i < match.length-2; i++) {
                if (match[i + 1] === undefined)
                    continue;

                rule = state[mapping[i]];

                if (rule.onMatch)
                    type = rule.onMatch(value, currentState, stack);
                else
                    type = rule.token;

                if (rule.next) {
                    if (typeof rule.next == "string")
                        currentState = rule.next;
                    else
                        currentState = rule.next(currentState, stack);

                    state = this.states[currentState];
                    if (!state) {
                        window.console && console.error && console.error(currentState, "doesn't exist");
                        currentState = "start";
                        state = this.states[currentState];
                    }
                    mapping = this.matchMappings[currentState];
                    lastIndex = index;
                    re = this.regExps[currentState];
                    re.lastIndex = index;
                }
                break;
            }

            if (value) {
                if (typeof type == "string") {
                    if ((!rule || rule.merge !== false) && token.type === type) {
                        token.value += value;
                    } else {
                        if (token.type)
                            tokens.push(token);
                        token = {type: type, value: value};
                    }
                } else if (type) {
                    if (token.type)
                        tokens.push(token);
                    token = {type: null, value: ""};
                    for (var i = 0; i < type.length; i++)
                        tokens.push(type[i]);
                }
            }

            if (lastIndex == line.length)
                break;

            lastIndex = index;

            if (tokens.length > MAX_TOKEN_COUNT) {
                while (lastIndex < line.length) {
                    if (token.type)
                        tokens.push(token);
                    token = {
                        value: line.substring(lastIndex, lastIndex += 2000),
                        type: "overflow"
                    };
                }
                currentState = "start";
                stack = [];
                break;
            }
        }

        if (token.type)
            tokens.push(token);
        
        if (stack.length > 1) {
            if (stack[0] !== currentState)
                stack.unshift(currentState);
        }
        return {
            tokens : tokens,
            state : stack.length ? stack : currentState
        };
    };

}).call(Tokenizer.prototype);

exports.Tokenizer = Tokenizer;
});

consoleAce.define('ace/mode/text_highlight_rules', ['require', 'exports', 'module' , 'ace/lib/lang'], function(require, exports, module) {


var lang = require("../lib/lang");

var TextHighlightRules = function() {

    this.$rules = {
        "start" : [{
            token : "empty_line",
            regex : '^$'
        }, {
            defaultToken : "text"
        }]
    };
};

(function() {

    this.addRules = function(rules, prefix) {
        if (!prefix) {
            for (var key in rules)
                this.$rules[key] = rules[key];
            return;
        }
        for (var key in rules) {
            var state = rules[key];
            for (var i = 0; i < state.length; i++) {
                var rule = state[i];
                if (rule.next) {
                    if (typeof rule.next != "string") {
                        if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
                            rule.nextState = prefix + rule.nextState;
                    } else {
                        if (rule.next.indexOf(prefix) !== 0)
                            rule.next = prefix + rule.next;
                    }

                }
            }
            this.$rules[prefix + key] = state;
        }
    };

    this.getRules = function() {
        return this.$rules;
    };

    this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {
        var embedRules = new HighlightRules().getRules();
        if (states) {
            for (var i = 0; i < states.length; i++)
                states[i] = prefix + states[i];
        } else {
            states = [];
            for (var key in embedRules)
                states.push(prefix + key);
        }

        this.addRules(embedRules, prefix);

        if (escapeRules) {
            var addRules = Array.prototype[append ? "push" : "unshift"];
            for (var i = 0; i < states.length; i++)
                addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
        }

        if (!this.$embeds)
            this.$embeds = [];
        this.$embeds.push(prefix);
    };

    this.getEmbeds = function() {
        return this.$embeds;
    };

    var pushState = function(currentState, stack) {
        if (currentState != "start")
            stack.unshift(this.nextState, currentState);
        return this.nextState;
    };
    var popState = function(currentState, stack) {
        if (stack[0] !== currentState)
            return "start";
        stack.shift();
        return stack.shift();
    };

    this.normalizeRules = function() {
        var id = 0;
        var rules = this.$rules;
        function processState(key) {
            var state = rules[key];
            state.processed = true;
            for (var i = 0; i < state.length; i++) {
                var rule = state[i];
                if (!rule.regex && rule.start) {
                    rule.regex = rule.start;
                    if (!rule.next)
                        rule.next = [];
                    rule.next.push({
                        defaultToken: rule.token
                    }, {
                        token: rule.token + ".end",
                        regex: rule.end || rule.start,
                        next: "pop"
                    });
                    rule.token = rule.token + ".start";
                    rule.push = true;
                }
                var next = rule.next || rule.push;
                if (next && Array.isArray(next)) {
                    var stateName = rule.stateName;
                    if (!stateName)  {
                        stateName = rule.token;
                        if (typeof stateName != "string")
                            stateName = stateName[0] || "";
                        if (rules[stateName])
                            stateName += id++;
                    }
                    rules[stateName] = next;
                    rule.next = stateName;
                    processState(stateName);
                } else if (next == "pop") {
                    rule.next = popState;
                }

                if (rule.push) {
                    rule.nextState = rule.next || rule.push;
                    rule.next = pushState;
                    delete rule.push;
                }

                if (rule.rules) {
                    for (var r in rule.rules) {
                        if (rules[r]) {
                            if (rules[r].push)
                                rules[r].push.apply(rules[r], rule.rules[r]);
                        } else {
                            rules[r] = rule.rules[r];
                        }
                    }
                }
                if (rule.include || typeof rule == "string") {
                    var includeName = rule.include || rule;
                    var toInsert = rules[includeName];
                } else if (Array.isArray(rule))
                    toInsert = rule;

                if (toInsert) {
                    var args = [i, 1].concat(toInsert);
                    if (rule.noEscape)
                        args = args.filter(function(x) {return !x.next;});
                    state.splice.apply(state, args);
                    i--;
                    toInsert = null
                }
                
                if (rule.keywordMap) {
                    rule.token = this.createKeywordMapper(
                        rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive
                    );
                    delete rule.defaultToken;
                }
            }
        };
        Object.keys(rules).forEach(processState, this);
    };

    this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
        var keywords = Object.create(null);
        Object.keys(map).forEach(function(className) {
            var a = map[className];
            if (ignoreCase)
                a = a.toLowerCase();
            var list = a.split(splitChar || "|");
            for (var i = list.length; i--; )
                keywords[list[i]] = className;
        });
        if (Object.getPrototypeOf(keywords)) {
            keywords.__proto__ = null;
        }
        this.$keywordList = Object.keys(keywords);
        map = null;
        return ignoreCase
            ? function(value) {return keywords[value.toLowerCase()] || defaultToken }
            : function(value) {return keywords[value] || defaultToken };
    }

    this.getKeywords = function() {
        return this.$keywords;
    };

}).call(TextHighlightRules.prototype);

exports.TextHighlightRules = TextHighlightRules;
});

consoleAce.define('ace/mode/behaviour', ['require', 'exports', 'module' ], function(require, exports, module) {


var Behaviour = function() {
   this.$behaviours = {};
};

(function () {

    this.add = function (name, action, callback) {
        switch (undefined) {
          case this.$behaviours:
              this.$behaviours = {};
          case this.$behaviours[name]:
              this.$behaviours[name] = {};
        }
        this.$behaviours[name][action] = callback;
    }
    
    this.addBehaviours = function (behaviours) {
        for (var key in behaviours) {
            for (var action in behaviours[key]) {
                this.add(key, action, behaviours[key][action]);
            }
        }
    }
    
    this.remove = function (name) {
        if (this.$behaviours && this.$behaviours[name]) {
            delete this.$behaviours[name];
        }
    }
    
    this.inherit = function (mode, filter) {
        if (typeof mode === "function") {
            var behaviours = new mode().getBehaviours(filter);
        } else {
            var behaviours = mode.getBehaviours(filter);
        }
        this.addBehaviours(behaviours);
    }
    
    this.getBehaviours = function (filter) {
        if (!filter) {
            return this.$behaviours;
        } else {
            var ret = {}
            for (var i = 0; i < filter.length; i++) {
                if (this.$behaviours[filter[i]]) {
                    ret[filter[i]] = this.$behaviours[filter[i]];
                }
            }
            return ret;
        }
    }

}).call(Behaviour.prototype);

exports.Behaviour = Behaviour;
});
consoleAce.define('ace/unicode', ['require', 'exports', 'module' ], function(require, exports, module) {
exports.packages = {};

addUnicodePackage({
    L:  "0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05250531-055605590561-058705D0-05EA05F0-05F20621-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280904-0939093D09500958-0961097109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510D0-10FA10FC1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209421022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2D00-2D252D30-2D652D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A65FA662-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78BA78CA7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
    Ll: "0061-007A00AA00B500BA00DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F0521052305250561-05871D00-1D2B1D62-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7C2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2D00-2D25A641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CFB00-FB06FB13-FB17FF41-FF5A",
    Lu: "0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E0520052205240531-055610A0-10C51E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CEDA640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BFF21-FF3A",
    Lt: "01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC",
    Lm: "02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D611D781D9B-1DBF2071207F2090-20942C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A9CFAA70AADDFF70FF9EFF9F",
    Lo: "01BB01C0-01C3029405D0-05EA05F0-05F20621-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150904-0939093D09500958-096109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF12135-21382D30-2D652D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
    M:  "0300-036F0483-04890591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DE-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0903093C093E-094E0951-0955096209630981-098309BC09BE-09C409C709C809CB-09CD09D709E209E30A01-0A030A3C0A3E-0A420A470A480A4B-0A4D0A510A700A710A750A81-0A830ABC0ABE-0AC50AC7-0AC90ACB-0ACD0AE20AE30B01-0B030B3C0B3E-0B440B470B480B4B-0B4D0B560B570B620B630B820BBE-0BC20BC6-0BC80BCA-0BCD0BD70C01-0C030C3E-0C440C46-0C480C4A-0C4D0C550C560C620C630C820C830CBC0CBE-0CC40CC6-0CC80CCA-0CCD0CD50CD60CE20CE30D020D030D3E-0D440D46-0D480D4A-0D4D0D570D620D630D820D830DCA0DCF-0DD40DD60DD8-0DDF0DF20DF30E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F3E0F3F0F71-0F840F860F870F90-0F970F99-0FBC0FC6102B-103E1056-1059105E-10601062-10641067-106D1071-10741082-108D108F109A-109D135F1712-17141732-1734175217531772177317B6-17D317DD180B-180D18A91920-192B1930-193B19B0-19C019C819C91A17-1A1B1A55-1A5E1A60-1A7C1A7F1B00-1B041B34-1B441B6B-1B731B80-1B821BA1-1BAA1C24-1C371CD0-1CD21CD4-1CE81CED1CF21DC0-1DE61DFD-1DFF20D0-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66F-A672A67CA67DA6F0A6F1A802A806A80BA823-A827A880A881A8B4-A8C4A8E0-A8F1A926-A92DA947-A953A980-A983A9B3-A9C0AA29-AA36AA43AA4CAA4DAA7BAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE3-ABEAABECABEDFB1EFE00-FE0FFE20-FE26",
    Mn: "0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0902093C0941-0948094D0951-095509620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F90-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135F1712-17141732-1734175217531772177317B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1DC0-1DE61DFD-1DFF20D0-20DC20E120E5-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66FA67CA67DA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26",
    Mc: "0903093E-09400949-094C094E0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1C24-1C2B1C341C351CE11CF2A823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BABE3ABE4ABE6ABE7ABE9ABEAABEC",
    Me: "0488048906DE20DD-20E020E2-20E4A670-A672",
    N:  "0030-003900B200B300B900BC-00BE0660-066906F0-06F907C0-07C90966-096F09E6-09EF09F4-09F90A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BF20C66-0C6F0C78-0C7E0CE6-0CEF0D66-0D750E50-0E590ED0-0ED90F20-0F331040-10491090-10991369-137C16EE-16F017E0-17E917F0-17F91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C5920702074-20792080-20892150-21822185-21892460-249B24EA-24FF2776-27932CFD30073021-30293038-303A3192-31953220-32293251-325F3280-328932B1-32BFA620-A629A6E6-A6EFA830-A835A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
    Nd: "0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
    Nl: "16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF",
    No: "00B200B300B900BC-00BE09F4-09F90BF0-0BF20C78-0C7E0D70-0D750F2A-0F331369-137C17F0-17F920702074-20792080-20892150-215F21892460-249B24EA-24FF2776-27932CFD3192-31953220-32293251-325F3280-328932B1-32BFA830-A835",
    P:  "0021-00230025-002A002C-002F003A003B003F0040005B-005D005F007B007D00A100AB00B700BB00BF037E0387055A-055F0589058A05BE05C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F3A-0F3D0F850FD0-0FD4104A-104F10FB1361-13681400166D166E169B169C16EB-16ED1735173617D4-17D617D8-17DA1800-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD32010-20272030-20432045-20512053-205E207D207E208D208E2329232A2768-277527C527C627E6-27EF2983-299829D8-29DB29FC29FD2CF9-2CFC2CFE2CFF2E00-2E2E2E302E313001-30033008-30113014-301F3030303D30A030FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFD3EFD3FFE10-FE19FE30-FE52FE54-FE61FE63FE68FE6AFE6BFF01-FF03FF05-FF0AFF0C-FF0FFF1AFF1BFF1FFF20FF3B-FF3DFF3FFF5BFF5DFF5F-FF65",
    Pd: "002D058A05BE140018062010-20152E172E1A301C303030A0FE31FE32FE58FE63FF0D",
    Ps: "0028005B007B0F3A0F3C169B201A201E2045207D208D23292768276A276C276E27702772277427C527E627E827EA27EC27EE2983298529872989298B298D298F299129932995299729D829DA29FC2E222E242E262E283008300A300C300E3010301430163018301A301DFD3EFE17FE35FE37FE39FE3BFE3DFE3FFE41FE43FE47FE59FE5BFE5DFF08FF3BFF5BFF5FFF62",
    Pe: "0029005D007D0F3B0F3D169C2046207E208E232A2769276B276D276F27712773277527C627E727E927EB27ED27EF298429862988298A298C298E2990299229942996299829D929DB29FD2E232E252E272E293009300B300D300F3011301530173019301B301E301FFD3FFE18FE36FE38FE3AFE3CFE3EFE40FE42FE44FE48FE5AFE5CFE5EFF09FF3DFF5DFF60FF63",
    Pi: "00AB2018201B201C201F20392E022E042E092E0C2E1C2E20",
    Pf: "00BB2019201D203A2E032E052E0A2E0D2E1D2E21",
    Pc: "005F203F20402054FE33FE34FE4D-FE4FFF3F",
    Po: "0021-00230025-0027002A002C002E002F003A003B003F0040005C00A100B700BF037E0387055A-055F058905C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F850FD0-0FD4104A-104F10FB1361-1368166D166E16EB-16ED1735173617D4-17D617D8-17DA1800-18051807-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD3201620172020-20272030-2038203B-203E2041-20432047-205120532055-205E2CF9-2CFC2CFE2CFF2E002E012E06-2E082E0B2E0E-2E162E182E192E1B2E1E2E1F2E2A-2E2E2E302E313001-3003303D30FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFE10-FE16FE19FE30FE45FE46FE49-FE4CFE50-FE52FE54-FE57FE5F-FE61FE68FE6AFE6BFF01-FF03FF05-FF07FF0AFF0CFF0EFF0FFF1AFF1BFF1FFF20FF3CFF61FF64FF65",
    S:  "0024002B003C-003E005E0060007C007E00A2-00A900AC00AE-00B100B400B600B800D700F702C2-02C502D2-02DF02E5-02EB02ED02EF-02FF03750384038503F604820606-0608060B060E060F06E906FD06FE07F609F209F309FA09FB0AF10B700BF3-0BFA0C7F0CF10CF20D790E3F0F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-139917DB194019E0-19FF1B61-1B6A1B74-1B7C1FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE20442052207A-207C208A-208C20A0-20B8210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B2140-2144214A-214D214F2190-2328232B-23E82400-24262440-244A249C-24E92500-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE27C0-27C427C7-27CA27CC27D0-27E527F0-29822999-29D729DC-29FB29FE-2B4C2B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F309B309C319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A700-A716A720A721A789A78AA828-A82BA836-A839AA77-AA79FB29FDFCFDFDFE62FE64-FE66FE69FF04FF0BFF1C-FF1EFF3EFF40FF5CFF5EFFE0-FFE6FFE8-FFEEFFFCFFFD",
    Sm: "002B003C-003E007C007E00AC00B100D700F703F60606-060820442052207A-207C208A-208C2140-2144214B2190-2194219A219B21A021A321A621AE21CE21CF21D221D421F4-22FF2308-230B23202321237C239B-23B323DC-23E125B725C125F8-25FF266F27C0-27C427C7-27CA27CC27D0-27E527F0-27FF2900-29822999-29D729DC-29FB29FE-2AFF2B30-2B442B47-2B4CFB29FE62FE64-FE66FF0BFF1C-FF1EFF5CFF5EFFE2FFE9-FFEC",
    Sc: "002400A2-00A5060B09F209F309FB0AF10BF90E3F17DB20A0-20B8A838FDFCFE69FF04FFE0FFE1FFE5FFE6",
    Sk: "005E006000A800AF00B400B802C2-02C502D2-02DF02E5-02EB02ED02EF-02FF0375038403851FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE309B309CA700-A716A720A721A789A78AFF3EFF40FFE3",
    So: "00A600A700A900AE00B000B60482060E060F06E906FD06FE07F609FA0B700BF3-0BF80BFA0C7F0CF10CF20D790F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-1399194019E0-19FF1B61-1B6A1B74-1B7C210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B214A214C214D214F2195-2199219C-219F21A121A221A421A521A7-21AD21AF-21CD21D021D121D321D5-21F32300-2307230C-231F2322-2328232B-237B237D-239A23B4-23DB23E2-23E82400-24262440-244A249C-24E92500-25B625B8-25C025C2-25F72600-266E2670-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE2800-28FF2B00-2B2F2B452B462B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A828-A82BA836A837A839AA77-AA79FDFDFFE4FFE8FFEDFFEEFFFCFFFD",
    Z:  "002000A01680180E2000-200A20282029202F205F3000",
    Zs: "002000A01680180E2000-200A202F205F3000",
    Zl: "2028",
    Zp: "2029",
    C:  "0000-001F007F-009F00AD03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-0605061C061D0620065F06DD070E070F074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17B417B517DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF200B-200F202A-202E2060-206F20722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-F8FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFD-FF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFFBFFFEFFFF",
    Cc: "0000-001F007F-009F",
    Cf: "00AD0600-060306DD070F17B417B5200B-200F202A-202E2060-2064206A-206FFEFFFFF9-FFFB",
    Co: "E000-F8FF",
    Cs: "D800-DFFF",
    Cn: "03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-05FF06040605061C061D0620065F070E074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF2065-206920722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-D7FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFDFEFEFF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFF8FFFEFFFF"
});

function addUnicodePackage (pack) {
    var codePoint = /\w{4}/g;
    for (var name in pack)
        exports.packages[name] = pack[name].replace(codePoint, "\\u$&");
};

});

consoleAce.define('ace/token_iterator', ['require', 'exports', 'module' ], function(require, exports, module) {
var TokenIterator = function(session, initialRow, initialColumn) {
    this.$session = session;
    this.$row = initialRow;
    this.$rowTokens = session.getTokens(initialRow);

    var token = session.getTokenAt(initialRow, initialColumn);
    this.$tokenIndex = token ? token.index : -1;
};

(function() { 
    this.stepBackward = function() {
        this.$tokenIndex -= 1;
        
        while (this.$tokenIndex < 0) {
            this.$row -= 1;
            if (this.$row < 0) {
                this.$row = 0;
                return null;
            }
                
            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = this.$rowTokens.length - 1;
        }
            
        return this.$rowTokens[this.$tokenIndex];
    };   
    this.stepForward = function() {
        this.$tokenIndex += 1;
        var rowCount;
        while (this.$tokenIndex >= this.$rowTokens.length) {
            this.$row += 1;
            if (!rowCount)
                rowCount = this.$session.getLength();
            if (this.$row >= rowCount) {
                this.$row = rowCount - 1;
                return null;
            }

            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = 0;
        }
            
        return this.$rowTokens[this.$tokenIndex];
    };      
    this.getCurrentToken = function () {
        return this.$rowTokens[this.$tokenIndex];
    };      
    this.getCurrentTokenRow = function () {
        return this.$row;
    };     
    this.getCurrentTokenColumn = function() {
        var rowTokens = this.$rowTokens;
        var tokenIndex = this.$tokenIndex;
        var column = rowTokens[tokenIndex].start;
        if (column !== undefined)
            return column;
            
        column = 0;
        while (tokenIndex > 0) {
            tokenIndex -= 1;
            column += rowTokens[tokenIndex].value.length;
        }
        
        return column;  
    };
            
}).call(TokenIterator.prototype);

exports.TokenIterator = TokenIterator;
});

consoleAce.define('ace/document', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/lib/event_emitter', 'ace/range', 'ace/anchor'], function(require, exports, module) {


var oop = require("./lib/oop");
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var Range = require("./range").Range;
var Anchor = require("./anchor").Anchor;

var Document = function(text) {
    this.$lines = [];
    if (text.length == 0) {
        this.$lines = [""];
    } else if (Array.isArray(text)) {
        this._insertLines(0, text);
    } else {
        this.insert({row: 0, column:0}, text);
    }
};

(function() {

    oop.implement(this, EventEmitter);
    this.setValue = function(text) {
        var len = this.getLength();
        this.remove(new Range(0, 0, len, this.getLine(len-1).length));
        this.insert({row: 0, column:0}, text);
    };
    this.getValue = function() {
        return this.getAllLines().join(this.getNewLineCharacter());
    };
    this.createAnchor = function(row, column) {
        return new Anchor(this, row, column);
    };
    if ("aaa".split(/a/).length == 0)
        this.$split = function(text) {
            return text.replace(/\r\n|\r/g, "\n").split("\n");
        }
    else
        this.$split = function(text) {
            return text.split(/\r\n|\r|\n/);
        };


    this.$detectNewLine = function(text) {
        var match = text.match(/^.*?(\r\n|\r|\n)/m);
        this.$autoNewLine = match ? match[1] : "\n";
    };
    this.getNewLineCharacter = function() {
        switch (this.$newLineMode) {
          case "windows":
            return "\r\n";
          case "unix":
            return "\n";
          default:
            return this.$autoNewLine;
        }
    };

    this.$autoNewLine = "\n";
    this.$newLineMode = "auto";
    this.setNewLineMode = function(newLineMode) {
        if (this.$newLineMode === newLineMode)
            return;

        this.$newLineMode = newLineMode;
    };
    this.getNewLineMode = function() {
        return this.$newLineMode;
    };
    this.isNewLine = function(text) {
        return (text == "\r\n" || text == "\r" || text == "\n");
    };
    this.getLine = function(row) {
        return this.$lines[row] || "";
    };
    this.getLines = function(firstRow, lastRow) {
        return this.$lines.slice(firstRow, lastRow + 1);
    };
    this.getAllLines = function() {
        return this.getLines(0, this.getLength());
    };
    this.getLength = function() {
        return this.$lines.length;
    };
    this.getTextRange = function(range) {
        if (range.start.row == range.end.row) {
            return this.getLine(range.start.row)
                .substring(range.start.column, range.end.column);
        }
        var lines = this.getLines(range.start.row, range.end.row);
        lines[0] = (lines[0] || "").substring(range.start.column);
        var l = lines.length - 1;
        if (range.end.row - range.start.row == l)
            lines[l] = lines[l].substring(0, range.end.column);
        return lines.join(this.getNewLineCharacter());
    };

    this.$clipPosition = function(position) {
        var length = this.getLength();
        if (position.row >= length) {
            position.row = Math.max(0, length - 1);
            position.column = this.getLine(length-1).length;
        } else if (position.row < 0)
            position.row = 0;
        return position;
    };
    this.insert = function(position, text) {
        if (!text || text.length === 0)
            return position;

        position = this.$clipPosition(position);
        if (this.getLength() <= 1)
            this.$detectNewLine(text);

        var lines = this.$split(text);
        var firstLine = lines.splice(0, 1)[0];
        var lastLine = lines.length == 0 ? null : lines.splice(lines.length - 1, 1)[0];

        position = this.insertInLine(position, firstLine);
        if (lastLine !== null) {
            position = this.insertNewLine(position); // terminate first line
            position = this._insertLines(position.row, lines);
            position = this.insertInLine(position, lastLine || "");
        }
        return position;
    };
    this.insertLines = function(row, lines) {
        if (row >= this.getLength())
            return this.insert({row: row, column: 0}, "\n" + lines.join("\n"));
        return this._insertLines(Math.max(row, 0), lines);
    };
    this._insertLines = function(row, lines) {
        if (lines.length == 0)
            return {row: row, column: 0};
        if (lines.length > 0xFFFF) {
            var end = this._insertLines(row, lines.slice(0xFFFF));
            lines = lines.slice(0, 0xFFFF);
        }

        var args = [row, 0];
        args.push.apply(args, lines);
        this.$lines.splice.apply(this.$lines, args);

        var range = new Range(row, 0, row + lines.length, 0);
        var delta = {
            action: "insertLines",
            range: range,
            lines: lines
        };
        this._emit("change", { data: delta });
        return end || range.end;
    };
    this.insertNewLine = function(position) {
        position = this.$clipPosition(position);
        var line = this.$lines[position.row] || "";

        this.$lines[position.row] = line.substring(0, position.column);
        this.$lines.splice(position.row + 1, 0, line.substring(position.column, line.length));

        var end = {
            row : position.row + 1,
            column : 0
        };

        var delta = {
            action: "insertText",
            range: Range.fromPoints(position, end),
            text: this.getNewLineCharacter()
        };
        this._emit("change", { data: delta });

        return end;
    };
    this.insertInLine = function(position, text) {
        if (text.length == 0)
            return position;

        var line = this.$lines[position.row] || "";

        this.$lines[position.row] = line.substring(0, position.column) + text
                + line.substring(position.column);

        var end = {
            row : position.row,
            column : position.column + text.length
        };

        var delta = {
            action: "insertText",
            range: Range.fromPoints(position, end),
            text: text
        };
        this._emit("change", { data: delta });

        return end;
    };
    this.remove = function(range) {
        if (!range instanceof Range)
            range = Range.fromPoints(range.start, range.end);
        range.start = this.$clipPosition(range.start);
        range.end = this.$clipPosition(range.end);

        if (range.isEmpty())
            return range.start;

        var firstRow = range.start.row;
        var lastRow = range.end.row;

        if (range.isMultiLine()) {
            var firstFullRow = range.start.column == 0 ? firstRow : firstRow + 1;
            var lastFullRow = lastRow - 1;

            if (range.end.column > 0)
                this.removeInLine(lastRow, 0, range.end.column);

            if (lastFullRow >= firstFullRow)
                this._removeLines(firstFullRow, lastFullRow);

            if (firstFullRow != firstRow) {
                this.removeInLine(firstRow, range.start.column, this.getLine(firstRow).length);
                this.removeNewLine(range.start.row);
            }
        }
        else {
            this.removeInLine(firstRow, range.start.column, range.end.column);
        }
        return range.start;
    };
    this.removeInLine = function(row, startColumn, endColumn) {
        if (startColumn == endColumn)
            return;

        var range = new Range(row, startColumn, row, endColumn);
        var line = this.getLine(row);
        var removed = line.substring(startColumn, endColumn);
        var newLine = line.substring(0, startColumn) + line.substring(endColumn, line.length);
        this.$lines.splice(row, 1, newLine);

        var delta = {
            action: "removeText",
            range: range,
            text: removed
        };
        this._emit("change", { data: delta });
        return range.start;
    };
    this.removeLines = function(firstRow, lastRow) {
        if (firstRow < 0 || lastRow >= this.getLength())
            return this.remove(new Range(firstRow, 0, lastRow + 1, 0));
        return this._removeLines(firstRow, lastRow);
    };

    this._removeLines = function(firstRow, lastRow) {
        var range = new Range(firstRow, 0, lastRow + 1, 0);
        var removed = this.$lines.splice(firstRow, lastRow - firstRow + 1);

        var delta = {
            action: "removeLines",
            range: range,
            nl: this.getNewLineCharacter(),
            lines: removed
        };
        this._emit("change", { data: delta });
        return removed;
    };
    this.removeNewLine = function(row) {
        var firstLine = this.getLine(row);
        var secondLine = this.getLine(row+1);

        var range = new Range(row, firstLine.length, row+1, 0);
        var line = firstLine + secondLine;

        this.$lines.splice(row, 2, line);

        var delta = {
            action: "removeText",
            range: range,
            text: this.getNewLineCharacter()
        };
        this._emit("change", { data: delta });
    };
    this.replace = function(range, text) {
        if (!range instanceof Range)
            range = Range.fromPoints(range.start, range.end);
        if (text.length == 0 && range.isEmpty())
            return range.start;
        if (text == this.getTextRange(range))
            return range.end;

        this.remove(range);
        if (text) {
            var end = this.insert(range.start, text);
        }
        else {
            end = range.start;
        }

        return end;
    };
    this.applyDeltas = function(deltas) {
        for (var i=0; i<deltas.length; i++) {
            var delta = deltas[i];
            var range = Range.fromPoints(delta.range.start, delta.range.end);

            if (delta.action == "insertLines")
                this.insertLines(range.start.row, delta.lines);
            else if (delta.action == "insertText")
                this.insert(range.start, delta.text);
            else if (delta.action == "removeLines")
                this._removeLines(range.start.row, range.end.row - 1);
            else if (delta.action == "removeText")
                this.remove(range);
        }
    };
    this.revertDeltas = function(deltas) {
        for (var i=deltas.length-1; i>=0; i--) {
            var delta = deltas[i];

            var range = Range.fromPoints(delta.range.start, delta.range.end);

            if (delta.action == "insertLines")
                this._removeLines(range.start.row, range.end.row - 1);
            else if (delta.action == "insertText")
                this.remove(range);
            else if (delta.action == "removeLines")
                this._insertLines(range.start.row, delta.lines);
            else if (delta.action == "removeText")
                this.insert(range.start, delta.text);
        }
    };
    this.indexToPosition = function(index, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        for (var i = startRow || 0, l = lines.length; i < l; i++) {
            index -= lines[i].length + newlineLength;
            if (index < 0)
                return {row: i, column: index + lines[i].length + newlineLength};
        }
        return {row: l-1, column: lines[l-1].length};
    };
    this.positionToIndex = function(pos, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        var index = 0;
        var row = Math.min(pos.row, lines.length);
        for (var i = startRow || 0; i < row; ++i)
            index += lines[i].length + newlineLength;

        return index + pos.column;
    };

}).call(Document.prototype);

exports.Document = Document;
});

consoleAce.define('ace/anchor', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/lib/event_emitter'], function(require, exports, module) {


var oop = require("./lib/oop");
var EventEmitter = require("./lib/event_emitter").EventEmitter;

var Anchor = exports.Anchor = function(doc, row, column) {
    this.$onChange = this.onChange.bind(this);
    this.attach(doc);
    
    if (typeof column == "undefined")
        this.setPosition(row.row, row.column);
    else
        this.setPosition(row, column);
};

(function() {

    oop.implement(this, EventEmitter);
    this.getPosition = function() {
        return this.$clipPositionToDocument(this.row, this.column);
    };
    this.getDocument = function() {
        return this.document;
    };
    this.$insertRight = false;
    this.onChange = function(e) {
        var delta = e.data;
        var range = delta.range;

        if (range.start.row == range.end.row && range.start.row != this.row)
            return;

        if (range.start.row > this.row)
            return;

        if (range.start.row == this.row && range.start.column > this.column)
            return;

        var row = this.row;
        var column = this.column;
        var start = range.start;
        var end = range.end;

        if (delta.action === "insertText") {
            if (start.row === row && start.column <= column) {
                if (start.column === column && this.$insertRight) {
                } else if (start.row === end.row) {
                    column += end.column - start.column;
                } else {
                    column -= start.column;
                    row += end.row - start.row;
                }
            } else if (start.row !== end.row && start.row < row) {
                row += end.row - start.row;
            }
        } else if (delta.action === "insertLines") {
            if (start.row <= row) {
                row += end.row - start.row;
            }
        } else if (delta.action === "removeText") {
            if (start.row === row && start.column < column) {
                if (end.column >= column)
                    column = start.column;
                else
                    column = Math.max(0, column - (end.column - start.column));

            } else if (start.row !== end.row && start.row < row) {
                if (end.row === row)
                    column = Math.max(0, column - end.column) + start.column;
                row -= (end.row - start.row);
            } else if (end.row === row) {
                row -= end.row - start.row;
                column = Math.max(0, column - end.column) + start.column;
            }
        } else if (delta.action == "removeLines") {
            if (start.row <= row) {
                if (end.row <= row)
                    row -= end.row - start.row;
                else {
                    row = start.row;
                    column = 0;
                }
            }
        }

        this.setPosition(row, column, true);
    };
    this.setPosition = function(row, column, noClip) {
        var pos;
        if (noClip) {
            pos = {
                row: row,
                column: column
            };
        } else {
            pos = this.$clipPositionToDocument(row, column);
        }

        if (this.row == pos.row && this.column == pos.column)
            return;

        var old = {
            row: this.row,
            column: this.column
        };

        this.row = pos.row;
        this.column = pos.column;
        this._emit("change", {
            old: old,
            value: pos
        });
    };
    this.detach = function() {
        this.document.removeEventListener("change", this.$onChange);
    };
    this.attach = function(doc) {
        this.document = doc || this.document;
        this.document.on("change", this.$onChange);
    };
    this.$clipPositionToDocument = function(row, column) {
        var pos = {};

        if (row >= this.document.getLength()) {
            pos.row = Math.max(0, this.document.getLength() - 1);
            pos.column = this.document.getLine(pos.row).length;
        }
        else if (row < 0) {
            pos.row = 0;
            pos.column = 0;
        }
        else {
            pos.row = row;
            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
        }

        if (column < 0)
            pos.column = 0;

        return pos;
    };

}).call(Anchor.prototype);

});

consoleAce.define('ace/background_tokenizer', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/lib/event_emitter'], function(require, exports, module) {


var oop = require("./lib/oop");
var EventEmitter = require("./lib/event_emitter").EventEmitter;

var BackgroundTokenizer = function(tokenizer, editor) {
    this.running = false;
    this.lines = [];
    this.states = [];
    this.currentLine = 0;
    this.tokenizer = tokenizer;

    var self = this;

    this.$worker = function() {
        if (!self.running) { return; }

        var workerStart = new Date();
        var currentLine = self.currentLine;
        var endLine = -1;
        var doc = self.doc;

        while (self.lines[currentLine])
            currentLine++;

        var startLine = currentLine;

        var len = doc.getLength();
        var processedLines = 0;
        self.running = false;
        while (currentLine < len) {
            self.$tokenizeRow(currentLine);
            endLine = currentLine;
            do {
                currentLine++;
            } while (self.lines[currentLine]);
            processedLines ++;
            if ((processedLines % 5 == 0) && (new Date() - workerStart) > 20) {                
                self.running = setTimeout(self.$worker, 20);
                self.currentLine = currentLine;
                return;
            }
        }
        self.currentLine = currentLine;
        
        if (startLine <= endLine)
            self.fireUpdateEvent(startLine, endLine);
    };
};

(function(){

    oop.implement(this, EventEmitter);
    this.setTokenizer = function(tokenizer) {
        this.tokenizer = tokenizer;
        this.lines = [];
        this.states = [];

        this.start(0);
    };
    this.setDocument = function(doc) {
        this.doc = doc;
        this.lines = [];
        this.states = [];

        this.stop();
    };
    this.fireUpdateEvent = function(firstRow, lastRow) {
        var data = {
            first: firstRow,
            last: lastRow
        };
        this._emit("update", {data: data});
    };
    this.start = function(startRow) {
        this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
        this.lines.splice(this.currentLine, this.lines.length);
        this.states.splice(this.currentLine, this.states.length);

        this.stop();
        this.running = setTimeout(this.$worker, 700);
    };
    
    this.scheduleStart = function() {
        if (!this.running)
            this.running = setTimeout(this.$worker, 700);
    }

    this.$updateOnChange = function(delta) {
        var range = delta.range;
        var startRow = range.start.row;
        var len = range.end.row - startRow;

        if (len === 0) {
            this.lines[startRow] = null;
        } else if (delta.action == "removeText" || delta.action == "removeLines") {
            this.lines.splice(startRow, len + 1, null);
            this.states.splice(startRow, len + 1, null);
        } else {
            var args = Array(len + 1);
            args.unshift(startRow, 1);
            this.lines.splice.apply(this.lines, args);
            this.states.splice.apply(this.states, args);
        }

        this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());

        this.stop();
    };
    this.stop = function() {
        if (this.running)
            clearTimeout(this.running);
        this.running = false;
    };
    this.getTokens = function(row) {
        return this.lines[row] || this.$tokenizeRow(row);
    };
    this.getState = function(row) {
        if (this.currentLine == row)
            this.$tokenizeRow(row);
        return this.states[row] || "start";
    };

    this.$tokenizeRow = function(row) {
        var line = this.doc.getLine(row);
        var state = this.states[row - 1];

        var data = this.tokenizer.getLineTokens(line, state, row);

        if (this.states[row] + "" !== data.state + "") {
            this.states[row] = data.state;
            this.lines[row + 1] = null;
            if (this.currentLine > row + 1)
                this.currentLine = row + 1;
        } else if (this.currentLine == row) {
            this.currentLine = row + 1;
        }

        return this.lines[row] = data.tokens;
    };

}).call(BackgroundTokenizer.prototype);

exports.BackgroundTokenizer = BackgroundTokenizer;
});

consoleAce.define('ace/search_highlight', ['require', 'exports', 'module' , 'ace/lib/lang', 'ace/lib/oop', 'ace/range'], function(require, exports, module) {


var lang = require("./lib/lang");
var oop = require("./lib/oop");
var Range = require("./range").Range;

var SearchHighlight = function(regExp, clazz, type) {
    this.setRegexp(regExp);
    this.clazz = clazz;
    this.type = type || "text";
};

(function() {
    this.MAX_RANGES = 500;
    
    this.setRegexp = function(regExp) {
        if (this.regExp+"" == regExp+"")
            return;
        this.regExp = regExp;
        this.cache = [];
    };

    this.update = function(html, markerLayer, session, config) {
        if (!this.regExp)
            return;
        var start = config.firstRow, end = config.lastRow;

        for (var i = start; i <= end; i++) {
            var ranges = this.cache[i];
            if (ranges == null) {
                ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
                if (ranges.length > this.MAX_RANGES)
                    ranges = ranges.slice(0, this.MAX_RANGES);
                ranges = ranges.map(function(match) {
                    return new Range(i, match.offset, i, match.offset + match.length);
                });
                this.cache[i] = ranges.length ? ranges : "";
            }

            for (var j = ranges.length; j --; ) {
                markerLayer.drawSingleLineMarker(
                    html, ranges[j].toScreenRange(session), this.clazz, config);
            }
        }
    };

}).call(SearchHighlight.prototype);

exports.SearchHighlight = SearchHighlight;
});

consoleAce.define('ace/edit_session/folding', ['require', 'exports', 'module' , 'ace/range', 'ace/edit_session/fold_line', 'ace/edit_session/fold', 'ace/token_iterator'], function(require, exports, module) {


var Range = require("../range").Range;
var FoldLine = require("./fold_line").FoldLine;
var Fold = require("./fold").Fold;
var TokenIterator = require("../token_iterator").TokenIterator;

function Folding() {
    this.getFoldAt = function(row, column, side) {
        var foldLine = this.getFoldLine(row);
        if (!foldLine)
            return null;

        var folds = foldLine.folds;
        for (var i = 0; i < folds.length; i++) {
            var fold = folds[i];
            if (fold.range.contains(row, column)) {
                if (side == 1 && fold.range.isEnd(row, column)) {
                    continue;
                } else if (side == -1 && fold.range.isStart(row, column)) {
                    continue;
                }
                return fold;
            }
        }
    };
    this.getFoldsInRange = function(range) {
        var start = range.start;
        var end = range.end;
        var foldLines = this.$foldData;
        var foundFolds = [];

        start.column += 1;
        end.column -= 1;

        for (var i = 0; i < foldLines.length; i++) {
            var cmp = foldLines[i].range.compareRange(range);
            if (cmp == 2) {
                continue;
            }
            else if (cmp == -2) {
                break;
            }

            var folds = foldLines[i].folds;
            for (var j = 0; j < folds.length; j++) {
                var fold = folds[j];
                cmp = fold.range.compareRange(range);
                if (cmp == -2) {
                    break;
                } else if (cmp == 2) {
                    continue;
                } else
                if (cmp == 42) {
                    break;
                }
                foundFolds.push(fold);
            }
        }
        start.column -= 1;
        end.column += 1;

        return foundFolds;
    };

    this.getFoldsInRangeList = function(ranges) {
        if (Array.isArray(ranges)) {
            var folds = [];
            ranges.forEach(function(range) {
                folds = folds.concat(this.getFoldsInRange(range));
            }, this);
        } else {
            var folds = this.getFoldsInRange(ranges);
        }
        return folds;
    }
    this.getAllFolds = function() {
        var folds = [];
        var foldLines = this.$foldData;
        
        for (var i = 0; i < foldLines.length; i++)
            for (var j = 0; j < foldLines[i].folds.length; j++)
                folds.push(foldLines[i].folds[j]);

        return folds;
    };
    this.getFoldStringAt = function(row, column, trim, foldLine) {
        foldLine = foldLine || this.getFoldLine(row);
        if (!foldLine)
            return null;

        var lastFold = {
            end: { column: 0 }
        };
        var str, fold;
        for (var i = 0; i < foldLine.folds.length; i++) {
            fold = foldLine.folds[i];
            var cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
                str = this
                    .getLine(fold.start.row)
                    .substring(lastFold.end.column, fold.start.column);
                break;
            }
            else if (cmp === 0) {
                return null;
            }
            lastFold = fold;
        }
        if (!str)
            str = this.getLine(fold.start.row).substring(lastFold.end.column);

        if (trim == -1)
            return str.substring(0, column - lastFold.end.column);
        else if (trim == 1)
            return str.substring(column - lastFold.end.column);
        else
            return str;
    };

    this.getFoldLine = function(docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
        if (i == -1)
            i = 0;
        for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
                return foldLine;
            } else if (foldLine.end.row > docRow) {
                return null;
            }
        }
        return null;
    };
    this.getNextFoldLine = function(docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
        if (i == -1)
            i = 0;
        for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.end.row >= docRow) {
                return foldLine;
            }
        }
        return null;
    };

    this.getFoldedRowCount = function(first, last) {
        var foldData = this.$foldData, rowCount = last-first+1;
        for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i],
                end = foldLine.end.row,
                start = foldLine.start.row;
            if (end >= last) {
                if(start < last) {
                    if(start >= first)
                        rowCount -= last-start;
                    else
                        rowCount = 0;//in one fold
                }
                break;
            } else if(end >= first){
                if (start >= first) //fold inside range
                    rowCount -=  end-start;
                else
                    rowCount -=  end-first+1;
            }
        }
        return rowCount;
    };

    this.$addFoldLine = function(foldLine) {
        this.$foldData.push(foldLine);
        this.$foldData.sort(function(a, b) {
            return a.start.row - b.start.row;
        });
        return foldLine;
    };
    this.addFold = function(placeholder, range) {
        var foldData = this.$foldData;
        var added = false;
        var fold;
        
        if (placeholder instanceof Fold)
            fold = placeholder;
        else {
            fold = new Fold(range, placeholder);
            fold.collapseChildren = range.collapseChildren;
        }
        this.$clipRangeToDocument(fold.range);

        var startRow = fold.start.row;
        var startColumn = fold.start.column;
        var endRow = fold.end.row;
        var endColumn = fold.end.column;
        if (!(startRow < endRow || 
            startRow == endRow && startColumn <= endColumn - 2))
            throw new Error("The range has to be at least 2 characters width");

        var startFold = this.getFoldAt(startRow, startColumn, 1);
        var endFold = this.getFoldAt(endRow, endColumn, -1);
        if (startFold && endFold == startFold)
            return startFold.addSubFold(fold);

        if (
            (startFold && !startFold.range.isStart(startRow, startColumn))
            || (endFold && !endFold.range.isEnd(endRow, endColumn))
        ) {
            throw new Error("A fold can't intersect already existing fold" + fold.range + startFold.range);
        }
        var folds = this.getFoldsInRange(fold.range);
        if (folds.length > 0) {
            this.removeFolds(folds);
            folds.forEach(function(subFold) {
                fold.addSubFold(subFold);
            });
        }

        for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (endRow == foldLine.start.row) {
                foldLine.addFold(fold);
                added = true;
                break;
            } else if (startRow == foldLine.end.row) {
                foldLine.addFold(fold);
                added = true;
                if (!fold.sameRow) {
                    var foldLineNext = foldData[i + 1];
                    if (foldLineNext && foldLineNext.start.row == endRow) {
                        foldLine.merge(foldLineNext);
                        break;
                    }
                }
                break;
            } else if (endRow <= foldLine.start.row) {
                break;
            }
        }

        if (!added)
            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));

        if (this.$useWrapMode)
            this.$updateWrapData(foldLine.start.row, foldLine.start.row);
        else
            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
        this.$modified = true;
        this._emit("changeFold", { data: fold, action: "add" });

        return fold;
    };

    this.addFolds = function(folds) {
        folds.forEach(function(fold) {
            this.addFold(fold);
        }, this);
    };

    this.removeFold = function(fold) {
        var foldLine = fold.foldLine;
        var startRow = foldLine.start.row;
        var endRow = foldLine.end.row;

        var foldLines = this.$foldData;
        var folds = foldLine.folds;
        if (folds.length == 1) {
            foldLines.splice(foldLines.indexOf(foldLine), 1);
        } else
        if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
            folds.pop();
            foldLine.end.row = folds[folds.length - 1].end.row;
            foldLine.end.column = folds[folds.length - 1].end.column;
        } else
        if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
            folds.shift();
            foldLine.start.row = folds[0].start.row;
            foldLine.start.column = folds[0].start.column;
        } else
        if (fold.sameRow) {
            folds.splice(folds.indexOf(fold), 1);
        } else
        {
            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
            folds = newFoldLine.folds;
            folds.shift();
            newFoldLine.start.row = folds[0].start.row;
            newFoldLine.start.column = folds[0].start.column;
        }

        if (!this.$updating) {
            if (this.$useWrapMode)
                this.$updateWrapData(startRow, endRow);
            else
                this.$updateRowLengthCache(startRow, endRow);
        }
        this.$modified = true;
        this._emit("changeFold", { data: fold, action: "remove" });
    };

    this.removeFolds = function(folds) {
        var cloneFolds = [];
        for (var i = 0; i < folds.length; i++) {
            cloneFolds.push(folds[i]);
        }

        cloneFolds.forEach(function(fold) {
            this.removeFold(fold);
        }, this);
        this.$modified = true;
    };

    this.expandFold = function(fold) {
        this.removeFold(fold);
        fold.subFolds.forEach(function(subFold) {
            fold.restoreRange(subFold);
            this.addFold(subFold);
        }, this);
        if (fold.collapseChildren > 0) {
            this.foldAll(fold.start.row+1, fold.end.row, fold.collapseChildren-1);
        }
        fold.subFolds = [];
    };

    this.expandFolds = function(folds) {
        folds.forEach(function(fold) {
            this.expandFold(fold);
        }, this);
    };

    this.unfold = function(location, expandInner) {
        var range, folds;
        if (location == null) {
            range = new Range(0, 0, this.getLength(), 0);
            expandInner = true;
        } else if (typeof location == "number")
            range = new Range(location, 0, location, this.getLine(location).length);
        else if ("row" in location)
            range = Range.fromPoints(location, location);
        else
            range = location;
        
        folds = this.getFoldsInRangeList(range);
        if (expandInner) {
            this.removeFolds(folds);
        } else {
            var subFolds = folds;
            while (subFolds.length) {
                this.expandFolds(subFolds);
                subFolds = this.getFoldsInRangeList(range);
            }
        }
        if (folds.length)
            return folds;
    };
    this.isRowFolded = function(docRow, startFoldRow) {
        return !!this.getFoldLine(docRow, startFoldRow);
    };

    this.getRowFoldEnd = function(docRow, startFoldRow) {
        var foldLine = this.getFoldLine(docRow, startFoldRow);
        return foldLine ? foldLine.end.row : docRow;
    };

    this.getRowFoldStart = function(docRow, startFoldRow) {
        var foldLine = this.getFoldLine(docRow, startFoldRow);
        return foldLine ? foldLine.start.row : docRow;
    };

    this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
        if (startRow == null) {
            startRow = foldLine.start.row;
            startColumn = 0;
        }

        if (endRow == null) {
            endRow = foldLine.end.row;
            endColumn = this.getLine(endRow).length;
        }
        var doc = this.doc;
        var textLine = "";

        foldLine.walk(function(placeholder, row, column, lastColumn) {
            if (row < startRow)
                return;
            if (row == startRow) {
                if (column < startColumn)
                    return;
                lastColumn = Math.max(startColumn, lastColumn);
            }

            if (placeholder != null) {
                textLine += placeholder;
            } else {
                textLine += doc.getLine(row).substring(lastColumn, column);
            }
        }, endRow, endColumn);
        return textLine;
    };

    this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
        var foldLine = this.getFoldLine(row);

        if (!foldLine) {
            var line;
            line = this.doc.getLine(row);
            return line.substring(startColumn || 0, endColumn || line.length);
        } else {
            return this.getFoldDisplayLine(
                foldLine, row, endColumn, startRow, startColumn);
        }
    };

    this.$cloneFoldData = function() {
        var fd = [];
        fd = this.$foldData.map(function(foldLine) {
            var folds = foldLine.folds.map(function(fold) {
                return fold.clone();
            });
            return new FoldLine(fd, folds);
        });

        return fd;
    };

    this.toggleFold = function(tryToUnfold) {
        var selection = this.selection;
        var range = selection.getRange();
        var fold;
        var bracketPos;

        if (range.isEmpty()) {
            var cursor = range.start;
            fold = this.getFoldAt(cursor.row, cursor.column);

            if (fold) {
                this.expandFold(fold);
                return;
            } else if (bracketPos = this.findMatchingBracket(cursor)) {
                if (range.comparePoint(bracketPos) == 1) {
                    range.end = bracketPos;
                } else {
                    range.start = bracketPos;
                    range.start.column++;
                    range.end.column--;
                }
            } else if (bracketPos = this.findMatchingBracket({row: cursor.row, column: cursor.column + 1})) {
                if (range.comparePoint(bracketPos) == 1)
                    range.end = bracketPos;
                else
                    range.start = bracketPos;

                range.start.column++;
            } else {
                range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
            }
        } else {
            var folds = this.getFoldsInRange(range);
            if (tryToUnfold && folds.length) {
                this.expandFolds(folds);
                return;
            } else if (folds.length == 1 ) {
                fold = folds[0];
            }
        }

        if (!fold)
            fold = this.getFoldAt(range.start.row, range.start.column);

        if (fold && fold.range.toString() == range.toString()) {
            this.expandFold(fold);
            return;
        }

        var placeholder = "...";
        if (!range.isMultiLine()) {
            placeholder = this.getTextRange(range);
            if(placeholder.length < 4)
                return;
            placeholder = placeholder.trim().substring(0, 2) + "..";
        }

        this.addFold(placeholder, range);
    };

    this.getCommentFoldRange = function(row, column, dir) {
        var iterator = new TokenIterator(this, row, column);
        var token = iterator.getCurrentToken();
        if (token && /^comment|string/.test(token.type)) {
            var range = new Range();
            var re = new RegExp(token.type.replace(/\..*/, "\\."));
            if (dir != 1) {
                do {
                    token = iterator.stepBackward();
                } while(token && re.test(token.type));
                iterator.stepForward();
            }
            
            range.start.row = iterator.getCurrentTokenRow();
            range.start.column = iterator.getCurrentTokenColumn() + 2;

            iterator = new TokenIterator(this, row, column);
            
            if (dir != -1) {
                do {
                    token = iterator.stepForward();
                } while(token && re.test(token.type));
                token = iterator.stepBackward();
            } else
                token = iterator.getCurrentToken();

            range.end.row = iterator.getCurrentTokenRow();
            range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;
            return range;
        }
    };

    this.foldAll = function(startRow, endRow, depth) {
        if (depth == undefined)
            depth = 100000; // JSON.stringify doesn't hanle Infinity
        var foldWidgets = this.foldWidgets;
        if (!foldWidgets)
            return; // mode doesn't support folding
        endRow = endRow || this.getLength();
        startRow = startRow || 0;
        for (var row = startRow; row < endRow; row++) {
            if (foldWidgets[row] == null)
                foldWidgets[row] = this.getFoldWidget(row);
            if (foldWidgets[row] != "start")
                continue;

            var range = this.getFoldWidgetRange(row);
            if (range && range.isMultiLine()
                && range.end.row <= endRow
                && range.start.row >= startRow
            ) {
                row = range.end.row;
                try {
                    var fold = this.addFold("...", range);
                    if (fold)
                        fold.collapseChildren = depth;
                } catch(e) {}
            }
        }
    };
    this.$foldStyles = {
        "manual": 1,
        "markbegin": 1,
        "markbeginend": 1
    };
    this.$foldStyle = "markbegin";
    this.setFoldStyle = function(style) {
        if (!this.$foldStyles[style])
            throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
        
        if (this.$foldStyle == style)
            return;

        this.$foldStyle = style;
        
        if (style == "manual")
            this.unfold();
        var mode = this.$foldMode;
        this.$setFolding(null);
        this.$setFolding(mode);
    };

    this.$setFolding = function(foldMode) {
        if (this.$foldMode == foldMode)
            return;
            
        this.$foldMode = foldMode;
        
        this.removeListener('change', this.$updateFoldWidgets);
        this._emit("changeAnnotation");
        
        if (!foldMode || this.$foldStyle == "manual") {
            this.foldWidgets = null;
            return;
        }
        
        this.foldWidgets = [];
        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
        
        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
        this.on('change', this.$updateFoldWidgets);
        
    };

    this.getParentFoldRangeData = function (row, ignoreCurrent) {
        var fw = this.foldWidgets;
        if (!fw || (ignoreCurrent && fw[row]))
            return {};

        var i = row - 1, firstRange;
        while (i >= 0) {
            var c = fw[i];
            if (c == null)
                c = fw[i] = this.getFoldWidget(i);

            if (c == "start") {
                var range = this.getFoldWidgetRange(i);
                if (!firstRange)
                    firstRange = range;
                if (range && range.end.row >= row)
                    break;
            }
            i--;
        }

        return {
            range: i !== -1 && range,
            firstRange: firstRange
        };
    }

    this.onFoldWidgetClick = function(row, e) {
        e = e.domEvent;
        var options = {
            children: e.shiftKey,
            all: e.ctrlKey || e.metaKey,
            siblings: e.altKey
        };
        
        var range = this.$toggleFoldWidget(row, options);
        if (!range) {
            var el = (e.target || e.srcElement)
            if (el && /ace_fold-widget/.test(el.className))
                el.className += " ace_invalid";
        }
    };
    
    this.$toggleFoldWidget = function(row, options) {
        if (!this.getFoldWidget)
            return;
        var type = this.getFoldWidget(row);
        var line = this.getLine(row);

        var dir = type === "end" ? -1 : 1;
        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);

        if (fold) {
            if (options.children || options.all)
                this.removeFold(fold);
            else
                this.expandFold(fold);
            return;
        }

        var range = this.getFoldWidgetRange(row, true);
        if (range && !range.isMultiLine()) {
            fold = this.getFoldAt(range.start.row, range.start.column, 1);
            if (fold && range.isEqual(fold.range)) {
                this.removeFold(fold);
                return;
            }
        }
        
        if (options.siblings) {
            var data = this.getParentFoldRangeData(row);
            if (data.range) {
                var startRow = data.range.start.row + 1;
                var endRow = data.range.end.row;
            }
            this.foldAll(startRow, endRow, options.all ? 10000 : 0);
        } else if (options.children) {
            endRow = range ? range.end.row : this.getLength();
            this.foldAll(row + 1, range.end.row, options.all ? 10000 : 0);
        } else if (range) {
            if (options.all) 
                range.collapseChildren = 10000;
            this.addFold("...", range);
        }
        
        return range;
    };
    
    
    
    this.toggleFoldWidget = function(toggleParent) {
        var row = this.selection.getCursor().row;
        row = this.getRowFoldStart(row);
        var range = this.$toggleFoldWidget(row, {});
        
        if (range)
            return;
        var data = this.getParentFoldRangeData(row, true);
        range = data.range || data.firstRange;
        
        if (range) {
            row = range.start.row;
            var fold = this.getFoldAt(row, this.getLine(row).length, 1);

            if (fold) {
                this.removeFold(fold);
            } else {
                this.addFold("...", range);
            }
        }
    };

    this.updateFoldWidgets = function(e) {
        var delta = e.data;
        var range = delta.range;
        var firstRow = range.start.row;
        var len = range.end.row - firstRow;

        if (len === 0) {
            this.foldWidgets[firstRow] = null;
        } else if (delta.action == "removeText" || delta.action == "removeLines") {
            this.foldWidgets.splice(firstRow, len + 1, null);
        } else {
            var args = Array(len + 1);
            args.unshift(firstRow, 1);
            this.foldWidgets.splice.apply(this.foldWidgets, args);
        }
    };

}

exports.Folding = Folding;

});

consoleAce.define('ace/edit_session/fold_line', ['require', 'exports', 'module' , 'ace/range'], function(require, exports, module) {


var Range = require("../range").Range;
function FoldLine(foldData, folds) {
    this.foldData = foldData;
    if (Array.isArray(folds)) {
        this.folds = folds;
    } else {
        folds = this.folds = [ folds ];
    }

    var last = folds[folds.length - 1]
    this.range = new Range(folds[0].start.row, folds[0].start.column,
                           last.end.row, last.end.column);
    this.start = this.range.start;
    this.end   = this.range.end;

    this.folds.forEach(function(fold) {
        fold.setFoldLine(this);
    }, this);
}

(function() {
    this.shiftRow = function(shift) {
        this.start.row += shift;
        this.end.row += shift;
        this.folds.forEach(function(fold) {
            fold.start.row += shift;
            fold.end.row += shift;
        });
    }

    this.addFold = function(fold) {
        if (fold.sameRow) {
            if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
                throw new Error("Can't add a fold to this FoldLine as it has no connection");
            }
            this.folds.push(fold);
            this.folds.sort(function(a, b) {
                return -a.range.compareEnd(b.start.row, b.start.column);
            });
            if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
                this.end.row = fold.end.row;
                this.end.column =  fold.end.column;
            } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
                this.start.row = fold.start.row;
                this.start.column = fold.start.column;
            }
        } else if (fold.start.row == this.end.row) {
            this.folds.push(fold);
            this.end.row = fold.end.row;
            this.end.column = fold.end.column;
        } else if (fold.end.row == this.start.row) {
            this.folds.unshift(fold);
            this.start.row = fold.start.row;
            this.start.column = fold.start.column;
        } else {
            throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
        }
        fold.foldLine = this;
    }

    this.containsRow = function(row) {
        return row >= this.start.row && row <= this.end.row;
    }

    this.walk = function(callback, endRow, endColumn) {
        var lastEnd = 0,
            folds = this.folds,
            fold,
            comp, stop, isNewRow = true;

        if (endRow == null) {
            endRow = this.end.row;
            endColumn = this.end.column;
        }

        for (var i = 0; i < folds.length; i++) {
            fold = folds[i];

            comp = fold.range.compareStart(endRow, endColumn);
            if (comp == -1) {
                callback(null, endRow, endColumn, lastEnd, isNewRow);
                return;
            }

            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
            stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
            if (stop || comp == 0) {
                return;
            }
            isNewRow = !fold.sameRow;
            lastEnd = fold.end.column;
        }
        callback(null, endRow, endColumn, lastEnd, isNewRow);
    }

    this.getNextFoldTo = function(row, column) {
        var fold, cmp;
        for (var i = 0; i < this.folds.length; i++) {
            fold = this.folds[i];
            cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
                return {
                    fold: fold,
                    kind: "after"
                };
            } else if (cmp == 0) {
                return {
                    fold: fold,
                    kind: "inside"
                }
            }
        }
        return null;
    }

    this.addRemoveChars = function(row, column, len) {
        var ret = this.getNextFoldTo(row, column),
            fold, folds;
        if (ret) {
            fold = ret.fold;
            if (ret.kind == "inside"
                && fold.start.column != column
                && fold.start.row != row)
            {
                window.console && window.console.log(row, column, fold);
            } else if (fold.start.row == row) {
                folds = this.folds;
                var i = folds.indexOf(fold);
                if (i == 0) {
                    this.start.column += len;
                }
                for (i; i < folds.length; i++) {
                    fold = folds[i];
                    fold.start.column += len;
                    if (!fold.sameRow) {
                        return;
                    }
                    fold.end.column += len;
                }
                this.end.column += len;
            }
        }
    }

    this.split = function(row, column) {
        var fold = this.getNextFoldTo(row, column).fold;
        var folds = this.folds;
        var foldData = this.foldData;

        if (!fold)
            return null;

        var i = folds.indexOf(fold);
        var foldBefore = folds[i - 1];
        this.end.row = foldBefore.end.row;
        this.end.column = foldBefore.end.column;
        folds = folds.splice(i, folds.length - i);

        var newFoldLine = new FoldLine(foldData, folds);
        foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
        return newFoldLine;
    }

    this.merge = function(foldLineNext) {
        var folds = foldLineNext.folds;
        for (var i = 0; i < folds.length; i++) {
            this.addFold(folds[i]);
        }
        var foldData = this.foldData;
        foldData.splice(foldData.indexOf(foldLineNext), 1);
    }

    this.toString = function() {
        var ret = [this.range.toString() + ": [" ];

        this.folds.forEach(function(fold) {
            ret.push("  " + fold.toString());
        });
        ret.push("]")
        return ret.join("\n");
    }

    this.idxToPosition = function(idx) {
        var lastFoldEndColumn = 0;
        var fold;

        for (var i = 0; i < this.folds.length; i++) {
            var fold = this.folds[i];

            idx -= fold.start.column - lastFoldEndColumn;
            if (idx < 0) {
                return {
                    row: fold.start.row,
                    column: fold.start.column + idx
                };
            }

            idx -= fold.placeholder.length;
            if (idx < 0) {
                return fold.start;
            }

            lastFoldEndColumn = fold.end.column;
        }

        return {
            row: this.end.row,
            column: this.end.column + idx
        };
    }
}).call(FoldLine.prototype);

exports.FoldLine = FoldLine;
});

consoleAce.define('ace/edit_session/fold', ['require', 'exports', 'module' , 'ace/range', 'ace/range_list', 'ace/lib/oop'], function(require, exports, module) {


var Range = require("../range").Range;
var RangeList = require("../range_list").RangeList;
var oop = require("../lib/oop")
var Fold = exports.Fold = function(range, placeholder) {
    this.foldLine = null;
    this.placeholder = placeholder;
    this.range = range;
    this.start = range.start;
    this.end = range.end;

    this.sameRow = range.start.row == range.end.row;
    this.subFolds = this.ranges = [];
};

oop.inherits(Fold, RangeList);

(function() {

    this.toString = function() {
        return '"' + this.placeholder + '" ' + this.range.toString();
    };

    this.setFoldLine = function(foldLine) {
        this.foldLine = foldLine;
        this.subFolds.forEach(function(fold) {
            fold.setFoldLine(foldLine);
        });
    };

    this.clone = function() {
        var range = this.range.clone();
        var fold = new Fold(range, this.placeholder);
        this.subFolds.forEach(function(subFold) {
            fold.subFolds.push(subFold.clone());
        });
        fold.collapseChildren = this.collapseChildren;
        return fold;
    };

    this.addSubFold = function(fold) {
        if (this.range.isEqual(fold))
            return;

        if (!this.range.containsRange(fold))
            throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);
        consumeRange(fold, this.start);

        var row = fold.start.row, column = fold.start.column;
        for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
            cmp = this.subFolds[i].range.compare(row, column);
            if (cmp != 1)
                break;
        }
        var afterStart = this.subFolds[i];

        if (cmp == 0)
            return afterStart.addSubFold(fold);
        var row = fold.range.end.row, column = fold.range.end.column;
        for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
            cmp = this.subFolds[j].range.compare(row, column);
            if (cmp != 1)
                break;
        }
        var afterEnd = this.subFolds[j];

        if (cmp == 0)
            throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);

        var consumedFolds = this.subFolds.splice(i, j - i, fold);
        fold.setFoldLine(this.foldLine);

        return fold;
    };
    
    this.restoreRange = function(range) {
        return restoreRange(range, this.start);
    };

}).call(Fold.prototype);

function consumePoint(point, anchor) {
    point.row -= anchor.row;
    if (point.row == 0)
        point.column -= anchor.column;
}
function consumeRange(range, anchor) {
    consumePoint(range.start, anchor);
    consumePoint(range.end, anchor);
}
function restorePoint(point, anchor) {
    if (point.row == 0)
        point.column += anchor.column;
    point.row += anchor.row;
}
function restoreRange(range, anchor) {
    restorePoint(range.start, anchor);
    restorePoint(range.end, anchor);
}

});

consoleAce.define('ace/range_list', ['require', 'exports', 'module' , 'ace/range'], function(require, exports, module) {

var Range = require("./range").Range;
var comparePoints = Range.comparePoints;

var RangeList = function() {
    this.ranges = [];
};

(function() {
    this.comparePoints = comparePoints;

    this.pointIndex = function(pos, excludeEdges, startIndex) {
        var list = this.ranges;

        for (var i = startIndex || 0; i < list.length; i++) {
            var range = list[i];
            var cmpEnd = comparePoints(pos, range.end);
            if (cmpEnd > 0)
                continue;
            var cmpStart = comparePoints(pos, range.start);
            if (cmpEnd === 0)
                return excludeEdges && cmpStart !== 0 ? -i-2 : i;
            if (cmpStart > 0 || (cmpStart === 0 && !excludeEdges))
                return i;

            return -i-1;
        }
        return -i - 1;
    };

    this.add = function(range) {
        var excludeEdges = !range.isEmpty();
        var startIndex = this.pointIndex(range.start, excludeEdges);
        if (startIndex < 0)
            startIndex = -startIndex - 1;

        var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);

        if (endIndex < 0)
            endIndex = -endIndex - 1;
        else
            endIndex++;
        return this.ranges.splice(startIndex, endIndex - startIndex, range);
    };

    this.addList = function(list) {
        var removed = [];
        for (var i = list.length; i--; ) {
            removed.push.call(removed, this.add(list[i]));
        }
        return removed;
    };

    this.substractPoint = function(pos) {
        var i = this.pointIndex(pos);

        if (i >= 0)
            return this.ranges.splice(i, 1);
    };
    this.merge = function() {
        var removed = [];
        var list = this.ranges;
        
        list = list.sort(function(a, b) {
            return comparePoints(a.start, b.start);
        });
        
        var next = list[0], range;
        for (var i = 1; i < list.length; i++) {
            range = next;
            next = list[i];
            var cmp = comparePoints(range.end, next.start);
            if (cmp < 0)
                continue;

            if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
                continue;

            if (comparePoints(range.end, next.end) < 0) {
                range.end.row = next.end.row;
                range.end.column = next.end.column;
            }

            list.splice(i, 1);
            removed.push(next);
            next = range;
            i--;
        }
        
        this.ranges = list;

        return removed;
    };

    this.contains = function(row, column) {
        return this.pointIndex({row: row, column: column}) >= 0;
    };

    this.containsPoint = function(pos) {
        return this.pointIndex(pos) >= 0;
    };

    this.rangeAtPoint = function(pos) {
        var i = this.pointIndex(pos);
        if (i >= 0)
            return this.ranges[i];
    };


    this.clipRows = function(startRow, endRow) {
        var list = this.ranges;
        if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
            return [];

        var startIndex = this.pointIndex({row: startRow, column: 0});
        if (startIndex < 0)
            startIndex = -startIndex - 1;
        var endIndex = this.pointIndex({row: endRow, column: 0}, startIndex);
        if (endIndex < 0)
            endIndex = -endIndex - 1;

        var clipped = [];
        for (var i = startIndex; i < endIndex; i++) {
            clipped.push(list[i]);
        }
        return clipped;
    };

    this.removeAll = function() {
        return this.ranges.splice(0, this.ranges.length);
    };

    this.attach = function(session) {
        if (this.session)
            this.detach();

        this.session = session;
        this.onChange = this.$onChange.bind(this);

        this.session.on('change', this.onChange);
    };

    this.detach = function() {
        if (!this.session)
            return;
        this.session.removeListener('change', this.onChange);
        this.session = null;
    };

    this.$onChange = function(e) {
        var changeRange = e.data.range;
        if (e.data.action[0] == "i"){
            var start = changeRange.start;
            var end = changeRange.end;
        } else {
            var end = changeRange.start;
            var start = changeRange.end;
        }
        var startRow = start.row;
        var endRow = end.row;
        var lineDif = endRow - startRow;

        var colDiff = -start.column + end.column;
        var ranges = this.ranges;

        for (var i = 0, n = ranges.length; i < n; i++) {
            var r = ranges[i];
            if (r.end.row < startRow)
                continue;
            if (r.start.row > startRow)
                break;

            if (r.start.row == startRow && r.start.column >= start.column ) {
                if (r.start.column == start.column && this.$insertRight) {
                } else {
                    r.start.column += colDiff;
                    r.start.row += lineDif;
                }
            }
            if (r.end.row == startRow && r.end.column >= start.column) {
                if (r.end.column == start.column && this.$insertRight) {
                    continue;
                }
                if (r.end.column == start.column && colDiff > 0 && i < n - 1) {                
                    if (r.end.column > r.start.column && r.end.column == ranges[i+1].start.column)
                        r.end.column -= colDiff;
                }
                r.end.column += colDiff;
                r.end.row += lineDif;
            }
        }

        if (lineDif != 0 && i < n) {
            for (; i < n; i++) {
                var r = ranges[i];
                r.start.row += lineDif;
                r.end.row += lineDif;
            }
        }
    };

}).call(RangeList.prototype);

exports.RangeList = RangeList;
});

consoleAce.define('ace/edit_session/bracket_match', ['require', 'exports', 'module' , 'ace/token_iterator', 'ace/range'], function(require, exports, module) {


var TokenIterator = require("../token_iterator").TokenIterator;
var Range = require("../range").Range;


function BracketMatch() {

    this.findMatchingBracket = function(position, chr) {
        if (position.column == 0) return null;

        var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column-1);
        if (charBeforeCursor == "") return null;

        var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
        if (!match)
            return null;

        if (match[1])
            return this.$findClosingBracket(match[1], position);
        else
            return this.$findOpeningBracket(match[2], position);
    };
    
    this.getBracketRange = function(pos) {
        var line = this.getLine(pos.row);
        var before = true, range;

        var chr = line.charAt(pos.column-1);
        var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
        if (!match) {
            chr = line.charAt(pos.column);
            pos = {row: pos.row, column: pos.column + 1};
            match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
            before = false;
        }
        if (!match)
            return null;

        if (match[1]) {
            var bracketPos = this.$findClosingBracket(match[1], pos);
            if (!bracketPos)
                return null;
            range = Range.fromPoints(pos, bracketPos);
            if (!before) {
                range.end.column++;
                range.start.column--;
            }
            range.cursor = range.end;
        } else {
            var bracketPos = this.$findOpeningBracket(match[2], pos);
            if (!bracketPos)
                return null;
            range = Range.fromPoints(bracketPos, pos);
            if (!before) {
                range.start.column++;
                range.end.column--;
            }
            range.cursor = range.start;
        }
        
        return range;
    };

    this.$brackets = {
        ")": "(",
        "(": ")",
        "]": "[",
        "[": "]",
        "{": "}",
        "}": "{"
    };

    this.$findOpeningBracket = function(bracket, position, typeRe) {
        var openBracket = this.$brackets[bracket];
        var depth = 1;

        var iterator = new TokenIterator(this, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token)
            token = iterator.stepForward();
        if (!token)
            return;
        
         if (!typeRe){
            typeRe = new RegExp(
                "(\\.?" +
                token.type.replace(".", "\\.").replace("rparen", ".paren")
                + ")+"
            );
        }
        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
        var value = token.value;
        
        while (true) {
        
            while (valueIndex >= 0) {
                var chr = value.charAt(valueIndex);
                if (chr == openBracket) {
                    depth -= 1;
                    if (depth == 0) {
                        return {row: iterator.getCurrentTokenRow(),
                            column: valueIndex + iterator.getCurrentTokenColumn()};
                    }
                }
                else if (chr == bracket) {
                    depth += 1;
                }
                valueIndex -= 1;
            }
            do {
                token = iterator.stepBackward();
            } while (token && !typeRe.test(token.type));

            if (token == null)
                break;
                
            value = token.value;
            valueIndex = value.length - 1;
        }
        
        return null;
    };

    this.$findClosingBracket = function(bracket, position, typeRe) {
        var closingBracket = this.$brackets[bracket];
        var depth = 1;

        var iterator = new TokenIterator(this, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token)
            token = iterator.stepForward();
        if (!token)
            return;

        if (!typeRe){
            typeRe = new RegExp(
                "(\\.?" +
                token.type.replace(".", "\\.").replace("lparen", ".paren")
                + ")+"
            );
        }
        var valueIndex = position.column - iterator.getCurrentTokenColumn();

        while (true) {

            var value = token.value;
            var valueLength = value.length;
            while (valueIndex < valueLength) {
                var chr = value.charAt(valueIndex);
                if (chr == closingBracket) {
                    depth -= 1;
                    if (depth == 0) {
                        return {row: iterator.getCurrentTokenRow(),
                            column: valueIndex + iterator.getCurrentTokenColumn()};
                    }
                }
                else if (chr == bracket) {
                    depth += 1;
                }
                valueIndex += 1;
            }
            do {
                token = iterator.stepForward();
            } while (token && !typeRe.test(token.type));

            if (token == null)
                break;

            valueIndex = 0;
        }
        
        return null;
    };
}
exports.BracketMatch = BracketMatch;

});

consoleAce.define('ace/search', ['require', 'exports', 'module' , 'ace/lib/lang', 'ace/lib/oop', 'ace/range'], function(require, exports, module) {


var lang = require("./lib/lang");
var oop = require("./lib/oop");
var Range = require("./range").Range;

var Search = function() {
    this.$options = {};
};

(function() {
    this.set = function(options) {
        oop.mixin(this.$options, options);
        return this;
    };
    this.getOptions = function() {
        return lang.copyObject(this.$options);
    };
    this.setOptions = function(options) {
        this.$options = options;
    };
    this.find = function(session) {
        var iterator = this.$matchIterator(session, this.$options);

        if (!iterator)
            return false;

        var firstRange = null;
        iterator.forEach(function(range, row, offset) {
            if (!range.start) {
                var column = range.offset + (offset || 0);
                firstRange = new Range(row, column, row, column+range.length);
            } else
                firstRange = range;
            return true;
        });

        return firstRange;
    };
    this.findAll = function(session) {
        var options = this.$options;
        if (!options.needle)
            return [];
        this.$assembleRegExp(options);

        var range = options.range;
        var lines = range
            ? session.getLines(range.start.row, range.end.row)
            : session.doc.getAllLines();

        var ranges = [];
        var re = options.re;
        if (options.$isMultiLine) {
            var len = re.length;
            var maxRow = lines.length - len;
            for (var row = re.offset || 0; row <= maxRow; row++) {
                for (var j = 0; j < len; j++)
                    if (lines[row + j].search(re[j]) == -1)
                        break;
                
                var startLine = lines[row];
                var line = lines[row + len - 1];
                var startIndex = startLine.match(re[0])[0].length;
                var endIndex = line.match(re[len - 1])[0].length;

                ranges.push(new Range(
                    row, startLine.length - startIndex,
                    row + len - 1, endIndex
                ));
            }
        } else {
            for (var i = 0; i < lines.length; i++) {
                var matches = lang.getMatchOffsets(lines[i], re);
                for (var j = 0; j < matches.length; j++) {
                    var match = matches[j];
                    ranges.push(new Range(i, match.offset, i, match.offset + match.length));
                }
            }
        }

        if (range) {
            var startColumn = range.start.column;
            var endColumn = range.start.column;
            var i = 0, j = ranges.length - 1;
            while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row)
                i++;

            while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row)
                j--;
            
            ranges = ranges.slice(i, j + 1);
            for (i = 0, j = ranges.length; i < j; i++) {
                ranges[i].start.row += range.start.row;
                ranges[i].end.row += range.start.row;
            }
        }

        return ranges;
    };
    this.replace = function(input, replacement) {
        var options = this.$options;

        var re = this.$assembleRegExp(options);
        if (options.$isMultiLine)
            return replacement;

        if (!re)
            return;

        var match = re.exec(input);
        if (!match || match[0].length != input.length)
            return null;
        
        replacement = input.replace(re, replacement);
        if (options.preserveCase) {
            replacement = replacement.split("");
            for (var i = Math.min(input.length, input.length); i--; ) {
                var ch = input[i];
                if (ch && ch.toLowerCase() != ch)
                    replacement[i] = replacement[i].toUpperCase();
                else
                    replacement[i] = replacement[i].toLowerCase();
            }
            replacement = replacement.join("");
        }
        
        return replacement;
    };

    this.$matchIterator = function(session, options) {
        var re = this.$assembleRegExp(options);
        if (!re)
            return false;

        var self = this, callback, backwards = options.backwards;

        if (options.$isMultiLine) {
            var len = re.length;
            var matchIterator = function(line, row, offset) {
                var startIndex = line.search(re[0]);
                if (startIndex == -1)
                    return;
                for (var i = 1; i < len; i++) {
                    line = session.getLine(row + i);
                    if (line.search(re[i]) == -1)
                        return;
                }

                var endIndex = line.match(re[len - 1])[0].length;

                var range = new Range(row, startIndex, row + len - 1, endIndex);
                if (re.offset == 1) {
                    range.start.row--;
                    range.start.column = Number.MAX_VALUE;
                } else if (offset)
                    range.start.column += offset;

                if (callback(range))
                    return true;
            };
        } else if (backwards) {
            var matchIterator = function(line, row, startIndex) {
                var matches = lang.getMatchOffsets(line, re);
                for (var i = matches.length-1; i >= 0; i--)
                    if (callback(matches[i], row, startIndex))
                        return true;
            };
        } else {
            var matchIterator = function(line, row, startIndex) {
                var matches = lang.getMatchOffsets(line, re);
                for (var i = 0; i < matches.length; i++)
                    if (callback(matches[i], row, startIndex))
                        return true;
            };
        }

        return {
            forEach: function(_callback) {
                callback = _callback;
                self.$lineIterator(session, options).forEach(matchIterator);
            }
        };
    };

    this.$assembleRegExp = function(options, $disableFakeMultiline) {
        if (options.needle instanceof RegExp)
            return options.re = options.needle;

        var needle = options.needle;

        if (!options.needle)
            return options.re = false;

        if (!options.regExp)
            needle = lang.escapeRegExp(needle);

        if (options.wholeWord)
            needle = "\\b" + needle + "\\b";

        var modifier = options.caseSensitive ? "g" : "gi";

        options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
        if (options.$isMultiLine)
            return options.re = this.$assembleMultilineRegExp(needle, modifier);

        try {
            var re = new RegExp(needle, modifier);
        } catch(e) {
            re = false;
        }
        return options.re = re;
    };

    this.$assembleMultilineRegExp = function(needle, modifier) {
        var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
        var re = [];
        for (var i = 0; i < parts.length; i++) try {
            re.push(new RegExp(parts[i], modifier));
        } catch(e) {
            return false;
        }
        if (parts[0] == "") {
            re.shift();
            re.offset = 1;
        } else {
            re.offset = 0;
        }
        return re;
    };

    this.$lineIterator = function(session, options) {
        var backwards = options.backwards == true;
        var skipCurrent = options.skipCurrent != false;

        var range = options.range;
        var start = options.start;
        if (!start)
            start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();
         
        if (start.start)
            start = start[skipCurrent != backwards ? "end" : "start"];

        var firstRow = range ? range.start.row : 0;
        var lastRow = range ? range.end.row : session.getLength() - 1;

        var forEach = backwards ? function(callback) {
                var row = start.row;

                var line = session.getLine(row).substring(0, start.column);
                if (callback(line, row))
                    return;

                for (row--; row >= firstRow; row--)
                    if (callback(session.getLine(row), row))
                        return;

                if (options.wrap == false)
                    return;

                for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
                    if (callback(session.getLine(row), row))
                        return;
            } : function(callback) {
                var row = start.row;

                var line = session.getLine(row).substr(start.column);
                if (callback(line, row, start.column))
                    return;

                for (row = row+1; row <= lastRow; row++)
                    if (callback(session.getLine(row), row))
                        return;

                if (options.wrap == false)
                    return;

                for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
                    if (callback(session.getLine(row), row))
                        return;
            };
        
        return {forEach: forEach};
    };

}).call(Search.prototype);

exports.Search = Search;
});
consoleAce.define('ace/commands/command_manager', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/keyboard/hash_handler', 'ace/lib/event_emitter'], function(require, exports, module) {


var oop = require("../lib/oop");
var HashHandler = require("../keyboard/hash_handler").HashHandler;
var EventEmitter = require("../lib/event_emitter").EventEmitter;

var CommandManager = function(platform, commands) {
    HashHandler.call(this, commands, platform);
    this.byName = this.commands;
    this.setDefaultHandler("exec", function(e) {
        return e.command.exec(e.editor, e.args || {});
    });
};

oop.inherits(CommandManager, HashHandler);

(function() {

    oop.implement(this, EventEmitter);

    this.exec = function(command, editor, args) {
        if (typeof command === 'string')
            command = this.commands[command];

        if (!command)
            return false;

        if (editor && editor.$readOnly && !command.readOnly)
            return false;

        var e = {editor: editor, command: command, args: args};
        var retvalue = this._emit("exec", e);
        this._signal("afterExec", e);

        return retvalue === false ? false : true;
    };

    this.toggleRecording = function(editor) {
        if (this.$inReplay)
            return;

        editor && editor._emit("changeStatus");
        if (this.recording) {
            this.macro.pop();
            this.removeEventListener("exec", this.$addCommandToMacro);

            if (!this.macro.length)
                this.macro = this.oldMacro;

            return this.recording = false;
        }
        if (!this.$addCommandToMacro) {
            this.$addCommandToMacro = function(e) {
                this.macro.push([e.command, e.args]);
            }.bind(this);
        }

        this.oldMacro = this.macro;
        this.macro = [];
        this.on("exec", this.$addCommandToMacro);
        return this.recording = true;
    };

    this.replay = function(editor) {
        if (this.$inReplay || !this.macro)
            return;

        if (this.recording)
            return this.toggleRecording(editor);

        try {
            this.$inReplay = true;
            this.macro.forEach(function(x) {
                if (typeof x == "string")
                    this.exec(x, editor);
                else
                    this.exec(x[0], editor, x[1]);
            }, this);
        } finally {
            this.$inReplay = false;
        }
    };

    this.trimMacro = function(m) {
        return m.map(function(x){
            if (typeof x[0] != "string")
                x[0] = x[0].name;
            if (!x[1])
                x = x[0];
            return x;
        });
    };

}).call(CommandManager.prototype);

exports.CommandManager = CommandManager;

});

consoleAce.define('ace/keyboard/hash_handler', ['require', 'exports', 'module' , 'ace/lib/keys', 'ace/lib/useragent'], function(require, exports, module) {


var keyUtil = require("../lib/keys");
var useragent = require("../lib/useragent");

function HashHandler(config, platform) {
    this.platform = platform || (useragent.isMac ? "mac" : "win");
    this.commands = {};
    this.commandKeyBinding = {};
    if (this.__defineGetter__ && this.__defineSetter__ && typeof console != "undefined" && console.error) {
        var warned = false;
        var warn = function() {
            if (!warned) {
                warned = true;
                console.error("commmandKeyBinding has too many m's. use commandKeyBinding");
            }
        };
        this.__defineGetter__("commmandKeyBinding", function() {
            warn();
            return this.commandKeyBinding;
        });
        this.__defineSetter__("commmandKeyBinding", function(val) {
            warn();
            return this.commandKeyBinding = val;
        });
    } else {
        this.commmandKeyBinding = this.commandKeyBinding;
    }

    this.addCommands(config);
};

(function() {

    this.addCommand = function(command) {
        if (this.commands[command.name])
            this.removeCommand(command);

        this.commands[command.name] = command;

        if (command.bindKey)
            this._buildKeyHash(command);
    };

    this.removeCommand = function(command) {
        var name = (typeof command === 'string' ? command : command.name);
        command = this.commands[name];
        delete this.commands[name];
        var ckb = this.commandKeyBinding;
        for (var hashId in ckb) {
            for (var key in ckb[hashId]) {
                if (ckb[hashId][key] == command)
                    delete ckb[hashId][key];
            }
        }
    };

    this.bindKey = function(key, command) {
        if(!key)
            return;
        if (typeof command == "function") {
            this.addCommand({exec: command, bindKey: key, name: command.name || key});
            return;
        }

        var ckb = this.commandKeyBinding;
        key.split("|").forEach(function(keyPart) {
            var binding = this.parseKeys(keyPart, command);
            var hashId = binding.hashId;
            (ckb[hashId] || (ckb[hashId] = {}))[binding.key] = command;
        }, this);
    };

    this.addCommands = function(commands) {
        commands && Object.keys(commands).forEach(function(name) {
            var command = commands[name];
            if (!command)
                return;
            
            if (typeof command === "string")
                return this.bindKey(command, name);

            if (typeof command === "function")
                command = { exec: command };

            if (typeof command !== "object")
                return;

            if (!command.name)
                command.name = name;

            this.addCommand(command);
        }, this);
    };

    this.removeCommands = function(commands) {
        Object.keys(commands).forEach(function(name) {
            this.removeCommand(commands[name]);
        }, this);
    };

    this.bindKeys = function(keyList) {
        Object.keys(keyList).forEach(function(key) {
            this.bindKey(key, keyList[key]);
        }, this);
    };

    this._buildKeyHash = function(command) {
        var binding = command.bindKey;
        if (!binding)
            return;

        var key = typeof binding == "string" ? binding: binding[this.platform];
        this.bindKey(key, command);
    };
    this.parseKeys = function(keys) {
        if (keys.indexOf(" ") != -1)
            keys = keys.split(/\s+/).pop();

        var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x){return x});
        var key = parts.pop();

        var keyCode = keyUtil[key];
        if (keyUtil.FUNCTION_KEYS[keyCode])
            key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
        else if (!parts.length)
            return {key: key, hashId: -1};
        else if (parts.length == 1 && parts[0] == "shift")
            return {key: key.toUpperCase(), hashId: -1};

        var hashId = 0;
        for (var i = parts.length; i--;) {
            var modifier = keyUtil.KEY_MODS[parts[i]];
            if (modifier == null) {
                if (typeof console != "undefined")
                console.error("invalid modifier " + parts[i] + " in " + keys);
                return false;
            }
            hashId |= modifier;
        }
        return {key: key, hashId: hashId};
    };

    this.findKeyCommand = function findKeyCommand(hashId, keyString) {
        var ckbr = this.commandKeyBinding;
        return ckbr[hashId] && ckbr[hashId][keyString];
    };

    this.handleKeyboard = function(data, hashId, keyString, keyCode) {
        return {
            command: this.findKeyCommand(hashId, keyString)
        };
    };

}).call(HashHandler.prototype)

exports.HashHandler = HashHandler;
});

consoleAce.define('ace/commands/default_commands', ['require', 'exports', 'module' , 'ace/lib/lang', 'ace/config'], function(require, exports, module) {


var lang = require("../lib/lang");
var config = require("../config");

function bindKey(win, mac) {
    return {win: win, mac: mac};
}
exports.commands = [{
    name: "showSettingsMenu",
    bindKey: bindKey("Ctrl-,", "Command-,"),
    exec: function(editor) {
        config.loadModule("ace/ext/settings_menu", function(module) {
            module.init(editor);
            editor.showSettingsMenu();
        });
    },
    readOnly: true
}, {
    name: "goToNextError",
    bindKey: bindKey("Alt-E", "Ctrl-E"),
    exec: function(editor) {
        config.loadModule("ace/ext/error_marker", function(module) {
            module.showErrorMarker(editor, 1);
        });
    },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "goToPreviousError",
    bindKey: bindKey("Alt-Shift-E", "Ctrl-Shift-E"),
    exec: function(editor) {
        config.loadModule("ace/ext/error_marker", function(module) {
            module.showErrorMarker(editor, -1);
        });
    },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "selectall",
    bindKey: bindKey("Ctrl-A", "Command-A"),
    exec: function(editor) { editor.selectAll(); },
    readOnly: true
}, {
    name: "centerselection",
    bindKey: bindKey(null, "Ctrl-L"),
    exec: function(editor) { editor.centerSelection(); },
    readOnly: true
}, {
    name: "gotoline",
    bindKey: bindKey("Ctrl-L", "Command-L"),
    exec: function(editor) {
        var line = parseInt(prompt("Enter line number:"), 10);
        if (!isNaN(line)) {
            editor.gotoLine(line);
        }
    },
    readOnly: true
}, {
    name: "fold",
    bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
    exec: function(editor) { editor.session.toggleFold(false); },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "unfold",
    bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
    exec: function(editor) { editor.session.toggleFold(true); },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "toggleFoldWidget",
    bindKey: bindKey("F2", "F2"),
    exec: function(editor) { editor.session.toggleFoldWidget(); },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "toggleParentFoldWidget",
    bindKey: bindKey("Alt-F2", "Alt-F2"),
    exec: function(editor) { editor.session.toggleFoldWidget(true); },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "foldall",
    bindKey: bindKey("Ctrl-Alt-0", "Ctrl-Command-Option-0"),
    exec: function(editor) { editor.session.foldAll(); },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "foldOther",
    bindKey: bindKey("Alt-0", "Command-Option-0"),
    exec: function(editor) { 
        editor.session.foldAll();
        editor.session.unfold(editor.selection.getAllRanges());
    },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "unfoldall",
    bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
    exec: function(editor) { editor.session.unfold(); },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "findnext",
    bindKey: bindKey("Ctrl-K", "Command-G"),
    exec: function(editor) { editor.findNext(); },
    readOnly: true
}, {
    name: "findprevious",
    bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
    exec: function(editor) { editor.findPrevious(); },
    readOnly: true
}, {
    name: "selectOrFindNext",
    bindKey: bindKey("ALt-K", "Ctrl-G"),
    exec: function(editor) {
        if (editor.selection.isEmpty())
            editor.selection.selectWord();
        else
            editor.findNext(); 
    },
    readOnly: true
}, {
    name: "selectOrFindPrevious",
    bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
    exec: function(editor) { 
        if (editor.selection.isEmpty())
            editor.selection.selectWord();
        else
            editor.findPrevious();
    },
    readOnly: true
}, {
    name: "find",
    bindKey: bindKey("Ctrl-F", "Command-F"),
    exec: function(editor) {
        config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor)});
    },
    readOnly: true
}, {
    name: "overwrite",
    bindKey: "Insert",
    exec: function(editor) { editor.toggleOverwrite(); },
    readOnly: true
}, {
    name: "selecttostart",
    bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Up"),
    exec: function(editor) { editor.getSelection().selectFileStart(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "gotostart",
    bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
    exec: function(editor) { editor.navigateFileStart(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "selectup",
    bindKey: bindKey("Shift-Up", "Shift-Up"),
    exec: function(editor) { editor.getSelection().selectUp(); },
    multiSelectAction: "forEach",
    readOnly: true
}, {
    name: "golineup",
    bindKey: bindKey("Up", "Up|Ctrl-P"),
    exec: function(editor, args) { editor.navigateUp(args.times); },
    multiSelectAction: "forEach",
    readOnly: true
}, {
    name: "selecttoend",
    bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-Down"),
    exec: function(editor) { editor.getSelection().selectFileEnd(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "gotoend",
    bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
    exec: function(editor) { editor.navigateFileEnd(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "selectdown",
    bindKey: bindKey("Shift-Down", "Shift-Down"),
    exec: function(editor) { editor.getSelection().selectDown(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "golinedown",
    bindKey: bindKey("Down", "Down|Ctrl-N"),
    exec: function(editor, args) { editor.navigateDown(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectwordleft",
    bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
    exec: function(editor) { editor.getSelection().selectWordLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotowordleft",
    bindKey: bindKey("Ctrl-Left", "Option-Left"),
    exec: function(editor) { editor.navigateWordLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selecttolinestart",
    bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left"),
    exec: function(editor) { editor.getSelection().selectLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotolinestart",
    bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
    exec: function(editor) { editor.navigateLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectleft",
    bindKey: bindKey("Shift-Left", "Shift-Left"),
    exec: function(editor) { editor.getSelection().selectLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotoleft",
    bindKey: bindKey("Left", "Left|Ctrl-B"),
    exec: function(editor, args) { editor.navigateLeft(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectwordright",
    bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
    exec: function(editor) { editor.getSelection().selectWordRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotowordright",
    bindKey: bindKey("Ctrl-Right", "Option-Right"),
    exec: function(editor) { editor.navigateWordRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selecttolineend",
    bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right"),
    exec: function(editor) { editor.getSelection().selectLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotolineend",
    bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
    exec: function(editor) { editor.navigateLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectright",
    bindKey: bindKey("Shift-Right", "Shift-Right"),
    exec: function(editor) { editor.getSelection().selectRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotoright",
    bindKey: bindKey("Right", "Right|Ctrl-F"),
    exec: function(editor, args) { editor.navigateRight(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectpagedown",
    bindKey: "Shift-PageDown",
    exec: function(editor) { editor.selectPageDown(); },
    readOnly: true
}, {
    name: "pagedown",
    bindKey: bindKey(null, "Option-PageDown"),
    exec: function(editor) { editor.scrollPageDown(); },
    readOnly: true
}, {
    name: "gotopagedown",
    bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
    exec: function(editor) { editor.gotoPageDown(); },
    readOnly: true
}, {
    name: "selectpageup",
    bindKey: "Shift-PageUp",
    exec: function(editor) { editor.selectPageUp(); },
    readOnly: true
}, {
    name: "pageup",
    bindKey: bindKey(null, "Option-PageUp"),
    exec: function(editor) { editor.scrollPageUp(); },
    readOnly: true
}, {
    name: "gotopageup",
    bindKey: "PageUp",
    exec: function(editor) { editor.gotoPageUp(); },
    readOnly: true
}, {
    name: "scrollup",
    bindKey: bindKey("Ctrl-Up", null),
    exec: function(e) { e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight); },
    readOnly: true
}, {
    name: "scrolldown",
    bindKey: bindKey("Ctrl-Down", null),
    exec: function(e) { e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight); },
    readOnly: true
}, {
    name: "selectlinestart",
    bindKey: "Shift-Home",
    exec: function(editor) { editor.getSelection().selectLineStart(); },
    multiSelectAction: "forEach",
    readOnly: true
}, {
    name: "selectlineend",
    bindKey: "Shift-End",
    exec: function(editor) { editor.getSelection().selectLineEnd(); },
    multiSelectAction: "forEach",
    readOnly: true
}, {
    name: "togglerecording",
    bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
    exec: function(editor) { editor.commands.toggleRecording(editor); },
    readOnly: true
}, {
    name: "replaymacro",
    bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
    exec: function(editor) { editor.commands.replay(editor); },
    readOnly: true
}, {
    name: "jumptomatching",
    bindKey: bindKey("Ctrl-P", "Ctrl-Shift-P"),
    exec: function(editor) { editor.jumpToMatching(); },
    multiSelectAction: "forEach",
    readOnly: true
}, {
    name: "selecttomatching",
    bindKey: bindKey("Ctrl-Shift-P", null),
    exec: function(editor) { editor.jumpToMatching(true); },
    multiSelectAction: "forEach",
    readOnly: true
}, 
{
    name: "cut",
    exec: function(editor) {
        var range = editor.getSelectionRange();
        editor._emit("cut", range);

        if (!editor.selection.isEmpty()) {
            editor.session.remove(range);
            editor.clearSelection();
        }
    },
    multiSelectAction: "forEach"
}, {
    name: "removeline",
    bindKey: bindKey("Ctrl-D", "Command-D"),
    exec: function(editor) { editor.removeLines(); },
    multiSelectAction: "forEachLine"
}, {
    name: "duplicateSelection",
    bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
    exec: function(editor) { editor.duplicateSelection(); },
    multiSelectAction: "forEach"
}, {
    name: "sortlines",
    bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
    exec: function(editor) { editor.sortLines(); },
    multiSelectAction: "forEachLine"
}, {
    name: "togglecomment",
    bindKey: bindKey("Ctrl-/", "Command-/"),
    exec: function(editor) { editor.toggleCommentLines(); },
    multiSelectAction: "forEachLine",
    scrollIntoView: "selectionPart"
}, {
    name: "toggleBlockComment",
    bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
    exec: function(editor) { editor.toggleBlockComment(); },
    multiSelectAction: "forEach"
}, {
    name: "modifyNumberUp",
    bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
    exec: function(editor) { editor.modifyNumber(1); },
    multiSelectAction: "forEach"
}, {
    name: "modifyNumberDown",
    bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
    exec: function(editor) { editor.modifyNumber(-1); },
    multiSelectAction: "forEach"
}, {
    name: "replace",
    bindKey: bindKey("Ctrl-H", "Command-Option-F"),
    exec: function(editor) {
        config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor, true)});
    }
}, {
    name: "undo",
    bindKey: bindKey("Ctrl-Z", "Command-Z"),
    exec: function(editor) { editor.undo(); }
}, {
    name: "redo",
    bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
    exec: function(editor) { editor.redo(); }
}, {
    name: "copylinesup",
    bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
    exec: function(editor) { editor.copyLinesUp(); }
}, {
    name: "movelinesup",
    bindKey: bindKey("Alt-Up", "Option-Up"),
    exec: function(editor) { editor.moveLinesUp(); }
}, {
    name: "copylinesdown",
    bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
    exec: function(editor) { editor.copyLinesDown(); }
}, {
    name: "movelinesdown",
    bindKey: bindKey("Alt-Down", "Option-Down"),
    exec: function(editor) { editor.moveLinesDown(); }
}, {
    name: "del",
    bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
    exec: function(editor) { editor.remove("right"); },
    multiSelectAction: "forEach"
}, {
    name: "backspace",
    bindKey: bindKey(
        "Shift-Backspace|Backspace",
        "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"
    ),
    exec: function(editor) { editor.remove("left"); },
    multiSelectAction: "forEach"
}, {
    name: "cut_or_delete",
    bindKey: bindKey("Shift-Delete", null),
    exec: function(editor) { 
        if (editor.selection.isEmpty()) {
            editor.remove("left");
        } else {
            return false;
        }
    },
    multiSelectAction: "forEach"
}, {
    name: "removetolinestart",
    bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
    exec: function(editor) { editor.removeToLineStart(); },
    multiSelectAction: "forEach"
}, {
    name: "removetolineend",
    bindKey: bindKey("Alt-Delete", "Ctrl-K"),
    exec: function(editor) { editor.removeToLineEnd(); },
    multiSelectAction: "forEach"
}, {
    name: "removewordleft",
    bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
    exec: function(editor) { editor.removeWordLeft(); },
    multiSelectAction: "forEach"
}, {
    name: "removewordright",
    bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
    exec: function(editor) { editor.removeWordRight(); },
    multiSelectAction: "forEach"
}, {
    name: "outdent",
    bindKey: bindKey("Shift-Tab", "Shift-Tab"),
    exec: function(editor) { editor.blockOutdent(); },
    multiSelectAction: "forEach",
    scrollIntoView: "selectionPart"
}, {
    name: "indent",
    bindKey: bindKey("Tab", "Tab"),
    exec: function(editor) { editor.indent(); },
    multiSelectAction: "forEach",
    scrollIntoView: "selectionPart"
}, {
    name: "blockoutdent",
    bindKey: bindKey("Ctrl-[", "Ctrl-["),
    exec: function(editor) { editor.blockOutdent(); },
    multiSelectAction: "forEachLine",
    scrollIntoView: "selectionPart"
}, {
    name: "blockindent",
    bindKey: bindKey("Ctrl-]", "Ctrl-]"),
    exec: function(editor) { editor.blockIndent(); },
    multiSelectAction: "forEachLine",
    scrollIntoView: "selectionPart"
}, {
    name: "insertstring",
    exec: function(editor, str) { editor.insert(str); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "inserttext",
    exec: function(editor, args) {
        editor.insert(lang.stringRepeat(args.text  || "", args.times || 1));
    },
    multiSelectAction: "forEach"
}, {
    name: "splitline",
    bindKey: bindKey(null, "Ctrl-O"),
    exec: function(editor) { editor.splitLine(); },
    multiSelectAction: "forEach"
}, {
    name: "transposeletters",
    bindKey: bindKey("Ctrl-T", "Ctrl-T"),
    exec: function(editor) { editor.transposeLetters(); },
    multiSelectAction: function(editor) {editor.transposeSelections(1); }
}, {
    name: "touppercase",
    bindKey: bindKey("Ctrl-U", "Ctrl-U"),
    exec: function(editor) { editor.toUpperCase(); },
    multiSelectAction: "forEach"
}, {
    name: "tolowercase",
    bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
    exec: function(editor) { editor.toLowerCase(); },
    multiSelectAction: "forEach"
}];

});

consoleAce.define('ace/undomanager', ['require', 'exports', 'module' ], function(require, exports, module) {
var UndoManager = function() {
    this.reset();
};

(function() {
    this.execute = function(options) {
        var deltas = options.args[0];
        this.$doc  = options.args[1];
        if (options.merge && this.hasUndo()){
            deltas = this.$undoStack.pop().concat(deltas);
        }
        this.$undoStack.push(deltas);
        this.$redoStack = [];

        if (this.dirtyCounter < 0) {
            this.dirtyCounter = NaN;
        }
        this.dirtyCounter++;
    };
    this.undo = function(dontSelect) {
        var deltas = this.$undoStack.pop();
        var undoSelectionRange = null;
        if (deltas) {
            undoSelectionRange =
                this.$doc.undoChanges(deltas, dontSelect);
            this.$redoStack.push(deltas);
            this.dirtyCounter--;
        }

        return undoSelectionRange;
    };
    this.redo = function(dontSelect) {
        var deltas = this.$redoStack.pop();
        var redoSelectionRange = null;
        if (deltas) {
            redoSelectionRange =
                this.$doc.redoChanges(deltas, dontSelect);
            this.$undoStack.push(deltas);
            this.dirtyCounter++;
        }

        return redoSelectionRange;
    };
    this.reset = function() {
        this.$undoStack = [];
        this.$redoStack = [];
        this.dirtyCounter = 0;
    };
    this.hasUndo = function() {
        return this.$undoStack.length > 0;
    };
    this.hasRedo = function() {
        return this.$redoStack.length > 0;
    };
    this.markClean = function() {
        this.dirtyCounter = 0;
    };
    this.isClean = function() {
        return this.dirtyCounter === 0;
    };

}).call(UndoManager.prototype);

exports.UndoManager = UndoManager;
});

consoleAce.define('ace/virtual_renderer', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/lib/dom', 'ace/lib/useragent', 'ace/config', 'ace/layer/gutter', 'ace/layer/marker', 'ace/layer/text', 'ace/layer/cursor', 'ace/scrollbar', 'ace/renderloop', 'ace/lib/event_emitter'], function(require, exports, module) {


var oop = require("./lib/oop");
var dom = require("./lib/dom");
var useragent = require("./lib/useragent");
var config = require("./config");
var GutterLayer = require("./layer/gutter").Gutter;
var MarkerLayer = require("./layer/marker").Marker;
var TextLayer = require("./layer/text").Text;
var CursorLayer = require("./layer/cursor").Cursor;
var HScrollBar = require("./scrollbar").HScrollBar;
var VScrollBar = require("./scrollbar").VScrollBar;
var RenderLoop = require("./renderloop").RenderLoop;
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var editorCss = ".ace_editor {\
position: relative;\
overflow: hidden;\
font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;\
font-size: 12px;\
line-height: normal;\
color: black;\
}\
.ace_editor .ace_line {\
direction: ltr;\
unicode-bidi: bidi-override;\
}\
.ace_scroller {\
position: absolute;\
overflow: hidden;\
top: 0;\
bottom: 0;\
background-color: inherit;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
}\
.ace_content {\
position: absolute;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
cursor: text;\
min-width: 100%;\
}\
.ace_dragging, .ace_dragging * {\
cursor: move !important;\
}\
.ace_dragging .ace_scroller:before{\
position: absolute;\
top: 0;\
left: 0;\
right: 0;\
bottom: 0;\
content: '';\
background: rgba(250, 250, 250, 0.01);\
z-index: 1000;\
}\
.ace_dragging.ace_dark .ace_scroller:before{\
background: rgba(0, 0, 0, 0.01);\
}\
.ace_selecting, .ace_selecting * {\
cursor: text !important;\
}\
.ace_gutter {\
position: absolute;\
overflow : hidden;\
width: auto;\
top: 0;\
bottom: 0;\
left: 0;\
cursor: default;\
z-index: 4;\
}\
.ace_gutter-active-line {\
position: absolute;\
left: 0;\
right: 0;\
}\
.ace_scroller.ace_scroll-left {\
box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\
}\
.ace_gutter-cell {\
padding-left: 19px;\
padding-right: 6px;\
background-repeat: no-repeat;\
}\
.ace_gutter-cell.ace_error {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QUM2OEZDQTQ4RTU0MTFFMUEzM0VFRTM2RUY1M0RBMjYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QUM2OEZDQTU4RTU0MTFFMUEzM0VFRTM2RUY1M0RBMjYiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpBQzY4RkNBMjhFNTQxMUUxQTMzRUVFMzZFRjUzREEyNiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpBQzY4RkNBMzhFNTQxMUUxQTMzRUVFMzZFRjUzREEyNiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PkgXxbAAAAJbSURBVHjapFNNaBNBFH4zs5vdZLP5sQmNpT82QY209heh1ioWisaDRcSKF0WKJ0GQnrzrxasHsR6EnlrwD0TagxJabaVEpFYxLWlLSS822tr87m66ccfd2GKyVhA6MMybgfe97/vmPUQphd0sZjto9XIn9OOsvlu2nkqRzVU+6vvlzPf8W6bk8dxQ0NPbxAALgCgg2JkaQuhzQau/El0zbmUA7U0Es8v2CiYmKQJHGO1QICCLoqilMhkmurDAyapKgqItezi/USRdJqEYY4D5jCy03ht2yMkkvL91jTTX10qzyyu2hruPRN7jgbH+EOsXcMLgYiThEgAMhABW85oqy1DXdRIdvP1AHJ2acQXvDIrVHcdQNrEKNYSVMSZGMjEzIIAwDXIo+6G/FxcGnzkC3T2oMhLjre49sBB+RRcHLqdafK6sYdE/GGBwU1VpFNj0aN8pJbe+BkZyevUrvLl6Xmm0W9IuTc0DxrDNAJd5oEvI/KRsNC3bQyNjPO9yQ1YHcfj2QvfQc/5TUhJTBc2iM0U7AWDQtc1nJHvD/cfO2s7jaGkiTEfa/Ep8coLu7zmNmh8+dc5lZDuUeFAGUNA/OY6JVaypQ0vjr7XYjUvJM37vt+j1vuTK5DgVfVUoTjVe+y3/LxMxY2GgU+CSLy4cpfsYorRXuXIOi0Vt40h67uZFTdIo6nLaZcwUJWAzwNS0tBnqqKzQDnjdG/iPyZxo46HaKUpbvYkj8qYRTZsBhge+JHhZyh0x9b95JqjVJkT084kZIPwu/mPWqPgfQ5jXh2+92Ay7HedfAgwA6KDWafb4w3cAAAAASUVORK5CYII=\");\
background-repeat: no-repeat;\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_warning {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QUM2OEZDQTg4RTU0MTFFMUEzM0VFRTM2RUY1M0RBMjYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QUM2OEZDQTk4RTU0MTFFMUEzM0VFRTM2RUY1M0RBMjYiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpBQzY4RkNBNjhFNTQxMUUxQTMzRUVFMzZFRjUzREEyNiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpBQzY4RkNBNzhFNTQxMUUxQTMzRUVFMzZFRjUzREEyNiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pgd7PfIAAAGmSURBVHjaYvr//z8DJZiJgUIANoCRkREb9gLiSVAaQx4OQM7AAkwd7XU2/v++/rOttdYGEB9dASEvOMydGKfH8Gv/p4XTkvRBfLxeQAP+1cUhXopyvzhP7P/IoSj7g7Mw09cNKO6J1QQ0L4gICPIv/veg/8W+JdFvQNLHVsW9/nmn9zk7B+cCkDwhL7gt6knSZnx9/LuCEOcvkIAMP+cvto9nfqyZmmUAksfnBUtbM60gX/3/kgyv3/xSFOL5DZT+L8vP+Yfh5cvfPvp/xUHyQHXGyAYwgpwBjZYFT3Y1OEl/OfCH4ffv3wzc4iwMvNIsDJ+f/mH4+vIPAxsb631WW0Yln6ZpQLXdMK/DXGDflh+sIv37EivD5x//Gb7+YWT4y86sl7BCCkSD+Z++/1dkvsFRl+HnD1Rvje4F8whjMXmGj58YGf5zsDMwcnAwfPvKcml62DsQDeaDxN+/Y0qwlpEHqrdB94IRNIDUgfgfKJChGK4OikEW3gTiXUB950ASLFAF54AC94A0G9QAfOnmF9DCDzABFqS08IHYDIScdijOjQABBgC+/9awBH96jwAAAABJRU5ErkJggg==\");\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_info {\
background-image: url(\"data:image/gif;base64,R0lGODlhEAAQAMQAAAAAAEFBQVJSUl5eXmRkZGtra39/f4WFhYmJiZGRkaampry8vMPDw8zMzNXV1dzc3OTk5Orq6vDw8P///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAkAABQALAAAAAAQABAAAAUuICWOZGmeaBml5XGwFCQSBGyXRSAwtqQIiRuiwIM5BoYVbEFIyGCQoeJGrVptIQA7\");\
background-position: 2px center;\
}\
.ace_dark .ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpGRTk5MTVGREIxNDkxMUUxOTc5Q0FFREQyMTNGMjBFQyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpGRTk5MTVGRUIxNDkxMUUxOTc5Q0FFREQyMTNGMjBFQyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZFOTkxNUZCQjE0OTExRTE5NzlDQUVERDIxM0YyMEVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkZFOTkxNUZDQjE0OTExRTE5NzlDQUVERDIxM0YyMEVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+SIDkjAAAAJ1JREFUeNpi/P//PwMlgImBQkB7A6qrq/+DMC55FkIGKCoq4pVnpFkgTp069f/+/fv/r1u37r+tre1/kg0A+ptn9uzZYLaRkRHpLvjw4cNXWVlZhufPnzOcO3eOdAO0tbVPAjHDmzdvGA4fPsxIsgGSkpJmv379Ynj37h2DjIyMCMkG3LhxQ/T27dsMampqDHZ2dq/pH41DxwCAAAMAFdc68dUsFZgAAAAASUVORK5CYII=\");\
}\
.ace_scrollbar {\
position: absolute;\
right: 0;\
bottom: 0;\
z-index: 6;\
}\
.ace_scrollbar-inner {\
position: absolute;\
cursor: text;\
left: 0;\
top: 0;\
}\
.ace_scrollbar-v{\
overflow-x: hidden;\
overflow-y: scroll;\
top: 0;\
}\
.ace_scrollbar-h {\
overflow-x: scroll;\
overflow-y: hidden;\
left: 0;\
}\
.ace_print-margin {\
position: absolute;\
height: 100%;\
}\
.ace_text-input {\
position: absolute;\
z-index: 0;\
width: 0.5em;\
height: 1em;\
opacity: 0;\
background: transparent;\
-moz-appearance: none;\
appearance: none;\
border: none;\
resize: none;\
outline: none;\
overflow: hidden;\
font: inherit;\
padding: 0 1px;\
margin: 0 -1px;\
text-indent: -1em;\
-ms-user-select: text;\
-moz-user-select: text;\
-webkit-user-select: text;\
user-select: text;\
}\
.ace_text-input.ace_composition {\
background: #f8f8f8;\
color: #111;\
z-index: 1000;\
opacity: 1;\
text-indent: 0;\
}\
.ace_layer {\
z-index: 1;\
position: absolute;\
overflow: hidden;\
white-space: pre;\
height: 100%;\
width: 100%;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
/* setting pointer-events: auto; on node under the mouse, which changes\
during scroll, will break mouse wheel scrolling in Safari */\
pointer-events: none;\
}\
.ace_gutter-layer {\
position: relative;\
width: auto;\
text-align: right;\
pointer-events: auto;\
}\
.ace_text-layer {\
font: inherit !important;\
}\
.ace_cjk {\
display: inline-block;\
text-align: center;\
}\
.ace_cursor-layer {\
z-index: 4;\
}\
.ace_cursor {\
z-index: 4;\
position: absolute;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
border-left: 2px solid\
}\
.ace_slim-cursors .ace_cursor {\
border-left-width: 1px;\
}\
.ace_overwrite-cursors .ace_cursor {\
border-left-width: 0px;\
border-bottom: 1px solid;\
}\
.ace_hidden-cursors .ace_cursor {\
opacity: 0.2;\
}\
.ace_smooth-blinking .ace_cursor {\
-moz-transition: opacity 0.18s;\
-webkit-transition: opacity 0.18s;\
-o-transition: opacity 0.18s;\
-ms-transition: opacity 0.18s;\
transition: opacity 0.18s;\
}\
.ace_cursor[style*=\"opacity: 0\"]{\
-ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)\";\
}\
.ace_editor.ace_multiselect .ace_cursor {\
border-left-width: 1px;\
}\
.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\
position: absolute;\
z-index: 3;\
}\
.ace_marker-layer .ace_selection {\
position: absolute;\
z-index: 5;\
}\
.ace_marker-layer .ace_bracket {\
position: absolute;\
z-index: 6;\
}\
.ace_marker-layer .ace_active-line {\
position: absolute;\
z-index: 2;\
}\
.ace_marker-layer .ace_selected-word {\
position: absolute;\
z-index: 4;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
}\
.ace_line .ace_fold {\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
display: inline-block;\
height: 11px;\
margin-top: -2px;\
vertical-align: middle;\
background-image:\
url(\"data:image/png,%89PNG%0D%0A%1A%0A%00%00%00%0DIHDR%00%00%00%11%00%00%00%09%08%06%00%00%00%D4%E8%C7%0C%00%00%03%1EiCCPICC%20Profile%00%00x%01%85T%DFk%D3P%14%FE%DAe%9D%B0%E1%8B%3Ag%11%09%3Eh%91ndStC%9C%B6kW%BA%CDZ%EA6%B7!H%9B%A6m%5C%9A%C6%24%ED~%B0%07%D9%8Bo%3A%C5w%F1%07%3E%F9%07%0C%D9%83o%7B%92%0D%C6%14a%F8%AC%88%22L%F6%22%B3%9E%9B4M'S%03%B9%F7%BB%DF%F9%EE9'%E7%E4%5E%A0%F9qZ%D3%14%2F%0F%14USO%C5%C2%FC%C4%E4%14%DF%F2%01%5E%1CC%2B%FChM%8B%86%16J%26G%40%0F%D3%B2y%EF%B3%F3%0E%1E%C6lt%EEo%DF%AB%FEc%D5%9A%95%0C%11%F0%1C%20%BE%945%C4%22%E1Y%A0i%5C%D4t%13%E0%D6%89%EF%9D15%C2%CDLsX%A7%04%09%1Fg8oc%81%E1%8C%8D%23%96f45%40%9A%09%C2%07%C5B%3AK%B8%408%98i%E0%F3%0D%D8%CE%81%14%E4'%26%A9%92.%8B%3C%ABER%2F%E5dE%B2%0C%F6%F0%1Fs%83%F2_%B0%A8%94%E9%9B%AD%E7%10%8Dm%9A%19N%D1%7C%8A%DE%1F9%7Dp%8C%E6%00%D5%C1%3F_%18%BDA%B8%9DpX6%E3%A35~B%CD%24%AE%11%26%BD%E7%EEti%98%EDe%9A%97Y)%12%25%1C%24%BCbT%AE3li%E6%0B%03%89%9A%E6%D3%ED%F4P%92%B0%9F4%BF43Y%F3%E3%EDP%95%04%EB1%C5%F5%F6KF%F4%BA%BD%D7%DB%91%93%07%E35%3E%A7)%D6%7F%40%FE%BD%F7%F5r%8A%E5y%92%F0%EB%B4%1E%8D%D5%F4%5B%92%3AV%DB%DB%E4%CD%A6%23%C3%C4wQ%3F%03HB%82%8E%1Cd(%E0%91B%0Ca%9Ac%C4%AA%F8L%16%19%22J%A4%D2itTy%B28%D6%3B(%93%96%ED%1CGx%C9_%0E%B8%5E%16%F5%5B%B2%B8%F6%E0%FB%9E%DD%25%D7%8E%BC%15%85%C5%B7%A3%D8Q%ED%B5%81%E9%BA%B2%13%9A%1B%7Fua%A5%A3n%E17%B9%E5%9B%1Bm%AB%0B%08Q%FE%8A%E5%B1H%5Ee%CAO%82Q%D7u6%E6%90S%97%FCu%0B%CF2%94%EE%25v%12X%0C%BA%AC%F0%5E%F8*l%0AO%85%17%C2%97%BF%D4%C8%CE%DE%AD%11%CB%80q%2C%3E%AB%9ES%CD%C6%EC%25%D2L%D2%EBd%B8%BF%8A%F5B%C6%18%F9%901CZ%9D%BE%24M%9C%8A9%F2%DAP%0B'%06w%82%EB%E6%E2%5C%2F%D7%07%9E%BB%CC%5D%E1%FA%B9%08%AD.r%23%8E%C2%17%F5E%7C!%F0%BE3%BE%3E_%B7o%88a%A7%DB%BE%D3d%EB%A31Z%EB%BB%D3%91%BA%A2%B1z%94%8F%DB'%F6%3D%8E%AA%13%19%B2%B1%BE%B1~V%08%2B%B4%A2cjJ%B3tO%00%03%25mN%97%F3%05%93%EF%11%84%0B%7C%88%AE-%89%8F%ABbW%90O%2B%0Ao%99%0C%5E%97%0CI%AFH%D9.%B0%3B%8F%ED%03%B6S%D6%5D%E6i_s9%F3*p%E9%1B%FD%C3%EB.7U%06%5E%19%C0%D1s.%17%A03u%E4%09%B0%7C%5E%2C%EB%15%DB%1F%3C%9E%B7%80%91%3B%DBc%AD%3Dma%BA%8B%3EV%AB%DBt.%5B%1E%01%BB%0F%AB%D5%9F%CF%AA%D5%DD%E7%E4%7F%0Bx%A3%FC%06%A9%23%0A%D6%C2%A1_2%00%00%00%09pHYs%00%00%0B%13%00%00%0B%13%01%00%9A%9C%18%00%00%00%B5IDAT(%15%A5%91%3D%0E%02!%10%85ac%E1%05%D6%CE%D6%C6%CE%D2%E8%ED%CD%DE%C0%C6%D6N.%E0V%F8%3D%9Ca%891XH%C2%BE%D9y%3F%90!%E6%9C%C3%BFk%E5%011%C6-%F5%C8N%04%DF%BD%FF%89%DFt%83DN%60%3E%F3%AB%A0%DE%1A%5Dg%BE%10Q%97%1B%40%9C%A8o%10%8F%5E%828%B4%1B%60%87%F6%02%26%85%1Ch%1E%C1%2B%5Bk%FF%86%EE%B7j%09%9A%DA%9B%ACe%A3%F9%EC%DA!9%B4%D5%A6%81%86%86%98%CC%3C%5B%40%FA%81%B3%E9%CB%23%94%C16Azo%05%D4%E1%C1%95a%3B%8A'%A0%E8%CC%17%22%85%1D%BA%00%A2%FA%DC%0A%94%D1%D1%8D%8B%3A%84%17B%C7%60%1A%25Z%FC%8D%00%00%00%00IEND%AEB%60%82\"),\
url(\"data:image/png,%89PNG%0D%0A%1A%0A%00%00%00%0DIHDR%00%00%00%05%00%00%007%08%06%00%00%00%C4%DD%80C%00%00%03%1EiCCPICC%20Profile%00%00x%01%85T%DFk%D3P%14%FE%DAe%9D%B0%E1%8B%3Ag%11%09%3Eh%91ndStC%9C%B6kW%BA%CDZ%EA6%B7!H%9B%A6m%5C%9A%C6%24%ED~%B0%07%D9%8Bo%3A%C5w%F1%07%3E%F9%07%0C%D9%83o%7B%92%0D%C6%14a%F8%AC%88%22L%F6%22%B3%9E%9B4M'S%03%B9%F7%BB%DF%F9%EE9'%E7%E4%5E%A0%F9qZ%D3%14%2F%0F%14USO%C5%C2%FC%C4%E4%14%DF%F2%01%5E%1CC%2B%FChM%8B%86%16J%26G%40%0F%D3%B2y%EF%B3%F3%0E%1E%C6lt%EEo%DF%AB%FEc%D5%9A%95%0C%11%F0%1C%20%BE%945%C4%22%E1Y%A0i%5C%D4t%13%E0%D6%89%EF%9D15%C2%CDLsX%A7%04%09%1Fg8oc%81%E1%8C%8D%23%96f45%40%9A%09%C2%07%C5B%3AK%B8%408%98i%E0%F3%0D%D8%CE%81%14%E4'%26%A9%92.%8B%3C%ABER%2F%E5dE%B2%0C%F6%F0%1Fs%83%F2_%B0%A8%94%E9%9B%AD%E7%10%8Dm%9A%19N%D1%7C%8A%DE%1F9%7Dp%8C%E6%00%D5%C1%3F_%18%BDA%B8%9DpX6%E3%A35~B%CD%24%AE%11%26%BD%E7%EEti%98%EDe%9A%97Y)%12%25%1C%24%BCbT%AE3li%E6%0B%03%89%9A%E6%D3%ED%F4P%92%B0%9F4%BF43Y%F3%E3%EDP%95%04%EB1%C5%F5%F6KF%F4%BA%BD%D7%DB%91%93%07%E35%3E%A7)%D6%7F%40%FE%BD%F7%F5r%8A%E5y%92%F0%EB%B4%1E%8D%D5%F4%5B%92%3AV%DB%DB%E4%CD%A6%23%C3%C4wQ%3F%03HB%82%8E%1Cd(%E0%91B%0Ca%9Ac%C4%AA%F8L%16%19%22J%A4%D2itTy%B28%D6%3B(%93%96%ED%1CGx%C9_%0E%B8%5E%16%F5%5B%B2%B8%F6%E0%FB%9E%DD%25%D7%8E%BC%15%85%C5%B7%A3%D8Q%ED%B5%81%E9%BA%B2%13%9A%1B%7Fua%A5%A3n%E17%B9%E5%9B%1Bm%AB%0B%08Q%FE%8A%E5%B1H%5Ee%CAO%82Q%D7u6%E6%90S%97%FCu%0B%CF2%94%EE%25v%12X%0C%BA%AC%F0%5E%F8*l%0AO%85%17%C2%97%BF%D4%C8%CE%DE%AD%11%CB%80q%2C%3E%AB%9ES%CD%C6%EC%25%D2L%D2%EBd%B8%BF%8A%F5B%C6%18%F9%901CZ%9D%BE%24M%9C%8A9%F2%DAP%0B'%06w%82%EB%E6%E2%5C%2F%D7%07%9E%BB%CC%5D%E1%FA%B9%08%AD.r%23%8E%C2%17%F5E%7C!%F0%BE3%BE%3E_%B7o%88a%A7%DB%BE%D3d%EB%A31Z%EB%BB%D3%91%BA%A2%B1z%94%8F%DB'%F6%3D%8E%AA%13%19%B2%B1%BE%B1~V%08%2B%B4%A2cjJ%B3tO%00%03%25mN%97%F3%05%93%EF%11%84%0B%7C%88%AE-%89%8F%ABbW%90O%2B%0Ao%99%0C%5E%97%0CI%AFH%D9.%B0%3B%8F%ED%03%B6S%D6%5D%E6i_s9%F3*p%E9%1B%FD%C3%EB.7U%06%5E%19%C0%D1s.%17%A03u%E4%09%B0%7C%5E%2C%EB%15%DB%1F%3C%9E%B7%80%91%3B%DBc%AD%3Dma%BA%8B%3EV%AB%DBt.%5B%1E%01%BB%0F%AB%D5%9F%CF%AA%D5%DD%E7%E4%7F%0Bx%A3%FC%06%A9%23%0A%D6%C2%A1_2%00%00%00%09pHYs%00%00%0B%13%00%00%0B%13%01%00%9A%9C%18%00%00%00%3AIDAT8%11c%FC%FF%FF%7F%18%03%1A%60%01%F2%3F%A0%891%80%04%FF%11-%F8%17%9BJ%E2%05%B1ZD%81v%26t%E7%80%F8%A3%82h%A12%1A%20%A3%01%02%0F%01%BA%25%06%00%19%C0%0D%AEF%D5%3ES%00%00%00%00IEND%AEB%60%82\");\
background-repeat: no-repeat, repeat-x;\
background-position: center center, top left;\
color: transparent;\
border: 1px solid black;\
-moz-border-radius: 2px;\
-webkit-border-radius: 2px;\
border-radius: 2px;\
cursor: pointer;\
pointer-events: auto;\
}\
.ace_dark .ace_fold {\
}\
.ace_fold:hover{\
background-image:\
url(\"data:image/png,%89PNG%0D%0A%1A%0A%00%00%00%0DIHDR%00%00%00%11%00%00%00%09%08%06%00%00%00%D4%E8%C7%0C%00%00%03%1EiCCPICC%20Profile%00%00x%01%85T%DFk%D3P%14%FE%DAe%9D%B0%E1%8B%3Ag%11%09%3Eh%91ndStC%9C%B6kW%BA%CDZ%EA6%B7!H%9B%A6m%5C%9A%C6%24%ED~%B0%07%D9%8Bo%3A%C5w%F1%07%3E%F9%07%0C%D9%83o%7B%92%0D%C6%14a%F8%AC%88%22L%F6%22%B3%9E%9B4M'S%03%B9%F7%BB%DF%F9%EE9'%E7%E4%5E%A0%F9qZ%D3%14%2F%0F%14USO%C5%C2%FC%C4%E4%14%DF%F2%01%5E%1CC%2B%FChM%8B%86%16J%26G%40%0F%D3%B2y%EF%B3%F3%0E%1E%C6lt%EEo%DF%AB%FEc%D5%9A%95%0C%11%F0%1C%20%BE%945%C4%22%E1Y%A0i%5C%D4t%13%E0%D6%89%EF%9D15%C2%CDLsX%A7%04%09%1Fg8oc%81%E1%8C%8D%23%96f45%40%9A%09%C2%07%C5B%3AK%B8%408%98i%E0%F3%0D%D8%CE%81%14%E4'%26%A9%92.%8B%3C%ABER%2F%E5dE%B2%0C%F6%F0%1Fs%83%F2_%B0%A8%94%E9%9B%AD%E7%10%8Dm%9A%19N%D1%7C%8A%DE%1F9%7Dp%8C%E6%00%D5%C1%3F_%18%BDA%B8%9DpX6%E3%A35~B%CD%24%AE%11%26%BD%E7%EEti%98%EDe%9A%97Y)%12%25%1C%24%BCbT%AE3li%E6%0B%03%89%9A%E6%D3%ED%F4P%92%B0%9F4%BF43Y%F3%E3%EDP%95%04%EB1%C5%F5%F6KF%F4%BA%BD%D7%DB%91%93%07%E35%3E%A7)%D6%7F%40%FE%BD%F7%F5r%8A%E5y%92%F0%EB%B4%1E%8D%D5%F4%5B%92%3AV%DB%DB%E4%CD%A6%23%C3%C4wQ%3F%03HB%82%8E%1Cd(%E0%91B%0Ca%9Ac%C4%AA%F8L%16%19%22J%A4%D2itTy%B28%D6%3B(%93%96%ED%1CGx%C9_%0E%B8%5E%16%F5%5B%B2%B8%F6%E0%FB%9E%DD%25%D7%8E%BC%15%85%C5%B7%A3%D8Q%ED%B5%81%E9%BA%B2%13%9A%1B%7Fua%A5%A3n%E17%B9%E5%9B%1Bm%AB%0B%08Q%FE%8A%E5%B1H%5Ee%CAO%82Q%D7u6%E6%90S%97%FCu%0B%CF2%94%EE%25v%12X%0C%BA%AC%F0%5E%F8*l%0AO%85%17%C2%97%BF%D4%C8%CE%DE%AD%11%CB%80q%2C%3E%AB%9ES%CD%C6%EC%25%D2L%D2%EBd%B8%BF%8A%F5B%C6%18%F9%901CZ%9D%BE%24M%9C%8A9%F2%DAP%0B'%06w%82%EB%E6%E2%5C%2F%D7%07%9E%BB%CC%5D%E1%FA%B9%08%AD.r%23%8E%C2%17%F5E%7C!%F0%BE3%BE%3E_%B7o%88a%A7%DB%BE%D3d%EB%A31Z%EB%BB%D3%91%BA%A2%B1z%94%8F%DB'%F6%3D%8E%AA%13%19%B2%B1%BE%B1~V%08%2B%B4%A2cjJ%B3tO%00%03%25mN%97%F3%05%93%EF%11%84%0B%7C%88%AE-%89%8F%ABbW%90O%2B%0Ao%99%0C%5E%97%0CI%AFH%D9.%B0%3B%8F%ED%03%B6S%D6%5D%E6i_s9%F3*p%E9%1B%FD%C3%EB.7U%06%5E%19%C0%D1s.%17%A03u%E4%09%B0%7C%5E%2C%EB%15%DB%1F%3C%9E%B7%80%91%3B%DBc%AD%3Dma%BA%8B%3EV%AB%DBt.%5B%1E%01%BB%0F%AB%D5%9F%CF%AA%D5%DD%E7%E4%7F%0Bx%A3%FC%06%A9%23%0A%D6%C2%A1_2%00%00%00%09pHYs%00%00%0B%13%00%00%0B%13%01%00%9A%9C%18%00%00%00%B5IDAT(%15%A5%91%3D%0E%02!%10%85ac%E1%05%D6%CE%D6%C6%CE%D2%E8%ED%CD%DE%C0%C6%D6N.%E0V%F8%3D%9Ca%891XH%C2%BE%D9y%3F%90!%E6%9C%C3%BFk%E5%011%C6-%F5%C8N%04%DF%BD%FF%89%DFt%83DN%60%3E%F3%AB%A0%DE%1A%5Dg%BE%10Q%97%1B%40%9C%A8o%10%8F%5E%828%B4%1B%60%87%F6%02%26%85%1Ch%1E%C1%2B%5Bk%FF%86%EE%B7j%09%9A%DA%9B%ACe%A3%F9%EC%DA!9%B4%D5%A6%81%86%86%98%CC%3C%5B%40%FA%81%B3%E9%CB%23%94%C16Azo%05%D4%E1%C1%95a%3B%8A'%A0%E8%CC%17%22%85%1D%BA%00%A2%FA%DC%0A%94%D1%D1%8D%8B%3A%84%17B%C7%60%1A%25Z%FC%8D%00%00%00%00IEND%AEB%60%82\"),\
url(\"data:image/png,%89PNG%0D%0A%1A%0A%00%00%00%0DIHDR%00%00%00%05%00%00%007%08%06%00%00%00%C4%DD%80C%00%00%03%1EiCCPICC%20Profile%00%00x%01%85T%DFk%D3P%14%FE%DAe%9D%B0%E1%8B%3Ag%11%09%3Eh%91ndStC%9C%B6kW%BA%CDZ%EA6%B7!H%9B%A6m%5C%9A%C6%24%ED~%B0%07%D9%8Bo%3A%C5w%F1%07%3E%F9%07%0C%D9%83o%7B%92%0D%C6%14a%F8%AC%88%22L%F6%22%B3%9E%9B4M'S%03%B9%F7%BB%DF%F9%EE9'%E7%E4%5E%A0%F9qZ%D3%14%2F%0F%14USO%C5%C2%FC%C4%E4%14%DF%F2%01%5E%1CC%2B%FChM%8B%86%16J%26G%40%0F%D3%B2y%EF%B3%F3%0E%1E%C6lt%EEo%DF%AB%FEc%D5%9A%95%0C%11%F0%1C%20%BE%945%C4%22%E1Y%A0i%5C%D4t%13%E0%D6%89%EF%9D15%C2%CDLsX%A7%04%09%1Fg8oc%81%E1%8C%8D%23%96f45%40%9A%09%C2%07%C5B%3AK%B8%408%98i%E0%F3%0D%D8%CE%81%14%E4'%26%A9%92.%8B%3C%ABER%2F%E5dE%B2%0C%F6%F0%1Fs%83%F2_%B0%A8%94%E9%9B%AD%E7%10%8Dm%9A%19N%D1%7C%8A%DE%1F9%7Dp%8C%E6%00%D5%C1%3F_%18%BDA%B8%9DpX6%E3%A35~B%CD%24%AE%11%26%BD%E7%EEti%98%EDe%9A%97Y)%12%25%1C%24%BCbT%AE3li%E6%0B%03%89%9A%E6%D3%ED%F4P%92%B0%9F4%BF43Y%F3%E3%EDP%95%04%EB1%C5%F5%F6KF%F4%BA%BD%D7%DB%91%93%07%E35%3E%A7)%D6%7F%40%FE%BD%F7%F5r%8A%E5y%92%F0%EB%B4%1E%8D%D5%F4%5B%92%3AV%DB%DB%E4%CD%A6%23%C3%C4wQ%3F%03HB%82%8E%1Cd(%E0%91B%0Ca%9Ac%C4%AA%F8L%16%19%22J%A4%D2itTy%B28%D6%3B(%93%96%ED%1CGx%C9_%0E%B8%5E%16%F5%5B%B2%B8%F6%E0%FB%9E%DD%25%D7%8E%BC%15%85%C5%B7%A3%D8Q%ED%B5%81%E9%BA%B2%13%9A%1B%7Fua%A5%A3n%E17%B9%E5%9B%1Bm%AB%0B%08Q%FE%8A%E5%B1H%5Ee%CAO%82Q%D7u6%E6%90S%97%FCu%0B%CF2%94%EE%25v%12X%0C%BA%AC%F0%5E%F8*l%0AO%85%17%C2%97%BF%D4%C8%CE%DE%AD%11%CB%80q%2C%3E%AB%9ES%CD%C6%EC%25%D2L%D2%EBd%B8%BF%8A%F5B%C6%18%F9%901CZ%9D%BE%24M%9C%8A9%F2%DAP%0B'%06w%82%EB%E6%E2%5C%2F%D7%07%9E%BB%CC%5D%E1%FA%B9%08%AD.r%23%8E%C2%17%F5E%7C!%F0%BE3%BE%3E_%B7o%88a%A7%DB%BE%D3d%EB%A31Z%EB%BB%D3%91%BA%A2%B1z%94%8F%DB'%F6%3D%8E%AA%13%19%B2%B1%BE%B1~V%08%2B%B4%A2cjJ%B3tO%00%03%25mN%97%F3%05%93%EF%11%84%0B%7C%88%AE-%89%8F%ABbW%90O%2B%0Ao%99%0C%5E%97%0CI%AFH%D9.%B0%3B%8F%ED%03%B6S%D6%5D%E6i_s9%F3*p%E9%1B%FD%C3%EB.7U%06%5E%19%C0%D1s.%17%A03u%E4%09%B0%7C%5E%2C%EB%15%DB%1F%3C%9E%B7%80%91%3B%DBc%AD%3Dma%BA%8B%3EV%AB%DBt.%5B%1E%01%BB%0F%AB%D5%9F%CF%AA%D5%DD%E7%E4%7F%0Bx%A3%FC%06%A9%23%0A%D6%C2%A1_2%00%00%00%09pHYs%00%00%0B%13%00%00%0B%13%01%00%9A%9C%18%00%00%003IDAT8%11c%FC%FF%FF%7F%3E%03%1A%60%01%F2%3F%A3%891%80%04%FFQ%26%F8w%C0%B43%A1%DB%0C%E2%8F%0A%A2%85%CAh%80%8C%06%08%3C%04%E8%96%18%00%A3S%0D%CD%CF%D8%C1%9D%00%00%00%00IEND%AEB%60%82\");\
background-repeat: no-repeat, repeat-x;\
background-position: center center, top left;\
}\
.ace_gutter-tooltip {\
background-color: #FFF;\
background-image: -webkit-linear-gradient(top, transparent, rgba(0, 0, 0, 0.1));\
background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));\
border: 1px solid gray;\
border-radius: 1px;\
box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\
color: black;\
display: inline-block;\
max-width: 500px;\
padding: 4px;\
position: fixed;\
z-index: 999999;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
cursor: default;\
white-space: pre-line;\
word-wrap: break-word;\
line-height: normal;\
font-style: normal;\
font-weight: normal;\
letter-spacing: normal;\
}\
.ace_folding-enabled > .ace_gutter-cell {\
padding-right: 13px;\
}\
.ace_fold-widget {\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
margin: 0 -12px 0 1px;\
display: none;\
width: 11px;\
vertical-align: top;\
background-image: url(\"data:image/png,%89PNG%0D%0A%1A%0A%00%00%00%0DIHDR%00%00%00%05%00%00%00%05%08%06%00%00%00%8Do%26%E5%00%00%004IDATx%DAe%8A%B1%0D%000%0C%C2%F2%2CK%96%BC%D0%8F9%81%88H%E9%D0%0E%96%C0%10%92%3E%02%80%5E%82%E4%A9*-%EEsw%C8%CC%11%EE%96w%D8%DC%E9*Eh%0C%151(%00%00%00%00IEND%AEB%60%82\");\
background-repeat: no-repeat;\
background-position: center;\
border-radius: 3px;\
border: 1px solid transparent;\
cursor: pointer;\
}\
.ace_folding-enabled .ace_fold-widget {\
display: inline-block;   \
}\
.ace_fold-widget.ace_end {\
background-image: url(\"data:image/png,%89PNG%0D%0A%1A%0A%00%00%00%0DIHDR%00%00%00%05%00%00%00%05%08%06%00%00%00%8Do%26%E5%00%00%004IDATx%DAm%C7%C1%09%000%08C%D1%8C%ECE%C8E(%8E%EC%02)%1EZJ%F1%C1'%04%07I%E1%E5%EE%CAL%F5%A2%99%99%22%E2%D6%1FU%B5%FE0%D9x%A7%26Wz5%0E%D5%00%00%00%00IEND%AEB%60%82\");\
}\
.ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png,%89PNG%0D%0A%1A%0A%00%00%00%0DIHDR%00%00%00%03%00%00%00%06%08%06%00%00%00%06%E5%24%0C%00%00%009IDATx%DA5%CA%C1%09%000%08%03%C0%AC*(%3E%04%C1%0D%BA%B1%23%A4Uh%E0%20%81%C0%CC%F8%82%81%AA%A2%AArGfr%88%08%11%11%1C%DD%7D%E0%EE%5B%F6%F6%CB%B8%05Q%2F%E9tai%D9%00%00%00%00IEND%AEB%60%82\");\
}\
.ace_fold-widget:hover {\
border: 1px solid rgba(0, 0, 0, 0.3);\
background-color: rgba(255, 255, 255, 0.2);\
-moz-box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\
-webkit-box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\
}\
.ace_fold-widget:active {\
border: 1px solid rgba(0, 0, 0, 0.4);\
background-color: rgba(0, 0, 0, 0.05);\
-moz-box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\
-webkit-box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\
}\
/**\
* Dark version for fold widgets\
*/\
.ace_dark .ace_fold-widget {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\");\
}\
.ace_dark .ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget:hover {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
background-color: rgba(255, 255, 255, 0.1);\
}\
.ace_dark .ace_fold-widget:active {\
-moz-box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
-webkit-box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
}\
.ace_fold-widget.ace_invalid {\
background-color: #FFB4B4;\
border-color: #DE5555;\
}\
.ace_fade-fold-widgets .ace_fold-widget {\
-moz-transition: opacity 0.4s ease 0.05s;\
-webkit-transition: opacity 0.4s ease 0.05s;\
-o-transition: opacity 0.4s ease 0.05s;\
-ms-transition: opacity 0.4s ease 0.05s;\
transition: opacity 0.4s ease 0.05s;\
opacity: 0;\
}\
.ace_fade-fold-widgets:hover .ace_fold-widget {\
-moz-transition: opacity 0.05s ease 0.05s;\
-webkit-transition: opacity 0.05s ease 0.05s;\
-o-transition: opacity 0.05s ease 0.05s;\
-ms-transition: opacity 0.05s ease 0.05s;\
transition: opacity 0.05s ease 0.05s;\
opacity:1;\
}\
.ace_underline {\
text-decoration: underline;\
}\
.ace_bold {\
font-weight: bold;\
}\
.ace_nobold .ace_bold {\
font-weight: normal;\
}\
.ace_italic {\
font-style: italic;\
}\
.ace_error-marker {\
background-color: rgba(255, 0, 0,0.2);\
position: absolute;\
z-index: 9;\
}\
.ace_highlight-marker {\
background-color: rgba(255, 255, 0,0.2);\
position: absolute;\
z-index: 8;\
}\
";

dom.importCssString(editorCss, "ace_editor");

var VirtualRenderer = function(container, theme) {
    var _self = this;

    this.container = container || dom.createElement("div");
    this.$keepTextAreaAtCursor = true;

    dom.addCssClass(this.container, "ace_editor");

    this.setTheme(theme);

    this.$gutter = dom.createElement("div");
    this.$gutter.className = "ace_gutter";
    this.container.appendChild(this.$gutter);

    this.scroller = dom.createElement("div");
    this.scroller.className = "ace_scroller";
    this.container.appendChild(this.scroller);

    this.content = dom.createElement("div");
    this.content.className = "ace_content";
    this.scroller.appendChild(this.content);

    this.$gutterLayer = new GutterLayer(this.$gutter);
    this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));

    this.$markerBack = new MarkerLayer(this.content);

    var textLayer = this.$textLayer = new TextLayer(this.content);
    this.canvas = textLayer.element;

    this.$markerFront = new MarkerLayer(this.content);

    this.$cursorLayer = new CursorLayer(this.content);
    this.$horizScroll = false;
    this.$vScroll = false;

    this.scrollBar = 
    this.scrollBarV = new VScrollBar(this.container, this);
    this.scrollBarH = new HScrollBar(this.container, this);
    this.scrollBarV.addEventListener("scroll", function(e) {
        if (!_self.$scrollAnimation)
            _self.session.setScrollTop(e.data - _self.scrollMargin.top);
    });
    this.scrollBarH.addEventListener("scroll", function(e) {
        if (!_self.$scrollAnimation)
            _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
    });

    this.scrollTop = 0;
    this.scrollLeft = 0;

    this.cursorPos = {
        row : 0,
        column : 0
    };

    this.$textLayer.addEventListener("changeCharacterSize", function() {
        _self.updateCharacterSize();
        _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
        _self._signal("changeCharacterSize");
    });

    this.$size = {
        width: 0,
        height: 0,
        scrollerHeight: 0,
        scrollerWidth: 0,
        $dirty: true
    };

    this.layerConfig = {
        width : 1,
        padding : 0,
        firstRow : 0,
        firstRowScreen: 0,
        lastRow : 0,
        lineHeight : 0,
        characterWidth : 0,
        minHeight : 1,
        maxHeight : 1,
        offset : 0,
        height : 1
    };
    
    this.scrollMargin = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        v: 0,
        h: 0
    };

    this.$loop = new RenderLoop(
        this.$renderChanges.bind(this),
        this.container.ownerDocument.defaultView
    );
    this.$loop.schedule(this.CHANGE_FULL);

    this.updateCharacterSize();
    this.setPadding(4);
    config.resetOptions(this);
    config._emit("renderer", this);
};

(function() {

    this.CHANGE_CURSOR = 1;
    this.CHANGE_MARKER = 2;
    this.CHANGE_GUTTER = 4;
    this.CHANGE_SCROLL = 8;
    this.CHANGE_LINES = 16;
    this.CHANGE_TEXT = 32;
    this.CHANGE_SIZE = 64;
    this.CHANGE_MARKER_BACK = 128;
    this.CHANGE_MARKER_FRONT = 256;
    this.CHANGE_FULL = 512;
    this.CHANGE_H_SCROLL = 1024;

    oop.implement(this, EventEmitter);

    this.updateCharacterSize = function() {
        if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
            this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
            this.setStyle("ace_nobold", !this.$allowBoldFonts);
        }

        this.layerConfig.characterWidth =
        this.characterWidth = this.$textLayer.getCharacterWidth();
        this.layerConfig.lineHeight =
        this.lineHeight = this.$textLayer.getLineHeight();
        this.$updatePrintMargin();
    };
    this.setSession = function(session) {
        this.session = session;
        
        if (this.scrollMargin.top && session.getScrollTop() <= 0)
            session.setScrollTop(-this.scrollMargin.top);

        this.$cursorLayer.setSession(session);
        this.$markerBack.setSession(session);
        this.$markerFront.setSession(session);
        this.$gutterLayer.setSession(session);
        this.$textLayer.setSession(session);
        this.$loop.schedule(this.CHANGE_FULL);
    };
    this.updateLines = function(firstRow, lastRow) {
        if (lastRow === undefined)
            lastRow = Infinity;

        if (!this.$changedLines) {
            this.$changedLines = {
                firstRow: firstRow,
                lastRow: lastRow
            };
        }
        else {
            if (this.$changedLines.firstRow > firstRow)
                this.$changedLines.firstRow = firstRow;

            if (this.$changedLines.lastRow < lastRow)
                this.$changedLines.lastRow = lastRow;
        }

        if (this.$changedLines.firstRow > this.layerConfig.lastRow ||
            this.$changedLines.lastRow < this.layerConfig.firstRow)
            return;
        this.$loop.schedule(this.CHANGE_LINES);
    };

    this.onChangeTabSize = function() {
        this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
        this.$textLayer.onChangeTabSize();
    };
    this.updateText = function() {
        this.$loop.schedule(this.CHANGE_TEXT);
    };
    this.updateFull = function(force) {
        if (force)
            this.$renderChanges(this.CHANGE_FULL, true);
        else
            this.$loop.schedule(this.CHANGE_FULL);
    };
    this.updateFontSize = function() {
        this.$textLayer.checkForSizeChanges();
    };

    this.$changes = 0;
    this.$updateSizeAsync = function() {
        if (this.$loop.pending)
            this.$size.$dirty = true;
        else
            this.onResize();
    };
    this.onResize = function(force, gutterWidth, width, height) {
        if (this.resizing > 2)
            return;
        else if (this.resizing > 0)
            this.resizing++;
        else
            this.resizing = force ? 1 : 0;
        var el = this.container;
        if (!height)
            height = el.clientHeight || el.scrollHeight;
        if (!width)
            width = el.clientWidth || el.scrollWidth;
        var changes = this.$updateCachedSize(force, gutterWidth, width, height);
        
        if (!this.$size.scrollerHeight || (!width && !height))
            return this.resizing = 0;

        if (force)
            this.$gutterLayer.$padding = null;

        if (force)
            this.$renderChanges(changes | this.$changes, true);
        else
            this.$loop.schedule(changes | this.$changes);

        if (this.resizing)
            this.resizing = 0;
    };
    
    this.$updateCachedSize = function(force, gutterWidth, width, height) {
        height -= (this.$extraHeight || 0);
        var changes = 0;
        var size = this.$size;
        var oldSize = {
            width: size.width,
            height: size.height,
            scrollerHeight: size.scrollerHeight,
            scrollerWidth: size.scrollerWidth
        };
        if (height && (force || size.height != height)) {
            size.height = height;
            changes = this.CHANGE_SIZE;

            size.scrollerHeight = size.height;
            if (this.$horizScroll)
                size.scrollerHeight -= this.scrollBarH.getHeight();
            this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";

            if (this.session) {
                changes = changes | this.CHANGE_SCROLL;
            }
        }

        if (width && (force || size.width != width)) {
            changes = this.CHANGE_SIZE;
            size.width = width;
            
            if (gutterWidth == null)
                gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
            
            this.gutterWidth = gutterWidth;
            
            this.scrollBarH.element.style.left = 
            this.scroller.style.left = gutterWidth + "px";
            size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth());           
            
            this.scrollBarH.element.style.right = 
            this.scroller.style.right = this.scrollBarV.getWidth() + "px";
            this.scroller.style.bottom = this.scrollBarH.getHeight() + "px";

            if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force)
                changes = changes | this.CHANGE_FULL;
        }
        
        size.$dirty = !width || !height;

        if (changes)
            this._signal("resize", oldSize);

        return changes;
    };

    this.onGutterResize = function() {
        var gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
        if (gutterWidth != this.gutterWidth)
            this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);

        if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
            this.$loop.schedule(this.CHANGE_FULL);
        } else if (this.$size.$dirty) {
            this.$loop.schedule(this.CHANGE_FULL);
        } else {
            this.$computeLayerConfig();
            this.$loop.schedule(this.CHANGE_MARKER);
        }
    };
    this.adjustWrapLimit = function() {
        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
        var limit = Math.floor(availableWidth / this.characterWidth);
        return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
    };
    this.setAnimatedScroll = function(shouldAnimate){
        this.setOption("animatedScroll", shouldAnimate);
    };
    this.getAnimatedScroll = function() {
        return this.$animatedScroll;
    };
    this.setShowInvisibles = function(showInvisibles) {
        this.setOption("showInvisibles", showInvisibles);
    };
    this.getShowInvisibles = function() {
        return this.getOption("showInvisibles");
    };
    this.getDisplayIndentGuides = function() {
        return this.getOption("displayIndentGuides");
    };

    this.setDisplayIndentGuides = function(display) {
        this.setOption("displayIndentGuides", display);
    };
    this.setShowPrintMargin = function(showPrintMargin) {
        this.setOption("showPrintMargin", showPrintMargin);
    };
    this.getShowPrintMargin = function() {
        return this.getOption("showPrintMargin");
    };
    this.setPrintMarginColumn = function(showPrintMargin) {
        this.setOption("printMarginColumn", showPrintMargin);
    };
    this.getPrintMarginColumn = function() {
        return this.getOption("printMarginColumn");
    };
    this.getShowGutter = function(){
        return this.getOption("showGutter");
    };
    this.setShowGutter = function(show){
        return this.setOption("showGutter", show);
    };

    this.getFadeFoldWidgets = function(){
        return this.getOption("fadeFoldWidgets")
    };

    this.setFadeFoldWidgets = function(show) {
        this.setOption("fadeFoldWidgets", show);
    };

    this.setHighlightGutterLine = function(shouldHighlight) {
        this.setOption("highlightGutterLine", shouldHighlight);
    };

    this.getHighlightGutterLine = function() {
        return this.getOption("highlightGutterLine");
    };

    this.$updateGutterLineHighlight = function() {
        var pos = this.$cursorLayer.$pixelPos;
        var height = this.layerConfig.lineHeight;
        if (this.session.getUseWrapMode()) {
            var cursor = this.session.selection.getCursor();
            cursor.column = 0;
            pos = this.$cursorLayer.getPixelPosition(cursor, true);
            height *= this.session.getRowLength(cursor.row);
        }
        this.$gutterLineHighlight.style.top = pos.top - this.layerConfig.offset + "px";
        this.$gutterLineHighlight.style.height = height + "px";
    };

    this.$updatePrintMargin = function() {
        if (!this.$showPrintMargin && !this.$printMarginEl)
            return;

        if (!this.$printMarginEl) {
            var containerEl = dom.createElement("div");
            containerEl.className = "ace_layer ace_print-margin-layer";
            this.$printMarginEl = dom.createElement("div");
            this.$printMarginEl.className = "ace_print-margin";
            containerEl.appendChild(this.$printMarginEl);
            this.content.insertBefore(containerEl, this.content.firstChild);
        }

        var style = this.$printMarginEl.style;
        style.left = ((this.characterWidth * this.$printMarginColumn) + this.$padding) + "px";
        style.visibility = this.$showPrintMargin ? "visible" : "hidden";
        
        if (this.session && this.session.$wrap == -1)
            this.adjustWrapLimit();
    };
    this.getContainerElement = function() {
        return this.container;
    };
    this.getMouseEventTarget = function() {
        return this.content;
    };
    this.getTextAreaContainer = function() {
        return this.container;
    };
    this.$moveTextAreaToCursor = function() {
        if (!this.$keepTextAreaAtCursor)
            return;
        var config = this.layerConfig;
        var posTop = this.$cursorLayer.$pixelPos.top;
        var posLeft = this.$cursorLayer.$pixelPos.left;
        posTop -= config.offset;

        var h = this.lineHeight;
        if (posTop < 0 || posTop > config.height - h)
            return;

        var w = this.characterWidth;
        if (this.$composition) {
            var val = this.textarea.value.replace(/^\x01+/, "");
            w *= (this.session.$getStringScreenWidth(val)[0]+2);
            h += 2;
            posTop -= 1;
        }
        posLeft -= this.scrollLeft;
        if (posLeft > this.$size.scrollerWidth - w)
            posLeft = this.$size.scrollerWidth - w;

        posLeft -= this.scrollBar.width;

        this.textarea.style.height = h + "px";
        this.textarea.style.width = w + "px";
        this.textarea.style.right = Math.max(0, this.$size.scrollerWidth - posLeft - w) + "px";
        this.textarea.style.bottom = Math.max(0, this.$size.height - posTop - h) + "px";
    };
    this.getFirstVisibleRow = function() {
        return this.layerConfig.firstRow;
    };
    this.getFirstFullyVisibleRow = function() {
        return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
    };
    this.getLastFullyVisibleRow = function() {
        var flint = Math.floor((this.layerConfig.height + this.layerConfig.offset) / this.layerConfig.lineHeight);
        return this.layerConfig.firstRow - 1 + flint;
    };
    this.getLastVisibleRow = function() {
        return this.layerConfig.lastRow;
    };

    this.$padding = null;
    this.setPadding = function(padding) {
        this.$padding = padding;
        this.$textLayer.setPadding(padding);
        this.$cursorLayer.setPadding(padding);
        this.$markerFront.setPadding(padding);
        this.$markerBack.setPadding(padding);
        this.$loop.schedule(this.CHANGE_FULL);
        this.$updatePrintMargin();
    };
    
    this.setScrollMargin = function(top, bottom, left, right) {
        var sm = this.scrollMargin;
        sm.top = top|0;
        sm.bottom = bottom|0;
        sm.right = right|0;
        sm.left = left|0;
        sm.v = sm.top + sm.bottom;
        sm.h = sm.left + sm.right;
        if (sm.top && this.scrollTop <= 0 && this.session)
            this.session.setScrollTop(sm.top);
        this.updateFull();
    };
    this.getHScrollBarAlwaysVisible = function() {
        return this.$hScrollBarAlwaysVisible;
    };
    this.setHScrollBarAlwaysVisible = function(alwaysVisible) {
        this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
    };
    this.getVScrollBarAlwaysVisible = function() {
        return this.$hScrollBarAlwaysVisible;
    };
    this.setVScrollBarAlwaysVisible = function(alwaysVisible) {
        this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
    };

    this.$updateScrollBarV = function() {
        this.scrollBarV.setScrollHeight(this.layerConfig.maxHeight + this.scrollMargin.v);
        this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
    };
    this.$updateScrollBarH = function() {
        this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
        this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
    };
    
    this.$frozen = false;
    this.freeze = function() {
        this.$frozen = true;
    };
    
    this.unfreeze = function() {
        this.$frozen = false;
    };

    this.$renderChanges = function(changes, force) {
        if (this.$changes) {
            changes |= this.$changes;
            this.$changes = 0;
        }
        if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes && !force)) {
            this.$changes |= changes;
            return; 
        } 
        if (this.$size.$dirty) {
            this.$changes |= changes;
            return this.onResize(true);
        }
        if (!this.lineHeight) {
            this.$textLayer.checkForSizeChanges();
        }
        
        this._signal("beforeRender");
        var config = this.layerConfig;
        if (changes & this.CHANGE_FULL ||
            changes & this.CHANGE_SIZE ||
            changes & this.CHANGE_TEXT ||
            changes & this.CHANGE_LINES ||
            changes & this.CHANGE_SCROLL ||
            changes & this.CHANGE_H_SCROLL
        ) {
            changes |= this.$computeLayerConfig();
            config = this.layerConfig;
            this.$updateScrollBarV();
            if (changes & this.CHANGE_H_SCROLL)
                this.$updateScrollBarH();
            this.$gutterLayer.element.style.marginTop = (-config.offset) + "px";
            this.content.style.marginTop = (-config.offset) + "px";
            this.content.style.width = config.width + 2 * this.$padding + "px";
            this.content.style.height = config.minHeight + "px";
        }
        if (changes & this.CHANGE_H_SCROLL) {
            this.content.style.marginLeft = -this.scrollLeft + "px";
            this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left";
        }
        if (changes & this.CHANGE_FULL) {
            this.$textLayer.update(config);
            if (this.$showGutter)
                this.$gutterLayer.update(config);
            this.$markerBack.update(config);
            this.$markerFront.update(config);
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
            this.$highlightGutterLine && this.$updateGutterLineHighlight();
            this._signal("afterRender");
            return;
        }
        if (changes & this.CHANGE_SCROLL) {
            if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
                this.$textLayer.update(config);
            else
                this.$textLayer.scrollLines(config);

            if (this.$showGutter)
                this.$gutterLayer.update(config);
            this.$markerBack.update(config);
            this.$markerFront.update(config);
            this.$cursorLayer.update(config);
            this.$highlightGutterLine && this.$updateGutterLineHighlight();
            this.$moveTextAreaToCursor();
            this._signal("afterRender");
            return;
        }

        if (changes & this.CHANGE_TEXT) {
            this.$textLayer.update(config);
            if (this.$showGutter)
                this.$gutterLayer.update(config);
        }
        else if (changes & this.CHANGE_LINES) {
            if (this.$updateLines() || (changes & this.CHANGE_GUTTER) && this.$showGutter)
                this.$gutterLayer.update(config);
        }
        else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
            if (this.$showGutter)
                this.$gutterLayer.update(config);
        }

        if (changes & this.CHANGE_CURSOR) {
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
            this.$highlightGutterLine && this.$updateGutterLineHighlight();
        }

        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
            this.$markerFront.update(config);
        }

        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
            this.$markerBack.update(config);
        }

        this._signal("afterRender");
    };

    
    this.$autosize = function() {
        var height = this.session.getScreenLength() * this.lineHeight;
        var maxHeight = this.$maxLines * this.lineHeight;
        var desiredHeight = Math.max(
            (this.$minLines||1) * this.lineHeight,
            Math.min(maxHeight, height)
        ) + this.scrollMargin.v + (this.$extraHeight || 0);
        var vScroll = height > maxHeight;
        
        if (desiredHeight != this.desiredHeight ||
            this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
            if (vScroll != this.$vScroll) {
                this.$vScroll = vScroll;
                this.scrollBarV.setVisible(vScroll);
            }
            
            var w = this.container.clientWidth;
            this.container.style.height = desiredHeight + "px";
            this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
            this.desiredHeight = desiredHeight;
        }
    };
    
    this.$computeLayerConfig = function() {
        if (this.$maxLines && this.lineHeight > 1)
            this.$autosize();

        var session = this.session;
        
        var hideScrollbars = this.$size.height <= 2 * this.lineHeight;
        var screenLines = this.session.getScreenLength();
        var maxHeight = screenLines * this.lineHeight;

        var offset = this.scrollTop % this.lineHeight;
        var minHeight = this.$size.scrollerHeight + this.lineHeight;

        var longestLine = this.$getLongestLine();
        
        var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible ||
            this.$size.scrollerWidth - longestLine - 2 * this.$padding < 0);

        var hScrollChanged = this.$horizScroll !== horizScroll;
        if (hScrollChanged) {
            this.$horizScroll = horizScroll;
            this.scrollBarH.setVisible(horizScroll);
        }
        
        if (!this.$maxLines && this.$scrollPastEnd) {
            if (this.scrollTop > maxHeight - this.$size.scrollerHeight)
                maxHeight += Math.min(
                    (this.$size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd,
                    this.scrollTop - maxHeight + this.$size.scrollerHeight
                );
        }
        
        var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible ||
            this.$size.scrollerHeight - maxHeight < 0);
        var vScrollChanged = this.$vScroll !== vScroll;
        if (vScrollChanged) {
            this.$vScroll = vScroll;
            this.scrollBarV.setVisible(vScroll);
        }
        
        this.session.setScrollTop(Math.max(-this.scrollMargin.top,
            Math.min(this.scrollTop, maxHeight - this.$size.scrollerHeight + this.scrollMargin.v)));

        this.session.setScrollLeft(Math.max(-this.scrollMargin.left, Math.min(this.scrollLeft, 
            longestLine + 2 * this.$padding - this.$size.scrollerWidth + this.scrollMargin.h)));

        var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
        var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
        var lastRow = firstRow + lineCount;
        var firstRowScreen, firstRowHeight;
        var lineHeight = this.lineHeight;
        firstRow = session.screenToDocumentRow(firstRow, 0);
        var foldLine = session.getFoldLine(firstRow);
        if (foldLine) {
            firstRow = foldLine.start.row;
        }

        firstRowScreen = session.documentToScreenRow(firstRow, 0);
        firstRowHeight = session.getRowLength(firstRow) * lineHeight;

        lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
        minHeight = this.$size.scrollerHeight + session.getRowLength(lastRow) * lineHeight +
                                                firstRowHeight;

        offset = this.scrollTop - firstRowScreen * lineHeight;

        var changes = 0;
        if (hScrollChanged || vScrollChanged) {
            changes = this.$updateCachedSize(true, this.gutterWidth, this.$size.width, this.$size.height);
            this._signal("scrollbarVisibilityChanged");
            if (vScrollChanged)
                longestLine = this.$getLongestLine();
        }
        
        this.layerConfig = {
            width : longestLine,
            padding : this.$padding,
            firstRow : firstRow,
            firstRowScreen: firstRowScreen,
            lastRow : lastRow,
            lineHeight : lineHeight,
            characterWidth : this.characterWidth,
            minHeight : minHeight,
            maxHeight : maxHeight,
            offset : offset,
            height : this.$size.scrollerHeight
        };

        return changes;
    };

    this.$updateLines = function() {
        var firstRow = this.$changedLines.firstRow;
        var lastRow = this.$changedLines.lastRow;
        this.$changedLines = null;

        var layerConfig = this.layerConfig;

        if (firstRow > layerConfig.lastRow + 1) { return; }
        if (lastRow < layerConfig.firstRow) { return; }
        if (lastRow === Infinity) {
            if (this.$showGutter)
                this.$gutterLayer.update(layerConfig);
            this.$textLayer.update(layerConfig);
            return;
        }
        this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
        return true;
    };

    this.$getLongestLine = function() {
        var charCount = this.session.getScreenWidth();
        if (this.showInvisibles && !this.session.$useWrapMode)
            charCount += 1;

        return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
    };
    this.updateFrontMarkers = function() {
        this.$markerFront.setMarkers(this.session.getMarkers(true));
        this.$loop.schedule(this.CHANGE_MARKER_FRONT);
    };
    this.updateBackMarkers = function() {
        this.$markerBack.setMarkers(this.session.getMarkers());
        this.$loop.schedule(this.CHANGE_MARKER_BACK);
    };
    this.addGutterDecoration = function(row, className){
        this.$gutterLayer.addGutterDecoration(row, className);
    };
    this.removeGutterDecoration = function(row, className){
        this.$gutterLayer.removeGutterDecoration(row, className);
    };
    this.updateBreakpoints = function(rows) {
        this.$loop.schedule(this.CHANGE_GUTTER);
    };
    this.setAnnotations = function(annotations) {
        this.$gutterLayer.setAnnotations(annotations);
        this.$loop.schedule(this.CHANGE_GUTTER);
    };
    this.updateCursor = function() {
        this.$loop.schedule(this.CHANGE_CURSOR);
    };
    this.hideCursor = function() {
        this.$cursorLayer.hideCursor();
    };
    this.showCursor = function() {
        this.$cursorLayer.showCursor();
    };

    this.scrollSelectionIntoView = function(anchor, lead, offset) {
        this.scrollCursorIntoView(anchor, offset);
        this.scrollCursorIntoView(lead, offset);
    };
    this.scrollCursorIntoView = function(cursor, offset) {
        if (this.$size.scrollerHeight === 0)
            return;

        var pos = this.$cursorLayer.getPixelPosition(cursor);

        var left = pos.left;
        var top = pos.top;
        
        var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;

        if (scrollTop > top) {
            if (offset)
                top -= offset * this.$size.scrollerHeight;
            if (top == 0)
                top = - this.scrollMargin.top;
            else if (top == 0)
                top = + this.scrollMargin.bottom;
            this.session.setScrollTop(top);
        } else if (scrollTop + this.$size.scrollerHeight < top + this.lineHeight) {
            if (offset)
                top += offset * this.$size.scrollerHeight;
            this.session.setScrollTop(top + this.lineHeight - this.$size.scrollerHeight);
        }

        var scrollLeft = this.scrollLeft;

        if (scrollLeft > left) {
            if (left < this.$padding + 2 * this.layerConfig.characterWidth)
                left = -this.scrollMargin.left;
            this.session.setScrollLeft(left);
        } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {
            this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));
        } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {
            this.session.setScrollLeft(0);
        }
    };
    this.getScrollTop = function() {
        return this.session.getScrollTop();
    };
    this.getScrollLeft = function() {
        return this.session.getScrollLeft();
    };
    this.getScrollTopRow = function() {
        return this.scrollTop / this.lineHeight;
    };
    this.getScrollBottomRow = function() {
        return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
    };
    this.scrollToRow = function(row) {
        this.session.setScrollTop(row * this.lineHeight);
    };

    this.alignCursor = function(cursor, alignment) {
        if (typeof cursor == "number")
            cursor = {row: cursor, column: 0};

        var pos = this.$cursorLayer.getPixelPosition(cursor);
        var h = this.$size.scrollerHeight - this.lineHeight;
        var offset = pos.top - h * (alignment || 0);

        this.session.setScrollTop(offset);
        return offset;
    };

    this.STEPS = 8;
    this.$calcSteps = function(fromValue, toValue){
        var i = 0;
        var l = this.STEPS;
        var steps = [];

        var func  = function(t, x_min, dx) {
            return dx * (Math.pow(t - 1, 3) + 1) + x_min;
        };

        for (i = 0; i < l; ++i)
            steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));

        return steps;
    };
    this.scrollToLine = function(line, center, animate, callback) {
        var pos = this.$cursorLayer.getPixelPosition({row: line, column: 0});
        var offset = pos.top;
        if (center)
            offset -= this.$size.scrollerHeight / 2;

        var initialScroll = this.scrollTop;
        this.session.setScrollTop(offset);
        if (animate !== false)
            this.animateScrolling(initialScroll, callback);
    };

    this.animateScrolling = function(fromValue, callback) {
        var toValue = this.scrollTop;
        if (!this.$animatedScroll)
            return;
        var _self = this;
        
        if (fromValue == toValue)
            return;
        
        if (this.$scrollAnimation) {
            var oldSteps = this.$scrollAnimation.steps;
            if (oldSteps.length) {
                fromValue = oldSteps[0];
                if (fromValue == toValue)
                    return;
            }
        }
        
        var steps = _self.$calcSteps(fromValue, toValue);
        this.$scrollAnimation = {from: fromValue, to: toValue, steps: steps};

        clearInterval(this.$timer);

        _self.session.setScrollTop(steps.shift());
        _self.session.$scrollTop = toValue;
        this.$timer = setInterval(function() {
            if (steps.length) {
                _self.session.setScrollTop(steps.shift());
                _self.session.$scrollTop = toValue;
            } else if (toValue != null) {
                _self.session.$scrollTop = -1;
                _self.session.setScrollTop(toValue);
                toValue = null;
            } else {
                _self.$timer = clearInterval(_self.$timer);
                _self.$scrollAnimation = null;
                callback && callback();
            }
        }, 10);
    };
    this.scrollToY = function(scrollTop) {
        if (this.scrollTop !== scrollTop) {
            this.$loop.schedule(this.CHANGE_SCROLL);
            this.scrollTop = scrollTop;
        }
    };
    this.scrollToX = function(scrollLeft) {
        if (this.scrollLeft !== scrollLeft)
            this.scrollLeft = scrollLeft;
        this.$loop.schedule(this.CHANGE_H_SCROLL);
    };
    this.scrollTo = function(x, y) {
        this.session.setScrollTop(y);
        this.session.setScrollLeft(y);
    };
    this.scrollBy = function(deltaX, deltaY) {
        deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
        deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
    };
    this.isScrollableBy = function(deltaX, deltaY) {
        if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
           return true;
        if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight
            - this.layerConfig.maxHeight - (this.$size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd
            < -1 + this.scrollMargin.bottom)
           return true;
        if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
            return true;
        if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth
            - this.layerConfig.width < -1 + this.scrollMargin.right)
           return true;
    };

    this.pixelToScreenCoordinates = function(x, y) {
        var canvasPos = this.scroller.getBoundingClientRect();

        var offset = (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth;
        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
        var col = Math.round(offset);

        return {row: row, column: col, side: offset - col > 0 ? 1 : -1};
    };

    this.screenToTextCoordinates = function(x, y) {
        var canvasPos = this.scroller.getBoundingClientRect();

        var col = Math.round(
            (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth
        );

        var row = (y + this.scrollTop - canvasPos.top) / this.lineHeight;

        return this.session.screenToDocumentPosition(row, Math.max(col, 0));
    };
    this.textToScreenCoordinates = function(row, column) {
        var canvasPos = this.scroller.getBoundingClientRect();
        var pos = this.session.documentToScreenPosition(row, column);

        var x = this.$padding + Math.round(pos.column * this.characterWidth);
        var y = pos.row * this.lineHeight;

        return {
            pageX: canvasPos.left + x - this.scrollLeft,
            pageY: canvasPos.top + y - this.scrollTop
        };
    };
    this.visualizeFocus = function() {
        dom.addCssClass(this.container, "ace_focus");
    };
    this.visualizeBlur = function() {
        dom.removeCssClass(this.container, "ace_focus");
    };
    this.showComposition = function(position) {
        if (!this.$composition)
            this.$composition = {
                keepTextAreaAtCursor: this.$keepTextAreaAtCursor,
                cssText: this.textarea.style.cssText
            };

        this.$keepTextAreaAtCursor = true;
        dom.addCssClass(this.textarea, "ace_composition");
        this.textarea.style.cssText = "";
        this.$moveTextAreaToCursor();
    };
    this.setCompositionText = function(text) {
        this.$moveTextAreaToCursor();
    };
    this.hideComposition = function() {
        if (!this.$composition)
            return;

        dom.removeCssClass(this.textarea, "ace_composition");
        this.$keepTextAreaAtCursor = this.$composition.keepTextAreaAtCursor;
        this.textarea.style.cssText = this.$composition.cssText;
        this.$composition = null;
    };
    this.setTheme = function(theme, cb) {
        var _self = this;
        this.$themeId = theme;
        _self._dispatchEvent('themeChange',{theme:theme});

        if (!theme || typeof theme == "string") {
            var moduleName = theme || this.$options.theme.initialValue;
            config.loadModule(["theme", moduleName], afterLoad);
        } else {
            afterLoad(theme);
        }

        function afterLoad(module) {
            if (_self.$themeId != theme)
                return cb && cb();
            if (!module.cssClass)
                return;
            dom.importCssString(
                module.cssText,
                module.cssClass,
                _self.container.ownerDocument
            );

            if (_self.theme)
                dom.removeCssClass(_self.container, _self.theme.cssClass);

            var padding = "padding" in module ? module.padding 
                : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
            if (_self.$padding && padding != _self.$padding)
                _self.setPadding(padding);
            _self.$theme = module.cssClass;

            _self.theme = module;
            dom.addCssClass(_self.container, module.cssClass);
            dom.setCssClass(_self.container, "ace_dark", module.isDark);
            if (_self.$size) {
                _self.$size.width = 0;
                _self.$updateSizeAsync();
            }

            _self._dispatchEvent('themeLoaded', {theme:module});
            cb && cb();
        }
    };
    this.getTheme = function() {
        return this.$themeId;
    };
    this.setStyle = function(style, include) {
        dom.setCssClass(this.container, style, include !== false);
    };
    this.unsetStyle = function(style) {
        dom.removeCssClass(this.container, style);
    };
    
    this.setCursorStyle = function(style) {
        if (this.content.style.cursor != style)
            this.content.style.cursor = style;
    };
    this.setMouseCursor = function(cursorStyle) {
        this.content.style.cursor = cursorStyle;
    };
    this.destroy = function() {
        this.$textLayer.destroy();
        this.$cursorLayer.destroy();
    };

}).call(VirtualRenderer.prototype);


config.defineOptions(VirtualRenderer.prototype, "renderer", {
    animatedScroll: {initialValue: false},
    showInvisibles: {
        set: function(value) {
            if (this.$textLayer.setShowInvisibles(value))
                this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: false
    },
    showPrintMargin: {
        set: function() { this.$updatePrintMargin(); },
        initialValue: true
    },
    printMarginColumn: {
        set: function() { this.$updatePrintMargin(); },
        initialValue: 80
    },
    printMargin: {
        set: function(val) {
            if (typeof val == "number")
                this.$printMarginColumn = val;
            this.$showPrintMargin = !!val;
            this.$updatePrintMargin();
        },
        get: function() {
            return this.$showPrintMargin && this.$printMarginColumn; 
        }
    },
    showGutter: {
        set: function(show){
            this.$gutter.style.display = show ? "block" : "none";
            this.onGutterResize();
        },
        initialValue: true
    },
    fadeFoldWidgets: {
        set: function(show) {
            dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
        },
        initialValue: false
    },
    showFoldWidgets: {
        set: function(show) {this.$gutterLayer.setShowFoldWidgets(show)},
        initialValue: true
    },
    displayIndentGuides: {
        set: function(show) {
            if (this.$textLayer.setDisplayIndentGuides(show))
                this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: true
    },
    highlightGutterLine: {
        set: function(shouldHighlight) {
            if (!this.$gutterLineHighlight) {
                this.$gutterLineHighlight = dom.createElement("div");
                this.$gutterLineHighlight.className = "ace_gutter-active-line";
                this.$gutter.appendChild(this.$gutterLineHighlight);
                return;
            }

            this.$gutterLineHighlight.style.display = shouldHighlight ? "" : "none";
            if (this.$cursorLayer.$pixelPos)
                this.$updateGutterLineHighlight();
        },
        initialValue: false,
        value: true
    },
    hScrollBarAlwaysVisible: {
        set: function(val) {
            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
                this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: false
    },
    vScrollBarAlwaysVisible: {
        set: function(val) {
            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
                this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: false
    },
    fontSize:  {
        set: function(size) {
            if (typeof size == "number")
                size = size + "px";
            this.container.style.fontSize = size;
            this.updateFontSize();
        },
        initialValue: 12
    },
    fontFamily: {
        set: function(name) {
            this.container.style.fontFamily = name;
            this.updateFontSize();
        }
    },
    maxLines: {
        set: function(val) {
            this.updateFull();
        }
    },
    minLines: {
        set: function(val) {
            this.updateFull();
        }
    },
    scrollPastEnd: {
        set: function(val) {
            val = +val || 0;
            if (this.$scrollPastEnd == val)
                return;
            this.$scrollPastEnd = val;
            this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: 0,
        handlesSet: true
    },
    fixedWidthGutter: {
        set: function(val) {
            this.$gutterLayer.$fixedWidth = !!val;
            this.$loop.schedule(this.CHANGE_GUTTER);
        }
    },
    theme: {
        set: function(val) { this.setTheme(val) },
        get: function() { return this.$themeId || this.theme; },
        initialValue: "./theme/textmate",
        handlesSet: true
    }
});

exports.VirtualRenderer = VirtualRenderer;
});

consoleAce.define('ace/layer/gutter', ['require', 'exports', 'module' , 'ace/lib/dom', 'ace/lib/oop', 'ace/lib/lang', 'ace/lib/event_emitter'], function(require, exports, module) {


var dom = require("../lib/dom");
var oop = require("../lib/oop");
var lang = require("../lib/lang");
var EventEmitter = require("../lib/event_emitter").EventEmitter;

var Gutter = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_gutter-layer";
    parentEl.appendChild(this.element);
    this.setShowFoldWidgets(this.$showFoldWidgets);
    
    this.gutterWidth = 0;

    this.$annotations = [];
    this.$updateAnnotations = this.$updateAnnotations.bind(this);

    this.$cells = [];
};

(function() {

    oop.implement(this, EventEmitter);

    this.setSession = function(session) {
        if (this.session)
            this.session.removeEventListener("change", this.$updateAnnotations);
        this.session = session;
        session.on("change", this.$updateAnnotations);
    };

    this.addGutterDecoration = function(row, className){
        if (window.console)
            console.warn && console.warn("deprecated use session.addGutterDecoration");
        this.session.addGutterDecoration(row, className);
    };

    this.removeGutterDecoration = function(row, className){
        if (window.console)
            console.warn && console.warn("deprecated use session.removeGutterDecoration");
        this.session.removeGutterDecoration(row, className);
    };

    this.setAnnotations = function(annotations) {
        this.$annotations = [];
        for (var i = 0; i < annotations.length; i++) {
            var annotation = annotations[i];
            var row = annotation.row;
            var rowInfo = this.$annotations[row];
            if (!rowInfo)
                rowInfo = this.$annotations[row] = {text: []};
           
            var annoText = annotation.text;
            annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";

            if (rowInfo.text.indexOf(annoText) === -1)
                rowInfo.text.push(annoText);

            var type = annotation.type;
            if (type == "error")
                rowInfo.className = " ace_error";
            else if (type == "warning" && rowInfo.className != " ace_error")
                rowInfo.className = " ace_warning";
            else if (type == "info" && (!rowInfo.className))
                rowInfo.className = " ace_info";
        }
    };

    this.$updateAnnotations = function (e) {
        if (!this.$annotations.length)
            return;
        var delta = e.data;
        var range = delta.range;
        var firstRow = range.start.row;
        var len = range.end.row - firstRow;
        if (len === 0) {
        } else if (delta.action == "removeText" || delta.action == "removeLines") {
            this.$annotations.splice(firstRow, len + 1, null);
        } else {
            var args = new Array(len + 1);
            args.unshift(firstRow, 1);
            this.$annotations.splice.apply(this.$annotations, args);
        }
    };

    this.update = function(config) {
        var firstRow = config.firstRow;
        var lastRow = config.lastRow;
        var session = this.session;
        var fold = session.getNextFoldLine(firstRow);
        var foldStart = fold ? fold.start.row : Infinity;
        var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
        var breakpoints = session.$breakpoints;
        var decorations = session.$decorations;
        var firstLineNumber = session.$firstLineNumber;
        var lastLineNumber = 0;
        
        var gutterRenderer = session.gutterRenderer;

        var cell = null;
        var index = -1;
        var row = firstRow;
        while (true) {
            if (row > foldStart) {
                row = fold.end.row + 1;
                fold = session.getNextFoldLine(row, fold);
                foldStart = fold ? fold.start.row : Infinity;
            }
            if (row > lastRow) {
                while (this.$cells.length > index + 1) {
                    cell = this.$cells.pop();
                    this.element.removeChild(cell.element);
                }
                break;
            }

            cell = this.$cells[++index];
            if (!cell) {
                cell = {element: null, textNode: null, foldWidget: null};
                cell.element = dom.createElement("div");
                cell.textNode = document.createTextNode('');
                cell.element.appendChild(cell.textNode);
                this.element.appendChild(cell.element);
                this.$cells[index] = cell;
            }

            var className = "ace_gutter-cell ";
            if (breakpoints[row])
                className += breakpoints[row];
            if (decorations[row])
                className += decorations[row];
            if (this.$annotations[row])
                className += this.$annotations[row].className;
            if (cell.element.className != className)
                cell.element.className = className;

            var height = session.getRowLength(row) * config.lineHeight + "px";
            if (height != cell.element.style.height)
                cell.element.style.height = height;

            if (foldWidgets) {
                var c = foldWidgets[row];
                if (c == null)
                    c = foldWidgets[row] = session.getFoldWidget(row);
            }

            if (c) {
                if (!cell.foldWidget) {
                    cell.foldWidget = dom.createElement("span");
                    cell.element.appendChild(cell.foldWidget);
                }
                var className = "ace_fold-widget ace_" + c;
                if (c == "start" && row == foldStart && row < fold.end.row)
                    className += " ace_closed";
                else
                    className += " ace_open";
                if (cell.foldWidget.className != className)
                    cell.foldWidget.className = className;

                var height = config.lineHeight + "px";
                if (cell.foldWidget.style.height != height)
                    cell.foldWidget.style.height = height;
            } else {
                if (cell.foldWidget) {
                    cell.element.removeChild(cell.foldWidget);
                    cell.foldWidget = null;
                }
            }
            
            var text = lastLineNumber = gutterRenderer
                ? gutterRenderer.getText(session, row)
                : row + firstLineNumber;
            if (text != cell.textNode.data)
                cell.textNode.data = text;

            row++;
        }

        this.element.style.height = config.minHeight + "px";

        if (this.$fixedWidth || session.$useWrapMode)
            lastLineNumber = session.getLength() + firstLineNumber;

        var gutterWidth = gutterRenderer 
            ? gutterRenderer.getWidth(session, lastLineNumber, config)
            : lastLineNumber.toString().length * config.characterWidth;
        
        var padding = this.$padding || this.$computePadding();
        gutterWidth += padding.left + padding.right;
        if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
            this.gutterWidth = gutterWidth;
            this.element.style.width = Math.ceil(this.gutterWidth) + "px";
            this._emit("changeGutterWidth", gutterWidth);
        }
    };

    this.$fixedWidth = false;
    
    this.$showFoldWidgets = true;
    this.setShowFoldWidgets = function(show) {
        if (show)
            dom.addCssClass(this.element, "ace_folding-enabled");
        else
            dom.removeCssClass(this.element, "ace_folding-enabled");

        this.$showFoldWidgets = show;
        this.$padding = null;
    };
    
    this.getShowFoldWidgets = function() {
        return this.$showFoldWidgets;
    };

    this.$computePadding = function() {
        if (!this.element.firstChild)
            return {left: 0, right: 0};
        var style = dom.computedStyle(this.element.firstChild);
        this.$padding = {};
        this.$padding.left = parseInt(style.paddingLeft) + 1 || 0;
        this.$padding.right = parseInt(style.paddingRight) || 0;
        return this.$padding;
    };

    this.getRegion = function(point) {
        var padding = this.$padding || this.$computePadding();
        var rect = this.element.getBoundingClientRect();
        if (point.x < padding.left + rect.left)
            return "markers";
        if (this.$showFoldWidgets && point.x > rect.right - padding.right)
            return "foldWidgets";
    };

}).call(Gutter.prototype);

exports.Gutter = Gutter;

});

consoleAce.define('ace/layer/marker', ['require', 'exports', 'module' , 'ace/range', 'ace/lib/dom'], function(require, exports, module) {


var Range = require("../range").Range;
var dom = require("../lib/dom");

var Marker = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_marker-layer";
    parentEl.appendChild(this.element);
};

(function() {

    this.$padding = 0;

    this.setPadding = function(padding) {
        this.$padding = padding;
    };
    this.setSession = function(session) {
        this.session = session;
    };
    
    this.setMarkers = function(markers) {
        this.markers = markers;
    };

    this.update = function(config) {
        var config = config || this.config;
        if (!config)
            return;

        this.config = config;


        var html = [];
        for (var key in this.markers) {
            var marker = this.markers[key];

            if (!marker.range) {
                marker.update(html, this, this.session, config);
                continue;
            }

            var range = marker.range.clipRows(config.firstRow, config.lastRow);
            if (range.isEmpty()) continue;

            range = range.toScreenRange(this.session);
            if (marker.renderer) {
                var top = this.$getTop(range.start.row, config);
                var left = this.$padding + range.start.column * config.characterWidth;
                marker.renderer(html, range, left, top, config);
            } else if (marker.type == "fullLine") {
                this.drawFullLineMarker(html, range, marker.clazz, config);
            } else if (marker.type == "screenLine") {
                this.drawScreenLineMarker(html, range, marker.clazz, config);
            } else if (range.isMultiLine()) {
                if (marker.type == "text")
                    this.drawTextMarker(html, range, marker.clazz, config);
                else
                    this.drawMultiLineMarker(html, range, marker.clazz, config);
            } else {
                this.drawSingleLineMarker(html, range, marker.clazz + " ace_start", config);
            }
        }
        this.element = dom.setInnerHtml(this.element, html.join(""));
    };

    this.$getTop = function(row, layerConfig) {
        return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
    };
    this.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {
        var row = range.start.row;

        var lineRange = new Range(
            row, range.start.column,
            row, this.session.getScreenLastRowColumn(row)
        );
        this.drawSingleLineMarker(stringBuilder, lineRange, clazz + " ace_start", layerConfig, 1, extraStyle);
        row = range.end.row;
        lineRange = new Range(row, 0, row, range.end.column);
        this.drawSingleLineMarker(stringBuilder, lineRange, clazz, layerConfig, 0, extraStyle);

        for (row = range.start.row + 1; row < range.end.row; row++) {
            lineRange.start.row = row;
            lineRange.end.row = row;
            lineRange.end.column = this.session.getScreenLastRowColumn(row);
            this.drawSingleLineMarker(stringBuilder, lineRange, clazz, layerConfig, 1, extraStyle);
        }
    };
    this.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
        var padding = this.$padding;
        var height = config.lineHeight;
        var top = this.$getTop(range.start.row, config);
        var left = padding + range.start.column * config.characterWidth;
        extraStyle = extraStyle || "";

        stringBuilder.push(
            "<div class='", clazz, " ace_start' style='",
            "height:", height, "px;",
            "right:0;",
            "top:", top, "px;",
            "left:", left, "px;", extraStyle, "'></div>"
        );
        top = this.$getTop(range.end.row, config);
        var width = range.end.column * config.characterWidth;

        stringBuilder.push(
            "<div class='", clazz, "' style='",
            "height:", height, "px;",
            "width:", width, "px;",
            "top:", top, "px;",
            "left:", padding, "px;", extraStyle, "'></div>"
        );
        height = (range.end.row - range.start.row - 1) * config.lineHeight;
        if (height < 0)
            return;
        top = this.$getTop(range.start.row + 1, config);

        stringBuilder.push(
            "<div class='", clazz, "' style='",
            "height:", height, "px;",
            "right:0;",
            "top:", top, "px;",
            "left:", padding, "px;", extraStyle, "'></div>"
        );
    };
    this.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
        var height = config.lineHeight;
        var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;

        var top = this.$getTop(range.start.row, config);
        var left = this.$padding + range.start.column * config.characterWidth;

        stringBuilder.push(
            "<div class='", clazz, "' style='",
            "height:", height, "px;",
            "width:", width, "px;",
            "top:", top, "px;",
            "left:", left, "px;", extraStyle || "", "'></div>"
        );
    };

    this.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
        var top = this.$getTop(range.start.row, config);
        var height = config.lineHeight;
        if (range.start.row != range.end.row)
            height += this.$getTop(range.end.row, config) - top;

        stringBuilder.push(
            "<div class='", clazz, "' style='",
            "height:", height, "px;",
            "top:", top, "px;",
            "left:0;right:0;", extraStyle || "", "'></div>"
        );
    };
    
    this.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
        var top = this.$getTop(range.start.row, config);
        var height = config.lineHeight;

        stringBuilder.push(
            "<div class='", clazz, "' style='",
            "height:", height, "px;",
            "top:", top, "px;",
            "left:0;right:0;", extraStyle || "", "'></div>"
        );
    };

}).call(Marker.prototype);

exports.Marker = Marker;

});

consoleAce.define('ace/layer/text', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/lib/dom', 'ace/lib/lang', 'ace/lib/useragent', 'ace/lib/event_emitter'], function(require, exports, module) {


var oop = require("../lib/oop");
var dom = require("../lib/dom");
var lang = require("../lib/lang");
var useragent = require("../lib/useragent");
var EventEmitter = require("../lib/event_emitter").EventEmitter;

var Text = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_text-layer";
    parentEl.appendChild(this.element);

    this.$characterSize = {width: 0, height: 0};
    this.checkForSizeChanges();
    this.$pollSizeChanges();
};

(function() {

    oop.implement(this, EventEmitter);

    this.EOF_CHAR = "\xB6"; //"&para;";
    this.EOL_CHAR = "\xAC"; //"&not;";
    this.TAB_CHAR = "\u2192"; //"&rarr;" "\u21E5";
    this.SPACE_CHAR = "\xB7"; //"&middot;";
    this.$padding = 0;

    this.setPadding = function(padding) {
        this.$padding = padding;
        this.element.style.padding = "0 " + padding + "px";
    };

    this.getLineHeight = function() {
        return this.$characterSize.height || 0;
    };

    this.getCharacterWidth = function() {
        return this.$characterSize.width || 0;
    };

    this.checkForSizeChanges = function() {
        var size = this.$measureSizes();
        if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
            this.$measureNode.style.fontWeight = "bold";
            var boldSize = this.$measureSizes();
            this.$measureNode.style.fontWeight = "";
            this.$characterSize = size;
            this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
            this._emit("changeCharacterSize", {data: size});
        }
    };

    this.$pollSizeChanges = function() {
        var self = this;
        this.$pollSizeChangesTimer = setInterval(function() {
            self.checkForSizeChanges();
        }, 500);
    };

    this.$fontStyles = {
        fontFamily : 1,
        fontSize : 1,
        fontWeight : 1,
        fontStyle : 1,
        lineHeight : 1
    };

    this.$measureSizes = useragent.isIE || useragent.isOldGecko ? function() {
        var n = 1000;
        if (!this.$measureNode) {
            var measureNode = this.$measureNode = dom.createElement("div");
            var style = measureNode.style;

            style.width = style.height = "auto";
            style.left = style.top = (-n * 40)  + "px";

            style.visibility = "hidden";
            style.position = "fixed";
            style.overflow = "visible";
            style.whiteSpace = "nowrap";
            measureNode.innerHTML = lang.stringRepeat("Xy", n);

            if (this.element.ownerDocument.body) {
                this.element.ownerDocument.body.appendChild(measureNode);
            } else {
                var container = this.element.parentNode;
                while (!dom.hasCssClass(container, "ace_editor"))
                    container = container.parentNode;
                container.appendChild(measureNode);
            }
        }
        if (!this.element.offsetWidth)
            return null;

        var style = this.$measureNode.style;
        var computedStyle = dom.computedStyle(this.element);
        for (var prop in this.$fontStyles)
            style[prop] = computedStyle[prop];

        var size = {
            height: this.$measureNode.offsetHeight,
            width: this.$measureNode.offsetWidth / (n * 2)
        };
        if (size.width == 0 || size.height == 0)
            return null;

        return size;
    }
    : function() {
        if (!this.$measureNode) {
            var measureNode = this.$measureNode = dom.createElement("div");
            var style = measureNode.style;

            style.width = style.height = "auto";
            style.left = style.top = -100 + "px";

            style.visibility = "hidden";
            style.position = "fixed";
            style.overflow = "visible";
            style.whiteSpace = "nowrap";
            measureNode.innerHTML = lang.stringRepeat("X", 100);

            var container = this.element.parentNode;
            while (container && !dom.hasCssClass(container, "ace_editor"))
                container = container.parentNode;

            if (!container)
                return this.$measureNode = null;

            container.appendChild(measureNode);
        }

        var rect = this.$measureNode.getBoundingClientRect();

        var size = {
            height: rect.height,
            width: rect.width / 100
        };
        if (size.width == 0 || size.height == 0)
            return null;

        return size;
    };

    this.setSession = function(session) {
        this.session = session;
        this.$computeTabString();
    };

    this.showInvisibles = false;
    this.setShowInvisibles = function(showInvisibles) {
        if (this.showInvisibles == showInvisibles)
            return false;

        this.showInvisibles = showInvisibles;
        this.$computeTabString();
        return true;
    };

    this.displayIndentGuides = true;
    this.setDisplayIndentGuides = function(display) {
        if (this.displayIndentGuides == display)
            return false;

        this.displayIndentGuides = display;
        this.$computeTabString();
        return true;
    };

    this.$tabStrings = [];
    this.onChangeTabSize =
    this.$computeTabString = function() {
        var tabSize = this.session.getTabSize();
        this.tabSize = tabSize;
        var tabStr = this.$tabStrings = [0];
        for (var i = 1; i < tabSize + 1; i++) {
            if (this.showInvisibles) {
                tabStr.push("<span class='ace_invisible'>"
                    + this.TAB_CHAR
                    + lang.stringRepeat("\xa0", i - 1)
                    + "</span>");
            } else {
                tabStr.push(lang.stringRepeat("\xa0", i));
            }
        }
        if (this.displayIndentGuides) {
            this.$indentGuideRe =  /\s\S| \t|\t |\s$/;
            var className = "ace_indent-guide";
            if (this.showInvisibles) {
                className += " ace_invisible";
                var spaceContent = lang.stringRepeat(this.SPACE_CHAR, this.tabSize);
                var tabContent = this.TAB_CHAR + lang.stringRepeat("\xa0", this.tabSize - 1);
            } else{
                var spaceContent = lang.stringRepeat("\xa0", this.tabSize);
                var tabContent = spaceContent;
            }

            this.$tabStrings[" "] = "<span class='" + className + "'>" + spaceContent + "</span>";
            this.$tabStrings["\t"] = "<span class='" + className + "'>" + tabContent + "</span>";
        }
    };

    this.updateLines = function(config, firstRow, lastRow) {
        if (this.config.lastRow != config.lastRow ||
            this.config.firstRow != config.firstRow) {
            this.scrollLines(config);
        }
        this.config = config;

        var first = Math.max(firstRow, config.firstRow);
        var last = Math.min(lastRow, config.lastRow);

        var lineElements = this.element.childNodes;
        var lineElementsIdx = 0;

        for (var row = config.firstRow; row < first; row++) {
            var foldLine = this.session.getFoldLine(row);
            if (foldLine) {
                if (foldLine.containsRow(first)) {
                    first = foldLine.start.row;
                    break;
                } else {
                    row = foldLine.end.row;
                }
            }
            lineElementsIdx ++;
        }

        var row = first;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (true) {
            if (row > foldStart) {
                row = foldLine.end.row+1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row :Infinity;
            }
            if (row > last)
                break;

            var lineElement = lineElements[lineElementsIdx++];
            if (lineElement) {
                var html = [];
                this.$renderLine(
                    html, row, !this.$useLineGroups(), row == foldStart ? foldLine : false
                );
                lineElement.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
                dom.setInnerHtml(lineElement, html.join(""));
            }
            row++;
        }
    };

    this.scrollLines = function(config) {
        var oldConfig = this.config;
        this.config = config;

        if (!oldConfig || oldConfig.lastRow < config.firstRow)
            return this.update(config);

        if (config.lastRow < oldConfig.firstRow)
            return this.update(config);

        var el = this.element;
        if (oldConfig.firstRow < config.firstRow)
            for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)
                el.removeChild(el.firstChild);

        if (oldConfig.lastRow > config.lastRow)
            for (var row=this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row>0; row--)
                el.removeChild(el.lastChild);

        if (config.firstRow < oldConfig.firstRow) {
            var fragment = this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1);
            if (el.firstChild)
                el.insertBefore(fragment, el.firstChild);
            else
                el.appendChild(fragment);
        }

        if (config.lastRow > oldConfig.lastRow) {
            var fragment = this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow);
            el.appendChild(fragment);
        }
    };

    this.$renderLinesFragment = function(config, firstRow, lastRow) {
        var fragment = this.element.ownerDocument.createDocumentFragment();
        var row = firstRow;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (true) {
            if (row > foldStart) {
                row = foldLine.end.row+1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row > lastRow)
                break;

            var container = dom.createElement("div");

            var html = [];
            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
            container.innerHTML = html.join("");
            if (this.$useLineGroups()) {
                container.className = 'ace_line_group';
                fragment.appendChild(container);
                container.style.height = config.lineHeight * this.session.getRowLength(row) + "px";

            } else {
                var lines = container.childNodes
                while(lines.length)
                    fragment.appendChild(lines[0]);
            }

            row++;
        }
        return fragment;
    };

    this.update = function(config) {
        this.config = config;

        var html = [];
        var firstRow = config.firstRow, lastRow = config.lastRow;

        var row = firstRow;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (true) {
            if (row > foldStart) {
                row = foldLine.end.row+1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row :Infinity;
            }
            if (row > lastRow)
                break;

            if (this.$useLineGroups())
                html.push("<div class='ace_line_group' style='height:", config.lineHeight*this.session.getRowLength(row), "px'>")

            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);

            if (this.$useLineGroups())
                html.push("</div>"); // end the line group

            row++;
        }
        this.element = dom.setInnerHtml(this.element, html.join(""));
    };

    this.$textToken = {
        "text": true,
        "rparen": true,
        "lparen": true
    };

    this.$renderToken = function(stringBuilder, screenColumn, token, value) {
        var self = this;
        var replaceReg = /\t|&|<|( +)|([\x00-\x1f\x80-\xa0\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\u3000\uFEFF])|[\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3000-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]/g;
        var replaceFunc = function(c, a, b, tabIdx, idx4) {
            if (a) {
                return self.showInvisibles ?
                    "<span class='ace_invisible'>" + lang.stringRepeat(self.SPACE_CHAR, c.length) + "</span>" :
                    lang.stringRepeat("\xa0", c.length);
            } else if (c == "&") {
                return "&#38;";
            } else if (c == "<") {
                return "&#60;";
            } else if (c == "\t") {
                var tabSize = self.session.getScreenTabSize(screenColumn + tabIdx);
                screenColumn += tabSize - 1;
                return self.$tabStrings[tabSize];
            } else if (c == "\u3000") {
                var classToUse = self.showInvisibles ? "ace_cjk ace_invisible" : "ace_cjk";
                var space = self.showInvisibles ? self.SPACE_CHAR : "";
                screenColumn += 1;
                return "<span class='" + classToUse + "' style='width:" +
                    (self.config.characterWidth * 2) +
                    "px'>" + space + "</span>";
            } else if (b) {
                return "<span class='ace_invisible ace_invalid'>" + self.SPACE_CHAR + "</span>";
            } else {
                screenColumn += 1;
                return "<span class='ace_cjk' style='width:" +
                    (self.config.characterWidth * 2) +
                    "px'>" + c + "</span>";
            }
        };

        var output = value.replace(replaceReg, replaceFunc);

        if (!this.$textToken[token.type]) {
            var classes = "ace_" + token.type.replace(/\./g, " ace_");
            var style = "";
            if (token.type == "fold")
                style = " style='width:" + (token.value.length * this.config.characterWidth) + "px;' ";
            stringBuilder.push("<span class='", classes, "'", style, ">", output, "</span>");
        }
        else {
            stringBuilder.push(output);
        }
        return screenColumn + value.length;
    };

    this.renderIndentGuide = function(stringBuilder, value, max) {
        var cols = value.search(this.$indentGuideRe);
        if (cols <= 0 || cols >= max)
            return value;
        if (value[0] == " ") {
            cols -= cols % this.tabSize;
            stringBuilder.push(lang.stringRepeat(this.$tabStrings[" "], cols/this.tabSize));
            return value.substr(cols);
        } else if (value[0] == "\t") {
            stringBuilder.push(lang.stringRepeat(this.$tabStrings["\t"], cols));
            return value.substr(cols);
        }
        return value;
    };

    this.$renderWrappedLine = function(stringBuilder, tokens, splits, onlyContents) {
        var chars = 0;
        var split = 0;
        var splitChars = splits[0];
        var screenColumn = 0;

        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            var value = token.value;
            if (i == 0 && this.displayIndentGuides) {
                chars = value.length;
                value = this.renderIndentGuide(stringBuilder, value, splitChars);
                if (!value)
                    continue;
                chars -= value.length;
            }

            if (chars + value.length < splitChars) {
                screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
                chars += value.length;
            } else {
                while (chars + value.length >= splitChars) {
                    screenColumn = this.$renderToken(
                        stringBuilder, screenColumn,
                        token, value.substring(0, splitChars - chars)
                    );
                    value = value.substring(splitChars - chars);
                    chars = splitChars;

                    if (!onlyContents) {
                        stringBuilder.push("</div>",
                            "<div class='ace_line' style='height:",
                            this.config.lineHeight, "px'>"
                        );
                    }

                    split ++;
                    screenColumn = 0;
                    splitChars = splits[split] || Number.MAX_VALUE;
                }
                if (value.length != 0) {
                    chars += value.length;
                    screenColumn = this.$renderToken(
                        stringBuilder, screenColumn, token, value
                    );
                }
            }
        }
    };

    this.$renderSimpleLine = function(stringBuilder, tokens) {
        var screenColumn = 0;
        var token = tokens[0];
        var value = token.value;
        if (this.displayIndentGuides)
            value = this.renderIndentGuide(stringBuilder, value);
        if (value)
            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
        for (var i = 1; i < tokens.length; i++) {
            token = tokens[i];
            value = token.value;
            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
        }
    };
    this.$renderLine = function(stringBuilder, row, onlyContents, foldLine) {
        if (!foldLine && foldLine != false)
            foldLine = this.session.getFoldLine(row);

        if (foldLine)
            var tokens = this.$getFoldLineTokens(row, foldLine);
        else
            var tokens = this.session.getTokens(row);


        if (!onlyContents) {
            stringBuilder.push(
                "<div class='ace_line' style='height:", 
                    this.config.lineHeight * (
                        this.$useLineGroups() ? 1 :this.session.getRowLength(row)
                    ), "px'>"
            );
        }

        if (tokens.length) {
            var splits = this.session.getRowSplitData(row);
            if (splits && splits.length)
                this.$renderWrappedLine(stringBuilder, tokens, splits, onlyContents);
            else
                this.$renderSimpleLine(stringBuilder, tokens);
        }

        if (this.showInvisibles) {
            if (foldLine)
                row = foldLine.end.row

            stringBuilder.push(
                "<span class='ace_invisible'>",
                row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR,
                "</span>"
            );
        }
        if (!onlyContents)
            stringBuilder.push("</div>");
    };

    this.$getFoldLineTokens = function(row, foldLine) {
        var session = this.session;
        var renderTokens = [];

        function addTokens(tokens, from, to) {
            var idx = 0, col = 0;
            while ((col + tokens[idx].value.length) < from) {
                col += tokens[idx].value.length;
                idx++;

                if (idx == tokens.length)
                    return;
            }
            if (col != from) {
                var value = tokens[idx].value.substring(from - col);
                if (value.length > (to - from))
                    value = value.substring(0, to - from);

                renderTokens.push({
                    type: tokens[idx].type,
                    value: value
                });

                col = from + value.length;
                idx += 1;
            }

            while (col < to && idx < tokens.length) {
                var value = tokens[idx].value;
                if (value.length + col > to) {
                    renderTokens.push({
                        type: tokens[idx].type,
                        value: value.substring(0, to - col)
                    });
                } else
                    renderTokens.push(tokens[idx]);
                col += value.length;
                idx += 1;
            }
        }

        var tokens = session.getTokens(row);
        foldLine.walk(function(placeholder, row, column, lastColumn, isNewRow) {
            if (placeholder != null) {
                renderTokens.push({
                    type: "fold",
                    value: placeholder
                });
            } else {
                if (isNewRow)
                    tokens = session.getTokens(row);

                if (tokens.length)
                    addTokens(tokens, lastColumn, column);
            }
        }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);

        return renderTokens;
    };

    this.$useLineGroups = function() {
        return this.session.getUseWrapMode();
    };

    this.destroy = function() {
        clearInterval(this.$pollSizeChangesTimer);
        if (this.$measureNode)
            this.$measureNode.parentNode.removeChild(this.$measureNode);
        delete this.$measureNode;
    };

}).call(Text.prototype);

exports.Text = Text;

});

consoleAce.define('ace/layer/cursor', ['require', 'exports', 'module' , 'ace/lib/dom'], function(require, exports, module) {


var dom = require("../lib/dom");

var Cursor = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_cursor-layer";
    parentEl.appendChild(this.element);

    this.isVisible = false;
    this.isBlinking = true;
    this.blinkInterval = 1000;
    this.smoothBlinking = false;

    this.cursors = [];
    this.cursor = this.addCursor();
    dom.addCssClass(this.element, "ace_hidden-cursors");
};

(function() {

    this.$padding = 0;
    this.setPadding = function(padding) {
        this.$padding = padding;
    };

    this.setSession = function(session) {
        this.session = session;
    };

    this.setBlinking = function(blinking) {
        if (blinking != this.isBlinking){
            this.isBlinking = blinking;
            this.restartTimer();
        }
    };

    this.setBlinkInterval = function(blinkInterval) {
        if (blinkInterval != this.blinkInterval){
            this.blinkInterval = blinkInterval;
            this.restartTimer();
        }
    };

    this.setSmoothBlinking = function(smoothBlinking) {
        if (smoothBlinking != this.smoothBlinking) {
            this.smoothBlinking = smoothBlinking;
            if (smoothBlinking)
                dom.addCssClass(this.element, "ace_smooth-blinking");
            else
                dom.removeCssClass(this.element, "ace_smooth-blinking");
            this.restartTimer();
        }
    };

    this.addCursor = function() {
        var el = dom.createElement("div");
        el.className = "ace_cursor";
        this.element.appendChild(el);
        this.cursors.push(el);
        return el;
    };

    this.removeCursor = function() {
        if (this.cursors.length > 1) {
            var el = this.cursors.pop();
            el.parentNode.removeChild(el);
            return el;
        }
    };

    this.hideCursor = function() {
        this.isVisible = false;
        dom.addCssClass(this.element, "ace_hidden-cursors");
        this.restartTimer();
    };

    this.showCursor = function() {
        this.isVisible = true;
        dom.removeCssClass(this.element, "ace_hidden-cursors");
        this.restartTimer();
    };

    this.restartTimer = function() {
        clearInterval(this.intervalId);
        clearTimeout(this.timeoutId);
        if (this.smoothBlinking)
            dom.removeCssClass(this.element, "ace_smooth-blinking");
        for (var i = this.cursors.length; i--; )
            this.cursors[i].style.opacity = "";

        if (!this.isBlinking || !this.blinkInterval || !this.isVisible)
            return;

        if (this.smoothBlinking)
            setTimeout(function(){
                dom.addCssClass(this.element, "ace_smooth-blinking");
            }.bind(this));

        var blink = function(){
            this.timeoutId = setTimeout(function() {
                for (var i = this.cursors.length; i--; ) {
                    this.cursors[i].style.opacity = 0;
                }
            }.bind(this), 0.6 * this.blinkInterval);
        }.bind(this);

        this.intervalId = setInterval(function() {
            for (var i = this.cursors.length; i--; ) {
                this.cursors[i].style.opacity = "";
            }
            blink();
        }.bind(this), this.blinkInterval);

        blink();
    };

    this.getPixelPosition = function(position, onScreen) {
        if (!this.config || !this.session)
            return {left : 0, top : 0};

        if (!position)
            position = this.session.selection.getCursor();
        var pos = this.session.documentToScreenPosition(position);
        var cursorLeft = this.$padding + pos.column * this.config.characterWidth;
        var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) *
            this.config.lineHeight;

        return {left : cursorLeft, top : cursorTop};
    };

    this.update = function(config) {
        this.config = config;

        var selections = this.session.$selectionMarkers;
        var i = 0, cursorIndex = 0;

        if (selections === undefined || selections.length === 0){
            selections = [{cursor: null}];
        }

        for (var i = 0, n = selections.length; i < n; i++) {
            var pixelPos = this.getPixelPosition(selections[i].cursor, true);
            if ((pixelPos.top > config.height + config.offset ||
                 pixelPos.top < -config.offset) && i > 1) {
                continue;
            }

            var style = (this.cursors[cursorIndex++] || this.addCursor()).style;

            style.left = pixelPos.left + "px";
            style.top = pixelPos.top + "px";
            style.width = config.characterWidth + "px";
            style.height = config.lineHeight + "px";
        }
        while (this.cursors.length > cursorIndex)
            this.removeCursor();

        var overwrite = this.session.getOverwrite();
        this.$setOverwrite(overwrite);
        this.$pixelPos = pixelPos;
        this.restartTimer();
    };

    this.$setOverwrite = function(overwrite) {
        if (overwrite != this.overwrite) {
            this.overwrite = overwrite;
            if (overwrite)
                dom.addCssClass(this.element, "ace_overwrite-cursors");
            else
                dom.removeCssClass(this.element, "ace_overwrite-cursors");
        }
    };

    this.destroy = function() {
        clearInterval(this.intervalId);
        clearTimeout(this.timeoutId);
    };

}).call(Cursor.prototype);

exports.Cursor = Cursor;

});

consoleAce.define('ace/scrollbar', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/lib/dom', 'ace/lib/event', 'ace/lib/event_emitter'], function(require, exports, module) {


var oop = require("./lib/oop");
var dom = require("./lib/dom");
var event = require("./lib/event");
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var ScrollBar = function(parent) {
    this.element = dom.createElement("div");
    this.element.className = "ace_scrollbar ace_scrollbar" + this.classSuffix;

    this.inner = dom.createElement("div");
    this.inner.className = "ace_scrollbar-inner";
    this.element.appendChild(this.inner);

    parent.appendChild(this.element);

    this.setVisible(false);
    this.skipEvent = false;

    event.addListener(this.element, "scroll", this.onScroll.bind(this));
    event.addListener(this.element, "mousedown", event.preventDefault);
};

(function() {
    oop.implement(this, EventEmitter);

    this.setVisible = function(isVisible) {
        this.element.style.display = isVisible ? "" : "none";
        this.isVisible = isVisible;
    };
}).call(ScrollBar.prototype);
var VScrollBar = function(parent, renderer) {
    ScrollBar.call(this, parent);
    this.scrollTop = 0;
    renderer.$scrollbarWidth = 
    this.width = dom.scrollbarWidth(parent.ownerDocument);
    this.inner.style.width =
    this.element.style.width = (this.width || 15) + 5 + "px";
};

oop.inherits(VScrollBar, ScrollBar);

(function() {

    this.classSuffix = '-v';
    this.onScroll = function() {
        if (!this.skipEvent) {
            this.scrollTop = this.element.scrollTop;
            this._emit("scroll", {data: this.scrollTop});
        }
        this.skipEvent = false;
    };
    this.getWidth = function() {
        return this.isVisible ? this.width : 0;
    };
    this.setHeight = function(height) {
        this.element.style.height = height + "px";
    };
    this.setInnerHeight = function(height) {
        this.inner.style.height = height + "px";
    };
    this.setScrollHeight = function(height) {
        this.inner.style.height = height + "px";
    };
    this.setScrollTop = function(scrollTop) {
        if (this.scrollTop != scrollTop) {
            this.skipEvent = true;
            this.scrollTop = this.element.scrollTop = scrollTop;
        }
    };

}).call(VScrollBar.prototype);
var HScrollBar = function(parent, renderer) {
    ScrollBar.call(this, parent);
    this.scrollLeft = 0;
    this.height = renderer.$scrollbarWidth;
    this.inner.style.height =
    this.element.style.height = (this.height || 15) + 5 + "px";
};

oop.inherits(HScrollBar, ScrollBar);

(function() {

    this.classSuffix = '-h';
    this.onScroll = function() {
        if (!this.skipEvent) {
            this.scrollLeft = this.element.scrollLeft;
            this._emit("scroll", {data: this.scrollLeft});
        }
        this.skipEvent = false;
    };
    this.getHeight = function() {
        return this.isVisible ? this.height : 0;
    };
    this.setWidth = function(width) {
        this.element.style.width = width + "px";
    };
    this.setInnerWidth = function(width) {
        this.inner.style.width = width + "px";
    };
    this.setScrollWidth = function(width) {
        this.inner.style.width = width + "px";
    };
    this.setScrollLeft = function(scrollLeft) {
        if (this.scrollLeft != scrollLeft) {
            this.skipEvent = true;
            this.scrollLeft = this.element.scrollLeft = scrollLeft;
        }
    };

}).call(HScrollBar.prototype);


exports.ScrollBar = VScrollBar; // backward compatibility
exports.ScrollBarV = VScrollBar; // backward compatibility
exports.ScrollBarH = HScrollBar; // backward compatibility

exports.VScrollBar = VScrollBar;
exports.HScrollBar = HScrollBar;
});

consoleAce.define('ace/renderloop', ['require', 'exports', 'module' , 'ace/lib/event'], function(require, exports, module) {


var event = require("./lib/event");


var RenderLoop = function(onRender, win) {
    this.onRender = onRender;
    this.pending = false;
    this.changes = 0;
    this.window = win || window;
};

(function() {


    this.schedule = function(change) {
        this.changes = this.changes | change;
        if (!this.pending && this.changes) {
            this.pending = true;
            var _self = this;
            event.nextFrame(function() {
                _self.pending = false;
                var changes;
                while (changes = _self.changes) {
                    _self.changes = 0;
                    _self.onRender(changes);
                }
            }, this.window);
        }
    };

}).call(RenderLoop.prototype);

exports.RenderLoop = RenderLoop;
});

consoleAce.define('ace/multi_select', ['require', 'exports', 'module' , 'ace/range_list', 'ace/range', 'ace/selection', 'ace/mouse/multi_select_handler', 'ace/lib/event', 'ace/lib/lang', 'ace/commands/multi_select_commands', 'ace/search', 'ace/edit_session', 'ace/editor', 'ace/config'], function(require, exports, module) {

var RangeList = require("./range_list").RangeList;
var Range = require("./range").Range;
var Selection = require("./selection").Selection;
var onMouseDown = require("./mouse/multi_select_handler").onMouseDown;
var event = require("./lib/event");
var lang = require("./lib/lang");
var commands = require("./commands/multi_select_commands");
exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
var Search = require("./search").Search;
var search = new Search();

function find(session, needle, dir) {
    search.$options.wrap = true;
    search.$options.needle = needle;
    search.$options.backwards = dir == -1;
    return search.find(session);
}
var EditSession = require("./edit_session").EditSession;
(function() {
    this.getSelectionMarkers = function() {
        return this.$selectionMarkers;
    };
}).call(EditSession.prototype);
(function() {
    this.ranges = null;
    this.rangeList = null;
    this.addRange = function(range, $blockChangeEvents) {
        if (!range)
            return;

        if (!this.inMultiSelectMode && this.rangeCount == 0) {
            var oldRange = this.toOrientedRange();
            this.rangeList.add(oldRange);
            this.rangeList.add(range);
            if (this.rangeList.ranges.length != 2) {
                this.rangeList.removeAll();
                return $blockChangeEvents || this.fromOrientedRange(range);
            }
            this.rangeList.removeAll();
            this.rangeList.add(oldRange);
            this.$onAddRange(oldRange);
        }

        if (!range.cursor)
            range.cursor = range.end;

        var removed = this.rangeList.add(range);

        this.$onAddRange(range);

        if (removed.length)
            this.$onRemoveRange(removed);

        if (this.rangeCount > 1 && !this.inMultiSelectMode) {
            this._emit("multiSelect");
            this.inMultiSelectMode = true;
            this.session.$undoSelect = false;
            this.rangeList.attach(this.session);
        }

        return $blockChangeEvents || this.fromOrientedRange(range);
    };

    this.toSingleRange = function(range) {
        range = range || this.ranges[0];
        var removed = this.rangeList.removeAll();
        if (removed.length)
            this.$onRemoveRange(removed);

        range && this.fromOrientedRange(range);
    };
    this.substractPoint = function(pos) {
        var removed = this.rangeList.substractPoint(pos);
        if (removed) {
            this.$onRemoveRange(removed);
            return removed[0];
        }
    };
    this.mergeOverlappingRanges = function() {
        var removed = this.rangeList.merge();
        if (removed.length)
            this.$onRemoveRange(removed);
        else if(this.ranges[0])
            this.fromOrientedRange(this.ranges[0]);
    };

    this.$onAddRange = function(range) {
        this.rangeCount = this.rangeList.ranges.length;
        this.ranges.unshift(range);
        this._emit("addRange", {range: range});
    };

    this.$onRemoveRange = function(removed) {
        this.rangeCount = this.rangeList.ranges.length;
        if (this.rangeCount == 1 && this.inMultiSelectMode) {
            var lastRange = this.rangeList.ranges.pop();
            removed.push(lastRange);
            this.rangeCount = 0;
        }

        for (var i = removed.length; i--; ) {
            var index = this.ranges.indexOf(removed[i]);
            this.ranges.splice(index, 1);
        }

        this._emit("removeRange", {ranges: removed});

        if (this.rangeCount == 0 && this.inMultiSelectMode) {
            this.inMultiSelectMode = false;
            this._emit("singleSelect");
            this.session.$undoSelect = true;
            this.rangeList.detach(this.session);
        }

        lastRange = lastRange || this.ranges[0];
        if (lastRange && !lastRange.isEqual(this.getRange()))
            this.fromOrientedRange(lastRange);
    };
    this.$initRangeList = function() {
        if (this.rangeList)
            return;

        this.rangeList = new RangeList();
        this.ranges = [];
        this.rangeCount = 0;
    };
    this.getAllRanges = function() {
        return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
    };

    this.splitIntoLines = function () {
        if (this.rangeCount > 1) {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);

            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
        } else {
            var range = this.getRange();
            var isBackwards = this.isBackwards();
            var startRow = range.start.row;
            var endRow = range.end.row;
            if (startRow == endRow) {
                if (isBackwards)
                    var start = range.end, end = range.start;
                else
                    var start = range.start, end = range.end;
                
                this.addRange(Range.fromPoints(end, end));
                this.addRange(Range.fromPoints(start, start));
                return;
            }

            var rectSel = [];
            var r = this.getLineRange(startRow, true);
            r.start.column = range.start.column;
            rectSel.push(r);

            for (var i = startRow + 1; i < endRow; i++)
                rectSel.push(this.getLineRange(i, true));

            r = this.getLineRange(endRow, true);
            r.end.column = range.end.column;
            rectSel.push(r);

            rectSel.forEach(this.addRange, this);
        }
    };
    this.toggleBlockSelection = function () {
        if (this.rangeCount > 1) {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);

            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
        } else {
            var cursor = this.session.documentToScreenPosition(this.selectionLead);
            var anchor = this.session.documentToScreenPosition(this.selectionAnchor);

            var rectSel = this.rectangularRangeBlock(cursor, anchor);
            rectSel.forEach(this.addRange, this);
        }
    };
    this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
        var rectSel = [];

        var xBackwards = screenCursor.column < screenAnchor.column;
        if (xBackwards) {
            var startColumn = screenCursor.column;
            var endColumn = screenAnchor.column;
        } else {
            var startColumn = screenAnchor.column;
            var endColumn = screenCursor.column;
        }

        var yBackwards = screenCursor.row < screenAnchor.row;
        if (yBackwards) {
            var startRow = screenCursor.row;
            var endRow = screenAnchor.row;
        } else {
            var startRow = screenAnchor.row;
            var endRow = screenCursor.row;
        }

        if (startColumn < 0)
            startColumn = 0;
        if (startRow < 0)
            startRow = 0;

        if (startRow == endRow)
            includeEmptyLines = true;

        for (var row = startRow; row <= endRow; row++) {
            var range = Range.fromPoints(
                this.session.screenToDocumentPosition(row, startColumn),
                this.session.screenToDocumentPosition(row, endColumn)
            );
            if (range.isEmpty()) {
                if (docEnd && isSamePoint(range.end, docEnd))
                    break;
                var docEnd = range.end;
            }
            range.cursor = xBackwards ? range.start : range.end;
            rectSel.push(range);
        }

        if (yBackwards)
            rectSel.reverse();

        if (!includeEmptyLines) {
            var end = rectSel.length - 1;
            while (rectSel[end].isEmpty() && end > 0)
                end--;
            if (end > 0) {
                var start = 0;
                while (rectSel[start].isEmpty())
                    start++;
            }
            for (var i = end; i >= start; i--) {
                if (rectSel[i].isEmpty())
                    rectSel.splice(i, 1);
            }
        }

        return rectSel;
    };
}).call(Selection.prototype);
var Editor = require("./editor").Editor;
(function() {
    this.updateSelectionMarkers = function() {
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };
    this.addSelectionMarker = function(orientedRange) {
        if (!orientedRange.cursor)
            orientedRange.cursor = orientedRange.end;

        var style = this.getSelectionStyle();
        orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);

        this.session.$selectionMarkers.push(orientedRange);
        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
        return orientedRange;
    };
    this.removeSelectionMarker = function(range) {
        if (!range.marker)
            return;
        this.session.removeMarker(range.marker);
        var index = this.session.$selectionMarkers.indexOf(range);
        if (index != -1)
            this.session.$selectionMarkers.splice(index, 1);
        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
    };

    this.removeSelectionMarkers = function(ranges) {
        var markerList = this.session.$selectionMarkers;
        for (var i = ranges.length; i--; ) {
            var range = ranges[i];
            if (!range.marker)
                continue;
            this.session.removeMarker(range.marker);
            var index = markerList.indexOf(range);
            if (index != -1)
                markerList.splice(index, 1);
        }
        this.session.selectionMarkerCount = markerList.length;
    };

    this.$onAddRange = function(e) {
        this.addSelectionMarker(e.range);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    this.$onRemoveRange = function(e) {
        this.removeSelectionMarkers(e.ranges);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    this.$onMultiSelect = function(e) {
        if (this.inMultiSelectMode)
            return;
        this.inMultiSelectMode = true;

        this.setStyle("ace_multiselect");
        this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
        this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);

        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    this.$onSingleSelect = function(e) {
        if (this.session.multiSelect.inVirtualMode)
            return;
        this.inMultiSelectMode = false;

        this.unsetStyle("ace_multiselect");
        this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);

        this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    this.$onMultiSelectExec = function(e) {
        var command = e.command;
        var editor = e.editor;
        if (!editor.multiSelect)
            return;
        if (!command.multiSelectAction) {
            var result = command.exec(editor, e.args || {});
            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
            editor.multiSelect.mergeOverlappingRanges();
        } else if (command.multiSelectAction == "forEach") {
            result = editor.forEachSelection(command, e.args);
        } else if (command.multiSelectAction == "forEachLine") {
            result = editor.forEachSelection(command, e.args, true);
        } else if (command.multiSelectAction == "single") {
            editor.exitMultiSelectMode();
            result = command.exec(editor, e.args || {});
        } else {
            result = command.multiSelectAction(editor, e.args || {});
        }
        return result;
    }; 
    this.forEachSelection = function(cmd, args, $byLines) {
        if (this.inVirtualSelectionMode)
            return;

        var session = this.session;
        var selection = this.selection;
        var rangeList = selection.rangeList;
        var result;
        
        var reg = selection._eventRegistry;
        selection._eventRegistry = {};

        var tmpSel = new Selection(session);
        this.inVirtualSelectionMode = true;
        for (var i = rangeList.ranges.length; i--;) {
            if ($byLines) {
                while (i > 0 && rangeList.ranges[i].start.row == rangeList.ranges[i - 1].end.row)
                    i--;
            }
            tmpSel.fromOrientedRange(rangeList.ranges[i]);
            this.selection = session.selection = tmpSel;
            var cmdResult = cmd.exec(this, args || {});
            if (!result == undefined)
                result = cmdResult;
            tmpSel.toOrientedRange(rangeList.ranges[i]);
        }
        tmpSel.detach();

        this.selection = session.selection = selection;
        this.inVirtualSelectionMode = false;
        selection._eventRegistry = reg;
        selection.mergeOverlappingRanges();
        
        var anim = this.renderer.$scrollAnimation;
        this.onCursorChange();
        this.onSelectionChange();
        if (anim && anim.from == anim.to)
            this.renderer.animateScrolling(anim.from);
        
        return result;
    };
    this.exitMultiSelectMode = function() {
        if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
            return;
        this.multiSelect.toSingleRange();
    };

    this.getSelectedText = function() {
        var text = "";
        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var ranges = this.multiSelect.rangeList.ranges;
            var buf = [];
            for (var i = 0; i < ranges.length; i++) {
                buf.push(this.session.getTextRange(ranges[i]));
            }
            var nl = this.session.getDocument().getNewLineCharacter();
            text = buf.join(nl);
            if (text.length == (buf.length - 1) * nl.length)
                text = "";
        } else if (!this.selection.isEmpty()) {
            text = this.session.getTextRange(this.getSelectionRange());
        }
        return text;
    };
    this.onPaste = function(text) {
        if (this.$readOnly)
            return;

        this._signal("paste", text);
        if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
            return this.insert(text);

        var lines = text.split(/\r\n|\r|\n/);
        var ranges = this.selection.rangeList.ranges;

        if (lines.length > ranges.length || lines.length < 2 || !lines[1])
            return this.commands.exec("insertstring", this, text);

        for (var i = ranges.length; i--;) {
            var range = ranges[i];
            if (!range.isEmpty())
                this.session.remove(range);

            this.session.insert(range.start, lines[i]);
        }
    };
    this.findAll = function(needle, options, additive) {
        options = options || {};
        options.needle = needle || options.needle;
        this.$search.set(options);

        var ranges = this.$search.findAll(this.session);
        if (!ranges.length)
            return 0;

        this.$blockScrolling += 1;
        var selection = this.multiSelect;

        if (!additive)
            selection.toSingleRange(ranges[0]);

        for (var i = ranges.length; i--; )
            selection.addRange(ranges[i], true);

        this.$blockScrolling -= 1;

        return ranges.length;
    };
    this.selectMoreLines = function(dir, skip) {
        var range = this.selection.toOrientedRange();
        var isBackwards = range.cursor == range.end;

        var screenLead = this.session.documentToScreenPosition(range.cursor);
        if (this.selection.$desiredColumn)
            screenLead.column = this.selection.$desiredColumn;

        var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);

        if (!range.isEmpty()) {
            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
        } else {
            var anchor = lead;
        }

        if (isBackwards) {
            var newRange = Range.fromPoints(lead, anchor);
            newRange.cursor = newRange.start;
        } else {
            var newRange = Range.fromPoints(anchor, lead);
            newRange.cursor = newRange.end;
        }

        newRange.desiredColumn = screenLead.column;
        if (!this.selection.inMultiSelectMode) {
            this.selection.addRange(range);
        } else {
            if (skip)
                var toRemove = range.cursor;
        }

        this.selection.addRange(newRange);
        if (toRemove)
            this.selection.substractPoint(toRemove);
    };
    this.transposeSelections = function(dir) {
        var session = this.session;
        var sel = session.multiSelect;
        var all = sel.ranges;

        for (var i = all.length; i--; ) {
            var range = all[i];
            if (range.isEmpty()) {
                var tmp = session.getWordRange(range.start.row, range.start.column);
                range.start.row = tmp.start.row;
                range.start.column = tmp.start.column;
                range.end.row = tmp.end.row;
                range.end.column = tmp.end.column;
            }
        }
        sel.mergeOverlappingRanges();

        var words = [];
        for (var i = all.length; i--; ) {
            var range = all[i];
            words.unshift(session.getTextRange(range));
        }

        if (dir < 0)
            words.unshift(words.pop());
        else
            words.push(words.shift());

        for (var i = all.length; i--; ) {
            var range = all[i];
            var tmp = range.clone();
            session.replace(range, words[i]);
            range.start.row = tmp.start.row;
            range.start.column = tmp.start.column;
        }
    };
    this.selectMore = function(dir, skip) {
        var session = this.session;
        var sel = session.multiSelect;

        var range = sel.toOrientedRange();
        if (range.isEmpty()) {
            range = session.getWordRange(range.start.row, range.start.column);
            range.cursor = dir == -1 ? range.start : range.end;
            this.multiSelect.addRange(range);
        }
        var needle = session.getTextRange(range);

        var newRange = find(session, needle, dir);
        if (newRange) {
            newRange.cursor = dir == -1 ? newRange.start : newRange.end;
            this.$blockScrolling += 1;
            this.session.unfold(newRange);
            this.multiSelect.addRange(newRange);
            this.$blockScrolling -= 1;
            this.renderer.scrollCursorIntoView(null, 0.5);
        }
        if (skip)
            this.multiSelect.substractPoint(range.cursor);
    };
    this.alignCursors = function() {
        var session = this.session;
        var sel = session.multiSelect;
        var ranges = sel.ranges;

        if (!ranges.length) {
            var range = this.selection.getRange();
            var fr = range.start.row, lr = range.end.row;
            var guessRange = fr == lr;
            if (guessRange) {
                var max = this.session.getLength();
                var line;
                do {
                    line = this.session.getLine(lr);
                } while (/[=:]/.test(line) && ++lr < max);
                do {
                    line = this.session.getLine(fr);
                } while (/[=:]/.test(line) && --fr > 0);
                
                if (fr < 0) fr = 0;
                if (lr >= max) lr = max - 1;
            }
            var lines = this.session.doc.removeLines(fr, lr);
            lines = this.$reAlignText(lines, guessRange);
            this.session.doc.insert({row: fr, column: 0}, lines.join("\n") + "\n");
            if (!guessRange) {
                range.start.column = 0;
                range.end.column = lines[lines.length - 1].length;
            }
            this.selection.setRange(range);
        } else {
            var row = -1;
            var sameRowRanges = ranges.filter(function(r) {
                if (r.cursor.row == row)
                    return true;
                row = r.cursor.row;
            });
            sel.$onRemoveRange(sameRowRanges);

            var maxCol = 0;
            var minSpace = Infinity;
            var spaceOffsets = ranges.map(function(r) {
                var p = r.cursor;
                var line = session.getLine(p.row);
                var spaceOffset = line.substr(p.column).search(/\S/g);
                if (spaceOffset == -1)
                    spaceOffset = 0;

                if (p.column > maxCol)
                    maxCol = p.column;
                if (spaceOffset < minSpace)
                    minSpace = spaceOffset;
                return spaceOffset;
            });
            ranges.forEach(function(r, i) {
                var p = r.cursor;
                var l = maxCol - p.column;
                var d = spaceOffsets[i] - minSpace;
                if (l > d)
                    session.insert(p, lang.stringRepeat(" ", l - d));
                else
                    session.remove(new Range(p.row, p.column, p.row, p.column - l + d));

                r.start.column = r.end.column = maxCol;
                r.start.row = r.end.row = p.row;
                r.cursor = r.end;
            });
            sel.fromOrientedRange(ranges[0]);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
        }
    };

    this.$reAlignText = function(lines, forceLeft) {
        var isLeftAligned = true, isRightAligned = true;
        var startW, textW, endW;

        return lines.map(function(line) {
            var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
            if (!m)
                return [line];

            if (startW == null) {
                startW = m[1].length;
                textW = m[2].length;
                endW = m[3].length;
                return m;
            }

            if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
                isRightAligned = false;
            if (startW != m[1].length)
                isLeftAligned = false;

            if (startW > m[1].length)
                startW = m[1].length;
            if (textW < m[2].length)
                textW = m[2].length;
            if (endW > m[3].length)
                endW = m[3].length;

            return m;
        }).map(forceLeft ? alignLeft :
            isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);

        function spaces(n) {
            return lang.stringRepeat(" ", n);
        }

        function alignLeft(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2]
                + spaces(textW - m[2].length + endW)
                + m[4].replace(/^([=:])\s+/, "$1 ")
        }
        function alignRight(m) {
            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2]
                + spaces(endW, " ")
                + m[4].replace(/^([=:])\s+/, "$1 ")
        }
        function unAlign(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2]
                + spaces(endW)
                + m[4].replace(/^([=:])\s+/, "$1 ")
        }
    }
}).call(Editor.prototype);


function isSamePoint(p1, p2) {
    return p1.row == p2.row && p1.column == p2.column;
}
exports.onSessionChange = function(e) {
    var session = e.session;
    if (!session.multiSelect) {
        session.$selectionMarkers = [];
        session.selection.$initRangeList();
        session.multiSelect = session.selection;
    }
    this.multiSelect = session.multiSelect;

    var oldSession = e.oldSession;
    if (oldSession) {
        oldSession.multiSelect.removeEventListener("addRange", this.$onAddRange);
        oldSession.multiSelect.removeEventListener("removeRange", this.$onRemoveRange);
        oldSession.multiSelect.removeEventListener("multiSelect", this.$onMultiSelect);
        oldSession.multiSelect.removeEventListener("singleSelect", this.$onSingleSelect);
    }

    session.multiSelect.on("addRange", this.$onAddRange);
    session.multiSelect.on("removeRange", this.$onRemoveRange);
    session.multiSelect.on("multiSelect", this.$onMultiSelect);
    session.multiSelect.on("singleSelect", this.$onSingleSelect);

    if (this.inMultiSelectMode != session.selection.inMultiSelectMode) {
        if (session.selection.inMultiSelectMode)
            this.$onMultiSelect();
        else
            this.$onSingleSelect();
    }
};
function MultiSelect(editor) {
    if (editor.$multiselectOnSessionChange)
        return;
    editor.$onAddRange = editor.$onAddRange.bind(editor);
    editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
    editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
    editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
    editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);

    editor.$multiselectOnSessionChange(editor);
    editor.on("changeSession", editor.$multiselectOnSessionChange);

    editor.on("mousedown", onMouseDown);
    editor.commands.addCommands(commands.defaultCommands);

    addAltCursorListeners(editor);
}

function addAltCursorListeners(editor){
    var el = editor.textInput.getElement();
    var altCursor = false;
    event.addListener(el, "keydown", function(e) {
        if (e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey)) {
            if (!altCursor) {
                editor.renderer.setMouseCursor("crosshair");
                altCursor = true;
            }
        } else if (altCursor) {
            reset();
        }
    });

    event.addListener(el, "keyup", reset);
    event.addListener(el, "blur", reset);
    function reset(e) {
        if (altCursor) {
            editor.renderer.setMouseCursor("");
            altCursor = false;
        }
    }
}

exports.MultiSelect = MultiSelect;


require("./config").defineOptions(Editor.prototype, "editor", {
    enableMultiselect: {
        set: function(val) {
            MultiSelect(this);
            if (val) {
                this.on("changeSession", this.$multiselectOnSessionChange);
                this.on("mousedown", onMouseDown);
            } else {
                this.off("changeSession", this.$multiselectOnSessionChange);
                this.off("mousedown", onMouseDown);
            }
        },
        value: true
    }
})



});

consoleAce.define('ace/mouse/multi_select_handler', ['require', 'exports', 'module' , 'ace/lib/event'], function(require, exports, module) {

var event = require("../lib/event");
function isSamePoint(p1, p2) {
    return p1.row == p2.row && p1.column == p2.column;
}

function onMouseDown(e) {
    var ev = e.domEvent;
    var alt = ev.altKey;
    var shift = ev.shiftKey;
    var ctrl = e.getAccelKey();
    var button = e.getButton();

    if (e.editor.inMultiSelectMode && button == 2) {
        e.editor.textInput.onContextMenu(e.domEvent);
        return;
    }
    
    if (!ctrl && !alt) {
        if (button == 0 && e.editor.inMultiSelectMode)
            e.editor.exitMultiSelectMode();
        return;
    }

    var editor = e.editor;
    var selection = editor.selection;
    var isMultiSelect = editor.inMultiSelectMode;
    var pos = e.getDocumentPosition();
    var cursor = selection.getCursor();
    var inSelection = e.inSelection() || (selection.isEmpty() && isSamePoint(pos, cursor));


    var mouseX = e.x, mouseY = e.y;
    var onMouseSelection = function(e) {
        mouseX = e.clientX;
        mouseY = e.clientY;
    };

    var blockSelect = function() {
        var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
        var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column);

        if (isSamePoint(screenCursor, newCursor)
            && isSamePoint(cursor, selection.selectionLead))
            return;
        screenCursor = newCursor;

        editor.selection.moveCursorToPosition(cursor);
        editor.selection.clearSelection();
        editor.renderer.scrollCursorIntoView();

        editor.removeSelectionMarkers(rectSel);
        rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
        rectSel.forEach(editor.addSelectionMarker, editor);
        editor.updateSelectionMarkers();
    };
    
    var session = editor.session;
    var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
    var screenCursor = screenAnchor;

    

    if (ctrl && !shift && !alt && button == 0) {
        if (!isMultiSelect && inSelection)
            return; // dragging

        if (!isMultiSelect) {
            var range = selection.toOrientedRange();
            editor.addSelectionMarker(range);
        }

        var oldRange = selection.rangeList.rangeAtPoint(pos);
        
        editor.$blockScrolling++;
        editor.once("mouseup", function() {
            var tmpSel = selection.toOrientedRange();

            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
                selection.substractPoint(tmpSel.cursor);
            else {
                if (range) {
                    editor.removeSelectionMarker(range);
                    selection.addRange(range);
                }
                selection.addRange(tmpSel);
            }
            editor.$blockScrolling--;
        });

    } else if (alt && button == 0) {
        e.stop();

        if (isMultiSelect && !ctrl)
            selection.toSingleRange();
        else if (!isMultiSelect && ctrl)
            selection.addRange();

        var rectSel = [];
        if (shift) {
            screenAnchor = session.documentToScreenPosition(selection.lead);
            blockSelect();
        } else {
            selection.moveCursorToPosition(pos);
            selection.clearSelection();
        }


        var onMouseSelectionEnd = function(e) {
            clearInterval(timerId);
            editor.removeSelectionMarkers(rectSel);
            for (var i = 0; i < rectSel.length; i++)
                selection.addRange(rectSel[i]);
        };

        var onSelectionInterval = blockSelect;

        event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
        var timerId = setInterval(function() {onSelectionInterval();}, 20);

        return e.preventDefault();
    }
}


exports.onMouseDown = onMouseDown;

});

consoleAce.define('ace/commands/multi_select_commands', ['require', 'exports', 'module' , 'ace/keyboard/hash_handler'], function(require, exports, module) {
exports.defaultCommands = [{
    name: "addCursorAbove",
    exec: function(editor) { editor.selectMoreLines(-1); },
    bindKey: {win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up"},
    readonly: true
}, {
    name: "addCursorBelow",
    exec: function(editor) { editor.selectMoreLines(1); },
    bindKey: {win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down"},
    readonly: true
}, {
    name: "addCursorAboveSkipCurrent",
    exec: function(editor) { editor.selectMoreLines(-1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up"},
    readonly: true
}, {
    name: "addCursorBelowSkipCurrent",
    exec: function(editor) { editor.selectMoreLines(1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down"},
    readonly: true
}, {
    name: "selectMoreBefore",
    exec: function(editor) { editor.selectMore(-1); },
    bindKey: {win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left"},
    readonly: true
}, {
    name: "selectMoreAfter",
    exec: function(editor) { editor.selectMore(1); },
    bindKey: {win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right"},
    readonly: true
}, {
    name: "selectNextBefore",
    exec: function(editor) { editor.selectMore(-1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left"},
    readonly: true
}, {
    name: "selectNextAfter",
    exec: function(editor) { editor.selectMore(1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right"},
    readonly: true
}, {
    name: "splitIntoLines",
    exec: function(editor) { editor.multiSelect.splitIntoLines(); },
    bindKey: {win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L"},
    readonly: true
}, {
    name: "alignCursors",
    exec: function(editor) { editor.alignCursors(); },
    bindKey: {win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A"}
}];
exports.multiSelectCommands = [{
    name: "singleSelection",
    bindKey: "esc",
    exec: function(editor) { editor.exitMultiSelectMode(); },
    readonly: true,
    isAvailable: function(editor) {return editor && editor.inMultiSelectMode}
}];

var HashHandler = require("../keyboard/hash_handler").HashHandler;
exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);

});

consoleAce.define('ace/worker/worker_client', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/lib/event_emitter', 'ace/config'], function(require, exports, module) {


var oop = require("../lib/oop");
var EventEmitter = require("../lib/event_emitter").EventEmitter;
var config = require("../config");

var WorkerClient = function(topLevelNamespaces, mod, classname) {
    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
    this.changeListener = this.changeListener.bind(this);
    this.onMessage = this.onMessage.bind(this);
    if (require.nameToUrl && !require.toUrl)
        require.toUrl = require.nameToUrl;

    var workerUrl;
    if (config.get("packaged") || !require.toUrl) {
        workerUrl = config.moduleUrl(mod, "worker");
    } else {
        var normalizePath = this.$normalizePath;
        workerUrl = normalizePath(require.toUrl("ace/worker/worker.js", null, '_'));

        var tlns = {};
        topLevelNamespaces.forEach(function(ns) {
            tlns[ns] = normalizePath(require.toUrl(ns, null, '_').replace(/(\.js)?(\?.*)?$/, ""));
        });
    }

    this.$worker = new Worker(workerUrl);
    this.$worker.postMessage({
        init : true,
        tlns: tlns,
        module: mod,
        classname: classname
    });

    this.callbackId = 1;
    this.callbacks = {};

    this.$worker.onmessage = this.onMessage;
};

(function(){

    oop.implement(this, EventEmitter);

    this.onMessage = function(e) {
        var msg = e.data;
        switch(msg.type) {
            case "log":
                window.console && console.log && console.log.apply(console, msg.data);
                break;

            case "event":
                this._emit(msg.name, {data: msg.data});
                break;

            case "call":
                var callback = this.callbacks[msg.id];
                if (callback) {
                    callback(msg.data);
                    delete this.callbacks[msg.id];
                }
                break;
        }
    };

    this.$normalizePath = function(path) {
        if (!location.host) // needed for file:// protocol
            return path;
        path = path.replace(/^[a-z]+:\/\/[^\/]+/, ""); // Remove domain name and rebuild it
        path = location.protocol + "//" + location.host
            + (path.charAt(0) == "/" ? "" : location.pathname.replace(/\/[^\/]*$/, ""))
            + "/" + path.replace(/^[\/]+/, "");
        return path;
    };

    this.terminate = function() {
        this._emit("terminate", {});
        this.deltaQueue = null;
        this.$worker.terminate();
        this.$worker = null;
        this.$doc.removeEventListener("change", this.changeListener);
        this.$doc = null;
    };

    this.send = function(cmd, args) {
        this.$worker.postMessage({command: cmd, args: args});
    };

    this.call = function(cmd, args, callback) {
        if (callback) {
            var id = this.callbackId++;
            this.callbacks[id] = callback;
            args.push(id);
        }
        this.send(cmd, args);
    };

    this.emit = function(event, data) {
        try {
            this.$worker.postMessage({event: event, data: {data: data.data}});
        }
        catch(ex) {}
    };

    this.attachToDocument = function(doc) {
        if(this.$doc)
            this.terminate();

        this.$doc = doc;
        this.call("setValue", [doc.getValue()]);
        doc.on("change", this.changeListener);
    };

    this.changeListener = function(e) {
        if (!this.deltaQueue) {
            this.deltaQueue = [e.data];
            setTimeout(this.$sendDeltaQueue, 0);
        } else
            this.deltaQueue.push(e.data);
    };

    this.$sendDeltaQueue = function() {
        var q = this.deltaQueue;
        if (!q) return;
        this.deltaQueue = null;
        if (q.length > 20 && q.length > this.$doc.getLength() >> 1) {
            this.call("setValue", [this.$doc.getValue()]);
        } else
            this.emit("change", {data: q});
    }

}).call(WorkerClient.prototype);


var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
    this.changeListener = this.changeListener.bind(this);
    this.callbackId = 1;
    this.callbacks = {};
    this.messageBuffer = [];

    var main = null;
    var sender = Object.create(EventEmitter);
    var _self = this;

    this.$worker = {};
    this.$worker.terminate = function() {};
    this.$worker.postMessage = function(e) {
        _self.messageBuffer.push(e);
        main && setTimeout(processNext);
    };

    var processNext = function() {
        var msg = _self.messageBuffer.shift();
        if (msg.command)
            main[msg.command].apply(main, msg.args);
        else if (msg.event)
            sender._emit(msg.event, msg.data);
    };

    sender.postMessage = function(msg) {
        _self.onMessage({data: msg});
    };
    sender.callback = function(data, callbackId) {
        this.postMessage({type: "call", id: callbackId, data: data});
    };
    sender.emit = function(name, data) {
        this.postMessage({type: "event", name: name, data: data});
    };

    config.loadModule(["worker", mod], function(Main) {
        main = new Main[classname](sender);
        while (_self.messageBuffer.length)
            processNext();
    });
};

UIWorkerClient.prototype = WorkerClient.prototype;

exports.UIWorkerClient = UIWorkerClient;
exports.WorkerClient = WorkerClient;

});
consoleAce.define('ace/placeholder', ['require', 'exports', 'module' , 'ace/range', 'ace/lib/event_emitter', 'ace/lib/oop'], function(require, exports, module) {


var Range = require("./range").Range;
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var oop = require("./lib/oop");

var PlaceHolder = function(session, length, pos, others, mainClass, othersClass) {
    var _self = this;
    this.length = length;
    this.session = session;
    this.doc = session.getDocument();
    this.mainClass = mainClass;
    this.othersClass = othersClass;
    this.$onUpdate = this.onUpdate.bind(this);
    this.doc.on("change", this.$onUpdate);
    this.$others = others;
    
    this.$onCursorChange = function() {
        setTimeout(function() {
            _self.onCursorChange();
        });
    };
    
    this.$pos = pos;
    var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || {length: -1};
    this.$undoStackDepth =  undoStack.length;
    this.setup();

    session.selection.on("changeCursor", this.$onCursorChange);
};

(function() {

    oop.implement(this, EventEmitter);
    this.setup = function() {
        var _self = this;
        var doc = this.doc;
        var session = this.session;
        var pos = this.$pos;

        this.pos = doc.createAnchor(pos.row, pos.column);
        this.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
        this.pos.on("change", function(event) {
            session.removeMarker(_self.markerId);
            _self.markerId = session.addMarker(new Range(event.value.row, event.value.column, event.value.row, event.value.column+_self.length), _self.mainClass, null, false);
        });
        this.others = [];
        this.$others.forEach(function(other) {
            var anchor = doc.createAnchor(other.row, other.column);
            _self.others.push(anchor);
        });
        session.setUndoSelect(false);
    };
    this.showOtherMarkers = function() {
        if(this.othersActive) return;
        var session = this.session;
        var _self = this;
        this.othersActive = true;
        this.others.forEach(function(anchor) {
            anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column+_self.length), _self.othersClass, null, false);
            anchor.on("change", function(event) {
                session.removeMarker(anchor.markerId);
                anchor.markerId = session.addMarker(new Range(event.value.row, event.value.column, event.value.row, event.value.column+_self.length), _self.othersClass, null, false);
            });
        });
    };
    this.hideOtherMarkers = function() {
        if(!this.othersActive) return;
        this.othersActive = false;
        for (var i = 0; i < this.others.length; i++) {
            this.session.removeMarker(this.others[i].markerId);
        }
    };
    this.onUpdate = function(event) {
        var delta = event.data;
        var range = delta.range;
        if(range.start.row !== range.end.row) return;
        if(range.start.row !== this.pos.row) return;
        if (this.$updating) return;
        this.$updating = true;
        var lengthDiff = delta.action === "insertText" ? range.end.column - range.start.column : range.start.column - range.end.column;
        
        if(range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1) {
            var distanceFromStart = range.start.column - this.pos.column;
            this.length += lengthDiff;
            if(!this.session.$fromUndo) {
                if(delta.action === "insertText") {
                    for (var i = this.others.length - 1; i >= 0; i--) {
                        var otherPos = this.others[i];
                        var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
                        if(otherPos.row === range.start.row && range.start.column < otherPos.column)
                            newPos.column += lengthDiff;
                        this.doc.insert(newPos, delta.text);
                    }
                } else if(delta.action === "removeText") {
                    for (var i = this.others.length - 1; i >= 0; i--) {
                        var otherPos = this.others[i];
                        var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
                        if(otherPos.row === range.start.row && range.start.column < otherPos.column)
                            newPos.column += lengthDiff;
                        this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
                    }
                }
                if(range.start.column === this.pos.column && delta.action === "insertText") {
                    setTimeout(function() {
                        this.pos.setPosition(this.pos.row, this.pos.column - lengthDiff);
                        for (var i = 0; i < this.others.length; i++) {
                            var other = this.others[i];
                            var newPos = {row: other.row, column: other.column - lengthDiff};
                            if(other.row === range.start.row && range.start.column < other.column)
                                newPos.column += lengthDiff;
                            other.setPosition(newPos.row, newPos.column);
                        }
                    }.bind(this), 0);
                }
                else if(range.start.column === this.pos.column && delta.action === "removeText") {
                    setTimeout(function() {
                        for (var i = 0; i < this.others.length; i++) {
                            var other = this.others[i];
                            if(other.row === range.start.row && range.start.column < other.column) {
                                other.setPosition(other.row, other.column - lengthDiff);
                            }
                        }
                    }.bind(this), 0);
                }
            }
            this.pos._emit("change", {value: this.pos});
            for (var i = 0; i < this.others.length; i++) {
                this.others[i]._emit("change", {value: this.others[i]});
            }
        }
        this.$updating = false;
    };

    this.onCursorChange = function(event) {
        if (this.$updating) return;
        var pos = this.session.selection.getCursor();
        if(pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
            this.showOtherMarkers();
            this._emit("cursorEnter", event);
        } else {
            this.hideOtherMarkers();
            this._emit("cursorLeave", event);
        }
    };    
    this.detach = function() {
        this.session.removeMarker(this.markerId);
        this.hideOtherMarkers();
        this.doc.removeEventListener("change", this.$onUpdate);
        this.session.selection.removeEventListener("changeCursor", this.$onCursorChange);
        this.pos.detach();
        for (var i = 0; i < this.others.length; i++) {
            this.others[i].detach();
        }
        this.session.setUndoSelect(true);
    };
    this.cancel = function() {
        if(this.$undoStackDepth === -1)
            throw Error("Canceling placeholders only supported with undo manager attached to session.");
        var undoManager = this.session.getUndoManager();
        var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
        for (var i = 0; i < undosRequired; i++) {
            undoManager.undo(true);
        }
    };
}).call(PlaceHolder.prototype);


exports.PlaceHolder = PlaceHolder;
});

consoleAce.define('ace/mode/folding/fold_mode', ['require', 'exports', 'module' , 'ace/range'], function(require, exports, module) {


var Range = require("../../range").Range;

var FoldMode = exports.FoldMode = function() {};

(function() {

    this.foldingStartMarker = null;
    this.foldingStopMarker = null;
    this.getFoldWidget = function(session, foldStyle, row) {
        var line = session.getLine(row);
        if (this.foldingStartMarker.test(line))
            return "start";
        if (foldStyle == "markbeginend"
                && this.foldingStopMarker
                && this.foldingStopMarker.test(line))
            return "end";
        return "";
    };

    this.getFoldWidgetRange = function(session, foldStyle, row) {
        return null;
    };

    this.indentationBlock = function(session, row, column) {
        var re = /\S/;
        var line = session.getLine(row);
        var startLevel = line.search(re);
        if (startLevel == -1)
            return;

        var startColumn = column || line.length;
        var maxRow = session.getLength();
        var startRow = row;
        var endRow = row;

        while (++row < maxRow) {
            var level = session.getLine(row).search(re);

            if (level == -1)
                continue;

            if (level <= startLevel)
                break;

            endRow = row;
        }

        if (endRow > startRow) {
            var endColumn = session.getLine(endRow).length;
            return new Range(startRow, startColumn, endRow, endColumn);
        }
    };

    this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
        var start = {row: row, column: column + 1};
        var end = session.$findClosingBracket(bracket, start, typeRe);
        if (!end)
            return;

        var fw = session.foldWidgets[end.row];
        if (fw == null)
            fw = session.getFoldWidget(end.row);

        if (fw == "start" && end.row > start.row) {
            end.row --;
            end.column = session.getLine(end.row).length;
        }
        return Range.fromPoints(start, end);
    };

    this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
        var end = {row: row, column: column};
        var start = session.$findOpeningBracket(bracket, end);

        if (!start)
            return;

        start.column++;
        end.column--;

        return  Range.fromPoints(start, end);
    };
}).call(FoldMode.prototype);

});

consoleAce.define('ace/theme/textmate', ['require', 'exports', 'module' , 'ace/lib/dom'], function(require, exports, module) {


exports.isDark = false;
exports.cssClass = "ace-tm";
exports.cssText = ".ace-tm .ace_gutter {\
background: #f0f0f0;\
color: #333;\
}\
.ace-tm .ace_print-margin {\
width: 1px;\
background: #e8e8e8;\
}\
.ace-tm .ace_fold {\
background-color: #6B72E6;\
}\
.ace-tm {\
background-color: #FFFFFF;\
}\
.ace-tm .ace_cursor {\
color: black;\
}\
.ace-tm .ace_invisible {\
color: rgb(191, 191, 191);\
}\
.ace-tm .ace_storage,\
.ace-tm .ace_keyword {\
color: blue;\
}\
.ace-tm .ace_constant {\
color: rgb(197, 6, 11);\
}\
.ace-tm .ace_constant.ace_buildin {\
color: rgb(88, 72, 246);\
}\
.ace-tm .ace_constant.ace_language {\
color: rgb(88, 92, 246);\
}\
.ace-tm .ace_constant.ace_library {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_invalid {\
background-color: rgba(255, 0, 0, 0.1);\
color: red;\
}\
.ace-tm .ace_support.ace_function {\
color: rgb(60, 76, 114);\
}\
.ace-tm .ace_support.ace_constant {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_support.ace_type,\
.ace-tm .ace_support.ace_class {\
color: rgb(109, 121, 222);\
}\
.ace-tm .ace_keyword.ace_operator {\
color: rgb(104, 118, 135);\
}\
.ace-tm .ace_string {\
color: rgb(3, 106, 7);\
}\
.ace-tm .ace_comment {\
color: rgb(76, 136, 107);\
}\
.ace-tm .ace_comment.ace_doc {\
color: rgb(0, 102, 255);\
}\
.ace-tm .ace_comment.ace_doc.ace_tag {\
color: rgb(128, 159, 191);\
}\
.ace-tm .ace_constant.ace_numeric {\
color: rgb(0, 0, 205);\
}\
.ace-tm .ace_variable {\
color: rgb(49, 132, 149);\
}\
.ace-tm .ace_xml-pe {\
color: rgb(104, 104, 91);\
}\
.ace-tm .ace_entity.ace_name.ace_function {\
color: #0000A2;\
}\
.ace-tm .ace_heading {\
color: rgb(12, 7, 255);\
}\
.ace-tm .ace_list {\
color:rgb(185, 6, 144);\
}\
.ace-tm .ace_meta.ace_tag {\
color:rgb(0, 22, 142);\
}\
.ace-tm .ace_string.ace_regex {\
color: rgb(255, 0, 0)\
}\
.ace-tm .ace_marker-layer .ace_selection {\
background: rgb(181, 213, 255);\
}\
.ace-tm.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px white;\
border-radius: 2px;\
}\
.ace-tm .ace_marker-layer .ace_step {\
background: rgb(252, 255, 0);\
}\
.ace-tm .ace_marker-layer .ace_stack {\
background: rgb(164, 229, 101);\
}\
.ace-tm .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid rgb(192, 192, 192);\
}\
.ace-tm .ace_marker-layer .ace_active-line {\
background: rgba(0, 0, 0, 0.07);\
}\
.ace-tm .ace_gutter-active-line {\
background-color : #dcdcdc;\
}\
.ace-tm .ace_marker-layer .ace_selected-word {\
background: rgb(250, 250, 255);\
border: 1px solid rgb(200, 200, 250);\
}\
.ace-tm .ace_indent-guide {\
background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\") right repeat-y;\
}\
";

var dom = require("../lib/dom");
dom.importCssString(exports.cssText, exports.cssClass);
});

consoleAce.define('ace/ext/error_marker', ['require', 'exports', 'module' , 'ace/line_widgets', 'ace/lib/dom', 'ace/range'], function(require, exports, module) {

var LineWidgets = require("ace/line_widgets").LineWidgets;
var dom = require("ace/lib/dom");
var Range = require("ace/range").Range;

function binarySearch(array, needle, comparator) {
    var first = 0;
    var last = array.length - 1;

    while (first <= last) {
        var mid = (first + last) >> 1;
        var c = comparator(needle, array[mid]);
        if (c > 0)
            first = mid + 1;
        else if (c < 0)
            last = mid - 1;
        else
            return mid;
    }
    return -(first + 1);
}

function findAnnotations(session, row, dir) {
    var annotations = session.getAnnotations().sort(Range.comparePoints);
    if (!annotations.length)
        return;
    
    var i = binarySearch(annotations, {row: row, column: -1}, Range.comparePoints);
    if (i < 0)
        i = -i - 1;
    
    if (i >= annotations.length - 1)
        i = dir > 0 ? 0 : annotations.length - 1;
    else if (i === 0 && dir < 0)
        i = annotations.length - 1;
    
    var annotation = annotations[i];
    if (!annotation || !dir)
        return;

    if (annotation.row === row) {
        do {
            annotation = annotations[i += dir];
        } while (annotation && annotation.row === row);
        if (!annotation)
            return annotations.slice();
    }
    
    
    var matched = [];
    row = annotation.row;
    do {
        matched[dir < 0 ? "unshift" : "push"](annotation);
        annotation = annotations[i += dir];
    } while (annotation && annotation.row == row);
    return matched.length && matched;
}

exports.showErrorMarker = function(editor, dir) {
    var session = editor.session;
    if (!session.widgetManager) {
        session.widgetManager = new LineWidgets(session);
        session.widgetManager.attach(editor);
    }
    
    var pos = editor.getCursorPosition();
    var row = pos.row;
    var oldWidget = session.lineWidgets && session.lineWidgets[row];
    if (oldWidget) {
        oldWidget.destroy();
    } else {
        row -= dir;
    }
    var annotations = findAnnotations(session, row, dir);
    var gutterAnno;
    if (annotations) {
        var annotation = annotations[0];
        if (annotation.pos && annotation.column == null)
            pos.column = annotation.pos.sc;
        pos.row = annotation.row;
        gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
    } else if (oldWidget) {
        return;
    } else {
        gutterAnno = {
            text: ["Looks good!"],
            className: "ace_ok"
        };
    }
    editor.session.unfold(pos.row);
    editor.selection.moveCursorToPosition(pos);
    editor.selection.clearSelection();
    
    var w = {
        row: pos.row, 
        fixedWidth: true,
        coverGutter: true,
        el: dom.createElement("div")
    };
    var el = w.el.appendChild(dom.createElement("div"));
    var arrow = w.el.appendChild(dom.createElement("div"));
    arrow.className = "error_widget_arrow " + gutterAnno.className;
    
    var left = editor.renderer.$cursorLayer
        .getPixelPosition(pos).left;
    arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";
    
    w.el.className = "error_widget_wrapper";
    el.className = "error_widget " + gutterAnno.className;
    el.innerHTML = gutterAnno.text.join("<br>");
    
    var kb = {
        handleKeyboard:function(_,hashId, keyString) {
            if (hashId === 0 && keyString === "esc") {
                w.destroy();
                return true;
            }
        }
    };
    
    w.destroy = function() {
        if (editor.$mouseHandler.isMousePressed)
            return;
        editor.keyBinding.removeKeyboardHandler(kb);
        session.widgetManager.removeLineWidget(w);
        editor.off("changeSelection", w.destroy);
        editor.off("changeSession", w.destroy);
        editor.off("mouseup", w.destroy);
        editor.off("change", w.destroy);
    };
    
    editor.keyBinding.addKeyboardHandler(kb);
    editor.on("changeSelection", w.destroy);
    editor.on("changeSession", w.destroy);
    editor.on("mouseup", w.destroy);
    editor.on("change", w.destroy);
    
    editor.session.widgetManager.addLineWidget(w);
    
    w.el.onmousedown = editor.focus.bind(editor);
};


dom.importCssString("\
    .error_widget_wrapper {\
        background: inherit;\
        color: inherit;\
        border:none\
    }\
    .error_widget {\
        border-top: solid 2px;\
        border-bottom: solid 2px;\
        margin: 5px 0;\
        padding: 10px 40px;\
        white-space: pre-wrap;\
    }\
    .error_widget.ace_error, .error_widget_arrow.ace_error{\
        border-color: #ff5a5a\
    }\
    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\
        border-color: #F1D817\
    }\
    .error_widget.ace_info, .error_widget_arrow.ace_info{\
        border-color: #5a5a5a\
    }\
    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\
        border-color: #5aaa5a\
    }\
    .error_widget_arrow {\
        position: absolute;\
        border: solid 5px;\
        border-top-color: transparent!important;\
        border-right-color: transparent!important;\
        border-left-color: transparent!important;\
        top: -5px;\
    }\
", "");

});

consoleAce.define('ace/line_widgets', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/lib/dom', 'ace/range'], function(require, exports, module) {


var oop = require("./lib/oop");
var dom = require("./lib/dom");
var Range = require("./range").Range;


function LineWidgets(session) {
    this.session = session;
    this.session.widgetManager = this;
    this.session.getRowLength = this.getRowLength;
    this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
    this.updateOnChange = this.updateOnChange.bind(this);
    this.renderWidgets = this.renderWidgets.bind(this);
    this.measureWidgets = this.measureWidgets.bind(this);
    this.session._changedWidgets = [];
    this.detach = this.detach.bind(this);
    
    this.session.on("change", this.updateOnChange);
}

(function() {
    this.getRowLength = function(row) {
        var h;
        if (this.lineWidgets)
            h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
        else 
            h = 0;
        if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1 + h;
        } else {
            return this.$wrapData[row].length + 1 + h;
        }
    };

    this.$getWidgetScreenLength = function() {
        var screenRows = 0;
        this.lineWidgets.forEach(function(w){
            if (w && w.rowCount)
                screenRows +=w.rowCount;
        });
        return screenRows;
    };    
    
    this.attach = function(editor) {
        if (editor.widgetManager && editor.widgetManager != this)
            editor.widgetManager.detach();

        if (this.editor == editor)
            return;

        this.detach();
        this.editor = editor;
        
        this.editor.on("changeSession", this.detach);
        
        editor.widgetManager = this;

        editor.setOption("enableLineWidgets", true);
        editor.renderer.on("beforeRender", this.measureWidgets);
        editor.renderer.on("afterRender", this.renderWidgets);
    };
    this.detach = function(e) {
        if (e && e.session == this.session)
            return; // sometimes attach can be called before setSession
        var editor = this.editor;
        if (!editor)
            return;

        editor.off("changeSession", this.detach);
        
        this.editor = null;
        editor.widgetManager = null;
        
        editor.renderer.off("beforeRender", this.measureWidgets);
        editor.renderer.off("afterRender", this.renderWidgets);
        var lineWidgets = this.session.lineWidgets;
        lineWidgets && lineWidgets.forEach(function(w) {
            if (w && w.el && w.el.parentNode) {
                w._inDocument = false;
                w.el.parentNode.removeChild(w.el);
            }
        });
    };

    this.updateOnChange = function(e) {
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets) return;
            
        var delta = e.data;
        var range = delta.range;
        var startRow = range.start.row;
        var len = range.end.row - startRow;

        if (len === 0) {
        } else if (delta.action == "removeText" || delta.action == "removeLines") {
            var removed = lineWidgets.splice(startRow + 1, len);
            removed.forEach(function(w) {
                w && this.removeLineWidget(w);
            }, this);
            this.$updateRows();
        } else {
            var args = new Array(len);
            args.unshift(startRow, 0);
            lineWidgets.splice.apply(lineWidgets, args);
            this.$updateRows();
        }
    };
    
    this.$updateRows = function() {
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets) return;
        var noWidgets = true;
        lineWidgets.forEach(function(w, i) {
            if (w) {
                noWidgets = false;
                w.row = i;
            }
        });
        if (noWidgets)
            this.session.lineWidgets = null;
    };

    this.addLineWidget = function(w) {
        if (!this.session.lineWidgets)
            this.session.lineWidgets = new Array(this.session.getLength());
        
        this.session.lineWidgets[w.row] = w;
        
        var renderer = this.editor.renderer;
        if (w.html && !w.el) {
            w.el = dom.createElement("div");
            w.el.innerHTML = w.html;
        }
        if (w.el) {
            dom.addCssClass(w.el, "ace_lineWidgetContainer");
            w.el.style.position = "absolute";
            w.el.style.zIndex = 5;
            renderer.container.appendChild(w.el);
            w._inDocument = true;
        }
        
        if (!w.coverGutter) {
            w.el.style.zIndex = 3;
        }
        if (!w.pixelHeight) {
            w.pixelHeight = w.el.offsetHeight;
        }
        if (w.rowCount == null)
            w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
        
        this.session._emit("changeFold", {data:{start:{row: w.row}}});
        
        this.$updateRows();
        this.renderWidgets(null, renderer);
        return w;
    };
    
    this.removeLineWidget = function(w) {
        w._inDocument = false;
        if (w.el && w.el.parentNode)
            w.el.parentNode.removeChild(w.el);
        if (w.editor && w.editor.destroy) try {
            w.editor.destroy();
        } catch(e){}
        if (this.session.lineWidgets)
            this.session.lineWidgets[w.row] = undefined;
        this.session._emit("changeFold", {data:{start:{row: w.row}}});
        this.$updateRows();
    };
    
    this.onWidgetChanged = function(w) {
        this.session._changedWidgets.push(w);
        this.editor && this.editor.renderer.updateFull();
    };
    
    this.measureWidgets = function(e, renderer) {
        var changedWidgets = this.session._changedWidgets;
        var config = renderer.layerConfig;
        
        if (!changedWidgets || !changedWidgets.length) return;
        var min = Infinity;
        for (var i = 0; i < changedWidgets.length; i++) {
            var w = changedWidgets[i];
            if (!w._inDocument) {
                w._inDocument = true;
                renderer.container.appendChild(w.el);
            }
            
            w.h = w.el.offsetHeight;
            
            if (!w.fixedWidth) {
                w.w = w.el.offsetWidth;
                w.screenWidth = Math.ceil(w.w / config.characterWidth);
            }
            
            var rowCount = w.h / config.lineHeight;
            if (w.coverLine) {
                rowCount -= this.session.getRowLineCount(w.row);
                if (rowCount < 0)
                    rowCount = 0;
            }
            if (w.rowCount != rowCount) {
                w.rowCount = rowCount;
                if (w.row < min)
                    min = w.row;
            }
        }
        if (min != Infinity) {
            this.session._emit("changeFold", {data:{start:{row: min}}});
            this.session.lineWidgetWidth = null;
        }
        this.session._changedWidgets = [];
    };
    
    this.renderWidgets = function(e, renderer) {
        var config = renderer.layerConfig;
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets)
            return;
        var first = Math.min(this.firstRow, config.firstRow);
        var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
        
        while (first > 0 && !lineWidgets[first])
            first--;
        
        this.firstRow = config.firstRow;
        this.lastRow = config.lastRow;

        renderer.$cursorLayer.config = config;
        for (var i = first; i <= last; i++) {
            var w = lineWidgets[i];
            if (!w || !w.el) continue;

            if (!w._inDocument) {
                w._inDocument = true;
                renderer.container.appendChild(w.el);
            }
            var top = renderer.$cursorLayer.getPixelPosition({row: i, column:0}, true).top;
            if (!w.coverLine)
                top += config.lineHeight * this.session.getRowLineCount(w.row);
            w.el.style.top = top - config.offset + "px";
            
            var left = w.coverGutter ? 0 : renderer.gutterWidth;
            if (!w.fixedWidth)
                left -= renderer.scrollLeft;
            w.el.style.left = left + "px";

            if (w.fixedWidth) {
                w.el.style.right = renderer.scrollBar.getWidth() + "px";
            } else {
                w.el.style.right = "";
            }
        }
    };
    
}).call(LineWidgets.prototype);


exports.LineWidgets = LineWidgets;

});


    

;
            (function() {
                consoleAce.require(["ace/ace"], function(a) {
                    a && a.config.init();
                    if (!window.consoleAce)
                        window.consoleAce = {};
                    for (var key in a) if (a.hasOwnProperty(key))
                        consoleAce[key] = a[key];
                });
            })();


/***/ }),
/* 3146 */,
/* 3147 */,
/* 3148 */,
/* 3149 */,
/* 3150 */,
/* 3151 */,
/* 3152 */,
/* 3153 */,
/* 3154 */,
/* 3155 */,
/* 3156 */,
/* 3157 */,
/* 3158 */
/***/ (function(module, exports) {

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

consoleAce.define('ace/ext/searchbox', ['require', 'exports', 'module' , 'ace/lib/dom', 'ace/lib/lang', 'ace/lib/event', 'ace/keyboard/hash_handler', 'ace/lib/keys'], function(require, exports, module) {


var dom = require("../lib/dom");
var lang = require("../lib/lang");
var event = require("../lib/event");
var searchboxCss = "\
/* ------------------------------------------------------------------------------------------\
* Editor Search Form\
* --------------------------------------------------------------------------------------- */\
.ace_search {\
background-color: #ddd;\
border: 1px solid #cbcbcb;\
border-top: 0 none;\
max-width: 297px;\
overflow: hidden;\
margin: 0;\
padding: 4px;\
padding-right: 6px;\
padding-bottom: 0;\
position: absolute;\
top: 0px;\
z-index: 99;\
white-space: normal;\
}\
.ace_search.left {\
border-left: 0 none;\
border-radius: 0px 0px 5px 0px;\
left: 0;\
}\
.ace_search.right {\
border-radius: 0px 0px 0px 5px;\
border-right: 0 none;\
right: 0;\
}\
.ace_search_form, .ace_replace_form {\
border-radius: 3px;\
border: 1px solid #cbcbcb;\
float: left;\
margin-bottom: 4px;\
overflow: hidden;\
}\
.ace_search_form.ace_nomatch {\
outline: 1px solid red;\
}\
.ace_search_field {\
background-color: white;\
border-right: 1px solid #cbcbcb;\
border: 0 none;\
-webkit-box-sizing: border-box;\
-moz-box-sizing: border-box;\
box-sizing: border-box;\
display: block;\
float: left;\
height: 22px;\
outline: 0;\
padding: 0 7px;\
width: 214px;\
margin: 0;\
}\
.ace_searchbtn,\
.ace_replacebtn {\
background: #fff;\
border: 0 none;\
border-left: 1px solid #dcdcdc;\
cursor: pointer;\
display: block;\
float: left;\
height: 22px;\
margin: 0;\
padding: 0;\
position: relative;\
}\
.ace_searchbtn:last-child,\
.ace_replacebtn:last-child {\
border-top-right-radius: 3px;\
border-bottom-right-radius: 3px;\
}\
.ace_searchbtn:disabled {\
background: none;\
cursor: default;\
}\
.ace_searchbtn {\
background-position: 50% 50%;\
background-repeat: no-repeat;\
width: 27px;\
}\
.ace_searchbtn.prev {\
background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAYAAAB4ka1VAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAADFJREFUeNpiSU1NZUAC/6E0I0yACYskCpsJiySKIiY0SUZk40FyTEgCjGgKwTRAgAEAQJUIPCE+qfkAAAAASUVORK5CYII=);    \
}\
.ace_searchbtn.next {\
background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAYAAAB4ka1VAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAADRJREFUeNpiTE1NZQCC/0DMyIAKwGJMUAYDEo3M/s+EpvM/mkKwCQxYjIeLMaELoLMBAgwAU7UJObTKsvAAAAAASUVORK5CYII=);    \
}\
.ace_searchbtn_close {\
background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAcCAYAAABRVo5BAAAAZ0lEQVR42u2SUQrAMAhDvazn8OjZBilCkYVVxiis8H4CT0VrAJb4WHT3C5xU2a2IQZXJjiQIRMdkEoJ5Q2yMqpfDIo+XY4k6h+YXOyKqTIj5REaxloNAd0xiKmAtsTHqW8sR2W5f7gCu5nWFUpVjZwAAAABJRU5ErkJggg==) no-repeat 50% 0;\
border-radius: 50%;\
border: 0 none;\
color: #656565;\
cursor: pointer;\
display: block;\
float: right;\
font-family: Arial;\
font-size: 16px;\
height: 14px;\
line-height: 16px;\
margin: 5px 1px 9px 5px;\
padding: 0;\
text-align: center;\
width: 14px;\
}\
.ace_searchbtn_close:hover {\
background-color: #656565;\
background-position: 50% 100%;\
color: white;\
}\
.ace_replacebtn.prev {\
width: 54px\
}\
.ace_replacebtn.next {\
width: 27px\
}\
.ace_button {\
margin-left: 2px;\
cursor: pointer;\
-webkit-user-select: none;\
-moz-user-select: none;\
-o-user-select: none;\
-ms-user-select: none;\
user-select: none;\
overflow: hidden;\
opacity: 0.7;\
border: 1px solid rgba(100,100,100,0.23);\
padding: 1px;\
-moz-box-sizing: border-box;\
box-sizing:    border-box;\
color: black;\
}\
.ace_button:hover {\
background-color: #eee;\
opacity:1;\
}\
.ace_button:active {\
background-color: #ddd;\
}\
.ace_button.checked {\
border-color: #3399ff;\
opacity:1;\
}\
.ace_search_options{\
margin-bottom: 3px;\
text-align: right;\
-webkit-user-select: none;\
-moz-user-select: none;\
-o-user-select: none;\
-ms-user-select: none;\
user-select: none;\
}";
var HashHandler = require("../keyboard/hash_handler").HashHandler;
var keyUtil = require("../lib/keys");

dom.importCssString(searchboxCss, "ace_searchbox");

var html = '<div class="ace_search right">\
    <button type="button" action="hide" class="ace_searchbtn_close"></button>\
    <div class="ace_search_form">\
        <input class="ace_search_field" placeholder="Search for" spellcheck="false"></input>\
        <button type="button" action="findNext" class="ace_searchbtn next"></button>\
        <button type="button" action="findPrev" class="ace_searchbtn prev"></button>\
    </div>\
    <div class="ace_replace_form">\
        <input class="ace_search_field" placeholder="Replace with" spellcheck="false"></input>\
        <button type="button" action="replaceAndFindNext" class="ace_replacebtn">Replace</button>\
        <button type="button" action="replaceAll" class="ace_replacebtn">All</button>\
    </div>\
    <div class="ace_search_options">\
        <span action="toggleRegexpMode" class="ace_button" title="RegExp Search">.*</span>\
        <span action="toggleCaseSensitive" class="ace_button" title="CaseSensitive Search">Aa</span>\
        <span action="toggleWholeWords" class="ace_button" title="Whole Word Search">\\b</span>\
    </div>\
</div>'.replace(/>\s+/g, ">");

var SearchBox = function(editor, range, showReplaceForm) {
    var div = dom.createElement("div");
    div.innerHTML = html;
    this.element = div.firstChild;

    this.$init();
    this.setEditor(editor);
};

(function() {
    this.setEditor = function(editor) {
        editor.searchBox = this;
        editor.container.appendChild(this.element);
        this.editor = editor;
    };

    this.$initElements = function(sb) {
        this.searchBox = sb.querySelector(".ace_search_form");
        this.replaceBox = sb.querySelector(".ace_replace_form");
        this.searchOptions = sb.querySelector(".ace_search_options");
        this.regExpOption = sb.querySelector("[action=toggleRegexpMode]");
        this.caseSensitiveOption = sb.querySelector("[action=toggleCaseSensitive]");
        this.wholeWordOption = sb.querySelector("[action=toggleWholeWords]");
        this.searchInput = this.searchBox.querySelector(".ace_search_field");
        this.replaceInput = this.replaceBox.querySelector(".ace_search_field");
    };
    
    this.$init = function() {
        var sb = this.element;
        
        this.$initElements(sb);
        
        var _this = this;
        event.addListener(sb, "mousedown", function(e) {
            setTimeout(function(){
                _this.activeInput.focus();
            }, 0);
            event.stopPropagation(e);
        });
        event.addListener(sb, "click", function(e) {
            var t = e.target || e.srcElement;
            var action = t.getAttribute("action");
            if (action && _this[action])
                _this[action]();
            else if (_this.$searchBarKb.commands[action])
                _this.$searchBarKb.commands[action].exec(_this);
            event.stopPropagation(e);
        });

        event.addCommandKeyListener(sb, function(e, hashId, keyCode) {
            var keyString = keyUtil.keyCodeToString(keyCode);
            var command = _this.$searchBarKb.findKeyCommand(hashId, keyString);
            if (command && command.exec) {
                command.exec(_this);
                event.stopEvent(e);
            }
        });

        this.$onChange = lang.delayedCall(function() {
            _this.find(false, false);
        });

        event.addListener(this.searchInput, "input", function() {
            _this.$onChange.schedule(20);
        });
        event.addListener(this.searchInput, "focus", function() {
            _this.activeInput = _this.searchInput;
            _this.searchInput.value && _this.highlight();
        });
        event.addListener(this.replaceInput, "focus", function() {
            _this.activeInput = _this.replaceInput;
            _this.searchInput.value && _this.highlight();
        });
    };
    this.$closeSearchBarKb = new HashHandler([{
        bindKey: "Esc",
        name: "closeSearchBar",
        exec: function(editor) {
            editor.searchBox.hide();
        }
    }]);
    this.$searchBarKb = new HashHandler();
    this.$searchBarKb.bindKeys({
        "Ctrl-f|Command-f|Ctrl-H|Command-Option-F": function(sb) {
            var isReplace = sb.isReplace = !sb.isReplace;
            sb.replaceBox.style.display = isReplace ? "" : "none";
            sb[isReplace ? "replaceInput" : "searchInput"].focus();
        },
        "Ctrl-G|Command-G": function(sb) {
            sb.findNext();
        },
        "Ctrl-Shift-G|Command-Shift-G": function(sb) {
            sb.findPrev();
        },
        "esc": function(sb) {
            setTimeout(function() { sb.hide();});
        },
        "Return": function(sb) {
            if (sb.activeInput == sb.replaceInput)
                sb.replace();
            sb.findNext();
        },
        "Shift-Return": function(sb) {
            if (sb.activeInput == sb.replaceInput)
                sb.replace();
            sb.findPrev();
        },
        "Tab": function(sb) {
            (sb.activeInput == sb.replaceInput ? sb.searchInput : sb.replaceInput).focus();
        }
    });

    this.$searchBarKb.addCommands([{
        name: "toggleRegexpMode",
        bindKey: {win: "Alt-R|Alt-/", mac: "Ctrl-Alt-R|Ctrl-Alt-/"},
        exec: function(sb) {
            sb.regExpOption.checked = !sb.regExpOption.checked;
            sb.$syncOptions();
        }
    }, {
        name: "toggleCaseSensitive",
        bindKey: {win: "Alt-C|Alt-I", mac: "Ctrl-Alt-R|Ctrl-Alt-I"},
        exec: function(sb) {
            sb.caseSensitiveOption.checked = !sb.caseSensitiveOption.checked;
            sb.$syncOptions();
        }
    }, {
        name: "toggleWholeWords",
        bindKey: {win: "Alt-B|Alt-W", mac: "Ctrl-Alt-B|Ctrl-Alt-W"},
        exec: function(sb) {
            sb.wholeWordOption.checked = !sb.wholeWordOption.checked;
            sb.$syncOptions();
        }
    }]);

    this.$syncOptions = function() {
        dom.setCssClass(this.regExpOption, "checked", this.regExpOption.checked);
        dom.setCssClass(this.wholeWordOption, "checked", this.wholeWordOption.checked);
        dom.setCssClass(this.caseSensitiveOption, "checked", this.caseSensitiveOption.checked);
        this.find(false, false);
    };

    this.highlight = function(re) {
        this.editor.session.highlight(re || this.editor.$search.$options.re);
        this.editor.renderer.updateBackMarkers()
    };
    this.find = function(skipCurrent, backwards) {
        var range = this.editor.find(this.searchInput.value, {
            skipCurrent: skipCurrent,
            backwards: backwards,
            wrap: true,
            regExp: this.regExpOption.checked,
            caseSensitive: this.caseSensitiveOption.checked,
            wholeWord: this.wholeWordOption.checked
        });
        var noMatch = !range && this.searchInput.value;
        dom.setCssClass(this.searchBox, "ace_nomatch", noMatch);
        this.editor._emit("findSearchBox", { match: !noMatch });
        this.highlight();
    };
    this.findNext = function() {
        this.find(true, false);
    };
    this.findPrev = function() {
        this.find(true, true);
    };
    this.replace = function() {
        if (!this.editor.getReadOnly())
            this.editor.replace(this.replaceInput.value);
    };    
    this.replaceAndFindNext = function() {
        if (!this.editor.getReadOnly()) {
            this.editor.replace(this.replaceInput.value);
            this.findNext()
        }
    };
    this.replaceAll = function() {
        if (!this.editor.getReadOnly())
            this.editor.replaceAll(this.replaceInput.value);
    };

    this.hide = function() {
        this.element.style.display = "none";
        this.editor.keyBinding.removeKeyboardHandler(this.$closeSearchBarKb);
        this.editor.focus();
    };
    this.show = function(value, isReplace) {
        this.element.style.display = "";
        this.replaceBox.style.display = isReplace ? "" : "none";

        this.isReplace = isReplace;

        if (value)
            this.searchInput.value = value;
        this.searchInput.focus();
        this.searchInput.select();

        this.editor.keyBinding.addKeyboardHandler(this.$closeSearchBarKb);
    };

}).call(SearchBox.prototype);

exports.SearchBox = SearchBox;

exports.Search = function(editor, isReplace) {
    var sb = editor.searchBox || new SearchBox(editor);
    sb.show(editor.session.getTextRange(), isReplace);
};

});


/***/ }),
/* 3159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = function (editor) {

  function isSeparatorToken(token) {
    switch ((token || {}).type) {
      case "url.slash":
      case "url.comma":
      case "url.questionmark":
      case "paren.lparen":
      case "paren.rparen":
      case "punctuation.colon":
      case "punctuation.comma":
      case "whitespace":
        return true;
      default:
        // standing on white space, quotes or another punctuation - no replacing
        return false;
    }
  }

  function isUrlPathToken(token) {
    switch ((token || {}).type) {
      case "url.slash":
      case "url.comma":
      case "url.part":
        return true;
      default:
        return false;
    }
  }

  function isUrlParamsToken(token) {
    switch ((token || {}).type) {
      case "url.param":
      case "url.equal":
      case "url.value":
      case "url.questionmark":
      case "url.amp":
        return true;
      default:
        return false;
    }
  }

  function getAutoCompleteValueFromToken(token) {
    switch ((token || {}).type) {
      case "variable":
      case "string":
      case "text":
      case "constant.numeric":
      case "constant.language.boolean":
        return token.value.replace(/"/g, '');
      case "method":
      case "url.part":
        return token.value;
      default:
        // standing on white space, quotes or another punctuation - no replacing
        return "";
    }
  }

  function addMetaToTermsList(list, meta, template) {
    return _lodash2.default.map(list, function (t) {
      if ((typeof t === 'undefined' ? 'undefined' : _typeof(t)) !== "object") {
        t = { name: t };
      }
      return _lodash2.default.defaults(t, { meta: meta, template: template });
    });
  }

  function applyTerm(term) {
    var session = editor.getSession();

    var context = term.context;

    // make sure we get up to date replacement info.
    addReplacementInfoToContext(context, editor.getCursorPosition(), term.insert_value);

    var termAsString;
    if (context.autoCompleteType == "body") {
      termAsString = typeof term.insert_value == "string" ? '"' + term.insert_value + '"' : term.insert_value + "";
      if (term.insert_value === "[" || term.insert_value === "{") {
        termAsString = "";
      }
    } else {
      termAsString = term.insert_value + "";
    }

    var valueToInsert = termAsString;
    var templateInserted = false;
    if (context.addTemplate && !_lodash2.default.isUndefined(term.template) && !_lodash2.default.isNull(term.template)) {
      var indentedTemplateLines = _utils2.default.jsonToString(term.template, true).split("\n");
      var currentIndentation = session.getLine(context.rangeToReplace.start.row);
      currentIndentation = currentIndentation.match(/^\s*/)[0];
      for (var i = 1; i < indentedTemplateLines.length; i++) {
        // skip first line
        indentedTemplateLines[i] = currentIndentation + indentedTemplateLines[i];
      }valueToInsert += ": " + indentedTemplateLines.join("\n");
      templateInserted = true;
    } else {
      templateInserted = true;
      if (term.value === "[") {
        valueToInsert += "[]";
      } else if (term.value == "{") {
        valueToInsert += "{}";
      } else {
        templateInserted = false;
      }
    }

    valueToInsert = context.prefixToAdd + valueToInsert + context.suffixToAdd;

    // disable listening to the changes we are making.
    removeChangeListener();

    if (context.rangeToReplace.start.column != context.rangeToReplace.end.column) {
      session.replace(context.rangeToReplace, valueToInsert);
    } else {
      editor.insert(valueToInsert);
    }

    editor.clearSelection(); // for some reason the above changes selection

    // go back to see whether we have one of ( : { & [ do not require a comma. All the rest do.
    var newPos = {
      row: context.rangeToReplace.start.row,
      column: context.rangeToReplace.start.column + termAsString.length + context.prefixToAdd.length + (templateInserted ? 0 : context.suffixToAdd.length)
    };

    var tokenIter = editor.iterForPosition(newPos.row, newPos.column);

    if (context.autoCompleteType === "body") {
      // look for the next place stand, just after a comma, {
      var nonEmptyToken = editor.parser.nextNonEmptyToken(tokenIter);
      switch (nonEmptyToken ? nonEmptyToken.type : "NOTOKEN") {
        case "paren.rparen":
          newPos = { row: tokenIter.getCurrentTokenRow(), column: tokenIter.getCurrentTokenColumn() };
          break;
        case "punctuation.colon":
          nonEmptyToken = editor.parser.nextNonEmptyToken(tokenIter);
          if ((nonEmptyToken || {}).type == "paren.lparen") {
            nonEmptyToken = editor.parser.nextNonEmptyToken(tokenIter);
            newPos = { row: tokenIter.getCurrentTokenRow(), column: tokenIter.getCurrentTokenColumn() };
            if (nonEmptyToken && nonEmptyToken.value.indexOf('"') === 0) {
              newPos.column++;
            } // don't stand on "
          }
          break;
        case "paren.lparen":
        case "punctuation.comma":
          tokenIter.stepForward();
          newPos = { row: tokenIter.getCurrentTokenRow(), column: tokenIter.getCurrentTokenColumn() };
          break;
      }
      editor.moveCursorToPosition(newPos);
    }

    // re-enable listening to typing
    addChangeListener();
  }

  function getAutoCompleteContext(editor, session, pos) {
    // deduces all the parameters need to position and insert the auto complete
    var context = {
      autoCompleteSet: null, // instructions for what can be here
      endpoint: null,
      urlPath: null,
      method: null,
      activeScheme: null,
      editor: editor
    };

    //  context.updatedForToken = session.getTokenAt(pos.row, pos.column);
    //
    //  if (!context.updatedForToken)
    //    context.updatedForToken = { value: "", start: pos.column }; // empty line
    //
    //  context.updatedForToken.row = pos.row; // extend

    context.autoCompleteType = getAutoCompleteType(pos);
    switch (context.autoCompleteType) {
      case "path":
        addPathAutoCompleteSetToContext(context, pos);
        break;
      case "url_params":
        addUrlParamsAutoCompleteSetToContext(context, pos);
        break;
      case "method":
        addMethodAutoCompleteSetToContext(context, pos);
        break;
      case "body":
        addBodyAutoCompleteSetToContext(context, pos);
        break;
      default:
        return null;
    }

    if (!context.autoCompleteSet) {
      return null; // nothing to do..
    }

    addReplacementInfoToContext(context, pos);

    context.createdWithToken = _lodash2.default.clone(context.updatedForToken);

    return context;
  }

  function getAutoCompleteType(pos) {
    // return "method", "path" or "body" to determine auto complete type.

    var rowMode = editor.parser.getRowParseMode(pos.row);

    //noinspection JSBitwiseOperatorUsage
    if (rowMode & editor.parser.MODE.IN_REQUEST) {
      return "body";
    }
    //noinspection JSBitwiseOperatorUsage
    if (rowMode & editor.parser.MODE.REQUEST_START) {
      // on url path, url params or method.
      var tokenIter = editor.iterForPosition(pos.row, pos.column);
      var t = tokenIter.getCurrentToken();

      while (t.type == "url.comma") {
        t = tokenIter.stepBackward();
      }
      switch (t.type) {
        case "method":
          return "method";
        case "whitespace":
          t = editor.parser.prevNonEmptyToken(tokenIter);

          switch ((t || {}).type) {
            case "method":
              // we moved one back
              return "path";
              break;
            default:
              if (isUrlPathToken(t)) {
                return "path";
              }
              if (isUrlParamsToken(t)) {
                return "url_params";
              }
              return null;
          }
          break;
        default:
          if (isUrlPathToken(t)) {
            return "path";
          }
          if (isUrlParamsToken(t)) {
            return "url_params";
          }
          return null;
      }
    }

    // after start to avoid single line url only requests
    //noinspection JSBitwiseOperatorUsage
    if (rowMode & editor.parser.MODE.REQUEST_END) {
      return "body";
    }

    // in between request on an empty
    if ((editor.getSession().getLine(pos.row) || "").trim() === "") {
      // check if the previous line is a single line begging of a new request
      rowMode = editor.parser.getRowParseMode(pos.row - 1);
      //noinspection JSBitwiseOperatorUsage
      if (rowMode & editor.parser.MODE.REQUEST_START && rowMode & editor.parser.MODE.REQUEST_END) {
        return "body";
      }
      //o.w suggest a method
      return "method";
    }

    return null;
  }

  function addReplacementInfoToContext(context, pos, replacingTerm) {
    // extract the initial value, rangeToReplace & textBoxPosition

    // Scenarios for current token:
    //   -  Nice token { "bla|"
    //   -  Broken text token {   bla|
    //   -  No token : { |
    //   - Broken scenario { , bla|
    //   - Nice token, broken before: {, "bla"

    var session = editor.getSession();

    context.updatedForToken = _lodash2.default.clone(session.getTokenAt(pos.row, pos.column));
    if (!context.updatedForToken) {
      context.updatedForToken = { value: "", start: pos.column };
    } // empty line

    var anchorToken = context.createdWithToken;
    if (!anchorToken) {
      anchorToken = context.updatedForToken;
    }

    switch (context.updatedForToken.type) {
      case "variable":
      case "string":
      case "text":
      case "constant.numeric":
      case "constant.language.boolean":
      case "method":
      case "url.index":
      case "url.type":
      case "url.id":
      case "url.method":
      case "url.endpoint":
      case "url.part":
      case "url.param":
      case "url.value":
        context.rangeToReplace = new AceRange(pos.row, anchorToken.start, pos.row, context.updatedForToken.start + context.updatedForToken.value.length);
        context.replacingToken = true;
        break;
      default:
        if (replacingTerm && context.updatedForToken.value == replacingTerm) {
          context.rangeToReplace = new AceRange(pos.row, anchorToken.start, pos.row, context.updatedForToken.start + context.updatedForToken.value.length);
          context.replacingToken = true;
        } else {
          // standing on white space, quotes or another punctuation - no replacing
          context.rangeToReplace = new AceRange(pos.row, pos.column, pos.row, pos.column);
          context.replacingToken = false;
        }
        break;
    }

    context.textBoxPosition = { row: context.rangeToReplace.start.row, column: context.rangeToReplace.start.column };

    switch (context.autoCompleteType) {
      case "path":
        addPathPrefixSuffixToContext(context);
        break;
      case "url_params":
        addUrlParamsPrefixSuffixToContext(context);
        break;
      case "method":
        addMethodPrefixSuffixToContext(context);
        break;
      case "body":
        addBodyPrefixSuffixToContext(context);
        break;
    }
  }

  function addBodyPrefixSuffixToContext(context) {
    // Figure out what happens next to the token to see whether it needs trailing commas etc.

    // Templates will be used if not destroying existing structure.
    // -> token : {} or token ]/} or token , but not token : SOMETHING ELSE

    context.prefixToAdd = "";
    context.suffixToAdd = "";

    var tokenIter = editor.iterForCurrentLoc();
    var nonEmptyToken = editor.parser.nextNonEmptyToken(tokenIter);
    switch (nonEmptyToken ? nonEmptyToken.type : "NOTOKEN") {
      case "NOTOKEN":
      case "paren.lparen":
      case "paren.rparen":
      case "punctuation.comma":
        context.addTemplate = true;
        break;
      case "punctuation.colon":
        // test if there is an empty object - if so we replace it
        context.addTemplate = false;

        nonEmptyToken = editor.parser.nextNonEmptyToken(tokenIter);
        if (!(nonEmptyToken && nonEmptyToken.value == "{")) {
          break;
        }
        nonEmptyToken = editor.parser.nextNonEmptyToken(tokenIter);
        if (!(nonEmptyToken && nonEmptyToken.value == "}")) {
          break;
        }
        context.addTemplate = true;
        // extend range to replace to include all up to token
        context.rangeToReplace.end.row = tokenIter.getCurrentTokenRow();
        context.rangeToReplace.end.column = tokenIter.getCurrentTokenColumn() + nonEmptyToken.value.length;

        // move one more time to check if we need a trailing comma
        nonEmptyToken = editor.parser.nextNonEmptyToken(tokenIter);
        switch (nonEmptyToken ? nonEmptyToken.type : "NOTOKEN") {
          case "NOTOKEN":
          case "paren.rparen":
          case "punctuation.comma":
          case "punctuation.colon":
            break;
          default:
            context.suffixToAdd = ", ";
        }

        break;
      default:
        context.addTemplate = true;
        context.suffixToAdd = ", ";
        break; // for now play safe and do nothing. May be made smarter.
    }

    // go back to see whether we have one of ( : { & [ do not require a comma. All the rest do.
    tokenIter = editor.iterForCurrentLoc();
    nonEmptyToken = tokenIter.getCurrentToken();
    var insertingRelativeToToken; // -1 is before token, 0 middle, +1 after token
    if (context.replacingToken) {
      insertingRelativeToToken = 0;
    } else {
      var pos = editor.getCursorPosition();
      if (pos.column == context.updatedForToken.start) {
        insertingRelativeToToken = -1;
      } else if (pos.column < context.updatedForToken.start + context.updatedForToken.value.length) {
        insertingRelativeToToken = 0;
      } else {
        insertingRelativeToToken = 1;
      }
    }
    // we should actually look at what's happening before this token
    if (editor.parser.isEmptyToken(nonEmptyToken) || insertingRelativeToToken <= 0) {
      nonEmptyToken = editor.parser.prevNonEmptyToken(tokenIter);
    }

    switch (nonEmptyToken ? nonEmptyToken.type : "NOTOKEN") {
      case "NOTOKEN":
      case "paren.lparen":
      case "punctuation.comma":
      case "punctuation.colon":
      case "method":
        break;
      default:
        if (nonEmptyToken && nonEmptyToken.type.indexOf("url") < 0) {
          context.prefixToAdd = ", ";
        }
    }

    return context;
  }

  function addUrlParamsPrefixSuffixToContext(context) {
    context.prefixToAdd = "";
    context.suffixToAdd = "";
  }

  function addMethodPrefixSuffixToContext(context) {
    context.prefixToAdd = "";
    context.suffixToAdd = "";
    var tokenIter = editor.iterForCurrentLoc();
    var row = tokenIter.getCurrentTokenRow();
    var t = editor.parser.nextNonEmptyToken(tokenIter);

    if (tokenIter.getCurrentTokenRow() != row || !t) {
      // we still have nothing next to the method, add a space..
      context.suffixToAdd = " ";
    }
  }

  function addPathPrefixSuffixToContext(context) {
    context.prefixToAdd = "";
    context.suffixToAdd = "";
  }

  function addMethodAutoCompleteSetToContext(context) {
    context.autoCompleteSet = ["GET", "PUT", "POST", "DELETE", "HEAD"].map(function (m, i) {
      return {
        name: m,
        score: -i,
        meta: 'method'
      };
    });
  }

  function addPathAutoCompleteSetToContext(context, pos) {
    var ret = getCurrentMethodAndTokenPaths(pos);
    context.method = ret.method;
    context.token = ret.token;
    context.otherTokenValues = ret.otherTokenValues;
    context.urlTokenPath = ret.urlTokenPath;
    (0, _engine.populateContext)(ret.urlTokenPath, context, editor, true, (0, _kb.getTopLevelUrlCompleteComponents)());
    context.autoCompleteSet = addMetaToTermsList(context.autoCompleteSet, "endpoint");
  }

  function addUrlParamsAutoCompleteSetToContext(context, pos) {
    var ret = getCurrentMethodAndTokenPaths(pos);
    context.method = ret.method;
    context.otherTokenValues = ret.otherTokenValues;
    context.urlTokenPath = ret.urlTokenPath;
    if (!ret.urlTokenPath) {
      // zero length tokenPath is true

      console.log("Can't extract a valid url token path.");
      return context;
    }

    (0, _engine.populateContext)(ret.urlTokenPath, context, editor, false, (0, _kb.getTopLevelUrlCompleteComponents)());

    if (!context.endpoint) {
      console.log("couldn't resolve an endpoint.");
      return context;
    }

    if (!ret.urlParamsTokenPath) {
      // zero length tokenPath is true
      console.log("Can't extract a valid urlParams token path.");
      return context;
    }
    var tokenPath = [],
        currentParam = ret.urlParamsTokenPath.pop();
    if (currentParam) {
      tokenPath = Object.keys(currentParam); // single key object
      context.otherTokenValues = currentParam[tokenPath[0]];
    }

    (0, _engine.populateContext)(tokenPath, context, editor, true, context.endpoint.paramsAutocomplete.getTopLevelComponents());
    return context;
  }

  function addBodyAutoCompleteSetToContext(context, pos) {

    var ret = getCurrentMethodAndTokenPaths(pos);
    context.method = ret.method;
    context.otherTokenValues = ret.otherTokenValues;
    context.urlTokenPath = ret.urlTokenPath;
    context.requestStartRow = ret.requestStartRow;
    if (!ret.urlTokenPath) {
      // zero length tokenPath is true
      console.log("Can't extract a valid url token path.");
      return context;
    }

    (0, _engine.populateContext)(ret.urlTokenPath, context, editor, false, (0, _kb.getTopLevelUrlCompleteComponents)());

    context.bodyTokenPath = ret.bodyTokenPath;
    if (!ret.bodyTokenPath) {
      // zero length tokenPath is true

      console.log("Can't extract a valid body token path.");
      return context;
    }

    // needed for scope linking + global term resolving
    context.endpointComponentResolver = _kb.getEndpointBodyCompleteComponents;
    context.globalComponentResolver = _kb.getGlobalAutocompleteComponents;
    var components;
    if (context.endpoint) {
      components = context.endpoint.bodyAutocompleteRootComponents;
    } else {
      components = (0, _kb.getUnmatchedEndpointComponents)();
    }
    (0, _engine.populateContext)(ret.bodyTokenPath, context, editor, true, components);

    return context;
  }

  function getCurrentMethodAndTokenPaths(pos) {
    var tokenIter = editor.iterForPosition(pos.row, pos.column);
    var startPos = pos;
    var bodyTokenPath = [],
        ret = {};

    var STATES = {
      looking_for_key: 0, // looking for a key but without jumping over anything but white space and colon.
      looking_for_scope_start: 1, // skip everything until scope start
      start: 3
    };
    var state = STATES.start;

    // initialization problems -
    var t = tokenIter.getCurrentToken();
    if (t) {
      if (startPos.column == 0) {
        // if we are at the beginning of the line, the current token is the one after cursor, not before which
        // deviates from the standard.
        t = tokenIter.stepBackward();
        state = STATES.looking_for_scope_start;
      }
    } else {
      if (startPos.column == 0) {
        // empty lines do no have tokens, move one back
        t = tokenIter.stepBackward();
        state = STATES.start;
      }
    }

    var walkedSomeBody = false;

    // climb one scope at a time and get the scope key
    for (; t && t.type.indexOf("url") == -1 && t.type != "method"; t = tokenIter.stepBackward()) {

      if (t.type != "whitespace") {
        walkedSomeBody = true;
      } // marks we saw something

      switch (t.type) {
        case "variable":
          if (state == STATES.looking_for_key) {
            bodyTokenPath.unshift(t.value.trim().replace(/"/g, ''));
          }
          state = STATES.looking_for_scope_start; // skip everything until the beginning of this scope
          break;

        case "paren.lparen":
          bodyTokenPath.unshift(t.value);
          if (state == STATES.looking_for_scope_start) {
            // found it. go look for the relevant key
            state = STATES.looking_for_key;
          }
          break;
        case "paren.rparen":
          // reset he search for key
          state = STATES.looking_for_scope_start;
          // and ignore this sub scope..
          var parenCount = 1;
          t = tokenIter.stepBackward();
          while (t && parenCount > 0) {
            switch (t.type) {
              case "paren.lparen":
                parenCount--;
                break;
              case "paren.rparen":
                parenCount++;
                break;
            }
            if (parenCount > 0) {
              t = tokenIter.stepBackward();
            }
          }
          if (!t) // oops we run out.. we don't know what's up return null;
            {
              return {};
            }
          continue;
        case "punctuation.end_triple_quote":
          // reset the search for key
          state = STATES.looking_for_scope_start;
          for (t = tokenIter.stepBackward(); t; t = tokenIter.stepBackward()) {
            if (t.type === "punctuation.start_tripple_qoute") {
              t = tokenIter.stepBackward();
              break;
            }
          }
          if (!t) // oops we run out.. we don't know what's up return null;
            {
              return {};
            }
          continue;
        case "punctuation.start_triple_quote":
          if (state == STATES.start) {
            state = STATES.looking_for_key;
          } else if (state == STATES.looking_for_key) {
            state = STATES.looking_for_scope_start;
          }
          bodyTokenPath.unshift('"""');
          continue;
        case "string":
        case "constant.numeric":
        case "constant.language.boolean":
        case "text":
          if (state == STATES.start) {
            state = STATES.looking_for_key;
          } else if (state == STATES.looking_for_key) {
            state = STATES.looking_for_scope_start;
          }

          break;
        case "punctuation.comma":
          if (state == STATES.start) {
            state = STATES.looking_for_scope_start;
          }
          break;
        case "punctuation.colon":
        case "whitespace":
          if (state == STATES.start) {
            state = STATES.looking_for_key;
          }
          break; // skip white space

      }
    }

    if (walkedSomeBody && (!bodyTokenPath || bodyTokenPath.length == 0)) {
      // we had some content and still no path -> the cursor is position after a closed body -> no auto complete
      return {};
    }

    if (tokenIter.getCurrentTokenRow() == startPos.row) {
      if (t.type === "url.part" || t.type === "url.param" || t.type === "url.value") {
        // we are on the same line as cursor and dealing with a url. Current token is not part of the context
        t = tokenIter.stepBackward();
      }
      bodyTokenPath = null; // no not on a body line.
    }

    ret.bodyTokenPath = bodyTokenPath;
    ret.urlTokenPath = [];
    ret.urlParamsTokenPath = null;
    ret.requestStartRow = tokenIter.getCurrentTokenRow();
    var curUrlPart;

    while (t && isUrlParamsToken(t)) {
      switch (t.type) {
        case "url.value":
          if (Array.isArray(curUrlPart)) {
            curUrlPart.unshift(t.value);
          } else if (curUrlPart) {
            curUrlPart = [t.value, curUrlPart];
          } else {
            curUrlPart = t.value;
          }
          break;
        case "url.comma":
          if (!curUrlPart) {
            curUrlPart = [];
          } else if (!Array.isArray(curUrlPart)) {
            curUrlPart = [curUrlPart];
          }
          break;
        case "url.param":
          var v = curUrlPart;
          curUrlPart = {};
          curUrlPart[t.value] = v;
          break;
        case "url.amp":
        case "url.questionmark":
          if (!ret.urlParamsTokenPath) {
            ret.urlParamsTokenPath = [];
          }
          ret.urlParamsTokenPath.unshift(curUrlPart || {});
          curUrlPart = null;
          break;
      }
      t = tokenIter.stepBackward();
    }

    curUrlPart = null;
    while (t && t.type.indexOf("url") != -1) {
      switch (t.type) {
        case "url.part":
          if (Array.isArray(curUrlPart)) {
            curUrlPart.unshift(t.value);
          } else if (curUrlPart) {
            curUrlPart = [t.value, curUrlPart];
          } else {
            curUrlPart = t.value;
          }
          break;
        case "url.comma":
          if (!curUrlPart) {
            curUrlPart = [];
          } else if (!Array.isArray(curUrlPart)) {
            curUrlPart = [curUrlPart];
          }
          break;
        case "url.slash":
          ret.urlTokenPath.unshift(curUrlPart);
          curUrlPart = null;
          break;
      }
      t = editor.parser.prevNonEmptyToken(tokenIter);
    }

    if (curUrlPart) {
      ret.urlTokenPath.unshift(curUrlPart);
    }

    if (!ret.bodyTokenPath && !ret.urlParamsTokenPath) {

      if (ret.urlTokenPath.length > 0) {
        // started on the url, first token is current token
        ret.otherTokenValues = ret.urlTokenPath.splice(-1)[0];
      }
    } else {
      // mark the url as completed.
      ret.urlTokenPath.push(_url_pattern_matcher.URL_PATH_END_MARKER);
    }

    if (t && t.type == "method") {
      ret.method = t.value;
    }
    return ret;
  }

  var evaluateCurrentTokenAfterAChange = _lodash2.default.debounce(function evaluateCurrentTokenAfterAChange(pos) {
    var session = editor.getSession();
    var currentToken = session.getTokenAt(pos.row, pos.column);

    if (!currentToken) {
      if (pos.row == 0) {
        LAST_EVALUATED_TOKEN = null;
        return;
      }
      currentToken = { start: 0, value: "" }; // empty row
    }

    currentToken.row = pos.row; // extend token with row. Ace doesn't supply it by default
    if (editor.parser.isEmptyToken(currentToken)) {
      // empty token. check what's coming next
      var nextToken = session.getTokenAt(pos.row, pos.column + 1);
      if (editor.parser.isEmptyToken(nextToken)) {
        // Empty line, or we're not on the edge of current token. Save the current position as base
        currentToken.start = pos.column;
        LAST_EVALUATED_TOKEN = currentToken;
      } else {
        nextToken.row = pos.row;
        LAST_EVALUATED_TOKEN = nextToken;
      }
      return;
    }

    if (!LAST_EVALUATED_TOKEN) {
      LAST_EVALUATED_TOKEN = currentToken;
      return; // wait for the next typing.
    }

    if (LAST_EVALUATED_TOKEN.start != currentToken.start || LAST_EVALUATED_TOKEN.row != currentToken.row || LAST_EVALUATED_TOKEN.value === currentToken.value) {
      // not on the same place or nothing changed, cache and wait for the next time
      LAST_EVALUATED_TOKEN = currentToken;
      return;
    }

    // don't automatically open the auto complete if some just hit enter (new line) or open a parentheses
    switch (currentToken.type || "UNKNOWN") {
      case "paren.lparen":
      case "paren.rparen":
      case "punctuation.colon":
      case "punctuation.comma":
      case "UNKOWN":
        return;
    }

    LAST_EVALUATED_TOKEN = currentToken;
    editor.execCommand("startAutocomplete");
  }, 100);

  function editorChangeListener() {
    var cursor = editor.selection.lead;
    if (editor.__ace.completer && editor.__ace.completer.activated) {
      return;
    }
    evaluateCurrentTokenAfterAChange(cursor);
  }

  function addChangeListener() {
    editor.on("changeSelection", editorChangeListener);
  }

  function removeChangeListener() {
    editor.off("changeSelection", editorChangeListener);
  }

  function getCompletions(aceEditor, session, pos, prefix, callback) {
    try {

      var context = getAutoCompleteContext(editor, session, pos);
      if (!context) {
        callback(null, []);
      } else {
        var terms = _lodash2.default.map(context.autoCompleteSet, function (term) {
          if ((typeof term === 'undefined' ? 'undefined' : _typeof(term)) !== "object") {
            term = {
              name: term
            };
          } else {
            term = _lodash2.default.clone(term);
          }

          return _lodash2.default.defaults(term, {
            value: term.name,
            meta: "API",
            score: 0,
            context: context,
            completer: {
              insertMatch: function insertMatch() {
                applyTerm(term);
              }
            }
          });
        });

        terms.sort(function (t1, t2) {
          /* score sorts from high to low */
          if (t1.score > t2.score) {
            return -1;
          }
          if (t1.score < t2.score) {
            return 1;
          }
          /* names sort from low to high */
          if (t1.name < t2.name) {
            return -1;
          }
          if (t1.name === t2.name) {
            return 0;
          }
          return 1;
        });

        callback(null, _lodash2.default.map(terms, function (t, i) {
          t.insert_value = t.insert_value || t.value;
          t.value = '' + t.value; // normalize to strings
          t.score = -i;
          return t;
        }));
      }
    } catch (e) {
      console.log("error while getting completion terms", e);
      callback(e, null);
    }
  }

  addChangeListener();

  // Hook into Ace

  // disable standard context based autocompletion.
  _ace2.default.define('ace/autocomplete/text_completer', ['require', 'exports', 'module'], function (require, exports) {
    exports.getCompletions = function (editor, session, pos, prefix, callback) {
      callback(null, []);
    };
  });

  var langTools = _ace2.default.require('ace/ext/language_tools');
  var aceUtils = _ace2.default.require('ace/autocomplete/util');
  var aceAutoComplete = _ace2.default.require('ace/autocomplete');

  langTools.addCompleter({
    getCompletions: getCompletions
  });

  editor.setOptions({
    enableBasicAutocompletion: true
  });

  // Ace doesn't care about tokenization when calculating prefix. It will thus stop on . in keys names.
  // we patch this behavior.
  // CHECK ON ACE UPDATE
  var aceAutoCompleteInstance = new aceAutoComplete.Autocomplete();
  aceAutoCompleteInstance.autoInsert = false;
  aceAutoCompleteInstance.gatherCompletions = function (ace_editor, callback) {
    var session = ace_editor.getSession();
    var pos = ace_editor.getCursorPosition();
    var prefix = "";
    // change starts here
    var token = session.getTokenAt(pos.row, pos.column);
    this.base = _lodash2.default.clone(pos);
    if (!editor.parser.isEmptyToken(token) && !isSeparatorToken(token)) {
      if (token.value.indexOf('"') == 0) {
        this.base.column = token.start + 1;
      } else {
        this.base.column = token.start;
      }

      prefix = getAutoCompleteValueFromToken(token);
    }

    var matches = [];
    aceUtils.parForEach(ace_editor.completers, function (completer, next) {
      completer.getCompletions(ace_editor, session, pos, prefix, function (err, results) {
        if (!err) {
          matches = matches.concat(results);
        }
        next();
      });
    }, function () {
      callback(null, {
        prefix: prefix,
        matches: matches
      });
    });
    return true;
  };

  editor.__ace.completer = aceAutoCompleteInstance;

  return {
    _test: {
      getCompletions: getCompletions,
      addReplacementInfoToContext: addReplacementInfoToContext,
      addChangeListener: addChangeListener,
      removeChangeListener: removeChangeListener
    }
  };
};

var _kb = __webpack_require__(541);

var _utils = __webpack_require__(265);

var _utils2 = _interopRequireDefault(_utils);

var _engine = __webpack_require__(140);

var _url_pattern_matcher = __webpack_require__(540);

var _lodash = __webpack_require__(1);

var _lodash2 = _interopRequireDefault(_lodash);

var _ace = __webpack_require__(51);

var _ace2 = _interopRequireDefault(_ace);

__webpack_require__(3160);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var AceRange = _ace2.default.require('ace/range').Range;

var LAST_EVALUATED_TOKEN = null;

module.exports = exports['default'];

/***/ }),
/* 3160 */
/***/ (function(module, exports) {

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2012, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

consoleAce.define('ace/ext/language_tools', ['require', 'exports', 'module' , 'ace/snippets', 'ace/autocomplete', 'ace/config', 'ace/autocomplete/text_completer', 'ace/editor'], function(require, exports, module) {


var snippetManager = require("../snippets").snippetManager;
var Autocomplete = require("../autocomplete").Autocomplete;
var config = require("../config");

var textCompleter = require("../autocomplete/text_completer");
var keyWordCompleter = {
    getCompletions: function(editor, session, pos, prefix, callback) {
        var state = editor.session.getState(pos.row);
        var completions = session.$mode.getCompletions(state, session, pos, prefix);
        callback(null, completions);
    }
};

var snippetCompleter = {
    getCompletions: function(editor, session, pos, prefix, callback) {
        var snippetMap = snippetManager.snippetMap;
        var completions = [];
        snippetManager.getActiveScopes(editor).forEach(function(scope) {
            var snippets = snippetMap[scope] || [];
            for (var i = snippets.length; i--;) {
                var s = snippets[i];
                var caption = s.name || s.tabTrigger;
                if (!caption)
                    continue;
                completions.push({
                    caption: caption,
                    snippet: s.content,
                    meta: s.tabTrigger && !s.name ? s.tabTrigger + "\u21E5 " : "snippet"
                });
            }
        }, this);
        callback(null, completions);
    }
};

var completers = [snippetCompleter, textCompleter, keyWordCompleter];
exports.addCompleter = function(completer) {
    completers.push(completer);
};

var expandSnippet = {
    name: "expandSnippet",
    exec: function(editor) {
        var success = snippetManager.expandWithTab(editor);
        if (!success)
            editor.execCommand("indent");
    },
    bindKey: "tab"
};

var onChangeMode = function(e, editor) {
    loadSnippetsForMode(editor.session.$mode);
};

var loadSnippetsForMode = function(mode) {
    var id = mode.$id;
    if (!snippetManager.files)
        snippetManager.files = {};
    loadSnippetFile(id);
    if (mode.modes)
        mode.modes.forEach(loadSnippetsForMode);
};

var loadSnippetFile = function(id) {
    if (!id || snippetManager.files[id])
        return;
    var snippetFilePath = id.replace("mode", "snippets");
    snippetManager.files[id] = {};
    config.loadModule(snippetFilePath, function(m) {
        if (m) {
            snippetManager.files[id] = m;
            m.snippets = snippetManager.parseSnippetFile(m.snippetText);
            snippetManager.register(m.snippets, m.scope);
            if (m.includeScopes) {
                snippetManager.snippetMap[m.scope].includeScopes = m.includeScopes;
                m.includeScopes.forEach(function(x) {
                    loadSnippetFile("ace/mode/" + x);
                });
            }
        }
    });
};

var Editor = require("../editor").Editor;
require("../config").defineOptions(Editor.prototype, "editor", {
    enableBasicAutocompletion: {
        set: function(val) {
            if (val) {
                this.completers = completers;
                this.commands.addCommand(Autocomplete.startCommand);
            } else {
                this.commands.removeCommand(Autocomplete.startCommand);
            }
        },
        value: false
    },
    enableSnippets: {
        set: function(val) {
            if (val) {
                this.commands.addCommand(expandSnippet);
                this.on("changeMode", onChangeMode);
                onChangeMode(null, this);
            } else {
                this.commands.removeCommand(expandSnippet);
                this.off("changeMode", onChangeMode);
            }
        },
        value: false
    }
});

});

consoleAce.define('ace/snippets', ['require', 'exports', 'module' , 'ace/lib/lang', 'ace/range', 'ace/keyboard/hash_handler', 'ace/tokenizer', 'ace/lib/dom'], function(require, exports, module) {

var lang = require("./lib/lang")
var Range = require("./range").Range
var HashHandler = require("./keyboard/hash_handler").HashHandler;
var Tokenizer = require("./tokenizer").Tokenizer;
var comparePoints = Range.comparePoints;

var SnippetManager = function() {
    this.snippetMap = {};
    this.snippetNameMap = {};
};

(function() {
    this.getTokenizer = function() {
        function TabstopToken(str, _, stack) {
            str = str.substr(1);
            if (/^\d+$/.test(str) && !stack.inFormatString)
                return [{tabstopId: parseInt(str, 10)}];
            return [{text: str}]
        }
        function escape(ch) {
            return "(?:[^\\\\" + ch + "]|\\\\.)";
        }
        SnippetManager.$tokenizer = new Tokenizer({
            start: [
                {regex: /:/, onMatch: function(val, state, stack) {
                    if (stack.length && stack[0].expectIf) {
                        stack[0].expectIf = false;
                        stack[0].elseBranch = stack[0];
                        return [stack[0]];
                    }
                    return ":";
                }},
                {regex: /\\./, onMatch: function(val, state, stack) {
                    var ch = val[1];
                    if (ch == "}" && stack.length) {
                        val = ch;
                    }else if ("`$\\".indexOf(ch) != -1) {
                        val = ch;
                    } else if (stack.inFormatString) {
                        if (ch == "n")
                            val = "\n";
                        else if (ch == "t")
                            val = "\n";
                        else if ("ulULE".indexOf(ch) != -1) {
                            val = {changeCase: ch, local: ch > "a"};
                        }
                    }

                    return [val];
                }},
                {regex: /}/, onMatch: function(val, state, stack) {
                    return [stack.length ? stack.shift() : val];
                }},
                {regex: /\$(?:\d+|\w+)/, onMatch: TabstopToken},
                {regex: /\$\{[\dA-Z_a-z]+/, onMatch: function(str, state, stack) {
                    var t = TabstopToken(str.substr(1), state, stack);
                    stack.unshift(t[0]);
                    return t;
                }, next: "snippetVar"},
                {regex: /\n/, token: "newline", merge: false}
            ],
            snippetVar: [
                {regex: "\\|" + escape("\\|") + "*\\|", onMatch: function(val, state, stack) {
                    stack[0].choices = val.slice(1, -1).split(",");
                }, next: "start"},
                {regex: "/(" + escape("/") + "+)/(?:(" + escape("/") + "*)/)(\\w*):?",
                 onMatch: function(val, state, stack) {
                    var ts = stack[0];
                    ts.fmtString = val;

                    val = this.splitRegex.exec(val);
                    ts.guard = val[1];
                    ts.fmt = val[2];
                    ts.flag = val[3];
                    return "";
                }, next: "start"},
                {regex: "`" + escape("`") + "*`", onMatch: function(val, state, stack) {
                    stack[0].code = val.splice(1, -1);
                    return "";
                }, next: "start"},
                {regex: "\\?", onMatch: function(val, state, stack) {
                    if (stack[0])
                        stack[0].expectIf = true;
                }, next: "start"},
                {regex: "([^:}\\\\]|\\\\.)*:?", token: "", next: "start"}
            ],
            formatString: [
                {regex: "/(" + escape("/") + "+)/", token: "regex"},
                {regex: "", onMatch: function(val, state, stack) {
                    stack.inFormatString = true;
                }, next: "start"}
            ]
        });
        SnippetManager.prototype.getTokenizer = function() {
            return SnippetManager.$tokenizer;
        }
        return SnippetManager.$tokenizer;
    };

    this.tokenizeTmSnippet = function(str, startState) {
        return this.getTokenizer().getLineTokens(str, startState).tokens.map(function(x) {
            return x.value || x;
        });
    };

    this.$getDefaultValue = function(editor, name) {
        if (/^[A-Z]\d+$/.test(name)) {
            var i = name.substr(1);
            return (this.variables[name[0] + "__"] || {})[i];
        }
        if (/^\d+$/.test(name)) {
            return (this.variables.__ || {})[name];
        }
        name = name.replace(/^TM_/, "");

        if (!editor)
            return;
        var s = editor.session;
        switch(name) {
            case "CURRENT_WORD":
                var r = s.getWordRange();
            case "SELECTION":
            case "SELECTED_TEXT":
                return s.getTextRange(r);
            case "CURRENT_LINE":
                return s.getLine(editor.getCursorPosition().row);
            case "PREV_LINE": // not possible in textmate
                return s.getLine(editor.getCursorPosition().row - 1);
            case "LINE_INDEX":
                return editor.getCursorPosition().column;
            case "LINE_NUMBER":
                return editor.getCursorPosition().row + 1;
            case "SOFT_TABS":
                return s.getUseSoftTabs() ? "YES" : "NO";
            case "TAB_SIZE":
                return s.getTabSize();
            case "FILENAME":
            case "FILEPATH":
                return "ace.ajax.org";
            case "FULLNAME":
                return "Ace";
        }
    };
    this.variables = {};
    this.getVariableValue = function(editor, varName) {
        if (this.variables.hasOwnProperty(varName))
            return this.variables[varName](editor, varName) || "";
        return this.$getDefaultValue(editor, varName) || "";
    };
    this.tmStrFormat = function(str, ch, editor) {
        var flag = ch.flag || "";
        var re = ch.guard;
        re = new RegExp(re, flag.replace(/[^gi]/, ""));
        var fmtTokens = this.tokenizeTmSnippet(ch.fmt, "formatString");
        var _self = this;
        var formatted = str.replace(re, function() {
            _self.variables.__ = arguments;
            var fmtParts = _self.resolveVariables(fmtTokens, editor);
            var gChangeCase = "E";
            for (var i  = 0; i < fmtParts.length; i++) {
                var ch = fmtParts[i];
                if (typeof ch == "object") {
                    fmtParts[i] = "";
                    if (ch.changeCase && ch.local) {
                        var next = fmtParts[i + 1];
                        if (next && typeof next == "string") {
                            if (ch.changeCase == "u")
                                fmtParts[i] = next[0].toUpperCase();
                            else
                                fmtParts[i] = next[0].toLowerCase();
                            fmtParts[i + 1] = next.substr(1);
                        }
                    } else if (ch.changeCase) {
                        gChangeCase = ch.changeCase;
                    }
                } else if (gChangeCase == "U") {
                    fmtParts[i] = ch.toUpperCase();
                } else if (gChangeCase == "L") {
                    fmtParts[i] = ch.toLowerCase();
                }
            }
            return fmtParts.join("");
        });
        this.variables.__ = null;
        return formatted;
    };

    this.resolveVariables = function(snippet, editor) {
        var result = [];
        for (var i = 0; i < snippet.length; i++) {
            var ch = snippet[i];
            if (typeof ch == "string") {
                result.push(ch);
            } else if (typeof ch != "object") {
                continue;
            } else if (ch.skip) {
                gotoNext(ch);
            } else if (ch.processed < i) {
                continue;
            } else if (ch.text) {
                var value = this.getVariableValue(editor, ch.text);
                if (value && ch.fmtString)
                    value = this.tmStrFormat(value, ch);
                ch.processed = i;
                if (ch.expectIf == null) {
                    if (value) {
                        result.push(value);
                        gotoNext(ch);
                    }
                } else {
                    if (value) {
                        ch.skip = ch.elseBranch;
                    } else
                        gotoNext(ch);
                }
            } else if (ch.tabstopId != null) {
                result.push(ch);
            } else if (ch.changeCase != null) {
                result.push(ch);
            }
        }
        function gotoNext(ch) {
            var i1 = snippet.indexOf(ch, i + 1);
            if (i1 != -1)
                i = i1;
        }
        return result;
    };

    this.insertSnippet = function(editor, snippetText) {
        var cursor = editor.getCursorPosition();
        var line = editor.session.getLine(cursor.row);
        var indentString = line.match(/^\s*/)[0];
        var tabString = editor.session.getTabString();

        var tokens = this.tokenizeTmSnippet(snippetText);
        tokens = this.resolveVariables(tokens, editor);
        tokens = tokens.map(function(x) {
            if (x == "\n")
                return x + indentString;
            if (typeof x == "string")
                return x.replace(/\t/g, tabString);
            return x;
        });
        var tabstops = [];
        tokens.forEach(function(p, i) {
            if (typeof p != "object")
                return;
            var id = p.tabstopId;
            var ts = tabstops[id];
            if (!ts) {
                ts = tabstops[id] = [];
                ts.index = id;
                ts.value = "";
            }
            if (ts.indexOf(p) !== -1)
                return;
            ts.push(p);
            var i1 = tokens.indexOf(p, i + 1);
            if (i1 === -1)
                return;

            var value = tokens.slice(i + 1, i1);
            var isNested = value.some(function(t) {return typeof t === "object"});          
            if (isNested && !ts.value) {
                ts.value = value;
            } else if (value.length && (!ts.value || typeof ts.value !== "string")) {
                ts.value = value.join("");
            }
        });
        tabstops.forEach(function(ts) {ts.length = 0});
        var expanding = {};
        function copyValue(val) {
            var copy = []
            for (var i = 0; i < val.length; i++) {
                var p = val[i];
                if (typeof p == "object") {
                    if (expanding[p.tabstopId])
                        continue;
                    var j = val.lastIndexOf(p, i - 1);
                    p = copy[j] || {tabstopId: p.tabstopId};
                }
                copy[i] = p;
            }
            return copy;
        }
        for (var i = 0; i < tokens.length; i++) {
            var p = tokens[i];
            if (typeof p != "object")
                continue;
            var id = p.tabstopId;
            var i1 = tokens.indexOf(p, i + 1);
            if (expanding[id] == p) { 
                expanding[id] = null;
                continue;
            }
            
            var ts = tabstops[id];
            var arg = typeof ts.value == "string" ? [ts.value] : copyValue(ts.value);
            arg.unshift(i + 1, Math.max(0, i1 - i));
            arg.push(p);
            expanding[id] = p;
            tokens.splice.apply(tokens, arg);

            if (ts.indexOf(p) === -1)
                ts.push(p);
        };
        var row = 0, column = 0;
        var text = "";
        tokens.forEach(function(t) {
            if (typeof t === "string") {
                if (t[0] === "\n"){
                    column = t.length - 1;
                    row ++;
                } else
                    column += t.length;
                text += t;
            } else {
                if (!t.start)
                    t.start = {row: row, column: column};
                else
                    t.end = {row: row, column: column};
            }
        });
        var range = editor.getSelectionRange();
        var end = editor.session.replace(range, text);

        var tabstopManager = new TabstopManager(editor);
        tabstopManager.addTabstops(tabstops, range.start, end);
        tabstopManager.tabNext();
    };

    this.$getScope = function(editor) {
        var scope = editor.session.$mode.$id || "";
        scope = scope.split("/").pop();
        if (scope === "html" || scope === "php") {
            if (scope === "php") 
                scope = "html";
            var c = editor.getCursorPosition()
            var state = editor.session.getState(c.row);
            if (typeof state === "object") {
                state = state[0];
            }
            if (state.substring) {
                if (state.substring(0, 3) == "js-")
                    scope = "javascript";
                else if (state.substring(0, 4) == "css-")
                    scope = "css";
                else if (state.substring(0, 4) == "php-")
                    scope = "php";
            }
        }
        
        return scope;
    };

    this.getActiveScopes = function(editor) {
        var scope = this.$getScope(editor);
        var scopes = [scope];
        var snippetMap = this.snippetMap;
        if (snippetMap[scope] && snippetMap[scope].includeScopes) {
            scopes.push.apply(scopes, snippetMap[scope].includeScopes);
        }
        scopes.push("_");
        return scopes;
    };

    this.expandWithTab = function(editor) {
        var cursor = editor.getCursorPosition();
        var line = editor.session.getLine(cursor.row);
        var before = line.substring(0, cursor.column);
        var after = line.substr(cursor.column);

        var snippetMap = this.snippetMap;
        var snippet;
        this.getActiveScopes(editor).some(function(scope) {
            var snippets = snippetMap[scope];
            if (snippets)
                snippet = this.findMatchingSnippet(snippets, before, after);
            return !!snippet;
        }, this);
        if (!snippet)
            return false;

        editor.session.doc.removeInLine(cursor.row,
            cursor.column - snippet.replaceBefore.length,
            cursor.column + snippet.replaceAfter.length
        );

        this.variables.M__ = snippet.matchBefore;
        this.variables.T__ = snippet.matchAfter;
        this.insertSnippet(editor, snippet.content);

        this.variables.M__ = this.variables.T__ = null;
        return true;
    };

    this.findMatchingSnippet = function(snippetList, before, after) {
        for (var i = snippetList.length; i--;) {
            var s = snippetList[i];
            if (s.startRe && !s.startRe.test(before))
                continue;
            if (s.endRe && !s.endRe.test(after))
                continue;
            if (!s.startRe && !s.endRe)
                continue;

            s.matchBefore = s.startRe ? s.startRe.exec(before) : [""];
            s.matchAfter = s.endRe ? s.endRe.exec(after) : [""];
            s.replaceBefore = s.triggerRe ? s.triggerRe.exec(before)[0] : "";
            s.replaceAfter = s.endTriggerRe ? s.endTriggerRe.exec(after)[0] : "";
            return s;
        }
    };

    this.snippetMap = {};
    this.snippetNameMap = {};
    this.register = function(snippets, scope) {
        var snippetMap = this.snippetMap;
        var snippetNameMap = this.snippetNameMap;
        var self = this;
        function wrapRegexp(src) {
            if (src && !/^\^?\(.*\)\$?$|^\\b$/.test(src))
                src = "(?:" + src + ")"

            return src || "";
        }
        function guardedRegexp(re, guard, opening) {
            re = wrapRegexp(re);
            guard = wrapRegexp(guard);
            if (opening) {
                re = guard + re;
                if (re && re[re.length - 1] != "$")
                    re = re + "$";
            } else {
                re = re + guard;
                if (re && re[0] != "^")
                    re = "^" + re;
            }
            return new RegExp(re);
        }

        function addSnippet(s) {
            if (!s.scope)
                s.scope = scope || "_";
            scope = s.scope
            if (!snippetMap[scope]) {
                snippetMap[scope] = [];
                snippetNameMap[scope] = {};
            }

            var map = snippetNameMap[scope];
            if (s.name) {
                var old = map[s.name];
                if (old)
                    self.unregister(old);
                map[s.name] = s;
            }
            snippetMap[scope].push(s);

            if (s.tabTrigger && !s.trigger) {
                if (!s.guard && /^\w/.test(s.tabTrigger))
                    s.guard = "\\b";
                s.trigger = lang.escapeRegExp(s.tabTrigger);
            }

            s.startRe = guardedRegexp(s.trigger, s.guard, true);
            s.triggerRe = new RegExp(s.trigger, "", true);

            s.endRe = guardedRegexp(s.endTrigger, s.endGuard, true);
            s.endTriggerRe = new RegExp(s.endTrigger, "", true);
        };

        if (snippets.content)
            addSnippet(snippets);
        else if (Array.isArray(snippets))
            snippets.forEach(addSnippet);
    };
    this.unregister = function(snippets, scope) {
        var snippetMap = this.snippetMap;
        var snippetNameMap = this.snippetNameMap;

        function removeSnippet(s) {
            var nameMap = snippetNameMap[s.scope||scope];
            if (nameMap && nameMap[s.name]) {
                delete nameMap[s.name];
                var map = snippetMap[s.scope||scope];
                var i = map && map.indexOf(s);
                if (i >= 0)
                    map.splice(i, 1);
            }
        }
        if (snippets.content)
            removeSnippet(snippets);
        else if (Array.isArray(snippets))
            snippets.forEach(removeSnippet);
    };
    this.parseSnippetFile = function(str) {
        str = str.replace(/\r/g, "");
        var list = [], snippet = {};
        var re = /^#.*|^({[\s\S]*})\s*$|^(\S+) (.*)$|^((?:\n*\t.*)+)/gm;
        var m;
        while (m = re.exec(str)) {
            if (m[1]) {
                try {
                    snippet = JSON.parse(m[1])
                    list.push(snippet);
                } catch (e) {}
            } if (m[4]) {
                snippet.content = m[4].replace(/^\t/gm, "");
                list.push(snippet);
                snippet = {};
            } else {
                var key = m[2], val = m[3];
                if (key == "regex") {
                    var guardRe = /\/((?:[^\/\\]|\\.)*)|$/g;
                    snippet.guard = guardRe.exec(val)[1];
                    snippet.trigger = guardRe.exec(val)[1];
                    snippet.endTrigger = guardRe.exec(val)[1];
                    snippet.endGuard = guardRe.exec(val)[1];
                } else if (key == "snippet") {
                    snippet.tabTrigger = val.match(/^\S*/)[0];
                    if (!snippet.name)
                        snippet.name = val;
                } else {
                    snippet[key] = val;
                }
            }
        }
        return list;
    };
    this.getSnippetByName = function(name, editor) {
        var snippetMap = this.snippetNameMap;
        var snippet;
        this.getActiveScopes(editor).some(function(scope) {
            var snippets = snippetMap[scope];
            if (snippets)
                snippet = snippets[name];
            return !!snippet;
        }, this);
        return snippet;
    };

}).call(SnippetManager.prototype);


var TabstopManager = function(editor) {
    if (editor.tabstopManager)
        return editor.tabstopManager;
    editor.tabstopManager = this;
    this.$onChange = this.onChange.bind(this);
    this.$onChangeSelection = lang.delayedCall(this.onChangeSelection.bind(this)).schedule;
    this.$onChangeSession = this.onChangeSession.bind(this);
    this.$onAfterExec = this.onAfterExec.bind(this);
    this.attach(editor);
};
(function() {
    this.attach = function(editor) {
        this.index = -1;
        this.ranges = [];
        this.tabstops = [];
        this.selectedTabstop = null;

        this.editor = editor;
        this.editor.on("change", this.$onChange);
        this.editor.on("changeSelection", this.$onChangeSelection);
        this.editor.on("changeSession", this.$onChangeSession);
        this.editor.commands.on("afterExec", this.$onAfterExec);
        this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
    };
    this.detach = function() {
        this.tabstops.forEach(this.removeTabstopMarkers, this);
        this.ranges = null;
        this.tabstops = null;
        this.selectedTabstop = null;
        this.editor.removeListener("change", this.$onChange);
        this.editor.removeListener("changeSelection", this.$onChangeSelection);
        this.editor.removeListener("changeSession", this.$onChangeSession);
        this.editor.commands.removeListener("afterExec", this.$onAfterExec);
        this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);
        this.editor.tabstopManager = null;
        this.editor = null;
    };

    this.onChange = function(e) {
        var changeRange = e.data.range;
        var isRemove = e.data.action[0] == "r";
        var start = changeRange.start;
        var end = changeRange.end;
        var startRow = start.row;
        var endRow = end.row;
        var lineDif = endRow - startRow;
        var colDiff = end.column - start.column;

        if (isRemove) {
            lineDif = -lineDif;
            colDiff = -colDiff;
        }
        if (!this.$inChange && isRemove) {
            var ts = this.selectedTabstop;
            var changedOutside = !ts.some(function(r) {
                return comparePoints(r.start, start) <= 0 && comparePoints(r.end, end) >= 0;
            });
            if (changedOutside)
                return this.detach();
        }
        var ranges = this.ranges;
        for (var i = 0; i < ranges.length; i++) {
            var r = ranges[i];
            if (r.end.row < start.row)
                continue;

            if (comparePoints(start, r.start) < 0 && comparePoints(end, r.end) > 0) {
                this.removeRange(r);
                i--;
                continue;
            }

            if (r.start.row == startRow && r.start.column > start.column)
                r.start.column += colDiff;
            if (r.end.row == startRow && r.end.column >= start.column)
                r.end.column += colDiff;
            if (r.start.row >= startRow)
                r.start.row += lineDif;
            if (r.end.row >= startRow)
                r.end.row += lineDif;

            if (comparePoints(r.start, r.end) > 0)
                this.removeRange(r);
        }
        if (!ranges.length)
            this.detach();
    };
    this.updateLinkedFields = function() {
        var ts = this.selectedTabstop;
        if (!ts.hasLinkedRanges)
            return;
        this.$inChange = true;
        var session = this.editor.session;
        var text = session.getTextRange(ts.firstNonLinked);
        for (var i = ts.length; i--;) {
            var range = ts[i];
            if (!range.linked)
                continue;
            var fmt = exports.snippetManager.tmStrFormat(text, range.original)
            session.replace(range, fmt);
        }
        this.$inChange = false;
    };
    this.onAfterExec = function(e) {
        if (e.command && !e.command.readOnly)
            this.updateLinkedFields();
    };
    this.onChangeSelection = function() {
        if (!this.editor)
            return
        var lead = this.editor.selection.lead;
        var anchor = this.editor.selection.anchor;
        var isEmpty = this.editor.selection.isEmpty();
        for (var i = this.ranges.length; i--;) {
            if (this.ranges[i].linked)
                continue;
            var containsLead = this.ranges[i].contains(lead.row, lead.column);
            var containsAnchor = isEmpty || this.ranges[i].contains(anchor.row, anchor.column);
            if (containsLead && containsAnchor)
                return;
        }
        this.detach();
    };
    this.onChangeSession = function() {
        this.detach();
    };
    this.tabNext = function(dir) {
        var max = this.tabstops.length - 1;
        var index = this.index + (dir || 1);
        index = Math.min(Math.max(index, 0), max);
        this.selectTabstop(index);
        if (index == max)
            this.detach();
    };
    this.selectTabstop = function(index) {
        var ts = this.tabstops[this.index];
        if (ts)
            this.addTabstopMarkers(ts);
        this.index = index;
        ts = this.tabstops[this.index];
        if (!ts || !ts.length)
            return;
        
        this.selectedTabstop = ts;
        if (!this.editor.inVirtualSelectionMode) {        
            var sel = this.editor.multiSelect;
            sel.toSingleRange(ts.firstNonLinked.clone());
            for (var i = ts.length; i--;) {
                if (ts.hasLinkedRanges && ts[i].linked)
                    continue;
                sel.addRange(ts[i].clone(), true);
            }
        } else {
            this.editor.selection.setRange(ts.firstNonLinked);
        }
        
        this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
    };
    this.addTabstops = function(tabstops, start, end) {
        if (!tabstops[0]) {
            var p = Range.fromPoints(end, end);
            moveRelative(p.start, start);
            moveRelative(p.end, start);
            tabstops[0] = [p];
            tabstops[0].index = 0;
        }

        var i = this.index;
        var arg = [i, 0];
        var ranges = this.ranges;
        var editor = this.editor;
        tabstops.forEach(function(ts) {
            for (var i = ts.length; i--;) {
                var p = ts[i];
                var range = Range.fromPoints(p.start, p.end || p.start);
                movePoint(range.start, start);
                movePoint(range.end, start);
                range.original = p;
                range.tabstop = ts;
                ranges.push(range);
                ts[i] = range;
                if (p.fmtString) {
                    range.linked = true;
                    ts.hasLinkedRanges = true;
                } else if (!ts.firstNonLinked)
                    ts.firstNonLinked = range;
            }
            if (!ts.firstNonLinked)
                ts.hasLinkedRanges = false;
            arg.push(ts);
            this.addTabstopMarkers(ts);
        }, this);
        arg.push(arg.splice(2, 1)[0]);
        this.tabstops.splice.apply(this.tabstops, arg);
    };

    this.addTabstopMarkers = function(ts) {
        var session = this.editor.session;
        ts.forEach(function(range) {
            if  (!range.markerId)
                range.markerId = session.addMarker(range, "ace_snippet-marker", "text");
        });
    };
    this.removeTabstopMarkers = function(ts) {
        var session = this.editor.session;
        ts.forEach(function(range) {
            session.removeMarker(range.markerId);
            range.markerId = null;
        });
    };
    this.removeRange = function(range) {
        var i = range.tabstop.indexOf(range);
        range.tabstop.splice(i, 1);
        i = this.ranges.indexOf(range);
        this.ranges.splice(i, 1);
        this.editor.session.removeMarker(range.markerId);
    };

    this.keyboardHandler = new HashHandler();
    this.keyboardHandler.bindKeys({
        "Tab": function(ed) {
            if (exports.snippetManager && exports.snippetManager.expandWithTab(ed)) {
                return;
            }

            ed.tabstopManager.tabNext(1);
        },
        "Shift-Tab": function(ed) {
            ed.tabstopManager.tabNext(-1);
        },
        "Esc": function(ed) {
            ed.tabstopManager.detach();
        },
        "Return": function(ed) {
            return false;
        }
    });
}).call(TabstopManager.prototype);


var movePoint = function(point, diff) {
    if (point.row == 0)
        point.column += diff.column;
    point.row += diff.row;
};

var moveRelative = function(point, start) {
    if (point.row == start.row)
        point.column -= start.column;
    point.row -= start.row;
};


require("./lib/dom").importCssString("\
.ace_snippet-marker {\
    -moz-box-sizing: border-box;\
    box-sizing: border-box;\
    background: rgba(194, 193, 208, 0.09);\
    border: 1px dotted rgba(211, 208, 235, 0.62);\
    position: absolute;\
}");

exports.snippetManager = new SnippetManager();


});

consoleAce.define('ace/autocomplete', ['require', 'exports', 'module' , 'ace/keyboard/hash_handler', 'ace/autocomplete/popup', 'ace/autocomplete/util', 'ace/lib/event', 'ace/lib/lang', 'ace/snippets'], function(require, exports, module) {


var HashHandler = require("./keyboard/hash_handler").HashHandler;
var AcePopup = require("./autocomplete/popup").AcePopup;
var util = require("./autocomplete/util");
var event = require("./lib/event");
var lang = require("./lib/lang");
var snippetManager = require("./snippets").snippetManager;

var Autocomplete = function() {
    this.autoInsert = true;
    this.keyboardHandler = new HashHandler();
    this.keyboardHandler.bindKeys(this.commands);

    this.blurListener = this.blurListener.bind(this);
    this.changeListener = this.changeListener.bind(this);
    this.mousedownListener = this.mousedownListener.bind(this);
    this.mousewheelListener = this.mousewheelListener.bind(this);
    
    this.changeTimer = lang.delayedCall(function() {
        this.updateCompletions(true);
    }.bind(this))
};

(function() {
    this.$init = function() {
        this.popup = new AcePopup(document.body || document.documentElement);
        this.popup.on("click", function(e) {
            this.insertMatch();
            e.stop();
        }.bind(this));
    };

    this.openPopup = function(editor, prefix, keepPopupPosition) {
        if (!this.popup)
            this.$init();

        this.popup.setData(this.completions.filtered);

        var renderer = editor.renderer;
        if (!keepPopupPosition) {
            this.popup.setRow(0);
            this.popup.setFontSize(editor.getFontSize());

            var lineHeight = renderer.layerConfig.lineHeight;
            
            var pos = renderer.$cursorLayer.getPixelPosition(this.base, true);            
            pos.left -= this.popup.getTextLeftOffset();
            
            var rect = editor.container.getBoundingClientRect();
            pos.top += rect.top - renderer.layerConfig.offset;
            pos.left += rect.left - editor.renderer.scrollLeft;
            pos.left += renderer.$gutterLayer.gutterWidth;

            this.popup.show(pos, lineHeight);
        }
    };

    this.detach = function() {
        this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);
        this.editor.off("changeSelection", this.changeListener);
        this.editor.off("blur", this.changeListener);
        this.editor.off("mousedown", this.mousedownListener);
        this.editor.off("mousewheel", this.mousewheelListener);
        this.changeTimer.cancel();
        
        if (this.popup)
            this.popup.hide();

        this.activated = false;
        this.completions = this.base = null;
    };

    this.changeListener = function(e) {
        var cursor = this.editor.selection.lead;
        if (cursor.row != this.base.row || cursor.column < this.base.column) {
            this.detach();
        }
        if (this.activated)
            this.changeTimer.schedule();
        else
            this.detach();
    };

    this.blurListener = function() {
        if (document.activeElement != this.editor.textInput.getElement())
            this.detach();
    };

    this.mousedownListener = function(e) {
        this.detach();
    };

    this.mousewheelListener = function(e) {
        this.detach();
    };

    this.goTo = function(where) {
        var row = this.popup.getRow();
        var max = this.popup.session.getLength() - 1;

        switch(where) {
            case "up": row = row < 0 ? max : row - 1; break;
            case "down": row = row >= max ? -1 : row + 1; break;
            case "start": row = 0; break;
            case "end": row = max; break;
        }

        this.popup.setRow(row);
    };

    this.insertMatch = function(data) {
        if (!data)
            data = this.popup.getData(this.popup.getRow());
        if (!data)
            return false;
        if (data.completer && data.completer.insertMatch) {
            data.completer.insertMatch(this.editor);
        } else {
            if (this.completions.filterText) {
                var ranges = this.editor.selection.getAllRanges();
                for (var i = 0, range; range = ranges[i]; i++) {
                    range.start.column -= this.completions.filterText.length;
                    this.editor.session.remove(range);
                }
            }
            if (data.snippet)
                snippetManager.insertSnippet(this.editor, data.snippet);
            else
                this.editor.execCommand("insertstring", data.value || data);
        }
        this.detach();
    };

    this.commands = {
        "Up": function(editor) { editor.completer.goTo("up"); },
        "Down": function(editor) { editor.completer.goTo("down"); },
        "Ctrl-Up|Ctrl-Home": function(editor) { editor.completer.goTo("start"); },
        "Ctrl-Down|Ctrl-End": function(editor) { editor.completer.goTo("end"); },

        "Esc": function(editor) { editor.completer.detach(); },
        "Space": function(editor) { editor.completer.detach(); editor.insert(" ");},
        "Return": function(editor) { editor.completer.insertMatch(); },
        "Shift-Return": function(editor) { editor.completer.insertMatch(); },
        "Tab": function(editor) { editor.completer.insertMatch(); },

        "PageUp": function(editor) { editor.completer.popup.gotoPageUp(); },
        "PageDown": function(editor) { editor.completer.popup.gotoPageDown(); }
    };

    this.gatherCompletions = function(editor, callback) {
        var session = editor.getSession();
        var pos = editor.getCursorPosition();
        
        var line = session.getLine(pos.row);
        var prefix = util.retrievePrecedingIdentifier(line, pos.column);
        
        this.base = editor.getCursorPosition();
        this.base.column -= prefix.length;

        var matches = [];
        util.parForEach(editor.completers, function(completer, next) {
            completer.getCompletions(editor, session, pos, prefix, function(err, results) {
                if (!err)
                    matches = matches.concat(results);
                next();
            });
        }, function() {
            callback(null, {
                prefix: prefix,
                matches: matches
            });
        });
        return true;
    };

    this.showPopup = function(editor) {
        if (this.editor)
            this.detach();
        
        this.activated = true;

        this.editor = editor;
        if (editor.completer != this) {
            if (editor.completer)
                editor.completer.detach();
            editor.completer = this;
        }

        editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
        editor.on("changeSelection", this.changeListener);
        editor.on("blur", this.blurListener);
        editor.on("mousedown", this.mousedownListener);
        editor.on("mousewheel", this.mousewheelListener);
        
        this.updateCompletions();
    };
    
    this.updateCompletions = function(keepPopupPosition) {
        if (keepPopupPosition && this.base && this.completions) {
            var pos = this.editor.getCursorPosition();
            var prefix = this.editor.session.getTextRange({start: this.base, end: pos});
            if (prefix == this.completions.filterText)
                return;
            this.completions.setFilter(prefix);
            if (!this.completions.filtered.length)
                return this.detach();
            this.openPopup(this.editor, prefix, keepPopupPosition);
            return;
        }
        this.gatherCompletions(this.editor, function(err, results) {
            var matches = results && results.matches;
            if (!matches || !matches.length)
                return this.detach();

            this.completions = new FilteredList(matches);
            this.completions.setFilter(results.prefix);
            var filtered = this.completions.filtered;
            if (!filtered.length)
                return this.detach();
            if (this.autoInsert && filtered.length == 1)
                return this.insertMatch(filtered[0]);
            this.openPopup(this.editor, results.prefix, keepPopupPosition);
        }.bind(this));
    };

    this.cancelContextMenu = function() {
        var stop = function(e) {
            this.editor.off("nativecontextmenu", stop);
            if (e && e.domEvent)
                event.stopEvent(e.domEvent);
        }.bind(this);
        setTimeout(stop, 10);
        this.editor.on("nativecontextmenu", stop);
    };

}).call(Autocomplete.prototype);

Autocomplete.startCommand = {
    name: "startAutocomplete",
    exec: function(editor) {
        if (!editor.completer)
            editor.completer = new Autocomplete();
        editor.completer.showPopup(editor);
        editor.completer.cancelContextMenu();
    },
    bindKey: "Ctrl-Space|Ctrl-Shift-Space|Alt-Space"
};

var FilteredList = function(array, filterText, mutateData) {
    this.all = array;
    this.filtered = array;
    this.filterText = filterText || "";
};
(function(){
    this.setFilter = function(str) {
        if (str.length > this.filterText && str.lastIndexOf(this.filterText, 0) === 0)
            var matches = this.filtered;
        else
            var matches = this.all;

        this.filterText = str;
        matches = this.filterCompletions(matches, this.filterText);
        matches = matches.sort(function(a, b) {
            return b.exactMatch - a.exactMatch || b.score - a.score;
        });
        var prev = null;
        matches = matches.filter(function(item){
            var caption = item.value || item.caption || item.snippet; 
            if (caption === prev) return false;
            prev = caption;
            return true;
        });
        
        this.filtered = matches;
    };
    this.filterCompletions = function(items, needle) {
        var results = [];
        var upper = needle.toUpperCase();
        var lower = needle.toLowerCase();
        loop: for (var i = 0, item; item = items[i]; i++) {
            var caption = item.value || item.caption || item.snippet;
            if (!caption) continue;
            var lastIndex = -1;
            var matchMask = 0;
            var penalty = 0;
            var index, distance;
            for (var j = 0; j < needle.length; j++) {
                var i1 = caption.indexOf(lower[j], lastIndex + 1);
                var i2 = caption.indexOf(upper[j], lastIndex + 1);
                index = (i1 >= 0) ? ((i2 < 0 || i1 < i2) ? i1 : i2) : i2;
                if (index < 0)
                    continue loop;
                distance = index - lastIndex - 1;
                if (distance > 0) {
                    if (lastIndex === -1)
                        penalty += 10;
                    penalty += distance;
                }
                matchMask = matchMask | (1 << index);
                lastIndex = index;
            }
            item.matchMask = matchMask;
            item.exactMatch = penalty ? 0 : 1;
            item.score = (item.score || 0) - penalty;
            results.push(item);
        }
        return results;
    };
}).call(FilteredList.prototype);

exports.Autocomplete = Autocomplete;
exports.FilteredList = FilteredList;

});

consoleAce.define('ace/autocomplete/popup', ['require', 'exports', 'module' , 'ace/edit_session', 'ace/virtual_renderer', 'ace/editor', 'ace/range', 'ace/lib/event', 'ace/lib/lang', 'ace/lib/dom'], function(require, exports, module) {


var EditSession = require("../edit_session").EditSession;
var Renderer = require("../virtual_renderer").VirtualRenderer;
var Editor = require("../editor").Editor;
var Range = require("../range").Range;
var event = require("../lib/event");
var lang = require("../lib/lang");
var dom = require("../lib/dom");

var $singleLineEditor = function(el) {
    var renderer = new Renderer(el);

    renderer.$maxLines = 4;
    
    var editor = new Editor(renderer);

    editor.setHighlightActiveLine(false);
    editor.setShowPrintMargin(false);
    editor.renderer.setShowGutter(false);
    editor.renderer.setHighlightGutterLine(false);

    editor.$mouseHandler.$focusWaitTimout = 0;

    return editor;
};

var AcePopup = function(parentNode) {
    var el = dom.createElement("div");
    var popup = new $singleLineEditor(el);
    
    if (parentNode)
        parentNode.appendChild(el);
    el.style.display = "none";
    popup.renderer.content.style.cursor = "default";
    popup.renderer.setStyle("ace_autocomplete");
    
    popup.setOption("displayIndentGuides", false);

    var noop = function(){};

    popup.focus = noop;
    popup.$isFocused = true;

    popup.renderer.$cursorLayer.restartTimer = noop;
    popup.renderer.$cursorLayer.element.style.opacity = 0;

    popup.renderer.$maxLines = 8;
    popup.renderer.$keepTextAreaAtCursor = false;

    popup.setHighlightActiveLine(false);
    popup.session.highlight("");
    popup.session.$searchHighlight.clazz = "ace_highlight-marker";

    popup.on("mousedown", function(e) {
        var pos = e.getDocumentPosition();
        popup.moveCursorToPosition(pos);
        popup.selection.clearSelection();
        selectionMarker.start.row = selectionMarker.end.row = pos.row;
        e.stop();
    });

    var lastMouseEvent;
    var hoverMarker = new Range(-1,0,-1,Infinity);
    var selectionMarker = new Range(-1,0,-1,Infinity);
    selectionMarker.id = popup.session.addMarker(selectionMarker, "ace_active-line", "fullLine");
    popup.setSelectOnHover = function(val) {
        if (!val) {
            hoverMarker.id = popup.session.addMarker(hoverMarker, "ace_line-hover", "fullLine");
        } else if (hoverMarker.id) {
            popup.session.removeMarker(hoverMarker.id);
            hoverMarker.id = null;
        }
    }
    popup.setSelectOnHover(false);
    popup.on("mousemove", function(e) {
        if (!lastMouseEvent) {
            lastMouseEvent = e;
            return;
        }
        if (lastMouseEvent.x == e.x && lastMouseEvent.y == e.y) {
            return;
        }
        lastMouseEvent = e;
        lastMouseEvent.scrollTop = popup.renderer.scrollTop;
        var row = lastMouseEvent.getDocumentPosition().row;
        if (hoverMarker.start.row != row) {
            if (!hoverMarker.id)
                popup.setRow(row);
            setHoverMarker(row);
        }
    });
    popup.renderer.on("beforeRender", function() {
        if (lastMouseEvent && hoverMarker.start.row != -1) {
            lastMouseEvent.$pos = null;
            var row = lastMouseEvent.getDocumentPosition().row;
            if (!hoverMarker.id)
                popup.setRow(row);
            setHoverMarker(row, true);
        }
    });
    popup.renderer.on("afterRender", function() {
        var row = popup.getRow();
        var t = popup.renderer.$textLayer;
        var selected = t.element.childNodes[row - t.config.firstRow];
        if (selected == t.selectedNode)
            return;
        if (t.selectedNode)
            dom.removeCssClass(t.selectedNode, "ace_selected");
        t.selectedNode = selected;
        if (selected)
            dom.addCssClass(selected, "ace_selected");
    });
    var hideHoverMarker = function() { setHoverMarker(-1) };
    var setHoverMarker = function(row, suppressRedraw) {
        if (row !== hoverMarker.start.row) {
            hoverMarker.start.row = hoverMarker.end.row = row;
            if (!suppressRedraw)
                popup.session._emit("changeBackMarker");
            popup._emit("changeHoverMarker");
        }
    };
    popup.getHoveredRow = function() {
        return hoverMarker.start.row;
    };
    
    event.addListener(popup.container, "mouseout", hideHoverMarker);
    popup.on("hide", hideHoverMarker);
    popup.on("changeSelection", hideHoverMarker);
    
    popup.session.doc.getLength = function() {
        return popup.data.length;
    };
    popup.session.doc.getLine = function(i) {
        var data = popup.data[i];
        if (typeof data == "string")
            return data;
        return (data && data.value) || "";
    };

    var bgTokenizer = popup.session.bgTokenizer;
    bgTokenizer.$tokenizeRow = function(i) {
        var data = popup.data[i];
        var tokens = [];
        if (!data)
            return tokens;
        if (typeof data == "string")
            data = {value: data};
        if (!data.caption)
            data.caption = data.value;

        var last = -1;
        var flag, c;
        for (var i = 0; i < data.caption.length; i++) {
            c = data.caption[i];
            flag = data.matchMask & (1 << i) ? 1 : 0;
            if (last !== flag) {
                tokens.push({type: data.className || "" + ( flag ? "completion-highlight" : ""), value: c});
                last = flag;
            } else {
                tokens[tokens.length - 1].value += c;
            }
        }

        if (data.meta) {
            var maxW = popup.renderer.$size.scrollerWidth / popup.renderer.layerConfig.characterWidth;
            if (data.meta.length + data.caption.length < maxW - 2)
                tokens.push({type: "rightAlignedText", value: data.meta});
        }
        return tokens;
    };
    bgTokenizer.$updateOnChange = noop;
    bgTokenizer.start = noop;
    
    popup.session.$computeWidth = function() {
        return this.screenWidth = 0;
    }
    popup.isOpen = false;
    popup.isTopdown = false;
    
    popup.data = [];
    popup.setData = function(list) {
        popup.data = list || [];
        popup.setValue(lang.stringRepeat("\n", list.length), -1);
        popup.setRow(0);
    };
    popup.getData = function(row) {
        return popup.data[row];
    };

    popup.getRow = function() {
        return selectionMarker.start.row;
    };
    popup.setRow = function(line) {
        line = Math.max(-1, Math.min(this.data.length, line));
        if (selectionMarker.start.row != line) {
            popup.selection.clearSelection();
            selectionMarker.start.row = selectionMarker.end.row = line || 0;
            popup.session._emit("changeBackMarker");
            popup.moveCursorTo(line || 0, 0);
            if (popup.isOpen)
                popup._signal("select");
        }
    };
    
    popup.on("changeSelection", function() {
        if (popup.isOpen)
            popup.setRow(popup.selection.lead.row);
    });

    popup.hide = function() {
        this.container.style.display = "none";
        this._signal("hide");
        popup.isOpen = false;
    };
    popup.show = function(pos, lineHeight, topdownOnly) {
        var el = this.container;
        var screenHeight = window.innerHeight;
        var screenWidth = window.innerWidth;
        var renderer = this.renderer;
        var maxH = renderer.$maxLines * lineHeight * 1.4;
        var top = pos.top + this.$borderSize;
        if (top + maxH > screenHeight - lineHeight && !topdownOnly) {
            el.style.top = "";
            el.style.bottom = screenHeight - top + "px";
            popup.isTopdown = false;
        } else {
            top += lineHeight;
            el.style.top = top + "px";
            el.style.bottom = "";
            popup.isTopdown = true;
        }

        el.style.display = "";
        this.renderer.$textLayer.checkForSizeChanges();
        
        var left = pos.left;
        if (left + el.offsetWidth > screenWidth)
            left = screenWidth - el.offsetWidth;
            
        el.style.left = left + "px";
        
        this._signal("show");
        lastMouseEvent = null;
        popup.isOpen = true;
    };
    
    popup.getTextLeftOffset = function() {
        return this.$borderSize + this.renderer.$padding + this.$imageSize;
    };
    
    popup.$imageSize = 0;
    popup.$borderSize = 1;

    return popup;
};

dom.importCssString("\
.ace_autocomplete.ace-tm .ace_marker-layer .ace_active-line {\
    background-color: #CAD6FA;\
    z-index: 1;\
}\
.ace_autocomplete.ace-tm .ace_line-hover {\
    border: 1px solid #abbffe;\
    margin-top: -1px;\
    background: rgba(233,233,253,0.4);\
}\
.ace_autocomplete .ace_line-hover {\
    position: absolute;\
    z-index: 2;\
}\
.ace_rightAlignedText {\
    color: gray;\
    display: inline-block;\
    position: absolute;\
    right: 4px;\
    text-align: right;\
    z-index: -1;\
}\
.ace_autocomplete .ace_completion-highlight{\
    color: #000;\
    text-shadow: 0 0 0.01em;\
}\
.ace_autocomplete {\
    width: 280px;\
    z-index: 200000;\
    background: #fbfbfb;\
    color: #444;\
    border: 1px lightgray solid;\
    position: fixed;\
    box-shadow: 2px 3px 5px rgba(0,0,0,.2);\
    line-height: 1.4;\
}");

exports.AcePopup = AcePopup;

});

consoleAce.define('ace/autocomplete/util', ['require', 'exports', 'module' ], function(require, exports, module) {


exports.parForEach = function(array, fn, callback) {
    var completed = 0;
    var arLength = array.length;
    if (arLength === 0)
        callback();
    for (var i = 0; i < arLength; i++) {
        fn(array[i], function(result, err) {
            completed++;
            if (completed === arLength)
                callback(result, err);
        });
    }
}

var ID_REGEX = /[a-zA-Z_0-9\$-]/;

exports.retrievePrecedingIdentifier = function(text, pos, regex) {
    regex = regex || ID_REGEX;
    var buf = [];
    for (var i = pos-1; i >= 0; i--) {
        if (regex.test(text[i]))
            buf.push(text[i]);
        else
            break;
    }
    return buf.reverse().join("");
}

exports.retrieveFollowingIdentifier = function(text, pos, regex) {
    regex = regex || ID_REGEX;
    var buf = [];
    for (var i = pos; i < text.length; i++) {
        if (regex.test(text[i]))
            buf.push(text[i]);
        else
            break;
    }
    return buf;
}

});

consoleAce.define('ace/autocomplete/text_completer', ['require', 'exports', 'module' , 'ace/range'], function(require, exports, module) {
    var Range = require("ace/range").Range;
    
    var splitRegex = /[^a-zA-Z_0-9\$\-]+/;

    function getWordIndex(doc, pos) {
        var textBefore = doc.getTextRange(Range.fromPoints({row: 0, column:0}, pos));
        return textBefore.split(splitRegex).length - 1;
    }
    function wordDistance(doc, pos) {
        var prefixPos = getWordIndex(doc, pos);
        var words = doc.getValue().split(splitRegex);
        var wordScores = Object.create(null);
        
        var currentWord = words[prefixPos];

        words.forEach(function(word, idx) {
            if (!word || word === currentWord) return;

            var distance = Math.abs(prefixPos - idx);
            var score = words.length - distance;
            if (wordScores[word]) {
                wordScores[word] = Math.max(score, wordScores[word]);
            } else {
                wordScores[word] = score;
            }
        });
        return wordScores;
    }

    exports.getCompletions = function(editor, session, pos, prefix, callback) {
        var wordScore = wordDistance(session, pos, prefix);
        var wordList = Object.keys(wordScore);
        callback(null, wordList.map(function(word) {
            return {
                name: word,
                value: word,
                score: wordScore[word],
                meta: "local"
            };
        }));
    };
});


/***/ }),
/* 3161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Mode = Mode;
var acequire = __webpack_require__(968);
__webpack_require__(51);
__webpack_require__(362);

var oop = acequire("ace/lib/oop");
var TextMode = acequire("ace/mode/text").Mode;
var ScriptMode = __webpack_require__(3162).ScriptMode;
var MatchingBraceOutdent = acequire("ace/mode/matching_brace_outdent").MatchingBraceOutdent;
var CstyleBehaviour = acequire("ace/mode/behaviour/cstyle").CstyleBehaviour;
var CStyleFoldMode = acequire("ace/mode/folding/cstyle").FoldMode;
var WorkerClient = acequire("ace/worker/worker_client").WorkerClient;
var AceTokenizer = acequire("ace/tokenizer").Tokenizer;

var HighlightRules = __webpack_require__(3163).InputHighlightRules;

acequire("ace/config").setModuleUrl("sense_editor/mode/worker", __webpack_require__(3164));

function Mode() {
  this.$tokenizer = new AceTokenizer(new HighlightRules().getRules());
  this.$outdent = new MatchingBraceOutdent();
  this.$behaviour = new CstyleBehaviour();
  this.foldingRules = new CStyleFoldMode();
  this.createModeDelegates({
    "script-": ScriptMode
  });
}
oop.inherits(Mode, TextMode);

(function () {
  this.getCompletions = function () {
    // autocomplete is done by the autocomplete module.
    return [];
  };

  this.getNextLineIndent = function (state, line, tab) {
    var indent = this.$getIndent(line);

    if (state !== "string_literal") {
      var match = line.match(/^.*[\{\(\[]\s*$/);
      if (match) {
        indent += tab;
      }
    }

    return indent;
  };

  this.checkOutdent = function (state, line, input) {
    return this.$outdent.checkOutdent(line, input);
  };

  this.autoOutdent = function (state, doc, row) {
    this.$outdent.autoOutdent(doc, row);
  };

  this.createWorker = function (session) {
    var worker = new WorkerClient(["ace", "sense_editor"], "sense_editor/mode/worker", "SenseWorker");
    worker.attachToDocument(session.getDocument());

    worker.on("error", function (e) {
      session.setAnnotations([e.data]);
    });

    worker.on("ok", function (anno) {
      session.setAnnotations(anno.data);
    });

    return worker;
  };
}).call(Mode.prototype);

/***/ }),
/* 3162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScriptMode = ScriptMode;
var acequire = __webpack_require__(968);
__webpack_require__(51);
__webpack_require__(362);

var oop = acequire("ace/lib/oop");
var TextMode = acequire("ace/mode/text").Mode;
var MatchingBraceOutdent = acequire("ace/mode/matching_brace_outdent").MatchingBraceOutdent;
var CstyleBehaviour = acequire("ace/mode/behaviour/cstyle").CstyleBehaviour;
var CStyleFoldMode = acequire("ace/mode/folding/cstyle").FoldMode;
acequire("ace/tokenizer");

var ScriptHighlightRules = __webpack_require__(969).ScriptHighlightRules;

function ScriptMode() {
  this.$outdent = new MatchingBraceOutdent();
  this.$behaviour = new CstyleBehaviour();
  this.foldingRules = new CStyleFoldMode();
}

oop.inherits(ScriptMode, TextMode);

(function () {

  this.HighlightRules = ScriptHighlightRules;

  this.getNextLineIndent = function (state, line, tab) {
    var indent = this.$getIndent(line);
    var match = line.match(/^.*[\{\[]\s*$/);
    if (match) {
      indent += tab;
    }

    return indent;
  };

  this.checkOutdent = function (state, line, input) {
    return this.$outdent.checkOutdent(line, input);
  };

  this.autoOutdent = function (state, doc, row) {
    this.$outdent.autoOutdent(doc, row);
  };

  // this.createWorker = function (session) {
  //   var worker = new WorkerClient(["ace", "sense_editor"], "sense_editor/mode/worker", "SenseWorker");
  //   worker.attachToDocument(session.getDocument());


  //   worker.on("error", function (e) {
  //     session.setAnnotations([e.data]);
  //   });

  //   worker.on("ok", function (anno) {
  //     session.setAnnotations(anno.data);
  //   });

  //   return worker;
  // };

}).call(ScriptMode.prototype);

/***/ }),
/* 3163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.InputHighlightRules = InputHighlightRules;
var ace = __webpack_require__(51);
var x_json = __webpack_require__(970);

var oop = ace.require("ace/lib/oop");
var TextHighlightRules = ace.require("ace/mode/text_highlight_rules").TextHighlightRules;

function InputHighlightRules() {
  function mergeTokens() /* ... */{
    return [].concat.apply([], arguments);
  }

  function addEOL(tokens, reg, nextIfEOL, normalNext) {
    if ((typeof reg === 'undefined' ? 'undefined' : _typeof(reg)) == "object") {
      reg = reg.source;
    }
    return [{ token: tokens.concat(["whitespace"]), regex: reg + "(\\s*)$", next: nextIfEOL }, { token: tokens, regex: reg, next: normalNext }];
  }

  // regexp must not have capturing parentheses. Use (?:) instead.
  // regexps are ordered -> the first match is used
  /*jshint -W015 */
  this.$rules = {
    "start": mergeTokens([{ "token": "warning", "regex": "#!.*$" }, { token: "comment", regex: /^#.*$/ }, { token: "paren.lparen", regex: "{", next: "json", push: true }], addEOL(["method"], /([a-zA-Z]+)/, "start", "method_sep"), [{
      token: "whitespace",
      regex: "\\s+"
    }, {
      token: "text",
      regex: ".+?"
    }]),
    "method_sep": mergeTokens(addEOL(["whitespace", "url.protocol_host", "url.slash"], /(\s+)(https?:\/\/[^?\/,]+)(\/)/, "start", "url"), addEOL(["whitespace", "url.protocol_host"], /(\s+)(https?:\/\/[^?\/,]+)/, "start", "url"), addEOL(["whitespace", "url.slash"], /(\s+)(\/)/, "start", "url"), addEOL(["whitespace"], /(\s+)/, "start", "url")),
    "url": mergeTokens(addEOL(["url.part"], /([^?\/,\s]+)/, "start"), addEOL(["url.comma"], /(,)/, "start"), addEOL(["url.slash"], /(\/)/, "start"), addEOL(["url.questionmark"], /(\?)/, "start", "urlParams")),
    "urlParams": mergeTokens(addEOL(["url.param", "url.equal", "url.value"], /([^&=]+)(=)([^&]*)/, "start"), addEOL(["url.param"], /([^&=]+)/, "start"), addEOL(["url.amp"], /(&)/, "start"))
  };

  x_json.addToRules(this);

  if (this.constructor === InputHighlightRules) {
    this.normalizeRules();
  }
}

oop.inherits(InputHighlightRules, TextHighlightRules);

/***/ }),
/* 3164 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "08dd79443c24d83e569939cc78508c5e.js";

/***/ }),
/* 3165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (input, output) {

  var $left = input.$el.parent();

  function readStoredEditorWidth() {
    return storage.get('editorWidth');
  }

  function storeEditorWidth(editorWidth) {
    storage.set('editorWidth', editorWidth);
  }

  function setEditorWidth(editorWidth) {
    storeEditorWidth(editorWidth);
    $left.width(editorWidth);
  }

  var $resizer = $('#editor_resizer');
  $resizer.on('mousedown', function (event) {
    $resizer.addClass('active');
    var startWidth = $left.width();
    var startX = event.pageX;
    input.resize.topRow = input.renderer.layerConfig.firstRow;
    output.resize.topRow = output.renderer.layerConfig.firstRow;

    function onMove(event) {
      setEditorWidth(startWidth + event.pageX - startX);
    }

    $(document.body).on('mousemove', onMove).one('mouseup', function () {
      $resizer.removeClass('active');
      $(this).off('mousemove', onMove);
      input.resize();
      output.resize();
    });
  });

  var initialEditorWidth = readStoredEditorWidth();
  if (initialEditorWidth != null) {
    setEditorWidth(initialEditorWidth);
  }
};

var $ = __webpack_require__(7);
var storage = __webpack_require__(269);

module.exports = exports['default'];

/***/ }),
/* 3166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Mode = Mode;
var ace = __webpack_require__(51);
__webpack_require__(362);
__webpack_require__(972);

var oop = ace.require("ace/lib/oop");
var JSONMode = ace.require("ace/mode/json").Mode;
var HighlightRules = __webpack_require__(972).OutputJsonHighlightRules;
var MatchingBraceOutdent = ace.require("ace/mode/matching_brace_outdent").MatchingBraceOutdent;
var CstyleBehaviour = ace.require("ace/mode/behaviour/cstyle").CstyleBehaviour;
var CStyleFoldMode = ace.require("ace/mode/folding/cstyle").FoldMode;
ace.require("ace/worker/worker_client");
var AceTokenizer = ace.require("ace/tokenizer").Tokenizer;

function Mode() {
  this.$tokenizer = new AceTokenizer(new HighlightRules().getRules());
  this.$outdent = new MatchingBraceOutdent();
  this.$behaviour = new CstyleBehaviour();
  this.foldingRules = new CStyleFoldMode();
}
oop.inherits(Mode, JSONMode);

(function () {
  this.createWorker = function () {
    return null;
  };

  this.$id = "sense/mode/input";
}).call(Mode.prototype);

/***/ }),
/* 3167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ = __webpack_require__(1);
var url_pattern_matcher = __webpack_require__(540);
var url_params = __webpack_require__(965);
var body_completer = __webpack_require__(3168);

/**
 *
 * @param urlParametrizedComponentFactories a dictionary of factory functions
 * that will be used as fallback for parametrized path part (i.e., {indices} )
 * see url_pattern_matcher.UrlPatternMatcher
 * @constructor
 * @param bodyParametrizedComponentFactories same as urlParametrizedComponentFactories but used for body compilation
 */
function Api(urlParametrizedComponentFactories, bodyParametrizedComponentFactories) {
  this.globalRules = {};
  this.endpoints = {};
  this.urlPatternMatcher = new url_pattern_matcher.UrlPatternMatcher(urlParametrizedComponentFactories);
  this.globalBodyComponentFactories = bodyParametrizedComponentFactories;
  this.name = "";
}

(function (cls) {
  cls.addGlobalAutocompleteRules = function (parentNode, rules) {
    this.globalRules[parentNode] = body_completer.compileBodyDescription("GLOBAL." + parentNode, rules, this.globalBodyComponentFactories);
  };

  cls.getGlobalAutocompleteComponents = function (term, throwOnMissing) {
    var result = this.globalRules[term];
    if (_.isUndefined(result) && (throwOnMissing || _.isUndefined(throwOnMissing))) {
      throw new Error("failed to resolve global components for  ['" + term + "']");
    }
    return result;
  };

  cls.addEndpointDescription = function (endpoint, description) {

    var copiedDescription = {};
    _.extend(copiedDescription, description || {});
    _.defaults(copiedDescription, {
      id: endpoint,
      patterns: [endpoint],
      methods: ['GET']
    });
    _.each(copiedDescription.patterns, function (p) {
      this.urlPatternMatcher.addEndpoint(p, copiedDescription);
    }, this);

    copiedDescription.paramsAutocomplete = new url_params.UrlParams(copiedDescription.url_params);
    copiedDescription.bodyAutocompleteRootComponents = body_completer.compileBodyDescription(copiedDescription.id, copiedDescription.data_autocomplete_rules, this.globalBodyComponentFactories);

    this.endpoints[endpoint] = copiedDescription;
  };

  cls.getEndpointDescriptionByEndpoint = function (endpoint) {
    return this.endpoints[endpoint];
  };

  cls.getTopLevelUrlCompleteComponents = function () {
    return this.urlPatternMatcher.getTopLevelComponents();
  };

  cls.getUnmatchedEndpointComponents = function () {
    return body_completer.globalsOnlyAutocompleteComponents();
  };

  cls.clear = function () {
    this.endpoints = {};
    this.globalRules = {};
  };
})(Api.prototype);

exports.default = Api;
module.exports = exports['default'];

/***/ }),
/* 3168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.globalsOnlyAutocompleteComponents = globalsOnlyAutocompleteComponents;
exports.compileBodyDescription = compileBodyDescription;
var _ = __webpack_require__(1);
var engine = __webpack_require__(140);

function CompilingContext(endpoint_id, parametrizedComponentFactories) {
  this.parametrizedComponentFactories = parametrizedComponentFactories;
  this.endpoint_id = endpoint_id;
}

function getTemplate(description) {
  if (description.__template) {
    return description.__template;
  } else if (description.__one_of) {
    return getTemplate(description.__one_of[0]);
  } else if (description.__any_of) {
    return [];
  } else if (description.__scope_link) {
    // assume an object for now.
    return {};
  } else if (Array.isArray(description)) {
    if (description.length == 1) {
      if (_.isObject(description[0])) {
        // shortcut to save typing
        var innerTemplate = getTemplate(description[0]);

        return innerTemplate != null ? [innerTemplate] : [];
      }
    }
    return [];
  } else if (_.isObject(description)) {
    return {};
  } else if (_.isString(description) && !/^\{.*\}$/.test(description)) {
    return description;
  } else {
    return description;
  }
}

function getOptions(description) {
  var options = {};
  var template = getTemplate(description);

  if (!_.isUndefined(template)) {
    options.template = template;
  }
  return options;
}

/**
 * @param description a json dict describing the endpoint
 * @param compilingContext
 */
function compileDescription(description, compilingContext) {
  if (Array.isArray(description)) {
    return [compileList(description, compilingContext)];
  } else if (_.isObject(description)) {
    // test for objects list as arrays are also objects
    if (description.__scope_link) {
      return [new ScopeResolver(description.__scope_link, compilingContext)];
    }
    if (description.__any_of) {
      return [compileList(description.__any_of, compilingContext)];
    }
    if (description.__one_of) {
      return _.flatten(_.map(description.__one_of, function (d) {
        return compileDescription(d, compilingContext);
      }));
    }
    var obj = compileObject(description, compilingContext);
    if (description.__condition) {
      return [compileCondition(description.__condition, obj, compilingContext)];
    } else {
      return [obj];
    }
  } else if (_.isString(description) && /^\{.*\}$/.test(description)) {
    return [compileParametrizedValue(description, compilingContext)];
  } else {
    return [new engine.ConstantComponent(description)];
  }
}

function compileParametrizedValue(value, compilingContext, template) {
  value = value.substr(1, value.length - 2).toLowerCase();
  var component = compilingContext.parametrizedComponentFactories[value];
  if (!component) {
    throw new Error("no factory found for '" + value + "'");
  }
  component = component(value, null, template);
  if (!_.isUndefined(template)) {
    component = engine.wrapComponentWithDefaults(component, { template: template });
  }
  return component;
}

function compileObject(objDescription, compilingContext) {
  var objectC = new engine.ConstantComponent("{");
  var constants = [],
      patterns = [];
  _.each(objDescription, function (desc, key) {
    if (key.indexOf("__") == 0) {
      // meta key
      return;
    }

    var options = getOptions(desc),
        component;
    if (/^\{.*\}$/.test(key)) {
      component = compileParametrizedValue(key, compilingContext, options.template);
      patterns.push(component);
    } else if (key === "*") {
      component = new engine.SharedComponent(key);
      patterns.push(component);
    } else {
      options.name = key;
      component = new engine.ConstantComponent(key, null, [options]);
      constants.push(component);
    }
    _.map(compileDescription(desc, compilingContext), function (subComponent) {
      component.addComponent(subComponent);
    });
  });
  objectC.addComponent(new ObjectComponent("inner", constants, patterns));
  return objectC;
}

function compileList(listRule, compilingContext) {
  var listC = new engine.ConstantComponent("[");
  _.each(listRule, function (desc) {
    _.each(compileDescription(desc, compilingContext), function (component) {
      listC.addComponent(component);
    });
  });
  return listC;
}

/** takes a compiled object and wraps in a {@link ConditionalProxy }*/
function compileCondition(description, compiledObject) {
  if (description.lines_regex) {
    return new ConditionalProxy(function (context, editor) {
      var lines = editor.getSession().getLines(context.requestStartRow, editor.getCursorPosition().row).join("\n");
      return new RegExp(description.lines_regex, "m").test(lines);
    }, compiledObject);
  } else {
    throw "unknown condition type - got: " + JSON.stringify(description);
  }
}

/**
 * @param constants list of components that represent constant keys
 * @param patternsAndWildCards list of components that represent patterns and should be matched only if
 * there is no constant matches
 */
function ObjectComponent(name, constants, patternsAndWildCards) {
  engine.AutocompleteComponent.call(this, name);
  this.constants = constants;
  this.patternsAndWildCards = patternsAndWildCards;
}

ObjectComponent.prototype = _.create(engine.AutocompleteComponent.prototype, { 'constructor': ObjectComponent });

(function (cls) {
  cls.getTerms = function (context, editor) {
    var options = [];
    _.each(this.constants, function (component) {
      options.push.apply(options, component.getTerms(context, editor));
    });
    _.each(this.patternsAndWildCards, function (component) {
      options.push.apply(options, component.getTerms(context, editor));
    });
    return options;
  };

  cls.match = function (token, context, editor) {
    var result = {
      next: []
    };
    _.each(this.constants, function (component) {
      var componentResult = component.match(token, context, editor);
      if (componentResult && componentResult.next) {
        result.next.push.apply(result.next, componentResult.next);
      }
    });

    // try to link to GLOBAL rules
    var globalRules = context.globalComponentResolver(token, false);
    if (globalRules) {
      result.next.push.apply(result.next, globalRules);
    }

    if (result.next.length) {
      return result;
    }
    _.each(this.patternsAndWildCards, function (component) {
      var componentResult = component.match(token, context, editor);
      if (componentResult && componentResult.next) {
        result.next.push.apply(result.next, componentResult.next);
      }
    });

    return result;
  };
})(ObjectComponent.prototype);

/**
 * An object to resolve scope links (syntax endpoint.path1.path2)
 * @param link the link either string (endpoint.path1.path2, or .path1.path2) or a function (context,editor)
 * which returns a description to be compiled
 * @constructor
 * @param compilingContext
 *
 *
 * For this to work we expect the context to include a method context.endpointComponentResolver(endpoint)
 * which should return the top level components for the given endpoint
 */
function ScopeResolver(link, compilingContext) {
  engine.SharedComponent.call(this, "__scope_link", null);
  if (_.isString(link) && link[0] === ".") {
    // relative link, inject current endpoint
    if (link === ".") {
      link = compilingContext.endpoint_id;
    } else {
      link = compilingContext.endpoint_id + link;
    }
  }
  this.link = link;
  this.compilingContext = compilingContext;
}

ScopeResolver.prototype = _.create(engine.SharedComponent.prototype, { 'constructor': ScopeResolver });

(function (cls) {

  cls.resolveLinkToComponents = function (context, editor) {
    if (_.isFunction(this.link)) {
      var desc = this.link(context, editor);
      return compileDescription(desc, this.compilingContext);
    }
    if (!_.isString(this.link)) {
      throw new Error("unsupported link format", this.link);
    }

    var path = this.link.replace(/\./g, "{").split(/(\{)/);
    var endpoint = path[0];
    var components;
    try {
      if (endpoint === "GLOBAL") {
        // global rules need an extra indirection
        if (path.length < 3) {
          throw new Error("missing term in global link: " + this.link);
        }
        var term = path[2];
        components = context.globalComponentResolver(term);
        path = path.slice(3);
      } else {
        path = path.slice(1);
        components = context.endpointComponentResolver(endpoint);
      }
    } catch (e) {
      throw new Error("failed to resolve link [" + this.link + "]: " + e);
    }
    return engine.resolvePathToComponents(path, context, editor, components);
  };

  cls.getTerms = function (context, editor) {
    var options = [],
        components = this.resolveLinkToComponents(context, editor);
    _.each(components, function (component) {
      options.push.apply(options, component.getTerms(context, editor));
    });
    return options;
  };

  cls.match = function (token, context, editor) {
    var result = {
      next: []
    },
        components = this.resolveLinkToComponents(context, editor);

    _.each(components, function (component) {
      var componentResult = component.match(token, context, editor);
      if (componentResult && componentResult.next) {
        result.next.push.apply(result.next, componentResult.next);
      }
    });

    return result;
  };
})(ScopeResolver.prototype);

function ConditionalProxy(predicate, delegate) {
  engine.SharedComponent.call(this, "__condition", null);
  this.predicate = predicate;
  this.delegate = delegate;
}

ConditionalProxy.prototype = _.create(engine.SharedComponent.prototype, { 'constructor': ConditionalProxy });

(function (cls) {

  cls.getTerms = function (context, editor) {
    if (this.predicate(context, editor)) {
      return this.delegate.getTerms(context, editor);
    } else {
      return null;
    }
  };

  cls.match = function (token, context, editor) {
    if (this.predicate(context, editor)) {
      return this.delegate.match(token, context, editor);
    } else {
      return false;
    }
  };
})(ConditionalProxy.prototype);

function GlobalOnlyComponent(name) {
  engine.AutocompleteComponent.call(this, name);
}

GlobalOnlyComponent.prototype = _.create(engine.AutocompleteComponent.prototype, { 'constructor': ObjectComponent });

(function (cls) {

  cls.getTerms = function () {
    return null;
  };

  cls.match = function (token, context) {
    var result = {
      next: []
    };

    // try to link to GLOBAL rules
    var globalRules = context.globalComponentResolver(token, false);
    if (globalRules) {
      result.next.push.apply(result.next, globalRules);
    }

    if (result.next.length) {
      return result;
    }
    // just loop back to us
    result.next = [this];

    return result;
  };
})(GlobalOnlyComponent.prototype);

// a list of component that match anything but give auto complete suggestions based on global API entries.
function globalsOnlyAutocompleteComponents() {
  return [new GlobalOnlyComponent("__global__")];
}

/**
 * @param endpoint_id id of the endpoint being compiled.
 * @param description a json dict describing the endpoint
 * @param endpointComponentResolver a function (endpoint,context,editor) which should resolve an endpoint
 *        to it's list of compiled components.
 * @param parametrizedComponentFactories a dict of the following structure
 * that will be used as a fall back for pattern keys (i.e.: {type} ,resolved without the $s)
 * {
   *   TYPE: function (part, parent, endpoint) {
   *      return new SharedComponent(part, parent)
   *   }
   * }
 */
function compileBodyDescription(endpoint_id, description, parametrizedComponentFactories) {
  return compileDescription(description, new CompilingContext(endpoint_id, parametrizedComponentFactories));
}

/***/ })
]);
//# sourceMappingURL=commons.bundle.js.map